<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::75702</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>036</td><td>Uiua</td><td>231014T081342Z</td><td><a href="https://codegolf.stackexchange.com/questions/75702/hilbert-curvify-a-matrix/265994#265994">Bubbler</a></td></tr>
<tr d-ix="1"><td>041</td><td>APL Dyalog Unicode</td><td>190302T061545Z</td><td><a href="https://codegolf.stackexchange.com/questions/75702/hilbert-curvify-a-matrix/180747#180747">voidhawk</a></td></tr>
<tr d-ix="2"><td>085</td><td>MATL</td><td>160330T015541Z</td><td><a href="https://codegolf.stackexchange.com/questions/75702/hilbert-curvify-a-matrix/76538#76538">Suever</a></td></tr>
<tr d-ix="3"><td>234</td><td>Python 3</td><td>160326T084514Z</td><td><a href="https://codegolf.stackexchange.com/questions/75702/hilbert-curvify-a-matrix/76300#76300">Sherlock</a></td></tr>
<tr d-ix="4"><td>060</td><td>CJam</td><td>160404T195043Z</td><td><a href="https://codegolf.stackexchange.com/questions/75702/hilbert-curvify-a-matrix/77109#77109">aditsu q</a></td></tr>
<tr d-ix="5"><td>216</td><td>Ruby</td><td>160326T114118Z</td><td><a href="https://codegolf.stackexchange.com/questions/75702/hilbert-curvify-a-matrix/76305#76305">Sherlock</a></td></tr>
<tr d-ix="6"><td>302</td><td>Mathcad</td><td>160328T130831Z</td><td><a href="https://codegolf.stackexchange.com/questions/75702/hilbert-curvify-a-matrix/76384#76384">Stuart B</a></td></tr>
<tr d-ix="7"><td>233</td><td>Wolfram</td><td>160317T161636Z</td><td><a href="https://codegolf.stackexchange.com/questions/75702/hilbert-curvify-a-matrix/75706#75706">swish</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://www.uiua.org/" rel="nofollow noreferrer">Uiua</a>, 36 bytes</h1>
<pre><code>⊏⍏∩♭⍥(⊂∶¯+¬×2⧻♭.⇌.≡⊂⊃⍉+∶⧻♭.)ₙ2⧻,↯1⇡1
</code></pre>
<p><a href="https://www.uiua.org/pad?src=ZyDihpAg4oqP4o2P4oip4pmt4o2lKOKKguKItsKvK8Ksw5cy4qe74pmtLuKHjC7iiaHiioLiioPijYkr4oi24qe74pmtLinigpky4qe7LOKGrzHih6ExCmcgW1sxXV0KZyBbWzEgMl0gWzMgNF1dCmcgW1sxIDIgMyA0XVs1IDYgNyA4XVs5IDEwIDExIDEyXVsxMyAxNCAxNSAxNl1d" rel="nofollow noreferrer">Try it online!</a></p>
<p>Constructs the path on the matrix directly, and uses it to index into the matrix.</p>
<pre><code>⊏⍏∩♭⍥(⊂∶¯+¬×2⧻♭.⇌.≡⊂⊃⍉+∶⧻♭.)ₙ2⧻,↯1⇡1    input: matrix M of size 2^n*2^n
↯1⇡1    the initial Hilbert matrix [[0]]
ₙ2⧻,    log 2 of the length of M (= n)
⍥(...)   repeatedly construct the Hilbert matrix by calling the inner function n times...
  ∶⧻♭.   put the number of elements in the current matrix under itself
  ⊃⍉+   construct the top two submatrices: 1) transpose 2) add to each element
  ≡⊂     join horizontally
  ⇌.     create a copy and reverse its rows
  ¯+¬×2⧻♭.  a bunch of arithmetic to get the bottom two submatrices
  ⊂∶      join vertically in reverse
∩♭    flatten the Hilbert matrix and M
⊏⍏    put the elements of M in the increasing order in the Hilbert matrix
</code></pre>
<h1><a href="https://www.uiua.org/" rel="nofollow noreferrer">Uiua</a>, 41 bytes</h1>
<pre><code>⊡⍉∧(≡⊂∶⍜⊢-≡⇌,-1×2∶≡⊂∶⇌⍜⊢+,,⇌)↯2⇡1ⁿ∶2⇡ₙ2⧻.
</code></pre>
<p><a href="https://www.uiua.org/pad?src=ZyDihpAg4oqh4o2J4oinKOKJoeKKguKItuKNnOKKoi3iiaHih4wsLTHDlzLiiLbiiaHiioLiiLbih4zijZziiqIrLCzih4wp4oavMuKHoTHigb_iiLYy4oeh4oKZMuKnuy4KZyBbWzFdXQpnIFtbMSAyXSBbMyA0XV0KZyBbWzEgMiAzIDRdWzUgNiA3IDhdWzkgMTAgMTEgMTJdWzEzIDE0IDE1IDE2XV0=" rel="nofollow noreferrer">Try it online!</a></p>
<p>Constructs the list of coordinates and indexes into the original matrix using <code>⊡</code> &quot;pick&quot;.</p>
</div>
<div id="pu1" class="pu"><h1><a href="https://www.dyalog.com/" rel="nofollow noreferrer">APL (Dyalog Unicode)</a>, 41 <a href="https://codegolf.meta.stackexchange.com/a/9429/43319" title="When can APL characters be counted as 1 byte each?">bytes</a><sup><a href="https://github.com/abrudz/SBCS" rel="nofollow noreferrer" title=".dyalog files using a single byte character set">SBCS</a></sup></h1>

<p>Saved 30 bytes (!) by consulting the wisdom of the APL Orchard, especially @ngn and @Sherlock9.
</p>

<pre class="lang-apl prettyprint-override"><code>{0::⍵⋄∊∇¨⌽∘⊖¨@4,⌽@1⊢∘⍉\⌽↑∘⍵¨∘.,⍨2 ¯2÷⍨≢⍵}
</code></pre>

<p><a href="https://tio.run/##SyzI0U2pTMzJT///v9rAyupR79ZH3S2POroedbQfWvGoZ@@jjhmPuqYdWuFgogPkORg@6loEEurtjAFJtk0Ec7YClXbM0NN51LvCSOHQeqPD24GsR52LgDK1/9MetU141Nv3qG@qp/@jruZD641B2vqmBgc5A8kQD8/g/0BDc4GqjBSMHvVuedS72YTrUe8arjSFXDANlTVRMIHIGpqhSvfshTDSQCwA" rel="nofollow noreferrer" title="APL (Dyalog Unicode) – Try It Online">Try it online!</a></p>

<p>Explanation as follows:</p>

<pre class="lang-apl prettyprint-override"><code>{0::⍵⋄∊∇¨⌽∘⊖¨@4,⌽@1⊢∘⍉\⌽↑∘⍵¨∘.,⍨2 ¯2÷⍨≢⍵} ⍝ Recursive function - takes input as an
                                          ⍝ n*n square matrix
 0::⍵                                     ⍝ Our base case - this is an error guard
                                          ⍝ If there's any error, catch it and
                                          ⍝ return the function's input
                                      ≢⍵  ⍝ Find the number of rows in the input
                                2 ¯2÷⍨    ⍝ Divide the above by 2 and negative 2,
                                          ⍝ resulting in a 2-element vector
                            ∘.,⍨          ⍝ Outer product - take the above vector and
                                          ⍝ apply concatenation (,) with each element
                                          ⍝ against all elements in the vector. Since
                                          ⍝ we have a 2-element vector, this results in
                                          ⍝ a 2-by-2 matrix, e.g.
                                          ⍝ [[(2,2),(2,¯2)],[(¯2,2),(¯2,¯2)]]
                        ↑∘⍵¨              ⍝ For each element in the matrix, we apply
                                          ⍝ "take" against our original input matrix.
                                          ⍝ Take, given a negative number, will take
                                          ⍝ elements from the end of a particular rank.
                                          ⍝ With our argument above, this means that we end
                                          ⍝ up with our original original input matrix
                                          ⍝ split by quadrant into a 2-by-2 matrix.
                                          ⍝ It is also worth noting that take expects
                                          ⍝ an integer argument, so for matrices whose
                                          ⍝ rowcount divided by two results in a decimal
                                          ⍝ (i.e., 1-by-1 matrices), we throw an error
                                          ⍝ which is caught by the guard above, returning
                                          ⍝ the original input.
                       ⌽                  ⍝ Flip the above matrix about the vertical axis.
                   ⊢∘⍉\                   ⍝ Apply a "monadic transpose scan". More details
                                          ⍝ on how this works below, but for our purposes
                                          ⍝ this applies transpose to each of the two 
                                          ⍝ sub-matrices on the right half.
                ⌽@1                       ⍝ Swap the two upper sub-matrices. Given our
                                          ⍝ flip for the overall matrix above, this returns
                                          ⍝ the two upper quadrants to their original
                                          ⍝ positions.
               ,                          ⍝ Ravel: flatten the 2-by-2 matrix into a
                                          ⍝ 4-element vector
         ⌽∘⊖¨@4                           ⍝ Take the last element of the list (the lower
                                          ⍝ right quadrant originally) and flip it
                                          ⍝ along the vertical and horizontal axes. Given
                                          ⍝ the transposition above, this has the final
                                          ⍝ effect of transposition along the antidiagonal.
       ∇¨                                 ⍝ For each element in the above vector, recurse.
      ∊                                   ⍝ Recursively flatten the results into a single
                                          ⍝ vector.
</code></pre>

<p>More details on "<a href="https://codegolf.stackexchange.com/questions/150117/boustrophedonise/150153#150153">monadic transpose scan</a>".</p>

<p>Dyalog documentation on <a href="http://help.dyalog.com/latest/Content/Language/Defined%20Functions%20and%20Operators/DynamicFunctions/Error%20Guards.htm" rel="nofollow noreferrer">error guards</a>.</p>
</div>
<div id="pu2" class="pu"><h1><a href="https://esolangs.org/wiki/MATL" rel="nofollow noreferrer">MATL</a>, <s>86</s> 85 bytes</h1>
<p>This solution is based upon Jonas Lundgren's <a href="http://www.mathworks.com/matlabcentral/fileexchange/27577-fractal-curves/content/hilbert.m" rel="nofollow noreferrer">File Exchange entry</a> which utilizes complex numbers to generate the Hilbert curve. These complex numbers are then converted to index values to retrieve the elements of the matrix that fall along the curve.</p>
<pre><code>nZl2/1XLJQXH1J-XI0,1L:&quot;XJJZj1j*XKKH-JI-JH+IK-,4$h2/]XJJ1L*XJJH+J1)-XHGHXjHYj3$)1$Xd1$
</code></pre>
<p><a href="https://matl.suever.net/?code=nZl2%2F1XLJQXH1J-XI0%2C1L%3A%22XJJZj1j%2aXKKH-JI-JH%2BIK-%2C4%24h2%2F%5DXJJ1L%2aXJJH%2BJ1%29-XHGHXjHYj3%24%291%24Xd1%24&amp;inputs=%5B1%2C2%2C3%2C4%3B5%2C6%2C7%2C8%3B9%2C10%2C11%2C12%3B13%2C14%2C15%2C16%5D&amp;version=15.1.0" rel="nofollow noreferrer">Try it online!</a></p>
<p><strong>Explanation</strong></p>
<pre><code>%--- Define some numbers to be used throughout ---%
n                   % Retrieve the number of elements in the input matrix
Zl2/                % Compute the order of the curve (log2(numel(i))/2)
1XL                 % Store the order in the 1L clipboard
JQ XH               % Store 1 + j in H clipboard
1J- XI              % Store 1 - j in I clipboard
0                   % Place 0 onto the stack

%--- Compute the hilbert curve ---%
1L:&quot;                % For k = 1:order
    XJ                   % Store the top of the stack (z) in J clipboard
    JZj                  % Compute the conjugate of z (stored in J)
    1j*                  % Multiply by j to get conj(z) * j
    XK                   % Store result in K clipboard
    KH- JI- JH+ IK- 4$h  % Horizontal concatenation of K-H, J-I, J+H, and I-K
    2/                   % Divide entire array by 2
]                   % End for loop
XJ                  % Store z in J clipboard

%----- Convert complex decimal values to complex integer indices ----%
J1L*                % Multiply z by the order
XJ                  % Store result in clipboard J
JH+                 % Add 1 + j to H
J1)-                % Subtract the first element of z
XH                  % Store integer complex numbers in H

%--- Retrieve the elements from the input along the curve ---%  
G HXj HYj 3$)       % Index into input using real/imag components input(real, imag)
                    % This will yield an numel(real) x numel(imag) matrix where 
            % the diagonal values are the values we want
1$Xd                % Extract the diagonals using diag with one input
1$                   % Display only the top element on the stack
</code></pre>
</div>
<div id="pu3" class="pu"><h1>Python 3, <s>327</s> <s>289</s> <s>275</s> <s>271</s> <s>239</s> 234 bytes</h1>



<p>This is a solution I modified from <a href="https://codegolf.stackexchange.com/a/67178/47581">my answer</a> for another Hilbert curve question <a href="https://codegolf.stackexchange.com/questions/66958/map-string-to-hilbert-curve">here</a>. Any golfing tips are appreciated.</p>

<p><strong>Edit:</strong> Changed how <code>g</code> is incremented and decremented. Now using <code>eval()</code> and <code>str.translate</code>. No longer using <code>l=len(s)</code>.</p>

<pre class="lang-python prettyprint-override"><code>def h(s):
 t=[s[0][0]];x=y=g=0;b="A"
 for j in range(len(bin(len(s)))-3):b=b.translate({65:"-BF+AFA+FB-",66:"+AF-BFB-FA+"})
 for c in b:g+=(c&lt;"-")-(c=="-");a=c&gt;"B";x,y=[[x,y],[[x+1-g%4,y],[x,y+g%4-2]][g%2]][a];t+=[s[x][y]]*a
 return t
</code></pre>

<p><strong>Ungolfed:</strong></p>

<pre class="lang-python prettyprint-override"><code># the following function is implemented in the code with b=b.translate

def hilbert(it):
    s="A"
    n=""
    for i in range(it):
        for c in s:
            if c == "A":
                n += "-BF+AFA+FB-"
            elif c == "B":
                n += "+AF-BFB-FA+"
            else:
                n += c
        s=n;n=""
    return s

def matrix_to_hilbert(mat):
    length = len(mat)       # this returns the number of rows in the matrix
    if length &lt; 2:
        return mat
    it = len(bin(length)) - 3
    hil = hilbert(it)
    output = [mat[0][0]]    # a list that starts with the first element of the matrix
    x = 0
    y = 0
    heading = 0
    for char in hil:        # navigating the Hilbert curve
        if char == "-": heading += -1
        elif char == "+": heading += 1
        elif char == "F":
            if heading % 4 == 3: y += 1
            elif heading % 4 == 2: x -= 1
            elif heading % 4 == 1: y -= 1
            else: x += 1
            output.append(mat[x][y])
    return output
</code></pre>
</div>
<div id="pu4" class="pu"><h1>CJam, 60</h1>

<pre><code>Lq~:A,2mL{:B1f^0B1B2B3f^]:+}*1+{AT=U=\2md'U^_~)@2*-':@+~;}%p
</code></pre>

<p><a href="http://cjam.aditsu.net/#code=Lq~%3AA%2C2mL%7B%3AB1f%5E0B1B2B3f%5E%5D%3A%2B%7D*1%2B%7BAT%3DU%3D%5C2md&#39;U%5E_~)%402*-&#39;%3A%40%2B~%3B%7D%25p&amp;input=%5B%5B1%202%203%204%5D%20%5B5%206%207%208%5D%20%5B9%2010%2011%2012%5D%20%5B13%2014%2015%2016%5D%5D" rel="nofollow">Try it online</a></p>

<p><strong>Explanation:</strong></p>

<p>I'm building the fractal as a series of movement directions: 0=right, 1=down, 2=left, 3=up.</p>

<pre><code>L          push an empty array (level 0 fractal)
q~:A       read the input, evaluate and store in A
,2mL       get the length (number of rows) and calculate the logarithm in base 2
            (to get the desired level)
{…}*       repeat &lt;level&gt; times
  :B       store the previous-level fractal in B
  1f^      XOR it with 1 (top-left part)
  0        (move right)
  B        copy the fractal (top right part)
  1        (move down)
  B        copy the fractal (bottom right part)
  2        (move left)
  B3f^     copy the fractal and XOR it with 3 (bottom left part)
  ]:+      put everything in an array and concatenate the parts
1+         add a dummy move (needed for the last step)
{…}%       apply to each direction in the array
  AT=U=    push A[T][U] (T and U are initially 0)
  \2md     bring the direction to the top and get the quotient and remainder mod 2
  'U^      XOR the 'U' character with the remainder,
            to get the variable we want to modify
  _~)      make a copy of it, then evaluate it and increment
  @2*-     bring the quotient to the top, multiply by 2 and subtract
  ':@+     concatenate ':' with the variable name
  ~;       evaluate (this updates the variable) and pop the result
p          pretty-print the resulting array
</code></pre>
</div>
<div id="pu5" class="pu"><h1>Ruby, <s>224</s> <s>221</s> 216 bytes</h1>



<p>This answer is based on <a href="https://codegolf.stackexchange.com/a/76300/47581">my Python answer</a>.</p>

<pre class="lang-ruby prettyprint-override"><code>-&gt;s{t=[s[0][0]];x=y=g=0;b=?A;(s.size.bit_length-1).times{b=b.split("").map{|c|c==?A?"-BF+AFA+FB-":c==?B?"+AF-BFB-FA+":c}.join("")};b.each_char{|c|g+=c==?-?-1:c==?+?1:0;(g%2&gt;0?y+=g%4-2:x+=1-g%4;t&lt;&lt;s[x][y])if c==?F};t}
</code></pre>

<p><strong>Ungolfing:</strong></p>

<pre class="lang-ruby prettyprint-override"><code>def hilbert(mat)
  result = mat[0][0]
  x = 0
  y = 0
  heading = 0
  b = "A"
  (mat.size.bit_length-1).times do each |j| # Hilbert curve using a Lindenmayer system
    a = b.split("").map do |char|
      if char == "A"
        "-BF+AFA+FB-"
      else if char == "B"
        "+AF-BFB-FA+"
      else
        char
      end
    end
    b = a.join("")
  end
  b.each_char do |char| # navigating the matrix
    if char == "-"
      heading += -1
    else if char == "+"
      heading += 1
    else if char == "F"
      if heading % 2 == 0
        y += heading % 4 - 2
      else
        x += 1 - heading % 4
      end
      result &lt;&lt; s[x][y]
    end
  return result
  end
</code></pre>
</div>
<div id="pu6" class="pu"><h1>Mathcad, 302 bytes</h1>

<p>The Mathcad program below is based on the @Sherlock9 Python program.  It differs by curvifying rectangular matrices by ignoring those parts of the Hilbert Curve that lie outside of the matrix bounds.  Note that as Mathcad has relatively poor string handling, I've mapped the Lindenmayer symbols to integers in the Hilbert function.</p>

<p><a href="https://i.stack.imgur.com/00QNo.jpg" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/00QNo.jpg" alt="enter image description here"></a></p>

<p>Mathcad works through a 2D interface that allows the user to place (and freely mix) mathematical expressions, plots, text, inputs and outputs.   I've equated a byte to the minimum user keyboard equivalent operation to create a symbol (for example, the definition operator (:=) is entered by simply typing :.</p>
</div>
<div id="pu7" class="pu"><h1>Wolfram - 233</h1>

<p>Based on representation as <a href="https://en.wikipedia.org/wiki/Hilbert_curve#Representation_as_Lindenmayer_system" rel="nofollow">Lindenmayer system</a>:</p>

<pre><code>f[m_]:=m[[Sequence@@Reverse[#+1]]]&amp;/@DeleteDuplicates@AnglePath[Pi/2,List@@StringReplace[Last@SubstitutionSystem[{"A"-&gt;"-BF+AFA+FB-","B"-&gt;"+AF-BFB-FA+"},"A",Round@Sqrt@Length@m],{"A"|"B"-&gt;"","-"-&gt;{0,-Pi/2},"+"-&gt;{0,Pi/2},"F"-&gt;{1,0}}]]
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/75702/">75702</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




