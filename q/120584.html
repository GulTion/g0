<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::120584</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>nan</td><td></td><td>240308T020703Z</td><td><a href="https://codegolf.stackexchange.com/questions/120584/is-it-a-cactus/271624#271624">138 Aspe</a></td></tr>
<tr d-ix="1"><td>289</td><td>Python 2</td><td>210630T095944Z</td><td><a href="https://codegolf.stackexchange.com/questions/120584/is-it-a-cactus/230755#230755">fireflam</a></td></tr>
<tr d-ix="2"><td>062</td><td>Mathematica</td><td>170515T021431Z</td><td><a href="https://codegolf.stackexchange.com/questions/120584/is-it-a-cactus/120620#120620">JungHwan</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>Mathemaitca</h1>
<hr />
<p>Ungolfed version of <a href="https://codegolf.stackexchange.com/a/120620/110802">@JungHwan Min's Mathematica answer</a>.</p>
<pre class="lang-mathematica prettyprint-override"><code>Clear[&quot;Global`*&quot;];
g = Graph[{1 \[UndirectedEdge] 2, 1 \[UndirectedEdge] 3, 
   3 \[UndirectedEdge] 4, 2 \[UndirectedEdge] 4, 
   3 \[UndirectedEdge] 5, 5 \[UndirectedEdge] 6, 
   6 \[UndirectedEdge] 7, 7 \[UndirectedEdge] 8, 
   8 \[UndirectedEdge] 5, 7 \[UndirectedEdge] 9, 
   9 \[UndirectedEdge] 10, 10 \[UndirectedEdge] 11, 
   11 \[UndirectedEdge] 7, 8 \[UndirectedEdge] 12, 
   8 \[UndirectedEdge] 13}, VertexLabels -&gt; &quot;Name&quot;, 
  GraphLayout -&gt; &quot;SpringElectricalEmbedding&quot;]

myCactusGraphQ[graph_] := 
 Module[{cycles, noDuplicateEdges },
  cycles = Join @@ FindCycle[graph, \[Infinity], All]; (*Find all cycles in the graph, with no limit on their length, and combine them into a single list*)
  noDuplicateEdges = Sort[cycles] == Union[cycles];
  noDuplicateEdges &amp;&amp; ConnectedGraphQ[graph] (*Finally, check that the graph is connected AND the noDuplicateEdges condition is met*)
] 

Print[&quot;myCactusGraphQ[g]=&quot;, myCactusGraphQ[g]]
</code></pre>
<p><a href="https://i.stack.imgur.com/vvmIqm.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/vvmIqm.png" alt="enter image description here" /></a></p>
</div>
<div id="pu1" class="pu"><h1><a href="https://docs.python.org/2/" rel="nofollow noreferrer">Python 2</a>, <s>299</s> 289 bytes</h1>

<pre class="lang-python prettyprint-override"><code>j=input()
n=len(j)
Q=range(n*n)
L=N=[[{1&lt;&lt;i%n|1&lt;&lt;i/n}]*j[i/n][i%n]for i in Q]
for _ in Q:N=[[a|b for A,B in zip(N[i/n::n],N[i%n::n])for a in A for b in B if{1}&gt;a&amp;b]for i in Q];L=[L[i]+N[i]for i in Q]
1/all(L[i]*all(A&amp;B|B&amp;C|C&amp;A for A in L[i]for B in L[i]for C in L[i])for i in Q if i%n&lt;i/n)
</code></pre>
<p><a href="https://tio.run/##zVVhb9owEP2eX2FlGkpoRJJqtFPWTIK2TJMQW9V9WhZVAUxrltqRbZqy0t/Ozg6EsJKBtn1YhMjL3b2792wHsrm8Y/R4KbGQAoUoMhBclv5WV1Qi/eQ5yIdP7GyHIebtDqtMJVyBX/gMF0@2s3/oromH9o1WsoGwlqqht4KAe0kq8CE6Xjiq@q9fgh2Znd0qUEs6fIHWc@q11STrtXsVZn3yX@1wqXGfhz02duW3nNSa2Wf2v/Xr7/Hr/Znfnfy/8Fvv1Putxnp1h7w5sWHgRzy6EZITegs/caZpLqchodlMWrZBwxRTa2obVyFP6C22aJPaRj8chFH05J@dkdd0oW4ufY6b0wjucQSxeMI4IohQdBUbCt9oHChashgiFeo4XRX8QTJroIhBQGNnoNgK2aokUQUdXT1UEAiTJ//5fdIYVie864dRPyLxEbC3JvtukqaWSjUV6DS6i27jfHHeKHp2VFl/xelWH87XD/amHcxGIE55tZewSsYrdDm4QB8@9XsG4GtyP0sTiZGQYyjXvNUikvuMcYmYcJCYC1V8J2UmAtcVMhl9Zw@YT1KWt0bs3k1cv@212yfHJ@7pm7d@2z81uINy2BgmWhnJsNoUnN8UU3R0MmYZbBKUmdy0DZaOi6ye1loXlthBJd/Itzrk0CGHDnrpx1On2DX93xfo85K3ck4ktjjOuAUVNjpC5jcKFBCfMqHEbdj4McMjice/NJF8HpSHUZ09q3IA7TLDsZilEvSp98goakc4k@gr5uyCPBBBGL3knPHgJUefcR2GTVtHw1LRhpHBUGmZnzvX12YxGwPzRb7X@djfGDI3EFZsOJPolkkIFoPs5U8" rel="nofollow noreferrer" title="Python 2 – Try It Online">Try it online!</a> (simulates STDIN to run all test cases at once)</p>
<p><em>-10 bytes thanks to @ovs</em></p>
<p>Takes input as an adjacency matrix from STDIN.</p>
<p>Outputs by the presence of an error in accordance with <a href="https://codegolf.meta.stackexchange.com/a/11908/68261">a default output method</a>. An IndexError represents non-cactus, and no error represents cactus.</p>
<h2>Theory</h2>
<p>A simple cycle can be thought of as two disjoint simple paths between a pair of vertices. Similarly, our conjoined cycles correspond to three distinct simple paths being present between a pair of vertices (better explanation near the bottom of the ungolfed code).</p>
<p>To detect these conjoined cycles, we:</p>
<ul>
<li>find all paths between all pairs of vertices, keeping track of the edges using Python sets.</li>
<li>for each pair of vertices, if three paths are pairwise disjoint, then a conjoined cycle is present.</li>
</ul>
<p>The first bullet has the side-benefit of making the connectedness easy to test: if a path exists between every pair of distinct vertices, then the graph is connected.</p>
<h2>Potential improvements</h2>
<p>If input could be taken via STDIN as <code>n</code> followed by <code>n*n</code> rows of boolean values, 13 bytes could be saved, but it doesn't feel right.</p>
<p>A lot of generator for-loop code is repeated, so surely there's a better way. I tried <code>itertools.product</code>, but that ended up with a net cost of +9 bytes. I might have to go with exec/string-replacement abuse like in <a href="https://codegolf.stackexchange.com/a/206476/68261">Baba</a>, which could especially help with <code>for i in Q</code> being used four times.</p>
<h2>Ungolfed Code</h2>
<p>Python 2 has two main benefits over Python 3 here:</p>
<ul>
<li><code>input()</code> automatically parses the input</li>
<li>Division is floor division by default.</li>
</ul>
<pre class="lang-python prettyprint-override"><code>j = input()
n = len(j)
Q = range(n * n)
# Replace each 0 in the adjacency matrix with []
#   and each edge with a label such that the element of N representing the edge m→n has the
#   same label as the element of N representing the edge n→m
L = N = [
    # Each edge label is a 2-hot integer (easiest way to ensure ensure equality in both directions since the graph is undirected)
    # Each path's edge sequence is stored as a set of edge labels
    # N[i] is a list of paths from vertex i % n to vertex i / n
    # N[i] starts out as all possible paths of length 1, i.e. edges
    # L[i] starts as the same
    [{1 &lt;&lt; i%n | 1 &lt;&lt; i/n}]
    * j[i / n][i % n]
    for i in Q
]

# Repeat this n**2 times:
# (In reality, only about log_2(n) times is needed, but there isn't a big performance loss)
for _ in Q:
    # Update N from the list of all possible paths of length k to the list of all possible paths of length k+1
    N = [
        [
            # The union of two paths is possible
            a | b
            # ... for every paths list in N
            for A, B in zip(N[i / n :: n], N[i % n :: n])
            # ... and for every pair of paths in each of these paths lists
            for a in A
            for b in B
            # Limit the search to be through disjoint paths only
            # equivalent to `{1}&gt;a&amp;b == not a&amp;b` because a,b contain only tuples, not integers
            if {1} &gt; a &amp; b
        ]
        for i in Q
    ]
    # Update L from being list of all possible paths of length at most k to the list of all possible paths of length at most k+1
    # (It really seems like these two generator for-loops can be merged into one for loop, but I couldn't get it to work
    #  I might be able to store L and N in the same list, but that's super slow performance; hard to test)
    L = [L[i] + N[i] for i in Q]
# Raises a ZeroDivisionError iff the result of the `all` call is False
1/all(
    # L[i] is falsey ←→ L[i] is an empty list ←→
    # no path exists between vertices i%n and i/n ←→ graph is not connected ←→ not cactus
    L[i]
    * all(
        # `A &amp; B | B &amp; C | C &amp; A` is falsey
        # → A,B,C are three disjoint simple paths between vertices i%n and i/n
        # → AB' and CB' are two cycles that share an edge
        # → The graph is non-cactus
        A &amp; B | B &amp; C | C &amp; A
        # using itertools.product is net +9 bytes last I checked
        for A in L[i]
        for B in L[i]
        for C in L[i]
    )
    for i in Q
    # L is symmetric, and we don't want to check the main diagonal
    if i % n &lt; i / n
)

</code></pre>
<h2>Super-ungolfed code</h2>
<pre class="lang-python prettyprint-override"><code>def dot(r1, r2):
    return [
        path1 | path2
        for paths1, paths2 in zip(r1, r2)
        for path1 in paths1
        for path2 in paths2
        # simple paths, so exclude those that share edges
        if len(path1 &amp; path2) == 0
    ]


def mul(paths1, paths2):
    return [[dot(row, col) for row in zip(*paths2)] for col in paths1]


def f(adj):
    n = len(adj)
    paths_length_1 = [
        [
            [{(min(x, y), max(x, y))}] if entry == 1 else []
            for x, entry in enumerate(row)
        ]
        for y, row in enumerate(adj)
    ]
    all_paths = paths_length_1
    paths_length_n = paths_length_1
    for _ in range(n):
        paths_length_n = mul(paths_length_1, paths_length_n)
        for y in range(n):
            for x in range(n):
                all_paths[y][x].extend(paths_length_n[y][x])
    for x, row in enumerate(all_paths):
        for y, paths in enumerate(row):
            # The graph is non-cactus if it is not conneted
            if x != y and len(paths) == 0:
                return False
            # The graph is non-cactus if there exist three piecewise disjoint simple paths A,B,C
            # between two nodes because A+B' forms one cycle and C+B' forms the other cycle
            for A, B, C in itertools.combinations(paths, 3):
                if len(A &amp; B) == 0 and len(B &amp; C) == 0 and len(A &amp; C) == 0:
                    return False
    return True
</code></pre>
</div>
<div id="pu2" class="pu"><h1>Mathematica, 62 bytes</h1>
<pre><code>Sort@#==#⋃#&amp;[Join@@FindCycle[#,∞,All]]&amp;&amp;ConnectedGraphQ@#&amp;
</code></pre>
<p>Checks: <code>(find all cycles, there are no duplicate edges)</code> and <code>(The graph is a connected graph)</code></p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/120584/">120584</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




