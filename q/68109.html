<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::68109</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>112</td><td>R</td><td>240515T100725Z</td><td><a href="https://codegolf.stackexchange.com/questions/68109/xorting-an-array/273095#273095">int 21h </a></td></tr>
<tr d-ix="1"><td>242</td><td>Scala 3</td><td>240515T111342Z</td><td><a href="https://codegolf.stackexchange.com/questions/68109/xorting-an-array/273097#273097">138 Aspe</a></td></tr>
<tr d-ix="2"><td>011</td><td>Japt</td><td>201006T193737Z</td><td><a href="https://codegolf.stackexchange.com/questions/68109/xorting-an-array/212134#212134">Shaggy</a></td></tr>
<tr d-ix="3"><td>029</td><td>Stax</td><td>180311T032056Z</td><td><a href="https://codegolf.stackexchange.com/questions/68109/xorting-an-array/157821#157821">Weijun Z</a></td></tr>
<tr d-ix="4"><td>030</td><td>Pyth</td><td>151229T215432Z</td><td><a href="https://codegolf.stackexchange.com/questions/68109/xorting-an-array/68131#68131">Jakube</a></td></tr>
<tr d-ix="5"><td>119</td><td>Add++</td><td>180310T231616Z</td><td><a href="https://codegolf.stackexchange.com/questions/68109/xorting-an-array/157813#157813">caird co</a></td></tr>
<tr d-ix="6"><td>079</td><td>Perl 6</td><td>160114T074426Z</td><td><a href="https://codegolf.stackexchange.com/questions/68109/xorting-an-array/69412#69412">Brad Gil</a></td></tr>
<tr d-ix="7"><td>084</td><td>ES6</td><td>151231T104502Z</td><td><a href="https://codegolf.stackexchange.com/questions/68109/xorting-an-array/68275#68275">Neil</a></td></tr>
<tr d-ix="8"><td>nan</td><td></td><td>151231T101246Z</td><td><a href="https://codegolf.stackexchange.com/questions/68109/xorting-an-array/68274#68274">edc65</a></td></tr>
<tr d-ix="9"><td>025</td><td>Jelly</td><td>151231T063040Z</td><td><a href="https://codegolf.stackexchange.com/questions/68109/xorting-an-array/68265#68265">Dennis</a></td></tr>
<tr d-ix="10"><td>194</td><td>Mathematica</td><td>151231T004942Z</td><td><a href="https://codegolf.stackexchange.com/questions/68109/xorting-an-array/68243#68243">DavidC</a></td></tr>
<tr d-ix="11"><td>037</td><td>CJam</td><td>151230T221239Z</td><td><a href="https://codegolf.stackexchange.com/questions/68109/xorting-an-array/68235#68235">Martin E</a></td></tr>
<tr d-ix="12"><td>144</td><td>C</td><td>151231T153339Z</td><td><a href="https://codegolf.stackexchange.com/questions/68109/xorting-an-array/68285#68285">Dave</a></td></tr>
<tr d-ix="13"><td>119</td><td>Ruby 2</td><td>151229T225312Z</td><td><a href="https://codegolf.stackexchange.com/questions/68109/xorting-an-array/68138#68138">histocra</a></td></tr>
<tr d-ix="14"><td>097</td><td>Mathematica</td><td>151231T110533Z</td><td><a href="https://codegolf.stackexchange.com/questions/68109/xorting-an-array/68276#68276">njpipeor</a></td></tr>
<tr d-ix="15"><td>204</td><td>Python 2</td><td>151231T092957Z</td><td><a href="https://codegolf.stackexchange.com/questions/68109/xorting-an-array/68272#68272">Gary Cul</a></td></tr>
<tr d-ix="16"><td>071</td><td>Julia</td><td>151229T215053Z</td><td><a href="https://codegolf.stackexchange.com/questions/68109/xorting-an-array/68130#68130">Rainer P</a></td></tr>
<tr d-ix="17"><td>312</td><td>C</td><td>151230T231433Z</td><td><a href="https://codegolf.stackexchange.com/questions/68109/xorting-an-array/68240#68240">jcai</a></td></tr>
<tr d-ix="18"><td>124</td><td>Julia</td><td>151230T192507Z</td><td><a href="https://codegolf.stackexchange.com/questions/68109/xorting-an-array/68218#68218">Alex A.</a></td></tr>
<tr d-ix="19"><td>214</td><td>Python 2</td><td>151230T140857Z</td><td><a href="https://codegolf.stackexchange.com/questions/68109/xorting-an-array/68183#68183">Blue</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://www.r-project.org" rel="nofollow noreferrer">R</a>, <s>123</s> 112 bytes</h1>
<ul>
<li>-11 bytes thanks to @pajonk</li>
</ul>
<pre class="lang-r prettyprint-override"><code>\(V,`+`=sum,p=2^(0:30),`*`=bitwXor,`?`=\(x)head(x,-1)&lt;x[-1])(s=+p[mapply(\(j)+(?V*j)&gt;+?V,p)])[!is.unsorted(V*s)]
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=7ZjPjpXHEcX33uUNOvbmXpixuruqq6sST3gDL5ElIBoSG8VWbI8YkMmzeIMj5aHsB_Bz5He-kQhIYeG14fKn5_v6dledOudUiR9_ev7638-u_vPyxbPL_Pnm8enhxfX966vbl99e3FzNv576n6yfL67vXV_97esXP3zx_fOL6wfXV49Pr87_-Orpl6dXF5fj_NmrR5fjyfl0e3X_5tG3T29u_vmv0-PTN-f7pwcP731z_sv9Bw8vbs5Pzo_--PXtpy-_u_3--Yuvvjw9vHd7fnJ37y9_-PXzq9u_P_3u9OLqY2-7RRutN_v4_Odnp8_P7ZP10UfvbhhseXvD5Xh7R-e9NWfPfrOjv3vEZMN48zLefqlXnc_m4221Mfj9Zut839bF5ne3vhvU6BmjD9_Vtmf5tiCPHTvHtkHOK7x77WwjR-6yTEIcbqv3bvW-U7OvOUtbM5eVRRDOGuHhezfu2D3Ssxl3-Jx9tT29Rq3RW66e7lHR5pjDrIePllGZM6o40cZYWUlyPsOCy4ho6IAdq-U0y80JjQQijG8podk5oYDY-9h99Nn4w7OYkyi5iYjLdpvd-alqZds8dO_G-1qcTvrcvkmpqgPrTnACCYqRXkXOyVXWk428Y4NbXyTLXq_YxBpQpO--CYyzONH6LJ86a_a5QIk3QYBJzqPbIhDvMGZZ56ONawED8BApFxKPNWoR2bm5Lb7rGXvpcoIeruxzAsqetVuqbr5Avswp5VjwlZS4kauJuqKHLc6u6RZJkORXm0g43IPkoo-2qtsogGq1KoYVxQKjGESmg6DMGCUmjcn-mpQFsHoMZb33nkQHuYjJLYe16kUtBJrBs-0r4EaumZ36NRNi3alz9iKosGprEZQbIWSwzrXEl-3Qanozj7moHCsIOAzuUc4Nb_rajcid4PdsztEjxgRYToV1btwGcGRUUGksL9c3wAdeWss9bShGLuuL0jlMCpRgBd5NwiAX0ZSrSHxKAxvdgLdDbevwvajtBBBK2sEo-lJRA5pA092LQg6DDeXSJfcW8U_wApo-R5jumXDa9PViWyIOFJyUBw2l8uI7QWQgbQ6ZlR_CAlQiHzCjZrqIT7IGtwGUe-Fpbz5qRAoS8kSdm3CDl9RqCFmn4sczKICSRZIl6ElEZEt-WgD3Hm-gFiCj2Nx1MwXcA4fY0TAACcUhZxjYg3uYzTzgZPcuRbVFuEMqiJycIAMwszMNCpADASI57e5TWB9pIYDFqsBRSIPJhgpziFyoIEWaFKsRYkP0VSQkLPrqLkGR3vJDgw4sBQtYTQzTqB2rVOjUQ4bAwigCPJ8-O9iSLw6BDBaY9Y2qGyChYukqhi9UQAQxqaSnniFcgpZfLCl1QODYPKCgvM0VCBqhBroRHzFQA7zRI6DtgsI6Lw1XwWqGVkC5Us-A1qRE9IV0oDrA2wZfaFLyfkJFklADS0IaJSoOaVxZEz04Y0tUrLukMZUZGZX81w8SYK29V6rziIEJaaAgFsualsPy0CLMxyIwTGWvLkUcVIuKYhzTCAEuw1b8ZMKpJp8qkUdPkwYEBeaxHClM4DPdAs3l4ek4Z6AdlmgO4iocbI2-VHdP1e7obiwDd8TUCAdLQZVd_qylDHrLBUNKGjJ4LIbzREDbPAMjCXJQJw6X19M45AwmXVBhPnxt2SZGkGZJWHQj5UbzxbyGNCQb2kjhWJpaZWkDZcW1kQmdQcKZanebrgzpXcu8k9HQMijAsSHFQhX16E1wZcrjcvMQk9HTrfWW6aAvSFl2tBS1ANTHEilB0K6WyEokmFrCSYBCXxgiAfU9j-VGiJnyFmkJo1P3poL4p55KLpviaMlZG-5oSbG4zP__PCT7LIzdZXKAS7mPDgyD-Us0K3GnujpwCaR-2EIhGSCkGdPUAbxkAhgrw0WSPkv0rJHHFa78WAoWXZYsj8MCBfvqYhwsT_66q8rhDrLNrfqMY3SAz3SNgyR06ZWkV8cEVVwtxsksaMm-jl7qyFEuZnILw5VEqA7DYXOTEQCknG9wfmokKpk9owvCy8P3uQpaaQkKhAMOWCNvTYRyZh_NJdoAPwZR6zCeDDVKyIcuuUaEktdWhEYE4qY3HYODzCNTnRBDV1c7zH4dSDJlaenSQxyuXLJTjFKkRhdqtCynKKzmxExA9hqsUDTpwx2pPzUqHFnAO-ac0DwmyiEAsZMv0cy29pIGKZuuGGrQdTgFFqfWgFOyHzJB_UPcyIwJZx6KhudTAwetFokujWyyKn6hc7AxVbxr9gAnpz6yV7VSLBSpBibAxIEhoQ_EgUGAFfxXV6JaeDLhcyQVHhonNT8cpoznATVWNhnIUqSidAHwzEp4rGZgYkKQcTBNhqi5je_iu3QD5iDHwQhGcxSBkWpnUOrVNJinUMX5j_JqdKYE2D1Tg7xIYxk9XjhO8G6Kj_mQepukjamkmrhORubEzAhHRdURURonsgJw2UsznoAjIOF48hSgIUeSQPD0QcZEPJ3-piadmlkxQegyNMhNDfvQFx9gaAx1BXoFLgZAeCmME9tKT0zWrdqChlRAXTXxHOqjuGSGTSxZDzoN_B0DmW9MgzM24wFPP7jHB_f4ze7xP8t4y0g-uMfvxT0ux91_97x-fffvfwE" rel="nofollow noreferrer">Attempt This Online!</a></p>
<p>This is a totally untrivial and interesting challenge. I am happy with the byte count.</p>
<p>My solution is based on the <a href="https://codegolf.stackexchange.com/a/68131/101276">Jakube's answer</a> (+1) and since my code has become so obscure even for myself =),  an ungolfed and commented version follows below.</p>
<p>I have managed to get rid of an <code>if</code> statement and save some bytes: the result to be returned is subsetted by a condition. I guess, that <code>TRUE</code> is being coerced to <code>1</code>, so, the first and the only item is returned, while <code>FALSE</code> is being turned to <code>0</code> which is an invalid index in R. In the last case a <code>numeric(0)</code> is returned, which is different from a <code>0</code> that would be a valid result.</p>
<pre><code>xort_R = function(V){
  
  # first we calculate how many elements are already correctly ordered
  # (it seems that &lt;= would be more robust, however `&lt;` works the same)

  SUM &lt;- sum(V[1:(length(V)-1)] &lt; V[2:length(V)])
  
  # now we iterate through all powers of 2 from 2^0 to the largest power
  # searching which number j would increase the sum of the ordered elements
  # (it turned out later that log2(max(V)) could be safely replaced with 30)

  POWERS &lt;- mapply(\(j) sum((bitwXor(V,j))[1:(length(V)-1)] &lt; (bitwXor(V,j))[2:length(V)]) &gt; SUM, 2^(0:30))
  
  # now we subset the powers and sum the terms to get the result 

  RESULT &lt;- sum(2^(0:30)[POWERS])
  
  # finally, we check if the RESULT we got produces an ordered vector:

  SUBSET_CONDITION &lt;- !unsorted(bitwXor(V, RESULT))
  
  # if TRUE, the &quot;ordering&quot; factor is returned,
  # otherwise this will give a numeric(0)

  RESULT[SUBSET_CONDITION]

}
</code></pre>
<h4>Edit:</h4>
<p>The solution has been successfully tested with the 4 large datasets and the processing times were less than a second each.</p>
<p>Additionally, 1000 more cases were generated and tested:</p>
<pre><code>&gt; all(mapply(\(j)f(bitwXor(1:1000,j)),0:999)==0:999)
[1] TRUE
</code></pre>
</div>
<div id="pu1" class="pu"><h1><a href="https://www.scala-lang.org/" rel="nofollow noreferrer">Scala 3</a>, 242 bytes</h1>
<p>A port of <a href="https://codegolf.stackexchange.com/a/68138/110802">@histocrat's Ruby answer</a> in Scala.</p>
<hr />
<p>Golfed version. <a href="https://ato.pxeger.com/run?1=7ZhLbqPHFYXnPc0GykRg_AQoot5Vt7spIAkyMBDDQAKPDMeguqkOE4oSSCpW0NBKMvEkngTIfpJleAX-TlHwoxMgvYDWgyrWX4_7OOfcK_792-Or9W6d_vnF7GJ_-_X6sJ99-a_bqz9vXp3cp-vt3r199o_70_VF__d3rzfX7np6eP6rw2H9ty8-2Z--nD_ndfX2r-udO6zGOctXt7sde7e3--XN_Wl9tdssP13fafVCO6b5i-vbwzSOmNaLq_nLi4flcbd9vd2_meJ8Ps7arqZfb9-wfFrP__g0uprPl1fb0-82-zenP12EF9vraXvpLsJ5x9VqWl9ebucfjwcHrNifMP44MfXxgdePVlfzt4fN6f6wZ9PjZnfcOM2vrh4fXxyWN-u76WF1-bD8Kr58yWuYL4_3N49nz__zi987J-dvOHJaH94cn7tzDP5wOmA3YXCf77cntyJYji9ZdNocT79ZHzdHZs_ejkfu6U1euLZwdeHCwvmFS3N3cenK4n-sCWPZD2suws8X-bEiLVwe69pY5P_roDjWhPG0_vzp-ZEfP238sL6wOOh37Ij_b0cZm36y410zg-81-JCbsT53yy1VOddq66GloGCUmn221pnuoTdLvcvmkFPx3id75-BZ6L7EaD2xvpdkqVbvWgk119ya44Lma8_dJc7PMfriWswWrATvevE952rVxRBDSr7m4Hq13mM148QUQunWmys51lS5DFOCDmi1uB5T6o0THMbXmtglZ6LnBMsuZh-aDz46fpmrMWIlN2Gxpeaiz7wzK901JnP2iedWOB3Hub3hkpnPHNqJESEozGYzfO5clXxnIc9YkJMvOMvabLVhaw2u-uYbhnEWJyYfLUedFX0sRIknFQM7PgefCoZkX4ld8nxrYSmEgfBgKRdiT3IkoXbPza6wN_faii7H6JDlfY8EpUVrrithuRB5S5kkhuId0SJ6nqux2qqvqXC2xZxqx0j8s4YlHJ4rzlUfXDGfghEoZ8VqSEayiFENWKaDQEsIeExeIustkhaC5WuQ1621iHXNVWzKqYfkzBu5UNASCGu5VLDRS-ye_LmkiPlMnrs3jKrJXCkYlRMm9Mq4lyK8tAysYnYp11jIHCMAGBLYI50N3PjSHJZnjG_RZY4ONUQCy6mgLiduI3B4ZEAplGxZO4gPuEyut5iCbOQyX0hdBkkVCiQj3k6MwBfBlKtwPIoDDcYQ7wy0kwfvRm4jASGlnhhVX5TUCkyAafNGIkMCDZZhpfhg2B-JF6HxMdSkeyKYTtpuLOuQw1zrpAcOdfnFnoplRDplwCz_IBZBxfIAMiz2LODjbALbBJR7wal3OVioXSHBT9jZMLfykFwFRTaT8TEHBGCyQFIUehwR2DrvCoGbLY93u-1pmrnZfMj4V8vTLQVjzp8hPe-IBkkiZDI6Z5lEZltAOlp1KIMYlEFtTSSFhNSUYh9xZnUzmduExMEh2I-zoIT4s7InsIFzWA4XtdpHJWH4CzMKIyPASgHBamAkBqEOenShqQvuMNShBmZ4qiD54rOYht8lD3Jm4mXAg1FERhNJZdRlOomSUjBIZAcCxBw9QcdfpAN-FILpG3R3RA96i3A15AI9sKBGUpy75mA0RktIiigcQHZtTJBpnvZSYToMrhBKQEVZE8ELvlbwXMC2zusJuUGDgkaEsnTNEdokikI8OAUHCHxqxBf8mAoCpsJVMINWwRkTRoPIL6-xnjijV2TMZ3EmyjM8MglzHuhAc723HqRuQLODJrCJ9jKmEjEcJIUSaAdKKu-D5D0hlaRXihITJgByYIzQRMDmJGAm8Gi2U5KAQBzD0BUTgE4ZgYx9iD2SWiEVQ8gIomUOekfBsvOsiiAVj2FFNlE7zEFroKuXcGso5W6SxyqKBSk_2sN5AmBqzBEjMTWQJw5XEaCiSDKSCEOG-WZbSQ0biTRDzKJMyTdqMqoWRC7pU4MKY5hUQ00LSCtyDk0oGSJOVB1sVGpAnzXsZxoFDSsJGAu6UKikjqIFVqLErzcmUR_NNo2b1Ah-AUpLo9aoNsA-hlAJgHrVSkYCQdQQTBIo-IVSYpBvcQwbROxdoiMuoYAq62QQYdWs6NJIjoac1cCOhiSLy95PQ-ipZpJaowhkCSLxBgGjWgNqXoQ8E5zMq1qb4uaHUhgsIqoUbhoAcmDSBUSYRqQTEYZQXM1RlgfSbpFaCCqSRw6rkDoXLxAC_M7LOVFDMCSxTSkLo80A4lSYgRsqeul4bKPTMq4WCKUflO9cRt3NMFTCliQgCaESxjygB-BO2kBsJYaB87vaJ1NhoM2Bi33UCK4CaRoSBcwhDqglT5MwlumT1MNoAZAJWK3DmAkqquARqnKNMCb5tVrVTmA3dWw0GdKT3lU1EX9VwFEYyogkHZmGWRSpQ6hNCot2CudQRUWZYRSqVcjoH_BeTRgkx33gJEHoaiuGF0CRnqiqdxMK4YQAyyYKX9Na3MDlpCuCirkN8UD1VC0QT9aDL9gw-A7z6IbiIDnQj2pOKMuwtqi9k3rxBfWJTVLGvfoU4pTJjxRXZRdVhb0VXaA7QaOgDHxBM4gVlFChIlvINOZzJBkOaj3VawydRgYJNeoWad66QEXqKoGnr0J21S9jExytA2nSSPV47EWKKRD0TBlRwxj1XBiGq56myptTA98VVYrBSK_abFJABaDDkDyphaMfUBwj8Xayj16SfCexHZ3pKvg6GeZjM-0eGVWRhGmcyIiAS3FcYoY4EiREUDJDaPARJ9AASiMtJTJPyVPd7upv0UXgEtT0Rf1jAHyRBhrMqkJB-UDYCBDyCuKENtNMkport0RDLCCv6o4G-0gunqEcRWoETyuSj6bE99IRzm90E-z4ICgfBOV9BeVHFfmJtnwQlA-Con9uxv8282fjz_XtwU3Tdn93f1q4zcPd5tVp83ruXl78-InU_OljqvMHVYfN8X6nz66uz7vmT8_uDtv9abefjrNPNP3c_fLteL68-cv5Y69ptsCsR7e6dJ_dn85Lng6bfvt0MVM_2DA7n_z4TL9PH61988357_c" rel="nofollow noreferrer">Attempt This Online!</a></p>
<pre class="lang-scala prettyprint-override"><code>def f(x:Array[Int]):Int={val r=scala.collection.mutable.Map[Int,Int]();for(Array(a,b)&lt;-x.sliding(2)){val i=(BigInt(a)^BigInt(b)).bitLength-1;if(i&gt; -1){val b=(a&gt;&gt;i)&amp;1;if(r.contains(i)&amp;&amp;r(i)!=b){return -1}else r(i)=b}};r.map(x=&gt;x._2&lt;&lt;x._1).sum}
</code></pre>
<p>Ungolfed version. <a href="https://ato.pxeger.com/run?1=7ZjLbpvXFYXnnne-KxQBiVLKuV8MW0CTdBCgQQdFR0FbUDalsKUplfwVJAj0JJ1k0jxU5n2PfuuQ1q0B6gewdTs8_7nsy1prb___-mn_ZrlZxh9__PftdHnafv7Vf64v_r56M9lXy_XWfnhh9nZ1aZfr3X76Yn15udqtt1efrafZ8qV9uZ0WdjH-zsdvez02mM0-W1_xebac21_tOL6Yz88u1tMfVtur6Rs7Nc_KuxfH87-73rF69_1L-91ut_z-azb85dmZ3y43tlv983a9W73FgD0Phulnb643GwxeX2_P3t1Oy4vN6uyr5c3XwzqdM5uP_ZfXO5uN02dLzJ7bq1PjxrP9Zv0Wn2ZhPj_edLhrzQW_4La2HletL222tnM79Q87D3vxk92zpZ2f23punwxnHzY9dgPztxOh3s-08JMnLmrq16912uMLjDXT7W7Lvfdzd7ba7FfPFj09aJzzsOHF47-H359-ap9fb79d7Sabvlk9Dfa75Y1N17bc2no7ra5Wu2NOdizb327krnsI82y9OFhNjB8f8-DGcddviZKC9eoVcXpkyuHxY4S8I0Yg5Gr_HiJ_mpQToeTP2_VTmEyr_fT5cr8SRg4ZP956-JAWVhdWFuYX5hYW53Z6bnnxC2v8WHa_5tQ_XeTGiriwNNbVscj9z0FhrPHjaXn69PDIje86vlmfWez1M3aE_7cjj02Pdjw307tWvPOpdtan1lONRc7VUpuv0SsYuSSXem1MN99qj63JZp9ids7F_uzgE99cDqG3yPqWY4-lOKvZl1RSrcYF1ZWWmkXOTyG4bDWk7nv2zlp2LaXSiwUffIyuJG-t9NZC6Z0To_e59VYtp1Bi4TJM8TqglmwtxNgqJxjGlxLZJWeC44SeLCTnq_MuGD_MlRCwkpuwuMdqwSU-9Z6bVSZTcpHnPXM6jnN7xaXeXeLQRowIQWY29Y7PjauiayzkGQtSdBlnWZt6qdhavBVXXcUwzuLE6EJPQWcFFzJR4knBwIbP3sWMIckVYhcdX1qYM2EgPFjKhdgTjSSU5rjZMntTKzXrcoz2Sd63QFBq6NWaEpYyke8xkUSfnREtoue4Gqt7cSVmzu4hxdIwEv96xRIOTwXnivOWu4u-EyjruRcfO8kiRsVjmQ4CLd7jMXkJrO-BtBAsV7y8rrUGrKtWsCnF5qN118mFghZBWE25gI2WQ3Pkz6Ii5hJ5bq5jVIndcsaoFDGhFcYtZ-GlJmAVksVUQiZzjACgj2CPdFZw43I1LE8YX4MljvbFBwLLqaAuRW4jcHjUgZLPqSftID7gMlqrIXrZyGUuk7oEkgoUiJ14mxiBL4IpV-F4EAcqjCHeCWhHB947uQ0EhJQ6YlRcVlILMAGm1XUS6SNo6AlWig8d-wPxIjQu-BJ1TwDTUds7yxrk6FYb6YFDTX6xp2AZkY4JMMs_iEVQsdyDjB5aEvBxNoJtAsq94NRZ8t2XppDgJ-ysmFt4SK68IpvI-JgDAjBZIMkKPY4IbI1PmcCdnO1vNhTFEzuZn1EhZn87m67VDfBnSM8z0SBJhExGpySTyGz1SEcthjKIQQnUlkhSSEiJMbQRZ1bXLnOrkDg4BPtxFpQQf1a2CDZwDsvhola7oCQMf2FGZtQJsFJAsCoYCV6ogx5NaGqCOww11KB3PFWQXHZJTMPvnAY5E_HqwINRQEYjSWXUZDqJklIwiGQHAoQUHEHHX6QDfmSC6Sp0N6IHvUW44lOGHlhQAilOTXMwGqMlJFkU9iC7VCbINE9bLjAdBhcIJaCirJHgeVcKeM5gW-e1iNygQV4jQpmb5ghtFEUhHpyCAwQ-VuILfroKAqbCVTCDVsGZLox6kV9eYz1xRq_ImEviTJBneNQlzGmgA811rjcvdQOaDTSBTbSXMZWI4SAplEA7UFJ57yXvEakkvVKUEDEBkANjhCYANpOAdYFHs42SBATCGPqmmAB0yghkbEPskdQCqRhCRhAtc9A7ClY_zKoIUvEYFmQTtcMctAa6Ogm3hlLuKnksopiX8qM9nCcAxsocMRJTPXnicBUBKookI4owZJgvtuVYsZFIM8QsypR8oyajal7kkj5VqDCGUTW0awFpRc6hCSVDxAmqg5VKDeiThu1AI69hIQFjQRMKldRRtMBKkPi1yiTqo9mqcZUawS9A2eOoNaoNsI8hVAKgTrWSkUAQNASTBAp-oZQY5GoYwwoRW5PoiEsooMo6GURYNSu6VJKjIWdVsKMhyeKyD9MQeqoTSW2nCCQJIvEGAaNaA2p-CXldcOpO1borbm4oRYdFRJXCTQNADrp0ARGmEWlEhCEUV3OU5IG0W6QWgrLkkcMKpE7ZCYQAv_HrkKghGJLYqpT50WYAcSrMwA0VPTc87qPT6lwtEEo_KN8pj7qbYKiELUpAIkIljDlAD8BN2kBsJYae85vap67CQJsDF9uoEVwF0jQkCphDHFBLnkZhLNEnqYfRAiDjsVqHMeNVVMEjVOUaYUzy20tRO4Hd1LHRZEhPWlPVRPxVAUdhyCOSdGQaJlGkDKHuUli0UziHKirKDINQrUJG_4D3asIgOe4DJwlCU1sxvACK9ERFvZtQCCcEWDZR-KrW4gYuR13hVcz7EA9UT9UC8WQ9-IINg-8wj24oDJID_aDmhLIMa7PaO6kX_6A-sYnKuFOfQpwS-ZHiquyiqrC3oAt0J2gUlIEvaAaxghIqVGQLmcZ8jiTDXq2neo2h08ggoUbdAs1bE6hIXSHw9FXIrvplbIKjZSBNGqkej71IMQWCnikhahijngvDcNXRVLluauCbokoxGOlVm00KqAB0GJIntXD0A4pjIN4m--glyXcU29GZpoKvk2E-NtPukVEVSZjGiYwIuBTHIjPEkSAhgpIZQoOPOIEGUBppKZF5Sp7qdlN_iy4CF6-mL-g_BsAXaaDBLCoUlA-EjQAhryBOaOuaiVJz5ZZoiAXkVd3RYB_JxTOUI0uN4GlB8tGU8EE6wvmVboIdHwXlo6B8qKA8qMgjbfkoKB8F5fz9K7j5i8fvvrY3t9PCVt_drN5Mq7fjJdj9G6mn7xjv352N959j4_uXize79XbabGf7ky81_dJ-88N4fvbuH4c3X7OTBZbd2etz--PtdFhyPG_2--PdTN2bcfLwfu3uxd3hbe_xpe_7l7__BQ" rel="nofollow noreferrer">Attempt This Online!</a></p>
<pre class="lang-scala prettyprint-override"><code>object Main {
  def firstDifferingBit(a: Int, b: Int): Int = {
    (BigInt(a) ^ BigInt(b)).bitLength - 1
  }

  def xort(ary: Array[Int]): Int = {
    val requiredBits = scala.collection.mutable.Map[Int, Int]()
    for (Array(a, b) &lt;- ary.sliding(2)) {
      val i = firstDifferingBit(a, b)
      if (i &gt; -1) {
        val bit = (a &gt;&gt; i) &amp; 1
        if (requiredBits.contains(i) &amp;&amp; requiredBits(i) != bit) {
          return -1
        } else {
          requiredBits(i) = bit
        }
      }
    }
    // Convert the requiredBits map to an integer
    var result = 0
    for ((i, bit) &lt;- requiredBits) {
      result += (bit &lt;&lt; i)
    }
    result
  }

  def main(args: Array[String]): Unit = {
    val testCases = Array(
      Array(4, 7, 6, 1, 0, 3) -&gt; 5,
      Array(4, 7, 1, 6, 0, 3) -&gt; -1,
      Array(0, 1, 3, 4, 6, 7) -&gt; 0,
      Array(4, 2, 3, 1) -&gt; 6,
      Array(2, 3, 0, 0, 7, 7, 4, 5, 11, 11) -&gt; 2,
      Array(2, 3, 0, 0, 7, 7, 5, 4, 11, 11) -&gt; -1,
      Array(1086101479, 748947367, 1767817317, 656404978, 1818793883, 1143500039) -&gt; -1,
      &quot;180522983 1885393660 751646477 367706848 331742205 724919510 850844696 2121330641 869882699 1831158987 542636180 1117249765 823387844 731663826 1762069894 240170102 1020696223 1212052937 2041219958 712044033 195249879 1871889904 1787674355 1849980586 1308879787 1743053674 1496763661 607071669 1987302942 178202560 1666170841 1035995406 75303032 1755269469 200581873 500680130 561748675 1749521426 1828237297 835004548 934883150 38711700 1978960635 209243689 1355970350 546308601 590319412 959613996 1956169400 140411967 112601925 88760619 1977727497 672943813 909069787 318174568 385280382 370710480 809689639 557034312 865578556 217468424 346250334 388513751 717158057 941441272 437016122 196344643 379529969 821549457 97008503 872313181 2105942402 603939495 143590999 1580192283 177939344 853074291 1288703007 1605552664 162070930 1325694479 850975127 681702163 1432762307 1994488829 780869518 4379756 602743458 1963508385 2115219284 1219523498 559301490 4191682 1918142271 169309431 346461371 1619467789 1521741606 1881525154&quot;.split(&quot; &quot;).map(_.toInt).toArray -&gt; -1,
      &quot;37580156 64423492 87193676 91914964 93632157 96332899 154427982 176139560 184435039 228963836 230164674 279802291 301492375 309127664 345705721 370150824 380319820 403997410 410504675 416543032 418193132 424733526 428149607 435596038 477224208 515649925 519407995 525469350 614538124 624884850 642649261 653488151 679260270 685637235 690613185 739141066 825795124 832026691 832633584 833213619 852655299 913744258 917674993 921902522 925691996 931307936 954676047 972992595 997654606 1020009811 1027484648 1052748108 1071580605 1108881241 1113730139 1122392118 1154042251 1170901568 1180031842 1180186856 1206428383 1214066097 1242934611 1243983997 1244736049 1262979035 1312007069 1312030297 1356274316 1368442960 1377432523 1415342434 1471294243 1529353536 1537868913 1566069818 1610578189 1612277199 1613646498 1639183592 1668015280 1764022840 1784234921 1786654280 1835593744 1849372222 1875931624 1877593764 1899940939 2007896363 2023046907 2030492562 2032619034 2085680072 2085750388 2110824853 2123924948 2131327206 2134927760 2136423634&quot;.split(&quot; &quot;).map(_.toInt).toArray -&gt; 0,
&quot;1922985547 1934203179 1883318806 1910889055 1983590560 1965316186 2059139291 2075108931 2067514794 2117429526 2140519185 1659645051 1676816799 1611982084 1736461223 1810643297 1753583499 1767991311 1819386745 1355466982 1349603237 1360540003 1453750157 1461849199 1439893078 1432297529 1431882086 1427078318 1487887679 1484011617 1476718655 1509845392 1496496626 1583530675 1579588643 1609495371 1559139172 1554135669 1549766410 1566844751 1562161307 1561938937 1123551908 1086169529 1093103602 1202377124 1193780708 1148229310 1144649241 1257633250 1247607861 1241535002 1262624219 1288523504 1299222235 840314050 909401445 926048886 886867060 873099939 979662326 963003815 1012918112 1034467235 1026553732 568519178 650996158 647728822 616596108 617472393 614787483 604041145 633043809 678181561 698401105 776651230 325294125 271242551 291800692 389634988 346041163 344959554 345547011 342290228 354762650 442183586 467158857 412090528 532898841 534371187 32464799 21286066 109721665 127458375 192166356 146495963 142507512 167676030 236532616 262832772&quot;.split(&quot; &quot;).map(_.toInt).toArray -&gt; 1927544832,
&quot;1922985547 1934203179 1883318806 1910889055 1983590560 1965316186 2059139291 2075108931 2067514794 2117429526 2140519185 1659645051 1676816799 1611982084 1736461223 1810643297 1753583499 1767991311 1819386745 1355466982 1349603237 1360540003 1453750157 1461849199 1439893078 1432297529 1431882086 1427078318 1487887679 1484011617 1476718655 1509845392 1496496626 1583530675 1579588643 1609495371 1559139172 1554135669 1549766410 1566844751 1562161307 1561938937 1123551908 1086169529 1093103602 1202377124 1193780708 1148229310 1144649241 1257633250 1241535002 1247607861 1262624219 1288523504 1299222235 840314050 909401445 926048886 886867060 873099939 979662326 963003815 1012918112 1034467235 1026553732 568519178 650996158 647728822 616596108 617472393 614787483 604041145 633043809 678181561 698401105 776651230 325294125 271242551 291800692 389634988 346041163 344959554 345547011 342290228 354762650 442183586 467158857 412090528 532898841 534371187 32464799 21286066 109721665 127458375 192166356 146495963 142507512 167676030 236532616 262832772&quot;.split(&quot; &quot;).map(_.toInt).toArray -&gt; -1
    )

    for ((input, expected) &lt;- testCases) {
      val result = xort(input)
      println(s&quot;Input: ${input.mkString(&quot;, &quot;)} =&gt; Output: $result (Expected: $expected)&quot;)
    }
  }
}
</code></pre>
</div>
<div id="pu2" class="pu"><h1><a href="https://github.com/ETHproductions/japt" rel="nofollow noreferrer">Japt</a>, 11 <a href="https://en.wikipedia.org/wiki/ISO/IEC_8859-1" rel="nofollow noreferrer">bytes</a></h1>
<p>(Eventually) Outputs <code>undefined</code> for falsey inputs.</p>
<pre><code>@Ë^XÃäÎø1}f
</code></pre>
<p><a href="https://petershaggynoble.github.io/Japt-Interpreter/?v=1.4.6&amp;code=QMteWMPkzvgxfWY&amp;input=WzQsIDcsIDYsIDEsIDAsIDNd" rel="nofollow noreferrer">Try it</a></p>
<pre><code>@Ë^XÃäÎø1}f     :Implicit input of array U
@               :Function taking an integer X as argument
 Ë              :  Map U
  ^X            :    XOR X
    Ã           :  End map
     ä          :  Consecutive pairs
      Î         :  Signs of differences
       ø1       :  Contains 1?
         }      :End function
          f     :Get the first X&gt;=0 that returns false
</code></pre>
</div>
<div id="pu3" class="pu"><h1><a href="https://github.com/tomtheisen/stax" rel="nofollow noreferrer">Stax</a>, 29 <a href="https://github.com/tomtheisen/stax/blob/master/docs/packed.md#packed-stax" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>¬√▬ⁿ{j╔■α√ï(íP♫_z(.▀ng▒JU↨@b┬
</code></pre>
<p><a href="https://staxlang.xyz/#p=aafb16fc7b6ac9fee0fb8b28a1500e5f7a282edf6e67b14a5517406383&amp;i=%5B4+7+6+1+0+3%5D%0A%5B4+7+1+6+0+3%5D%0A%5B0+1+3+4+6+7%5D%0A%5B4+2+3+1%5D%0A%5B2+3+0+0+7+7+4+5+11+11%5D%0A%5B2+3+0+0+7+7+5+4+11+11%5D%0A%5B1086101479+748947367+1767817317+656404978+1818793883+1143500039%5D%0A%5B180522983+1885393660+751646477+367706848+331742205+724919510+850844696+2121330641+869882699+1831158987+542636180+1117249765+823387844+731663826+1762069894+240170102+1020696223+1212052937+2041219958+712044033+195249879+1871889904+1787674355+1849980586+1308879787+1743053674+1496763661+607071669+1987302942+178202560+1666170841+1035995406+75303032+1755269469+200581873+500680130+561748675+1749521426+1828237297+835004548+934883150+38711700+1978960635+209243689+1355970350+546308601+590319412+959613996+1956169400+140411967+112601925+88760619+1977727497+672943813+909069787+318174568+385280382+370710480+809689639+557034312+865578556+217468424+346250334+388513751+717158057+941441272+437016122+196344643+379529969+821549457+97008503+872313181+2105942402+603939495+143590999+1580192283+177939344+853074291+1288703007+1605552664+162070930+1325694479+850975127+681702163+1432762307+1994488829+780869518+4379756+602743458+1963508385+2115219284+1219523498+559301490+4191682+1918142271+169309431+346461371+1619467789+1521741606+1881525154%5D%0A%5B37580156+64423492+87193676+91914964+93632157+96332899+154427982+176139560+184435039+228963836+230164674+279802291+301492375+309127664+345705721+370150824+380319820+403997410+410504675+416543032+418193132+424733526+428149607+435596038+477224208+515649925+519407995+525469350+614538124+624884850+642649261+653488151+679260270+685637235+690613185+739141066+825795124+832026691+832633584+833213619+852655299+913744258+917674993+921902522+925691996+931307936+954676047+972992595+997654606+1020009811+1027484648+1052748108+1071580605+1108881241+1113730139+1122392118+1154042251+1170901568+1180031842+1180186856+1206428383+1214066097+1242934611+1243983997+1244736049+1262979035+1312007069+1312030297+1356274316+1368442960+1377432523+1415342434+1471294243+1529353536+1537868913+1566069818+1610578189+1612277199+1613646498+1639183592+1668015280+1764022840+1784234921+1786654280+1835593744+1849372222+1875931624+1877593764+1899940939+2007896363+2023046907+2030492562+2032619034+2085680072+2085750388+2110824853+2123924948+2131327206+2134927760+2136423634%5D%0A%5B1922985547+1934203179+1883318806+1910889055+1983590560+1965316186+2059139291+2075108931+2067514794+2117429526+2140519185+1659645051+1676816799+1611982084+1736461223+1810643297+1753583499+1767991311+1819386745+1355466982+1349603237+1360540003+1453750157+1461849199+1439893078+1432297529+1431882086+1427078318+1487887679+1484011617+1476718655+1509845392+1496496626+1583530675+1579588643+1609495371+1559139172+1554135669+1549766410+1566844751+1562161307+1561938937+1123551908+1086169529+1093103602+1202377124+1193780708+1148229310+1144649241+1257633250+1247607861+1241535002+1262624219+1288523504+1299222235+840314050+909401445+926048886+886867060+873099939+979662326+963003815+1012918112+1034467235+1026553732+568519178+650996158+647728822+616596108+617472393+614787483+604041145+633043809+678181561+698401105+776651230+325294125+271242551+291800692+389634988+346041163+344959554+345547011+342290228+354762650+442183586+467158857+412090528+532898841+534371187+32464799+21286066+109721665+127458375+192166356+146495963+142507512+167676030+236532616+262832772%5D%0A%5B1922985547+1934203179+1883318806+1910889055+1983590560+1965316186+2059139291+2075108931+2067514794+2117429526+2140519185+1659645051+1676816799+1611982084+1736461223+1810643297+1753583499+1767991311+1819386745+1355466982+1349603237+1360540003+1453750157+1461849199+1439893078+1432297529+1431882086+1427078318+1487887679+1484011617+1476718655+1509845392+1496496626+1583530675+1579588643+1609495371+1559139172+1554135669+1549766410+1566844751+1562161307+1561938937+1123551908+1086169529+1093103602+1202377124+1193780708+1148229310+1144649241+1257633250+1241535002+1247607861+1262624219+1288523504+1299222235+840314050+909401445+926048886+886867060+873099939+979662326+963003815+1012918112+1034467235+1026553732+568519178+650996158+647728822+616596108+617472393+614787483+604041145+633043809+678181561+698401105+776651230+325294125+271242551+291800692+389634988+346041163+344959554+345547011+342290228+354762650+442183586+467158857+412090528+532898841+534371187+32464799+21286066+109721665+127458375+192166356+146495963+142507512+167676030+236532616+262832772%5D&amp;a=1&amp;m=2" rel="nofollow noreferrer">Run and debug online!</a></p>
<p>Uses @RainerP.'s solution (came up with the flipping bit part independently but uses the <code>32rr</code> part)</p>
<p>Linear time complexity.</p>
<p>Uses the unpacked version to explain.</p>
<pre><code>32rr{|2Y;{y/m:^!c{,{y|^m~}Mm,:^ud:b
32rr                                   Range [32,31..0]
    {                      m           Map each number `k` in the range with
     |2Y                                   `2^k`
        ;{y/m                              Map each number `l` in the input to `floor(l/2^k)`
             :^!                           The mapped array is not non-decreasing
                                           This is the binary digit `l` is mapped to
                c{       }M                If that's true, do
                  ,{y|^m~                  Flip the corresponding bit of every element in the input
                            ,:^        The final array is sorted
                               ud      Take inverse and discard, if the final array is not sorted this results in zero-division error
                                 :b    Convert mapped binary to integer
</code></pre>
</div>
<div id="pu4" class="pu"><h1>Pyth, <s>40</s> <s>36</s> <s>31</s> 30 bytes</h1>

<pre><code>Ju.|G^2slHxMf&gt;FT.:Q2Z|tSIxRJQJ
</code></pre>

<p>Try it online: <a href="http://pyth.herokuapp.com/?test_suite=0&amp;test_suite_input=%5B4%2C7%2C6%2C1%2C0%2C3%5D%0A%5B4%2C7%2C1%2C6%2C0%2C3%5D%0A%5B0%2C1%2C3%2C4%2C6%2C7%5D%0A%5B4%2C2%2C3%2C1%5D%0A%5B2%2C3%2C0%2C0%2C7%2C7%2C4%2C5%2C11%2C11%5D%0A%5B2%2C3%2C0%2C0%2C7%2C7%2C5%2C4%2C11%2C11%5D%0A%5B1086101479%2C748947367%2C1767817317%2C656404978%2C1818793883%2C1143500039%5D%0A%5B37580156%2C64423492%2C87193676%2C91914964%2C93632157%2C96332899%2C154427982%2C176139560%2C184435039%2C228963836%2C230164674%2C279802291%2C301492375%2C309127664%2C345705721%2C370150824%2C380319820%2C403997410%2C410504675%2C416543032%2C418193132%2C424733526%2C428149607%2C435596038%2C477224208%2C515649925%2C519407995%2C525469350%2C614538124%2C624884850%2C642649261%2C653488151%2C679260270%2C685637235%2C690613185%2C739141066%2C825795124%2C832026691%2C832633584%2C833213619%2C852655299%2C913744258%2C917674993%2C921902522%2C925691996%2C931307936%2C954676047%2C972992595%2C997654606%2C1020009811%2C1027484648%2C1052748108%2C1071580605%2C1108881241%2C1113730139%2C1122392118%2C1154042251%2C1170901568%2C1180031842%2C1180186856%2C1206428383%2C1214066097%2C1242934611%2C1243983997%2C1244736049%2C1262979035%2C1312007069%2C1312030297%2C1356274316%2C1368442960%2C1377432523%2C1415342434%2C1471294243%2C1529353536%2C1537868913%2C1566069818%2C1610578189%2C1612277199%2C1613646498%2C1639183592%2C1668015280%2C1764022840%2C1784234921%2C1786654280%2C1835593744%2C1849372222%2C1875931624%2C1877593764%2C1899940939%2C2007896363%2C2023046907%2C2030492562%2C2032619034%2C2085680072%2C2085750388%2C2110824853%2C2123924948%2C2131327206%2C2134927760%2C2136423634%5D%0A%5B1922985547%2C1934203179%2C1883318806%2C1910889055%2C1983590560%2C1965316186%2C2059139291%2C2075108931%2C2067514794%2C2117429526%2C2140519185%2C1659645051%2C1676816799%2C1611982084%2C1736461223%2C1810643297%2C1753583499%2C1767991311%2C1819386745%2C1355466982%2C1349603237%2C1360540003%2C1453750157%2C1461849199%2C1439893078%2C1432297529%2C1431882086%2C1427078318%2C1487887679%2C1484011617%2C1476718655%2C1509845392%2C1496496626%2C1583530675%2C1579588643%2C1609495371%2C1559139172%2C1554135669%2C1549766410%2C1566844751%2C1562161307%2C1561938937%2C1123551908%2C1086169529%2C1093103602%2C1202377124%2C1193780708%2C1148229310%2C1144649241%2C1257633250%2C1247607861%2C1241535002%2C1262624219%2C1288523504%2C1299222235%2C840314050%2C909401445%2C926048886%2C886867060%2C873099939%2C979662326%2C963003815%2C1012918112%2C1034467235%2C1026553732%2C568519178%2C650996158%2C647728822%2C616596108%2C617472393%2C614787483%2C604041145%2C633043809%2C678181561%2C698401105%2C776651230%2C325294125%2C271242551%2C291800692%2C389634988%2C346041163%2C344959554%2C345547011%2C342290228%2C354762650%2C442183586%2C467158857%2C412090528%2C532898841%2C534371187%2C32464799%2C21286066%2C109721665%2C127458375%2C192166356%2C146495963%2C142507512%2C167676030%2C236532616%2C262832772%5D&amp;input=%5B4%2C7%2C6%2C1%2C0%2C3%5D&amp;code=Ju.%7CG%5E2slHxMf%3EFT.%3AQ2Z%7CtSIxRJQJ" rel="nofollow noreferrer">Demonstration</a> or <a href="http://pyth.herokuapp.com/?test_suite=1&amp;test_suite_input=%5B4%2C7%2C6%2C1%2C0%2C3%5D%0A%5B4%2C7%2C1%2C6%2C0%2C3%5D%0A%5B0%2C1%2C3%2C4%2C6%2C7%5D%0A%5B4%2C2%2C3%2C1%5D%0A%5B2%2C3%2C0%2C0%2C7%2C7%2C4%2C5%2C11%2C11%5D%0A%5B2%2C3%2C0%2C0%2C7%2C7%2C5%2C4%2C11%2C11%5D%0A%5B1086101479%2C748947367%2C1767817317%2C656404978%2C1818793883%2C1143500039%5D%0A%5B37580156%2C64423492%2C87193676%2C91914964%2C93632157%2C96332899%2C154427982%2C176139560%2C184435039%2C228963836%2C230164674%2C279802291%2C301492375%2C309127664%2C345705721%2C370150824%2C380319820%2C403997410%2C410504675%2C416543032%2C418193132%2C424733526%2C428149607%2C435596038%2C477224208%2C515649925%2C519407995%2C525469350%2C614538124%2C624884850%2C642649261%2C653488151%2C679260270%2C685637235%2C690613185%2C739141066%2C825795124%2C832026691%2C832633584%2C833213619%2C852655299%2C913744258%2C917674993%2C921902522%2C925691996%2C931307936%2C954676047%2C972992595%2C997654606%2C1020009811%2C1027484648%2C1052748108%2C1071580605%2C1108881241%2C1113730139%2C1122392118%2C1154042251%2C1170901568%2C1180031842%2C1180186856%2C1206428383%2C1214066097%2C1242934611%2C1243983997%2C1244736049%2C1262979035%2C1312007069%2C1312030297%2C1356274316%2C1368442960%2C1377432523%2C1415342434%2C1471294243%2C1529353536%2C1537868913%2C1566069818%2C1610578189%2C1612277199%2C1613646498%2C1639183592%2C1668015280%2C1764022840%2C1784234921%2C1786654280%2C1835593744%2C1849372222%2C1875931624%2C1877593764%2C1899940939%2C2007896363%2C2023046907%2C2030492562%2C2032619034%2C2085680072%2C2085750388%2C2110824853%2C2123924948%2C2131327206%2C2134927760%2C2136423634%5D%0A%5B1922985547%2C1934203179%2C1883318806%2C1910889055%2C1983590560%2C1965316186%2C2059139291%2C2075108931%2C2067514794%2C2117429526%2C2140519185%2C1659645051%2C1676816799%2C1611982084%2C1736461223%2C1810643297%2C1753583499%2C1767991311%2C1819386745%2C1355466982%2C1349603237%2C1360540003%2C1453750157%2C1461849199%2C1439893078%2C1432297529%2C1431882086%2C1427078318%2C1487887679%2C1484011617%2C1476718655%2C1509845392%2C1496496626%2C1583530675%2C1579588643%2C1609495371%2C1559139172%2C1554135669%2C1549766410%2C1566844751%2C1562161307%2C1561938937%2C1123551908%2C1086169529%2C1093103602%2C1202377124%2C1193780708%2C1148229310%2C1144649241%2C1257633250%2C1247607861%2C1241535002%2C1262624219%2C1288523504%2C1299222235%2C840314050%2C909401445%2C926048886%2C886867060%2C873099939%2C979662326%2C963003815%2C1012918112%2C1034467235%2C1026553732%2C568519178%2C650996158%2C647728822%2C616596108%2C617472393%2C614787483%2C604041145%2C633043809%2C678181561%2C698401105%2C776651230%2C325294125%2C271242551%2C291800692%2C389634988%2C346041163%2C344959554%2C345547011%2C342290228%2C354762650%2C442183586%2C467158857%2C412090528%2C532898841%2C534371187%2C32464799%2C21286066%2C109721665%2C127458375%2C192166356%2C146495963%2C142507512%2C167676030%2C236532616%2C262832772%5D&amp;input=%5B4%2C7%2C6%2C1%2C0%2C3%5D&amp;code=Ju.%7CG%5E2slHxMf%3EFT.%3AQ2Z%7CtSIxRJQJ" rel="nofollow noreferrer">Test Suite</a></p>

<p>Each of the big test-cases finishes in a couple of seconds. </p>

<h3>Explanation:</h3>

<p>First I'll explain the method and why it works. I'll do this with the example list: <code>[7, 2, 13, 9]</code>. </p>

<p>The first two numbers are already wrong (<code>7 &gt; 2</code>). We want to xor with some number to change that inequality symbol (<code>7 xor X &lt; 2 xor X</code>). Since xor operates on the binary representations, lets look at them. </p>

<pre><code>7 = 1 1 1
2 =   1 0
</code></pre>

<p>When we apply xor with some number to each number, the value at some positions will change. If you change the values at the first position (<code>2^0</code>), the inequality symbol doesn't change. The same thing happens, when we change the values at the second position (<code>2^1</code>). Also the symbol won't change if we change values at the fourth, fifth, ... positions (<code>2^3</code>, <code>2^4</code>, ...). The inequality symbol only changes direction, if we change the third position (<code>2^2</code>). </p>

<pre><code>7 xor 2^0 = 1 1 0   7 xor 2^1 = 1 0 1   7 xor 2^2 =   1 1   7 xor 2^3 = 1 1 1 1
2 xor 2^0 =   1 1   2 xor 2^1 =     0   2 xor 2^2 = 1 1 0   2 xor 2^3 = 1 0 1 0
     6 &gt; 3               5 &gt; 0               3 &lt; 6               15 &gt; 10
</code></pre>

<p>If we change multiple positions at once, of course the same thing happens. If any of the positions we change is the third, than the inequality symbol changes, otherwise not. </p>

<p>The next pair is already sorted: <code>2 &lt; 13</code>. If we look at the binary representation, we notice, that we can xor anything to it and the inequality symbol is still correct, except when we change the fourth position (<code>2^3</code>). </p>

<pre><code> 2 =     1 0    2 xor 2^3 = 1 0 1 0
13 = 1 1 0 1   13 xor 2^3 =   1 0 1
   2 &lt; 13            10 &gt; 5
</code></pre>

<p>So we don't want to change the fourth position. For the next pair we want to change something, since <code>13 &gt; 9</code>. Here we again have to change the third position. </p>

<pre><code>13 = 1 1 0 1   13 xor 2^2 = 1 0 0 1
 9 = 1 0 0 1    9 xor 2^2 = 1 1 0 1
   13 &gt; 9            9 &lt; 13
</code></pre>

<p>Now recap: To end up in a sorted list, we again have to change the third position and don't want to change the fourth position. All other positions doesn't matter. The smallest number is simply <code>4 = 0100</code>. Other choices would be <code>5 = 0101</code>, <code>6 = 0110</code>, <code>7 = 0111</code>, <code>20 = 10100</code>, <code>21 = 10101</code>, ...</p>

<p>Xoring with <code>4</code> will result in the list <code>[3, 6, 9, 13]</code>, with <code>6</code> will get <code>[1, 4, 11, 15]</code>, and with <code>21</code> will get <code>[18, 23, 24, 28]</code>. </p>

<p>So for a list, we need to find the positions, that will change the inequality symbol if it points into the wrong direction. We find the position simply by taking the most significant bit of the xor of the pair. We combine all these position (with or) to result in a candidate number. The we check, if we haven't accidentally destroyed the already sorted pairs. </p>

<pre><code>Ju.|G^2slHxMf&gt;FT.:Q2Z   implicit: Q = input list
                .:Q2    all substrings of length 2
            f&gt;FT        filter for pairs that are in descending order
          xM            apply xor to each such pair
 u                  Z   reduce this list, start value G = 0
                           iteration value is H
     ^2slH                 2 to the power of floor(logarithm base 2 of H)
                           this gives a mask representing the most significant bit
  .|G                      update G with the bitwise or of G and ^
J                       store the result in J


|tSIxRJQJ   
    xRJQ      xor each element of the input list with J
  SI          check if the list is sorted
 t            subtract 1
|       J     this number or (if equal to zero) J
              implicit print
</code></pre>
</div>
<div id="pu5" class="pu"><h1><a href="https://github.com/cairdcoinheringaahing/AddPlusPlus" rel="nofollow noreferrer">Add++</a>, <s>125</s> 119 bytes</h1>

<pre><code>D,g,@@,BxBBBDbU1€oB]BJ2$Bb1+
D,j,@,bUBSVcGbU£{g}B]BkAbUBSVcGbU£&gt;B]BKBcB*¦Bo2/i
L!,B#a=
D,f,?!,{j}Vad{j}BF€Bx1]G$0=-1$Qp
</code></pre>

<p><a href="https://tio.run/##TVTLbl1FEFznfsWN8AquRb@mH4sczJFFJIIUIeTssrBjOSIs4gVIkaJs@BUkVnxFPoUfMTU9FuDF8a2eme6uqp65vr29v394uDy9PV1cnPYP@75f3lzx37//9X5/vX8vZ/sNf3W4PL07XZxurvafXr15fnP1@Y@Pbz9h@Zdv/xfaEHixv9m//Pzn/l6@/vnww9PT/sX1Mxy@O33z9PTx3adX17f47t8h@/6BXz8/o2fnfPbj/cPZ3WZbbL7xRpseXh4OjxFG7L8IASvivsW/ewQRfkTH@cclUjmGxXEDUBNSjpogUxUf8l5hyiwao0HqwG@n43Z4wuVD2TnnPqFRrCXFDWLgWOkCDmRRNgFzmNQQnxmEjQYqZCf3UW4DgQbhiU91Q86oLJQzA4e6OYto95BMbirVLGLoSLV1KOZpVu50CYbpYV1IwdodGTsD9jupaGdQp2FEpBPY0BjEo1dQM6145TYtsKPIzoD6aGDI4xKkQ68tnklgEyINMjJnVwsYMYjFyoAwdFwiD6pE6ZLeB03KXTodyA2dcjaIGpkg3xmcygr9NtvRXnDIAgbG4NvAKtyNqYF7msUUHBmGC/oBqbU0BaslCgsU46JmAWbs9UiWYDFBs6WkEFQMlrYJ5yMp1iHQhUS6yrIZOIl1qzLCVWWsiRIIAcF8LRnDT6JmIZBATLjLSuZAT9SFpDDJGIcxM0BVnUNFRywVNCFUGw3EyRKCTYB/mAby3pahVFVax5mhYsqt0vvKFbOQ3BmYUAuTxN0QKWhElwUQeKehrcPwnEON4cCSw81yONfAItC7SIMeeOi5QBiSlXYPjoHIsNReIiODaN0DtCLTpGoQiXZgVYPqiaLRGQIuD/jWBCGvlEHqCWQaJPCzAfgQeXVD8NtxGTI7g5rPst49gGuNwiQtMF8N1FoAxpJIs1DE4VOrf3hisAsDuxSHVhAhcZcmwKjgGVmHhkqiqPEChhnmjNWDYFLmG9C9wnYn9@PyogLj6ssYwcVO3NUGNeMY@OO6WT47XyxwHcd8mZrtfGEwbEshUTxlAkcauKQKnDq8fHg4P//t17t/AA" rel="nofollow noreferrer" title="Add++ – Try It Online">Try it online!</a></p>

<p><sub>I am actually really proud that Add++ is able to do this, and isn't the longest solution here</sub></p>

<p>Declares a function <code>f</code> that takes each element as a separate argument (e.g. <code>$f&gt;4&gt;2&gt;3&gt;1</code>)</p>

<h2>How it works</h2>

<p>Buckle up folks, it's going to be a long ride</p>

<pre><code>D,g,@@,&#9;&#9;; Declare a function 'g'
&#9;&#9;; Example arguments: &#9;&#9;[4 7]
&#9;Bx&#9;; Xor;&#9;&#9;&#9;STACK = [3]
&#9;BB&#9;; To binary;&#9;&#9;STACK = [11]
&#9;BD&#9;; Digits;&#9;&#9;STACK = [[1 1]]
&#9;bU&#9;; Unpack;&#9;&#9;STACK = [1 1]
&#9;1€o&#9;; Replace 0s with 1s;&#9;STACK = [1 1]
&#9;B]&#9;; Wrap;&#9;&#9;&#9;STACK = [[1 1]]
&#9;BJ&#9;; Concatenate;&#9;&#9;STACK = ['11']
&#9;2$Bb&#9;; From binary;&#9;&#9;STACK = [3]
&#9;1+&#9;; Increment;&#9;&#9;STACK = [4]
&#9;&#9;;&#9;&#9;&#9;Return   4

D,j,@,&#9;&#9;; Declare a function 'j'
&#9;&#9;; Example argument:&#9;&#9;[[4 7 6 1 0 3]]
&#9;bU&#9;; Unpack;&#9;&#9;STACK = [4 7 6 1 0 3]
&#9;BS&#9;; Overlapping pairs;&#9;STACK = [4 7 6 1 0 3 [[4 7] [4 6] [6 1] [1 0] [0 3]]]
&#9;VcG&#9;; Keep first element;&#9;STACK = [[[4 7] [4 6] [6 1] [1 0] [0 3]]]
&#9;bU&#9;; Unpack;&#9;&#9;STACK = [[4 7] [4 6] [6 1] [1 0] [0 3]]
&#9;£{g}&#9;; Apply 'g' over each;&#9;STACK = [4 2 8 2 4]
&#9;B]&#9;; Wrap;&#9;&#9;&#9;STACK = [[4 2 8 2 4]]
&#9;Bk&#9;; Global save;&#9;&#9;STACK = []&#9;&#9;; GLOBAL = [4 2 8 2 4]
&#9;A&#9;; Push arguments;&#9;STACK = [[4 7 6 1 0 3]]
&#9;bU&#9;; Unpack;&#9;&#9;STACK = [4 7 6 1 0 3]
&#9;BSVcGbU&#9;; Overlapping pairs;&#9;STACK = [[4 7] [4 6] [6 1] [1 0] [0 3]]
&#9;£&gt;&#9;; Greater than each;&#9;STACK = [0 1 1 1 0]
&#9;B]&#9;; Wrap;&#9;&#9;&#9;STACK = [[0 1 1 1 0]]
&#9;BK&#9;; Global get;&#9;&#9;STACK = [[0 1 1 1 0] [4 2 8 2 4]]
&#9;BcB*&#9;; Products;&#9;&#9;STACK = [[0 2 8 2 0]]
&#9;¦Bo&#9;; Reduce by logical OR;&#9;STACK = [10]
&#9;2/i&#9;; Halve;&#9;&#9;STACK = [5]
&#9;&#9;;&#9;&#9;&#9;Return   5

L!,&#9;&#9;; Declare 'lambda 1'
&#9;&#9;; Example argument:&#9;&#9;[[1 2 3 4 5]]
&#9;B#&#9;; Sort;&#9;&#9;&#9;STACK = [[1 2 3 4 5]]
&#9;a=&#9;; Equal to argument;&#9;STACK = [1]
&#9;&#9;; &#9;&#9;&#9;Return   1

D,f,?!,&#9;&#9;; Declare a function 'f'
&#9;&#9;; Example arguments:&#9;&#9;[[4 7 6 1 0 3]]
&#9;{j}&#9;; Call 'j';&#9;&#9;STACK = [5]
&#9;V&#9;; Save;&#9;&#9;&#9;STACK = []&#9;&#9;; REGISTER = 5
&#9;ad&#9;; Push arguments twice;&#9;STACK = [[4 7 6 1 0 3] [4 7 6 1 0 3]]
&#9;{j}&#9;; Call 'j';&#9;&#9;STACK = [[4 7 6 1 0 3] 5]
&#9;BF&#9;; Flatten;&#9;&#9;STACK = [4 7 6 1 0 3 5]
&#9;€Bx&#9;; Xor each with 5;&#9;STACK = [1 2 3 4 5 6]
&#9;1]&#9;; Call 'lambda 1';&#9;STACK = [1]
&#9;G$&#9;; Retrieve REGISTER;&#9;STACK = [5 1]
&#9;0=&#9;; If equal to 0:
&#9;-1$Q&#9;;   Return -1
&#9;p&#9;; Else, pop condition;&#9;STACK = [5]
&#9;&#9;;&#9;&#9;&#9;Return   5
</code></pre>
</div>
<div id="pu6" class="pu"><h1><a href="http://perl6.org" rel="nofollow noreferrer">Perl 6</a>, 79 bytes</h1>

<p>If there wasn't a time limit the shortest Perl 6 code would probably be</p>
<pre class="lang-perl6 prettyprint-override"><code>{first {[&lt;=] $_ X+^@_},^2*.max} # 31 bytes
</code></pre>
<hr />
<p>Instead I have to do something a bit more clever.<br />
Since I took a while to come back to this, there was already an <a href="https://codegolf.stackexchange.com/questions/68109/xorting-an-array/68131#68131">answer</a> that describes a good algorithm, and the reasoning behind it.</p>
<pre class="lang-perl6 prettyprint-override"><code>{$/=0;for @_.rotor(2=&gt;-1) -&gt;(\a,\b){b&gt;=a or$/+|=2**msb a+^b};$/if [&lt;=] $/X+^@_} # 79
</code></pre>

<pre class="lang-perl6 prettyprint-override"><code>{
  # cheat by using a special variable
  # so there is no need to declare it
  $/=0;

  # takes the elements two at a time, backing up one
  for @_.rotor(2=&gt;-1)
    # since that is a non-flat list, desugar each element into 2
    # terms
    -&gt;(\a,\b){
      # if they are not sorted
      b&gt;=a or
      # take the most significant bit of xoring the two values
      # and numeric or ｢+|｣ it into ｢$/｣
      $/+|=2**msb a+^b
    };
  

  # returns ｢$/｣ if the list is Xorted
  # otherwise returns Empty
  $/if [&lt;=] $/X+^@_

  # ｢ $/ X[+^] @_ ｣
  # does numeric xor ｢+^｣ between ｢$/｣
  # and each element of the original list ｢@_｣
}
</code></pre>
<p>Usage:</p>
<pre class="lang-perl6 prettyprint-override"><code># give it a lexical name for ease of use
my &amp;code = {...}

say code [8,4,3,2,1];     # 15

say code [4,7,6,1,0,3]; # 5
say code [4,7,1,6,0,3]; # ()
say code [0,1,3,4,6,7]; # 0
say code [4,2,3,1];     # 6
say code [2,3,0,0,7,7,4,5,11,11]; # 2
say code [2,3,0,0,7,7,5,4,11,11]; # ()
say code [1086101479,748947367,1767817317,656404978,1818793883,1143500039]; # ()

# the example files
for 'testfiles'.IO.dir.sort».comb(/«\d+»/) {
  printf &quot;%10s in %5.2f secs\n&quot;, code( @$_ ).gist, now - ENTER now;
}
#         () in  9.99 secs
#          0 in 11.70 secs
# 1096442624 in 13.54 secs
#         () in 11.44 secs
</code></pre>
</div>
<div id="pu7" class="pu"><h2>ES6, 84 bytes</h2>

<pre><code>a=&gt;(i=e=0,a.reduce((x,y)=&gt;(z=1&lt;&lt;31-Math.clz32(x^y),x&gt;y?i|=z:y&gt;x?e|=z:z,y)),i&amp;e?-1:i)
</code></pre>

<p>Edit: By the time it took me to write the answer the algorithm had already been independently posted by @Jakube; my algorithm is the same but this wasn't plagiarism honest! Also I notice another JavaScript answer has since been posted too. Sorry if I'm stepping on anyone's toes.</p>

<p>Edit: Saved 8 bytes thanks to edc65.</p>
</div>
<div id="pu8" class="pu"><h1>JavaScript (ES6) 85 <s>97 114 117</s></h1>

<p><strong>Edit</strong> Removed stupid,useless last AND<br>
<strong>Edit2</strong> Top bit search shortened<br>
<strong>Edit3</strong> Wow! I discovered that ES6 (almost) has a <em>builtin</em> to find the top bit (Math.clz32 counts the top 0 bits)</p>

<p>This is based on the solution of @Jakube (pls upvote that). I could never have found it by myself. </p>

<p>Here I go one step forward, iterating the list once and keeping a bit mask with the bits that have to be flipped, and another one with the bits that have to be kept.</p>

<p>If there is an overlap of the bit masks, then no solution is possible, else the solution is "bits to flip"</p>

<p>As binary operations in javascript work only on signed 32 bits integers, the return value is a signed 32 bit integer that can be negative or 0.</p>

<p>If there is no solution the return value is 'X'</p>



<pre><code>l=&gt;l.map(v=&gt;(t=v^p&amp;&amp;1&lt;&lt;(31-Math.clz32(v^p)),v&gt;p?k|=t:c|=t,p=v),p=l[c=k=0])&amp;&amp;c&amp;k?"X":c
</code></pre>

<p><strong>Test</strong></p>

<p><a href="https://jsfiddle.net/x3wk2hje/4/" rel="noreferrer">The longer tests on jsfiddle</a></p>

<p><div class="snippet" data-lang="js" data-hide="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>X=l=&gt;l.map(v=&gt;(t=v^p&amp;&amp;1&lt;&lt;(31-Math.clz32(v^p)),v&gt;p?k|=t:c|=t,p=v),p=l[c=k=0])&amp;&amp;c&amp;k?"X":c

console.log=x=&gt;O.textContent+=x+'\n'
;[
[[4,7,6,1,0,3], 5],
[[4,7,1,6,0,3], 'X'],
[[0,1,3,4,6,7], 0],
[[4,2,3,1], 6], 
[[2,3,0,0,7,7,4,5,11,11], 2],
[[2,3,0,0,7,7,5,4,11,11], 'X'],
[[1086101479,748947367,1767817317,656404978,1818793883,1143500039],'X'],
[[180522983,1885393660,751646477,367706848,331742205,724919510,850844696,2121330641,869882699,1831158987,542636180,1117249765,823387844,731663826,1762069894,240170102,1020696223,1212052937,2041219958,712044033,195249879,1871889904,1787674355,1849980586,1308879787,1743053674,1496763661,607071669,1987302942,178202560,1666170841,1035995406,75303032,1755269469,200581873,500680130,561748675,1749521426,1828237297,835004548,934883150,38711700,1978960635,209243689,1355970350,546308601,590319412,959613996,1956169400,140411967,112601925,88760619,1977727497,672943813,909069787,318174568,385280382,370710480,809689639,557034312,865578556,217468424,346250334,388513751,717158057,941441272,437016122,196344643,379529969,821549457,97008503,872313181,2105942402,603939495,143590999,1580192283,177939344,853074291,1288703007,1605552664,162070930,1325694479,850975127,681702163,1432762307,1994488829,780869518,4379756,602743458,1963508385,2115219284,1219523498,559301490,4191682,1918142271,169309431,346461371,1619467789,1521741606,1881525154],'X'],
[[37580156,64423492,87193676,91914964,93632157,96332899,154427982,176139560,184435039,228963836,230164674,279802291,301492375,309127664,345705721,370150824,380319820,403997410,410504675,416543032,418193132,424733526,428149607,435596038,477224208,515649925,519407995,525469350,614538124,624884850,642649261,653488151,679260270,685637235,690613185,739141066,825795124,832026691,832633584,833213619,852655299,913744258,917674993,921902522,925691996,931307936,954676047,972992595,997654606,1020009811,1027484648,1052748108,1071580605,1108881241,1113730139,1122392118,1154042251,1170901568,1180031842,1180186856,1206428383,1214066097,1242934611,1243983997,1244736049,1262979035,1312007069,1312030297,1356274316,1368442960,1377432523,1415342434,1471294243,1529353536,1537868913,1566069818,1610578189,1612277199,1613646498,1639183592,1668015280,1764022840,1784234921,1786654280,1835593744,1849372222,1875931624,1877593764,1899940939,2007896363,2023046907,2030492562,2032619034,2085680072,2085750388,2110824853,2123924948,2131327206,2134927760,2136423634],0],
[[1922985547,1934203179,1883318806,1910889055,1983590560,1965316186,2059139291,2075108931,2067514794,2117429526,2140519185,1659645051,1676816799,1611982084,1736461223,1810643297,1753583499,1767991311,1819386745,1355466982,1349603237,1360540003,1453750157,1461849199,1439893078,1432297529,1431882086,1427078318,1487887679,1484011617,1476718655,1509845392,1496496626,1583530675,1579588643,1609495371,1559139172,1554135669,1549766410,1566844751,1562161307,1561938937,1123551908,1086169529,1093103602,1202377124,1193780708,1148229310,1144649241,1257633250,1247607861,1241535002,1262624219,1288523504,1299222235,840314050,909401445,926048886,886867060,873099939,979662326,963003815,1012918112,1034467235,1026553732,568519178,650996158,647728822,616596108,617472393,614787483,604041145,633043809,678181561,698401105,776651230,325294125,271242551,291800692,389634988,346041163,344959554,345547011,342290228,354762650,442183586,467158857,412090528,532898841,534371187,32464799,21286066,109721665,127458375,192166356,146495963,142507512,167676030,236532616,262832772],1927544832],
[[1922985547,1934203179,1883318806,1910889055,1983590560,1965316186,2059139291,2075108931,2067514794,2117429526,2140519185,1659645051,1676816799,1611982084,1736461223,1810643297,1753583499,1767991311,1819386745,1355466982,1349603237,1360540003,1453750157,1461849199,1439893078,1432297529,1431882086,1427078318,1487887679,1484011617,1476718655,1509845392,1496496626,1583530675,1579588643,1609495371,1559139172,1554135669,1549766410,1566844751,1562161307,1561938937,1123551908,1086169529,1093103602,1202377124,1193780708,1148229310,1144649241,1257633250,1241535002,1247607861,1262624219,1288523504,1299222235,840314050,909401445,926048886,886867060,873099939,979662326,963003815,1012918112,1034467235,1026553732,568519178,650996158,647728822,616596108,617472393,614787483,604041145,633043809,678181561,698401105,776651230,325294125,271242551,291800692,389634988,346041163,344959554,345547011,342290228,354762650,442183586,467158857,412090528,532898841,534371187,32464799,21286066,109721665,127458375,192166356,146495963,142507512,167676030,236532616,262832772],'X']
].forEach(t=&gt;{
  var i=t[0],k=t[1],r=X(i)
  console.log((k==r?'OK ':'Error (expected '+k+') ')+r+' for input '+i)
})</code></pre>
<pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;pre id=O&gt;&lt;/pre&gt;</code></pre>
</div>
</div>
</p>
</div>
<div id="pu9" class="pu"><h1>Jelly, 25 bytes</h1>

<pre><code>ṡ2Zµ^/Bo1Ḅ‘×&gt;/|/H
Ç-¹^Ç¥?
</code></pre>

<p>The latest commits postdate this challenge, but the above code works with <a href="https://github.com/DennisMitchell/jelly/tree/7ee6838e9979ef33cab5085f413b3b6855e1ba46" rel="nofollow noreferrer">this revision</a>, which predates it. <a href="http://jelly.tryitonline.net/#code=4bmhMlrCtV4vQm8x4biE4oCYw5c-L3wvSArDhy3CuV7Dh8KlPw&amp;input=&amp;args=WzQsIDcsIDYsIDEsIDAsIDNd" rel="nofollow noreferrer">Try it online!</a></p>

<p>To run the large test cases, depending on your shell, it may be necessary to wrap the above code in a program that reads input from STDIN. <a href="http://jelly.tryitonline.net/#code=4bmhMlrCtV4vQm8x4biE4oCYw5c-L3wvSArDhy3CuV7Dh8KlPwrGk8OH&amp;input=WzQsIDcsIDYsIDEsIDAsIDNd" rel="nofollow noreferrer">Try it online!</a></p>

<h3>Test cases</h3>

<pre><code>$ xxd -c 13 -g 1 xort-prog.jelly 
0000000: ae 32 5a 8c 5e 2f 42 6f 31 a4 b6 94 3e  .2Z.^/Bo1...&gt;
000000d: 2f 7c 2f 48 0a 92 2d 8e 5e 92 84 3f     /|/H..-.^..?
$ ./jelly f xort-prog.jelly '[4, 7, 6, 1, 0, 3]'; echo
5
$ ./jelly f xort-prog.jelly '[4, 7, 1, 6, 0, 3]'; echo
-1
$ ./jelly f xort-prog.jelly '[0, 1, 3, 4, 6, 7]'; echo
0
$ ./jelly f xort-prog.jelly '[4, 2, 3, 1]'; echo
6
$ ./jelly f xort-prog.jelly '[2, 3, 0, 0, 7, 7, 4, 5, 11, 11]'; echo
2
$ ./jelly f xort-prog.jelly '[2, 3, 0, 0, 7, 7, 5, 4, 11, 11]'; echo
-1
$
$ wget -q http://pastebin.com/raw/{P96PNi79,zCNLMsx9,GFLBXn5b,6F1Yn3gG}
$ xxd -c 14 -g 1 xort-func.jelly 
0000000: ae 32 5a 8c 5e 2f 42 6f 31 a4 b6 94 3e 2f  .2Z.^/Bo1...&gt;/
000000e: 7c 2f 48 0a 92 2d 8e 5e 92 84 3f 0a a0 92  |/H..-.^..?...
$ tr \  , &lt; P96PNi79 | time -f '\n%es' ./jelly f xort-func.jelly
-1
3.69s
$ tr \  , &lt; zCNLMsx9 | time -f '\n%es' ./jelly f xort-func.jelly
0
2.78s
$ tr \  , &lt; GFLBXn5b | time -f '\n%es' ./jelly f xort-func.jelly
1096442624
2.73s
$ tr \  , &lt; 6F1Yn3gG | time -f '\n%es' ./jelly f xort-func.jelly
-1
2.70s
</code></pre>

<h3>Idea</h3>

<p>This uses a the same approach as <a href="https://codegolf.stackexchange.com/a/68131">@Jakube's answer</a>, but my implementation is a bit different.</p>

<p>Jelly has no sorting yet, so we compute a xorting candidate, XOR the input list with it, compute a xorting candidate of the XORed list, and check if the new candidate is zero. If it is, we print the first candidate; otherwise, we print <strong>-1</strong>.</p>

<p>Also, Jelly seems to have no sane way to cast to integer yet (even integer division can return floats), so I had to come up with a rather creative way of rounding a list of numbers down to the next power of <strong>2</strong>. Rather than log-floor-pow, I convert all integers to binary, replace all binary digits with <strong>1</strong>, convert back to integer, add <strong>1</strong>, and divide by <strong>2</strong>.</p>

<h3>Code</h3>

<pre><code>ṡ2Zµ^/Bo1Ḅ‘×&gt;/|/H  Helper link. Argument: M (list of integers)

ṡ2                 Yield all overlapping slices of length 2 (pairs) of M.
  Z                Zip to group first and second coordinates.
   µ               Begin a new, monadic chain.
    ^/             XOR the corresponding coordinates.
      B            Convert all results to binary.
       o1          OR (logical) all binary digits with 1.
         Ḅ         Convert back to integer.
          ‘        Increment all integers.
           ×&gt;/     Multiply each rounded (a ^ b) by (a &gt; b).
                   This replaces (a ^ b) with 0 unless a &gt; b.
              |/   OR all results.
                H  Halve the result.

Ç-¹^Ç¥?            Main link. Input: L (list of integers)

Ç                  Call the helper link on L. Result: C (integer)
     ¥             Create a dyadic chain:
   ^                 XOR the elements of L with C.
    Ç                Call the helper link on the result.
      ?            If the result in non-zero:
 -                   Yield -1.
  ¹                Else, yield C.
</code></pre>
</div>
<div id="pu10" class="pu"><h1>Mathematica <s>650 415</s> 194 bytes</h1>
<p>This challenge helped me understand quite a bit about <code>Xor</code> that I had never thought about.  It took a long time to whittle down the code, but was worth the effort.</p>
<p><code>BitXor</code> works directly on base 10 numbers.  This greatly reduced the code from the earlier versions.</p>
<p>The logic is simple.  One works, not with pairs of numbers (as some submissions did) but rather with the complete set of numbers after being <code>BitXor</code>ed with the current &quot;key&quot;.</p>
<p>Start with tentative solution, or &quot;key&quot; of zero, that is with all bits are zero.  When the original <code>n</code> numbers are <code>BitXor</code>ed with zero , they are returned, unaltered.  Correlate the ordering of the numbers with the range<code>1, 2, ...n</code>, which represent a perfectly ordered list.  The correlation, with a value between -1 and 1, reflects how well the numbers are ordered.</p>
<p>Then set the hi bit, obtain the new key, and <code>BitXor</code> the key with the current set of numbers.  If the correlation between the new sequence of numbers and the perfectly ordered list is an improvement, keep the bit set.  If not, leave the bit unset.</p>
<p>Proceed in this manner from the hi to the low bit.  If the best correlation is 1, then the key is the solution.  If not, it is -1.</p>
<p>There would be ways to make the code a bit more efficient, for example, by interrupting the process as soon as a solution is found, but this would require more coding and the current approach is very fast as it is.  (The final and longest test case takes 20 msec.)</p>
<pre><code>c@i_:=Correlation[Ordering@i,Range[Length[i]]]//N;
t@{i_,k_,b_,w_}:=(v= c@BitXor[i,m=k+2^(b-1)];{i,If[v&gt;w,m,k],b-1,v~Max~w})
g@i_:= (If[#4==1,#2,-1] &amp;@@Nest[t,{i,0,b=1+Floor@Log[2,Max@i],x=c@i},b])
</code></pre>
<hr />
<pre><code>g[{4, 7, 6, 1, 0, 3}]
</code></pre>
<blockquote>
<p>5</p>
</blockquote>
<hr />
<pre><code>g[{4, 7, 1, 6, 0, 3}]
</code></pre>
<blockquote>
<p>-1</p>
</blockquote>
<hr />
<pre><code>g2@{0, 1, 3, 4, 6, 7}
</code></pre>
<blockquote>
<p>0</p>
</blockquote>
<hr />
<pre><code>g@{1922985547, 1934203179, 1883318806, 1910889055, 1983590560, 1965316186,2059139291, 2075108931, 2067514794, 2117429526, 2140519185, 1659645051, 1676816799, 1611982084, 1736461223, 1810643297, 1753583499, 1767991311, 1819386745, 1355466982, 1349603237, 1360540003, 1453750157, 1461849199, 1439893078, 1432297529, 1431882086, 1427078318, 1487887679, 1484011617, 1476718655, 1509845392, 1496496626, 1583530675, 1579588643, 1609495371, 1559139172, 1554135669, 1549766410, 1566844751, 1562161307,1561938937, 1123551908, 1086169529, 1093103602, 1202377124, 1193780708, 1148229310, 1144649241, 1257633250, 1247607861, 1241535002, 1262624219, 1288523504, 1299222235,840314050, 909401445, 926048886, 886867060, 873099939, 979662326,963003815, 1012918112, 1034467235, 1026553732, 568519178, 650996158,647728822, 616596108, 617472393, 614787483, 604041145, 633043809, 678181561, 698401105, 776651230, 325294125, 271242551, 291800692, 389634988, 346041163, 344959554, 345547011, 342290228, 354762650, 442183586, 467158857, 412090528, 532898841, 534371187, 32464799, 21286066, 109721665, 127458375, 192166356, 146495963, 142507512, 167676030, 236532616, 262832772}
</code></pre>
<blockquote>
<p>1927544832</p>
</blockquote>
</div>
<div id="pu11" class="pu"><h2>CJam, 37 bytes</h2>

<pre><code>q~_2ew{:&gt;},{:^2mLi2\#}%0+:|_@f^_$=\W?
</code></pre>

<p><a href="http://cjam.aditsu.net/#code=q~_2ew%7B%3A%3E%7D%2C%7B%3A%5E2mLi2%5C%23%7D%250%2B%3A%7C_%40f%5E_%24%3D%5CW%3F&amp;input=%5B4%207%206%201%200%203%5D" rel="nofollow">Test it here.</a></p>

<p>This uses the same algorithm as several of the other answers. It's essentially my reference implementation which I used to create the test cases. However, I did steal Jakube's trick of checking only the offending pairs and simply trying out the result with a sort. That breaks the pseudolinearity, but <em>O(n log n)</em> is still fast enough for the test cases. My original code also checked the pairs that are already in order, and built up a list of bits which must not be toggled in order to keep their relative order, and checked at the end that there are no overlaps between the two bit masks. This algorithm was originally suggested by <a href="http://meta.codegolf.stackexchange.com/users/1829/ben-jackson">Ben Jackson</a>.</p>
</div>
<div id="pu12" class="pu"><h1>C, 144 bytes</h1>

<pre class="lang-c prettyprint-override"><code>#include &lt;strings.h&gt;
#include &lt;stdio.h&gt;
m[2],l,i;main(v){while(scanf("%d",&amp;v)==1)m[l&lt;v]|=(i++&amp;&amp;v^l)&lt;&lt;~-fls(v^l),l=v;printf("%d",*m&amp;m[1]?-1:*m);}
</code></pre>

<p>This is almost standard C99 (it misses a few <code>int</code> specifiers and has 1 argument for <code>main</code>). It also relies on <code>0&lt;&lt;-1</code> being 0 (which seems to be true when compiled with Clang at least — I haven't tested others)</p>

<p>I've taken Jakube's method and ported it to C. I think it does surprisingly well size-wise for C. It's also super-fast (0.061s to run all test files, including the massive 4). It takes input from STDIN and will print the matching value or -1 to STDOUT, so run it with one of:</p>

<pre class="lang-sh prettyprint-override"><code>echo "4 7 6 1 0 0 3" | ./xort
./xort &lt; file.txt
</code></pre>

<p>Breakdown:</p>

<pre class="lang-c prettyprint-override"><code>// Globals initialise to 0
m[2],                                    // Stores our bit masks
                                         // (m[0]=CHANGE, m[1]=MUST NOT CHANGE)
l,                                       // Last value
i;                                       // Current iteration
main(v){
    while(scanf("%d",&amp;v)==1)             // Read each value in turn
        m[l&lt;v]|=                         // If they are sorted, we mark a bit as
                                         // MUST NOT CHANGE (m[1]), otherwise we
                                         // mark as CHANGE (m[0])
                (i++&amp;&amp;v^l)               // If this is the first iteration,
                                         // or the value is unchanged, mark nothing
                          &lt;&lt;~-fls(v^l),  // Mark the highest bit which has changed
                                         // = (1&lt;&lt;(fls(v^l)-1)
        l=v;                             // Update last value
    printf("%d",
                *m&amp;m[1]                  // Check if result is valid (if any bits
                                         // are both MUST NOT CHANGE and CHANGE,
                                         // it is not valid)
                       ?-1               // Print -1 on failure
                          :*m);          // Print value on success
}
</code></pre>
</div>
<div id="pu13" class="pu"><h1>Ruby 2, 119</h1>



<pre class="lang-rb prettyprint-override"><code>-&gt;a,*o{a.each_cons(2){|x,y|x==y||o[i=(x^y).bit_length-1]==1-(o[i]=x[i])&amp;&amp;(return-1)};(o.map(&amp;:to_i).reverse*'').to_i 2}
</code></pre>

<p>Runs in 42 milliseconds on the large test cases.</p>

<p>Ungolfed:</p>

<pre class="lang-rb prettyprint-override"><code>def first_differing_bit(a,b)
  (a^b).bit_length - 1
end

def xort(ary)
  required_bits = []
  ary.each_cons(2) do |a,b|
    i = first_differing_bit(a,b)
    if i &gt; -1
      bit = a[i]
      if required_bits[i] &amp;&amp; required_bits[i] != bit
        return -1
      else
        required_bits[i] = bit
      end
    end
  end
  required_bits.map(&amp;:to_i).reverse.join.to_i(2)
end
</code></pre>

<p>For once I wrote the ungolfed version first, then golfed it, since figuring out the right algorithm was a challenge in itself.</p>

<p>I actually tried to write something like this a few years ago to make a binary tree structure that would locally self-balance by letting each node redefine its comparison function dynamically. At first I thought I could just use xor, but as you say for random data there's unlikely to be a viable value.</p>
</div>
<div id="pu14" class="pu"><h1>Mathematica, <strike>99</strike> 97 Characters</h1>

<p>Thanks to Martin Büttner for advices.</p>

<pre><code>x@l_:=If[OrderedQ[l~BitXor~#],#,-1]&amp;@Fold[#+#2Boole@!OrderedQ@⌊l~BitXor~#/#2⌋&amp;,0,2^32/2^Range@32]
</code></pre>

<p><strong>Explanation:</strong></p>

<p>We will do multiple tries to modify <code>N</code> starting from zero, and do a test to validate the candidate <code>N</code>. </p>

<p><em>Step 1.</em> We get these numbers (32-bit integers) "xor"ed by <code>N</code>(<code>= 0</code> now) and divided by <code>2^31</code>: <code>⌊l~BitXor~#/#2⌋</code>. There are three cases:</p>

<ul>
<li>ordered, e.g. <code>{0, 0, 1, 1, 1, 1, 1, 1}</code>;</li>
<li>can be corrected, e.g. <code>{1, 1, 1, 1, 0, 0, 0, 0}</code>;</li>
<li>else, e.g. <code>{0, 0, 1, 0, 0, 1, 1, 1}</code>.</li>
</ul>

<p>We do nothing to <code>N</code> for the first case, or we add <code>2^31</code> to <code>N</code> to correct the order for the second case: <code>#+#2Boole@!OrderedQ@...</code>. While for the third case, it is impossible to xorting the list what ever we do, thus we just add <code>2^31</code> to <code>N</code> for simplicity (or anything!). </p>

<p><em>Step 2.</em> We get these numbers "xor"ed by <code>N</code> and divided by <code>2^30</code>. There are again three cases:</p>

<ul>
<li>ordered, e.g. <code>{0, 1, 2, 2, 2, 2, 3, 3}</code>;</li>
<li>can be corrected, e.g. <code>{1, 1 , 0, 0, 3, 2, 2, 2}</code>;</li>
<li>else, e.g. <code>{3, 3, 1, 3, 2, 0, 1, 0}</code>.</li>
</ul>

<p>We do nothing to <code>N</code> for the first case, or we add <code>2^30</code> to <code>N</code> to correct the order for the second case. Otherwise, we realize that xorting is impossible, thus we just add <code>2^30</code> to <code>N</code> for simplicity again.</p>

<p><em>Step 3 ~ 32.</em> We recursively get these numbers "xor"ed by <code>N</code> and divided by <code>2^29</code>, <code>2^28</code>, ..., <code>2^0</code>. And do similar things: <code>Fold[...,0,2^32/2^Range[32]]</code></p>

<p><em>Step 33.</em> Now we finally get a candidate <code>N</code>. <code>If[OrderedQ[l~BitXor~#],#,-1]&amp;</code> is used to check if such <code>N</code> indeed xorting the list. If the list can be xorting by some <code>N</code>, it is not difficult to proof that we will always encounter the first or the second case. </p>
</div>
<div id="pu15" class="pu"><h1>Python 2, 204 bytes</h1>

<pre><code>def f(a):
 m=n=0
 for i in range(32):
  b=2**(31-i);m|=b
  for n in[n,n|b]:
   if not q(a,m,n):break
  else:return-1
 return n
def q(a,m,n):
 if a:p=a[0]&amp;m^n
 for t in a:
  t=t&amp;m^n
  if t&lt;p:return 1
  p=t
</code></pre>

<p>The input is passed as a list to function f.</p>

<p>This code figures out the value of N (named n in the program) one bit at a time, starting with the most significant bit. (the "for i" loop)</p>

<p>For each bit position, the "for n" loop first tries using 0 for that bit of n. If that doesn't work, it tries using 1. If neither of these works, then there is no solution. Note that the else clause is on the "for n" loop, not the if statement. In Python, a for statement can have an else clause, which is executed after the loop runs to completion, but is <em>not</em> executed if we break out of the loop.</p>

<p>The q function checks for problems with the list order given the list (a), a bit mask (m), and the value to be xored with each value in the list (n). It returns 1 if there is a problem with the ordering, or None if the order is ok. None is the default return value, so that saved me several characters.</p>

<p>This code handles an empty list or a list with 1 element correctly, returning 0. The "if a:" in function q is there only to avoid an IndexError exception when the list is empty. So 5 more bytes could be removed if handling empty lists isn't required.</p>

<p>On my computer, large test case #3 took 0.262 seconds. #2 took about the same. All the test cases together took 0.765 seconds.</p>
</div>
<div id="pu16" class="pu"><h1>Julia, <s>174</s> <s>144</s> <s>77</s> <s>75</s> 71</h1>
<p>[EDIT] Thanks to Alex A. for anonymizing &amp; various shorthands.<br />
[EDIT 2] Replaced my own implementation by the builtin <code>issorted()</code>.</p>
<p>Runs in linear time and handles the big files without noticeable delay. Works just as well for negative numbers.</p>
<pre><code>l-&gt;(r=0;s=issorted;for d=63:-1:0 s((l$r).&gt;&gt;d)||(r$=2^d)end;s(l$r)?r:[])
</code></pre>
<p>Another variant that calculates the result closest to a given key (the above returns the smallest).</p>
<pre><code>(l,r)-&gt;(s=issorted;for d=63:-1:0 s((l$r).&gt;&gt;d)||(r$=2^d)end;s(l$r)?r:[])
</code></pre>
<p>usage:</p>
<pre><code>julia&gt; xort = l-&gt;(r=0;s=issorted;for d=63:-1:0 s((l$r).&gt;&gt;d)||(r$=2^d)end;s(l$r)?r:[])
(anonymous function)

julia&gt; xort([4 7 6 1 0 3])
5
</code></pre>
<p>Example, step by step: <code>[4 7 6 1 0 3] =&gt; 5</code></p>
<pre><code>Start with:
     4  0b0100
     7  0b0111
     6  0b0110
     1  0b0001
     0  0b0000
     3  0b0011
result  0b0000

If the first n bits are sorted, do nothing.
        0b0
        0b0
        0b0
        0b0
        0b0
        0b0
result  0b0000
          ^
If the first n bits are not sorted, flip the nth bit.
        0b01            0b00
        0b01            0b00
        0b01            0b00
        0b00      =&gt;    0b01
        0b00            0b01
        0b00            0b01
result  0b0000          0b0100
           ^               ^
        0b000
        0b001
        0b001
        0b010
        0b010
        0b011
result  0b0100
            ^
        0b0000          0b0001  1
        0b0011          0b0010  2
        0b0010          0b0011  3
        0b0101    =&gt;    0b0100  4
        0b0100          0b0101  5
        0b0111          0b0110  6
result  0b0100          0b0101  5
             ^               ^
If the bit flip does not sort the truncated integers, xorting is
impossible. We continue anyway and check for success in the end.
</code></pre>
</div>
<div id="pu17" class="pu"><h1>C, 312 bytes</h1>

<pre><code>#define R return
t,i,*b;f(int*a,int l,int k){int s=a[0]&gt;&gt;k&amp;1,j=-1,i=1;if(k&lt;0)R 0;for(;i&lt;l;++i){t=a[i]&gt;&gt;k&amp;1;if(s!=t)if(j&lt;0)j=i,s=t;else R 1;}if(j&lt;0)R f(a,l,k-1);else{if(s+b[k]==2)R 1;b[k]=s+1;R f(a,j,--k)||f(a+j,l-j,k);}}h(int*a,int l){int c[32]={0};b=c;if(f(a,l,30))R -1;t=0;for(i=0;i&lt;32;++i)t|=(b[i]&amp;1)&lt;&lt;i;R t;}
</code></pre>

<p>Defines a function <code>h(int*a,int l)</code> taking a pointer to an array and its length. <a href="http://pastebin.com/raw/Vm8xDfBi" rel="nofollow">Here</a> is a test program behemoth.</p>

<p>Slightly ungolfed:</p>

<pre><code>int t, i, *b;

int f(int * a, int l, int k) {
    int s = a[0] &gt;&gt; k &amp; 1;
    int j = -1;
    int i = 1;
    if (k &lt; 0) return 0;
    for (; i &lt; l; ++i) {
        t = a[i] &gt;&gt; k &amp; 1;
        if (s != t) {
            if (j &lt; 0) {
                j = i;
                s = t;
            } else return 1;
        }
    }
    if (j &lt; 0) {
        return f(a, l, k - 1);
    } else {
        if (s + b[k] == 2) return 1;
        b[k] = s + 1;
        return f(a, j, --k) || f(a + j, l - j, k);
    }
}

int h(int * a, int l) {
    int c[32] = {0};
    b = c;
    if (f(a, l, 30)) return -1;
    t = 0;
    for (i = 0; i &lt; 32; ++i) {
        t |= (b[i] &amp; 1) &lt;&lt; i;
    }
    return t;
}
</code></pre>
</div>
<div id="pu18" class="pu"><h1>Julia, 124 bytes</h1>



<pre class="lang-default prettyprint-override"><code>f(x,g=0)=issorted(([g|=2^Int(log2(h)÷1)for h=map(k-&gt;k[1]$k[2],filter(j-&gt;j[1]&gt;=j[2],[x[i-1:i]for i=2:endof(x)]))];g)$x)?g:-1
</code></pre>

<p>This is a function that accepts an integer array and returns an integer. It uses <a href="https://codegolf.stackexchange.com/a/68131/20469">Jakube's approach</a>.</p>

<p>Ungolfed:</p>

<pre class="lang-default prettyprint-override"><code>function f{T&lt;:Integer}(x::Array{T,1}, g::T=0)
    # Get all pairs of elements in the input array
    pairs = [x[i-1:i] for i = 2:endof(x)]

    # Filter to pairs in descending order
    desc = filter(j -&gt; j[1] ≥ j[2], pairs)

    # Map XOR over these pairs
    xord = map(k -&gt; k[1] $ k[2], desc)

    # For each element of this array, update the
    # parameter g (which defaults to 0) as the
    # bitwise OR of itself and 2^floor(log2(element))
    for h in xord
        g |= 2^Int(log2(h) ÷ 1)
    end

    # If the array constructed as g XOR the input is
    # sorted, we've found our answer! Otherwise -1.
    return issorted(g $ x) ? g : -1
end
</code></pre>
</div>
<div id="pu19" class="pu"><h1>Python 2, <s>226</s> 214 bytes</h1>
<p>Simpleish algorithm, built it yesterday, golfed today.</p>
<pre><code>o=input()
s=sorted
p=s(set(o),key=o.index)
n=q=0
while 1:
 a=1
 while 1-q and p[0]&lt;p[1]:p=p[1:];q=len(p)==1
 if q:break
 while not p[0]^a&lt;p[1]^a:a*=2
 n+=a;p=[i^a for i in p]
t=[a^n for a in o]
print[-1,n][s(t)==t]
</code></pre>
<p>Ungolfed:</p>
<pre><code>def xor(a,b): return a^b

def rm_dupes(seq):
    seen = set()
    seen_add = seen.add
    return [x for x in seq if not (x in seen or seen_add(x))]

def rm_sorted(seq):
    while seq[0] &lt; seq[1]:
        seq = seq[1:]
        if len(seq) == 1: return seq
    return seq

inp = input()
oi = inp

inp = rm_dupes(inp)
n=0
old_inp=0
while old_inp != inp:
    old_inp = inp
    inp = rm_sorted(inp)
    if len(inp)==1:break
    highest_set0 = len(bin(inp[0]))-3 # bin returns in form 0bxxx
    highest_set1 = len(bin(inp[1]))-3 # bin returns in form 0bxxx
    if highest_set1 == 0:
        try:
            t0 = max(int(bin(inp[0])[3:], 2), 1)
        except ValueError: toggle_amount = 1
        else: toggle_amount = t0^inp[0]
    else:
        fallen = False
        for i in xrange(max(highest_set0,highest_set1)+1):
            toggle_amount = 2**i
            if inp[0]^toggle_amount &lt; inp[1]^toggle_amount:
                fallen = True
                break
        assert(fallen)
    n+=toggle_amount
    inp = [i^toggle_amount for i in inp]

out=map(xor, oi, [n]*len(oi))
if sorted(out)==out :print n
else:print -1
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/68109/">68109</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




