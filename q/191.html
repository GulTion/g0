<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::191</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>nan</td><td>If a string is used in an arithmetic operation</td><td>240516T181147Z</td><td><a href="https://codegolf.stackexchange.com/questions/191/tips-for-golfing-in-powershell/273140#273140">nwellnho</a></td></tr>
<tr d-ix="1"><td>nan</td><td></td><td>240209T033836Z</td><td><a href="https://codegolf.stackexchange.com/questions/191/tips-for-golfing-in-powershell/269931#269931">Julian</a></td></tr>
<tr d-ix="2"><td>nan</td><td></td><td>210407T125737Z</td><td><a href="https://codegolf.stackexchange.com/questions/191/tips-for-golfing-in-powershell/223025#223025">Nico Nek</a></td></tr>
<tr d-ix="3"><td>001</td><td>If you're tackling a drawing/rendering problem that involves creating</td><td>210920T190955Z</td><td><a href="https://codegolf.stackexchange.com/questions/191/tips-for-golfing-in-powershell/235563#235563">Tor</a></td></tr>
<tr d-ix="4"><td>nan</td><td></td><td>210421T215036Z</td><td><a href="https://codegolf.stackexchange.com/questions/191/tips-for-golfing-in-powershell/224115#224115">Nico Nek</a></td></tr>
<tr d-ix="5"><td>nan</td><td></td><td>210421T171214Z</td><td><a href="https://codegolf.stackexchange.com/questions/191/tips-for-golfing-in-powershell/224099#224099">Nico Nek</a></td></tr>
<tr d-ix="6"><td>nan</td><td></td><td>210216T035700Z</td><td><a href="https://codegolf.stackexchange.com/questions/191/tips-for-golfing-in-powershell/219118#219118">btnlq</a></td></tr>
<tr d-ix="7"><td>nan</td><td></td><td>201221T113557Z</td><td><a href="https://codegolf.stackexchange.com/questions/191/tips-for-golfing-in-powershell/216701#216701">gjh71</a></td></tr>
<tr d-ix="8"><td>nan</td><td></td><td>160514T013742Z</td><td><a href="https://codegolf.stackexchange.com/questions/191/tips-for-golfing-in-powershell/79895#79895">Tessella</a></td></tr>
<tr d-ix="9"><td>nan</td><td></td><td>200113T055144Z</td><td><a href="https://codegolf.stackexchange.com/questions/191/tips-for-golfing-in-powershell/197982#197982">mazzy</a></td></tr>
<tr d-ix="10"><td>nan</td><td></td><td>200109T225951Z</td><td><a href="https://codegolf.stackexchange.com/questions/191/tips-for-golfing-in-powershell/197859#197859">GMills</a></td></tr>
<tr d-ix="11"><td>nan</td><td></td><td>190621T151527Z</td><td><a href="https://codegolf.stackexchange.com/questions/191/tips-for-golfing-in-powershell/187239#187239">Veskah</a></td></tr>
<tr d-ix="12"><td>nan</td><td></td><td>190115T234300Z</td><td><a href="https://codegolf.stackexchange.com/questions/191/tips-for-golfing-in-powershell/178780#178780">Veskah</a></td></tr>
<tr d-ix="13"><td>nan</td><td></td><td>190319T181049Z</td><td><a href="https://codegolf.stackexchange.com/questions/191/tips-for-golfing-in-powershell/181833#181833">mazzy</a></td></tr>
<tr d-ix="14"><td>nan</td><td>When declaring a hardcoded list of strings</td><td>181218T205044Z</td><td><a href="https://codegolf.stackexchange.com/questions/191/tips-for-golfing-in-powershell/177747#177747">Tor</a></td></tr>
<tr d-ix="15"><td>nan</td><td></td><td>181103T073530Z</td><td><a href="https://codegolf.stackexchange.com/questions/191/tips-for-golfing-in-powershell/175164#175164">mazzy</a></td></tr>
<tr d-ix="16"><td>nan</td><td>A simple one but controlflow statements as opposed to pipelines</td><td>181025T214653Z</td><td><a href="https://codegolf.stackexchange.com/questions/191/tips-for-golfing-in-powershell/174728#174728">Veskah</a></td></tr>
<tr d-ix="17"><td>nan</td><td>If a path contains more than 1 space</td><td>181009T225118Z</td><td><a href="https://codegolf.stackexchange.com/questions/191/tips-for-golfing-in-powershell/173758#173758">TDiff</a></td></tr>
<tr d-ix="18"><td>nan</td><td>You can use $s|% t*y instead [char[]]$s to split a string to char array.</td><td>180708T063833Z</td><td><a href="https://codegolf.stackexchange.com/questions/191/tips-for-golfing-in-powershell/168174#168174">mazzy</a></td></tr>
<tr d-ix="19"><td>nan</td><td>If you're calling a command with a string argument</td><td>180602T160259Z</td><td><a href="https://codegolf.stackexchange.com/questions/191/tips-for-golfing-in-powershell/166009#166009">briantis</a></td></tr>
<tr d-ix="20"><td>nan</td><td></td><td>171129T133351Z</td><td><a href="https://codegolf.stackexchange.com/questions/191/tips-for-golfing-in-powershell/149474#149474">AdmBorkB</a></td></tr>
<tr d-ix="21"><td>nan</td><td>Starting with PowerShell Core 6</td><td>171123T075003Z</td><td><a href="https://codegolf.stackexchange.com/questions/191/tips-for-golfing-in-powershell/148873#148873">Joey</a></td></tr>
<tr d-ix="22"><td>nan</td><td></td><td>171024T131831Z</td><td><a href="https://codegolf.stackexchange.com/questions/191/tips-for-golfing-in-powershell/146214#146214">AdmBorkB</a></td></tr>
<tr d-ix="23"><td>nan</td><td></td><td>170227T153932Z</td><td><a href="https://codegolf.stackexchange.com/questions/191/tips-for-golfing-in-powershell/111526#111526">briantis</a></td></tr>
<tr d-ix="24"><td>nan</td><td>Converting floatingpoint numbers to integers in PowerShell is a bit of a minefield. By default the conversion does Bankers Rounding which doesn't always trim off the decimal and leave the smaller whole number</td><td>160514T012759Z</td><td><a href="https://codegolf.stackexchange.com/questions/191/tips-for-golfing-in-powershell/79894#79894">Tessella</a></td></tr>
<tr d-ix="25"><td>nan</td><td>When using a number as an argument to an operator that would otherwise require a string</td><td>110208T230306Z</td><td><a href="https://codegolf.stackexchange.com/questions/191/tips-for-golfing-in-powershell/753#753">Joey</a></td></tr>
<tr d-ix="26"><td>nan</td><td></td><td>160525T202653Z</td><td><a href="https://codegolf.stackexchange.com/questions/191/tips-for-golfing-in-powershell/80674#80674">AdmBorkB</a></td></tr>
<tr d-ix="27"><td>nan</td><td></td><td>160314T163238Z</td><td><a href="https://codegolf.stackexchange.com/questions/191/tips-for-golfing-in-powershell/75524#75524">Matt</a></td></tr>
<tr d-ix="28"><td>nan</td><td></td><td>110129T185507Z</td><td><a href="https://codegolf.stackexchange.com/questions/191/tips-for-golfing-in-powershell/203#203">Joey</a></td></tr>
<tr d-ix="29"><td>nan</td><td></td><td>110129T133830Z</td><td><a href="https://codegolf.stackexchange.com/questions/191/tips-for-golfing-in-powershell/193#193">Joey</a></td></tr>
<tr d-ix="30"><td>nan</td><td></td><td>160314T153152Z</td><td><a href="https://codegolf.stackexchange.com/questions/191/tips-for-golfing-in-powershell/75512#75512">Matt</a></td></tr>
<tr d-ix="31"><td>nan</td><td></td><td>160304T195835Z</td><td><a href="https://codegolf.stackexchange.com/questions/191/tips-for-golfing-in-powershell/74786#74786">AdmBorkB</a></td></tr>
<tr d-ix="32"><td>nan</td><td>If you need to silence errors</td><td>140708T082010Z</td><td><a href="https://codegolf.stackexchange.com/questions/191/tips-for-golfing-in-powershell/33113#33113">Joey</a></td></tr>
<tr d-ix="33"><td>nan</td><td>If you are assigning an array that you know will only have two values</td><td>140602T054549Z</td><td><a href="https://codegolf.stackexchange.com/questions/191/tips-for-golfing-in-powershell/29982#29982">SomeShin</a></td></tr>
<tr d-ix="34"><td>nan</td><td>You can skip spaces a lot in PowerShell. If it feels like it might not be needed</td><td>131114T235249Z</td><td><a href="https://codegolf.stackexchange.com/questions/191/tips-for-golfing-in-powershell/15270#15270">Iszi</a></td></tr>
<tr d-ix="35"><td>nan</td><td>Consider storing repeated script blocks in variables</td><td>131126T193754Z</td><td><a href="https://codegolf.stackexchange.com/questions/191/tips-for-golfing-in-powershell/15432#15432">Iszi</a></td></tr>
<tr d-ix="36"><td>nan</td><td></td><td>131115T165758Z</td><td><a href="https://codegolf.stackexchange.com/questions/191/tips-for-golfing-in-powershell/15288#15288">Iszi</a></td></tr>
<tr d-ix="37"><td>nan</td><td>A switch can act like a loop</td><td>131124T100536Z</td><td><a href="https://codegolf.stackexchange.com/questions/191/tips-for-golfing-in-powershell/15387#15387">Iszi</a></td></tr>
<tr d-ix="38"><td>nan</td><td></td><td>131122T145249Z</td><td><a href="https://codegolf.stackexchange.com/questions/191/tips-for-golfing-in-powershell/15368#15368">Danko Du</a></td></tr>
<tr d-ix="39"><td>nan</td><td>If you need to run a loop</td><td>131120T180518Z</td><td><a href="https://codegolf.stackexchange.com/questions/191/tips-for-golfing-in-powershell/15352#15352">Iszi</a></td></tr>
<tr d-ix="40"><td>nan</td><td>Don't forget that you don't always need to provide the full name of a parameter</td><td>131115T210748Z</td><td><a href="https://codegolf.stackexchange.com/questions/191/tips-for-golfing-in-powershell/15290#15290">Iszi</a></td></tr>
<tr d-ix="41"><td>nan</td><td></td><td>131115T162505Z</td><td><a href="https://codegolf.stackexchange.com/questions/191/tips-for-golfing-in-powershell/15287#15287">Rynant</a></td></tr>
<tr d-ix="42"><td>nan</td><td></td><td>110209T192219Z</td><td><a href="https://codegolf.stackexchange.com/questions/191/tips-for-golfing-in-powershell/778#778">Joey</a></td></tr>
<tr d-ix="43"><td>nan</td><td>If you need an if/else at the end of the program maybe to handle a special case differently</td><td>110628T001245Z</td><td><a href="https://codegolf.stackexchange.com/questions/191/tips-for-golfing-in-powershell/3012#3012">Joey</a></td></tr>
<tr d-ix="44"><td>nan</td><td></td><td>110129T170641Z</td><td><a href="https://codegolf.stackexchange.com/questions/191/tips-for-golfing-in-powershell/199#199">Joey</a></td></tr>
<tr d-ix="45"><td>nan</td><td></td><td>110214T012620Z</td><td><a href="https://codegolf.stackexchange.com/questions/191/tips-for-golfing-in-powershell/924#924">Joey</a></td></tr>
<tr d-ix="46"><td>nan</td><td></td><td>110209T192913Z</td><td><a href="https://codegolf.stackexchange.com/questions/191/tips-for-golfing-in-powershell/781#781">Joey</a></td></tr>
<tr d-ix="47"><td>nan</td><td></td><td>110209T192521Z</td><td><a href="https://codegolf.stackexchange.com/questions/191/tips-for-golfing-in-powershell/780#780">Joey</a></td></tr>
<tr d-ix="48"><td>nan</td><td></td><td>110209T192402Z</td><td><a href="https://codegolf.stackexchange.com/questions/191/tips-for-golfing-in-powershell/779#779">Joey</a></td></tr>
<tr d-ix="49"><td>nan</td><td></td><td>110208T212401Z</td><td><a href="https://codegolf.stackexchange.com/questions/191/tips-for-golfing-in-powershell/746#746">Joey</a></td></tr>
<tr d-ix="50"><td>nan</td><td></td><td>110208T212232Z</td><td><a href="https://codegolf.stackexchange.com/questions/191/tips-for-golfing-in-powershell/745#745">Joey</a></td></tr>
</table>
<div id="pu0" class="pu"><p>If a string is used in an arithmetic operation, it is implicitly converted to a number. What's interesting is that this conversion supports all prefixes and suffixes of <a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_numeric_literals?view=powershell-7.4" rel="nofollow noreferrer">PowerShell numeric literals</a>. So you can do:</p>
<pre><code>&quot;0x$h&quot;  # convert hex string to number
&quot;0b$b&quot;  # convert binary string to number
</code></pre>
<p>The <code>n</code> suffix is useful to create large BigInts like powers of ten:</p>
<pre><code>'9'*50+'n'
&quot;1$('0'*50)n&quot;
'10n*'*50+1|iex
(0n)::Pow(10,50)
[bigint]::Pow(10,50)
</code></pre>
<p>You can also combine <code>0x</code> and <code>0b</code> with <code>n</code>, or use suffixes like <code>KB</code>. The resulting string must be used in an arithmetic operation to be converted, for example by subtracting zero.</p>
</div>
<div id="pu1" class="pu"><h2>Fake ternary operator for recursive invocations</h2>
<p>If the <a href="https://codegolf.stackexchange.com/a/79895/97729">fake ternary operator</a> returns a code block and a function, it can be used to perform recursive invocations:</p>

<pre class="lang-powershell prettyprint-override"><code>$f={&amp;($f,{result})[condition]}
</code></pre>
<p>Notice the <code>{}</code> around the result and the <code>&amp;</code> before the array instead of before the function variable <code>$f</code></p>
<p>Example, a recursive function that returns only when <code>$r</code> has the value 1:</p>
<pre class="lang-powershell prettyprint-override"><code>$f={if($r=(Get-Random)%2){$r}else{&amp;$f}} # with an if else
$f={&amp;($f,{$r})[($r=(Get-Random)%2)]}    # with a fake ternary operator recursive invocations
</code></pre>
</div>
<div id="pu2" class="pu"><p>Rather than using <code>[bool]</code> for boolean conversion you can instead use <code>!!</code></p>
<pre><code>1         # 1
[bool]1   # True
!!1       # True

0         # 0
[bool]0   # False
!!0       # False
!!$null   # False
</code></pre>
</div>
<div id="pu3" class="pu"><p>If you're tackling a drawing/rendering problem that involves creating, manipulating, and then printing a 2D array, I've found it shorter character-wise to instead deal with a 1D array that you access with <code>$arr[$y*$width+$x]</code> rather than <code>$arr[$y][$x]</code>.</p>
<p>It's very simple and short to set up the array with blanks or zeroes with something like</p>
<pre><code>$arr=@(&quot; &quot;)*$width*$height
</code></pre>
<p>Half the reason for using 1D arrays is that initialization is much shorter.</p>
<p>To easily print the 1D array as a &quot;2D&quot; array to console, you can use a width-based regular expression to split your array into rows. This will join your array into a string, and then split the string into equally sized chunks and print them in order, effectively printing your 1D array as a 2D array:</p>
<pre><code>-join$arr-split&quot;(.{$width})&quot;|?{$_}
</code></pre>
</div>
<div id="pu4" class="pu"><h2>Utilize subtraction and booleans in comparisons</h2>
<p>If you are in need of an operation like <code>-ne</code> and <code>-gt</code> and you are counting down, you can use the subtraction operator, <code>-</code>, instead of using an extra two bytes</p>
<p>Example:</p>
<pre><code>for($i=40;$i-10;$i--){$i}                                         # 40...11
for($i=40;$i-gt10;$i--){$i}                                       # 40...11
for($i=40;$i-ne10;$i--){$i}                                       # 40...11
&quot;$(for($i=40;$i-10;$i--){$i})&quot;`
-eq&quot;$(for($i=40;$i-gt10;$i--){$i})&quot;`
-eq&quot;$(for($i=40;$i-ne10;$i--){$i})&quot;                               # true
</code></pre>
</div>
<div id="pu5" class="pu"><h2><strong>Use <code>[bigint]</code> instead of <code>[Math]::floor</code></strong></h2>
<p>The <code>bigint</code> datatype is a numeric type that can store arbitrarily large numbers and holds no decimal values. It always floors when using <code>[bigint]::new()</code>.</p>
<p>A suffix for it was added in PowerShell core but using the <code>n</code> prefix rounds normally instead of floor which doesn't work for this.</p>
<p>Example:</p>
<pre><code>[bigint](.9)        # 0
[bigint]3/4         # 0
[bigint](.1)        # 0
[bigint]1/4         # 0
[bigint]10.5        # 10
[bigint]100/3       # 33

(.9)n               # 1
3/4n                # 1
(.1)n               # 0
1/4n                # 0
10.5n               # 11
100/3n              # 33
</code></pre>
</div>
<div id="pu6" class="pu"><p>You can access static methods via instance:</p>
<pre class="lang-ps prettyprint-override"><code>$x=4,2,3
$x::Sort($x) # [Array]::Sort($x)
&quot;$x&quot; # 2 3 4
$x::Reverse($x) # [Array]::Reverse($x)
&quot;$x&quot; # 4 3 2
</code></pre>
<p>BigInteger suffix (<code>n</code>) introduced in PowerShell 7:</p>
<pre class="lang-ps prettyprint-override"><code>(0n)::Pow(4,5) # [bigint]::Pow(4,5)
(0n)::Abs(-3) # [bigint]::Abs(-3)
2*0n::Abs(-3) # some cases don't require parentheses
</code></pre>
</div>
<div id="pu7" class="pu"><p>String multiplication:</p>
<pre><code>&quot;#&quot;*5 ==&gt; #####
</code></pre>
</div>
<div id="pu8" class="pu"><p>Fake ternary operator. You can assign straight from an <code>if</code> statement:</p>

<pre><code>$z=if($x-eq$y){"truth"}else{"false"}
</code></pre>

<p>But you can use a 2-element array and use the test to index into it. $falsey results get element 0, $truthy results take element 1:</p>

<pre><code>$z=("false","true")[$x-eq$y]
</code></pre>

<p>NB. that this is really doing array indexing, and if the test results in a value which <em>can</em> be cast to an integer, you'll ask for an item outside the bounds of the array and get $null back, and will need to do <code>!(test)</code> to force cast the result to a bool, with the options reversed.</p>

<p>[ Edit: There's a genuine ternary operator in PowerShell 7+ in the C-language-style <code>cond ? 1 : 0</code> ]</p>
</div>
<div id="pu9" class="pu"><h1>Short way to convert bits to integer:</h1>

<p>if you trust that <code>$args</code> contains <code>int</code> only (see Joey's comments below):</p>

<pre><code>$args|%{$r+=$_+$r};$r
</code></pre>

<p>if you assume that <code>$args</code> is an array of <code>int</code> or <code>string</code> representation:</p>

<pre><code>$args|%{$r+=+$r+$_};$r
</code></pre>

<p><code>$args</code> is an array of <code>char</code> 48, 49:</p>

<pre><code>$args|%{$r+=+$r+"$_"};$r
</code></pre>

<p>A sliding byte containing 8 bits from the array of <code>int</code>:</p>

<pre><code>$args|%{($r=2*$r%256+$_)}
</code></pre>

<p>Compare to:</p>

<pre><code>[Convert]::ToInt64($args,2)
</code></pre>
</div>
<div id="pu10" class="pu"><h1>Use the <code>new()</code> method instead of <code>New-Object</code></h1>

<p>For example, instead of doing the following (37 bytes):</p>

<pre><code>New-Object Drawing.Bitmap(1024,1024)
</code></pre>

<p>Try (32 bytes):</p>

<pre><code>[Drawing.Bitmap]::new(1024,1024)
</code></pre>

<p>Kind of an edge case, but you can do this pretty much anytime you initialize a new .NET object. Sadly, there's no equivalent for COM objects so you still have to use <code>New-Object</code> for those :P</p>
</div>
<div id="pu11" class="pu"><h1>Use Uppercase over lowercase when dealing with ASCII values</h1>
<p>When given the choice, it's usually better to deal entirely with Uppercase. This is because their range is 65..90 vs lowercase's 97..122. For example, the one-liner to generate <code>ABCD...Z</code> in PS v5</p>
<pre><code>-join([char[]](65..90))
-join([char[]](97..122))
</code></pre>
<p>This still applies when normalizing mix-case because using the <code>|%</code> short-property trick, ToUpper and ToLower shorten to <code>*per</code> and <code>*wer</code>, respectively.</p>
<pre><code>&quot;Lower to upper: &quot;+-join([char[]](97..122))|% *per
&quot;Upper to lower: &quot;+-join([char[]](65..90))|% *wer
</code></pre>
<p><a href="https://tio.run/##K8gvTy0qzkjNyfn/XzcrPzNPIzo5I7EoOjZWw8xUT8/SQFOTC03c0lxPz9DICCjBpeQD0q5Qkq9QWlCQWmSloKSNS3GNqoIWUAmXUihIJUhLDkgvFi0we0E6gCr@//8PAA" rel="nofollow noreferrer" title="PowerShell – Try It Online">Try it online!</a></p>
</div>
<div id="pu12" class="pu"><h1>Use <code>$x-shr$k</code> if you want to get the result of <span class="math-container">\$ \big\lfloor{x\over2^k}\big\rfloor \$</span>.</h1>
<p>The biggest application of this is getting the truncated int result of halving a positive number without having to deal with Banker's rounding.</p>
<p>Works on ints and floats, however it will cast floats to ints before shifting, resulting in the same banker problem as before. Whether or not this is acceptable will obviously depend. Below is a sample script that shows the results of <code>-5..10</code>. <code>3/2</code> and <code>7/2</code> demonstrate the difference in return value.</p>
<p><a href="https://tio.run/##K8gvTy0qzkjNyfn/X9dUT8/QoEa1Wik6M68kVkMlPkHfSNNKiYtTSUEhOCMzrURBwVZJW0FJBSilW5xRZKippFeQmJKTmlaiYaIJVuaXX5SbmANTBjMHaAy6UiWu2v//AQ" rel="nofollow noreferrer" title="PowerShell – Try It Online">Try it online!</a></p>
<p><sup><a href="https://codegolf.stackexchange.com/a/178758/78849">Inspired by this answer</a></sup></p>
</div>
<div id="pu13" class="pu"><h1>Get <code>Length</code> of elements of an array</h1>

<p>You can write the name immediately after the point to get the value of the property or method.</p>

<pre><code>$a=gci
$a.fullName
</code></pre>

<p>compare to:</p>

<pre><code>$a|%{$_.fullName}
</code></pre>

<p>Both expressions returns array like this:</p>

<pre><code>C:\Archive
C:\PerfLogs
C:\Pictures
C:\Program Files
C:\Program Files (x86)
C:\Users
C:\Windows
</code></pre>

<p>There is a property <code>Length</code> which is defined for the array itself. So the Powershell expression <code>$a.Length</code> returns the number of elements in an array. You can use the <a href="https://codegolf.stackexchange.com/a/111526/80745">Shortening Names</a> to get length of elements:</p>



<pre class="lang-powershell prettyprint-override"><code>$s=@('22','55555','7777777')
$s|% Length       # 11 bytes
</code></pre>

<p>or shortcut:</p>

<pre class="lang-powershell prettyprint-override"><code>$s|% Le*          # 8 bytes.
</code></pre>

<p>Compare to:</p>

<pre class="lang-powershell prettyprint-override"><code>$s|%{$_.Length}   # 15 bytes
</code></pre>

<p>Result is the array <code>2,5,7</code>, not the number <code>3</code>.</p>
</div>
<div id="pu14" class="pu"><p>When declaring a hard-coded list of strings, depending on the size of the strings and the number of them, it's often shorter to split a single string up by spaces, since space-delimited splitting doesn't require a delimiter provided as a parameter</p>

<p>For example,</p>

<p>Instead of</p>

<pre><code>$numbers='one','two','three','four','five','six','seven','eight','nine','ten'
</code></pre>

<p>Do</p>

<pre><code>$numbers=-split'one two three four five six seven eight nine ten'
</code></pre>

<p>You can further delimit with another character and split twice to hold shortened hard-coded multidimensional arrays</p>
</div>
<div id="pu15" class="pu"><h1><code>SLS</code> instead <code>-match</code></h1>

<p>You can use an <code>sls</code> cmdlet (alias for <a href="https://docs.microsoft.com/en-us/powershell/module/Microsoft.PowerShell.Utility/Select-String" rel="nofollow noreferrer">Select-String</a>) with <code>|% M*</code> as <a href="https://codegolf.stackexchange.com/a/111526/80745">shortcut</a> for property <code>Matches</code> instead a <code>-match</code> operator with a <code>$Matches</code> automatic variable. Compare:</p>

<p><code>$args|sls 'pattern'|% M*</code></p>

<p>vs.</p>

<p><code>if("$args"-match'pattern'){$Matches}</code></p>

<hr>

<p>You can also use <code>sls</code> with <code>-a</code> parameter (<code>-AllMatches</code>) to find all matches:</p>

<p><code>$args|sls 'pattern'-a|% M*</code></p>

<hr>

<p>Also, you can find all matched lines in a multiline string without explicitly line breaking. It need to use a <a href="https://docs.microsoft.com/en-us/dotnet/standard/base-types/regular-expression-language-quick-reference#regular-expression-options" rel="nofollow noreferrer">regexp option</a> <code>?(m)</code>. Compare:</p>

<p><code>$args|sls '(?m)^pattern$'-a|% M*</code></p>

<p>vs.</p>

<p><code>$args-split"``n"|%{$_-match'^pattern$';$Matches}</code></p>
</div>
<div id="pu16" class="pu"><p>A simple one but control-flow statements (as opposed to pipelines), such as <code>if</code>, <code>for</code>, and <code>while</code>, do not need a semi-colon after their braces.</p>

<p>E.g.</p>

<pre><code># Control-flow statements (All are valid)
if(...){...}"foo"
for(...){...}"foo"
while(...){...}"foo"
switch(...){...}"foo"

# Pipelines
1..2|%{...}"bar" #This will throw an error.
1..2|%{...};"bar" #This will work.
</code></pre>

<p>A free byte that's easy to miss.</p>
</div>
<div id="pu17" class="pu"><p>If a path contains more than 1 space, you can do : </p>

<pre><code>gci C:\My*Example*Path
</code></pre>

<p>instead of </p>

<pre><code>gci 'C:\My Example Path'
</code></pre>

<p>or </p>

<pre><code>gci C:\My` Example` Path
</code></pre>
</div>
<div id="pu18" class="pu"><p>You can use <code>$s|% t*y</code> instead <code>[char[]]$s</code> to split a string to char array.
Given from <a href="https://codegolf.stackexchange.com/a/158441/80745">TessellatingHeckler's answer</a>: <code>% t*y</code> expands to <code>| ForEach-Object -Method ToCharArray</code> equiv. of <code>"$args".ToCharArray()</code></p>

<p>For example, compare</p>

<pre><code>$s|% t*y
</code></pre>

<p>and</p>

<pre><code>[char[]]$s
</code></pre>

<p>and</p>

<pre><code>$s.ToCharArray()
</code></pre>

<p>It's useful with <code>$args</code> especially: <code>$args|% t*y</code></p>
</div>
<div id="pu19" class="pu"><p>If you're calling a command with a string argument, you don't need quotes unless there are spaces:</p>

<pre><code>gci MyPath
gci 'My Path'
</code></pre>

<p>But that space cost you 2 extra bytes. You can save a single byte by escaping the space without quotes:</p>

<pre><code>gci My` Path
</code></pre>

<p>This is only worth it when there's a single space, because there's no advantage with 2 or more.</p>
</div>
<div id="pu20" class="pu"><h3>Use variables to store .NET names</h3>
<p>As outlined by cogumel0 in <a href="https://codegolf.stackexchange.com/a/148058/42963">this answer</a>, you can use variables to store .NET type names. For example, changing</p>
<pre><code>param($a)$a-[math]::pow(2,[math]::floor([math]::log($a,2)))
</code></pre>
<p>into</p>
<pre><code>param($a)$a-($m=[math])::pow(2,$m::floor($m::log($a,2)))
</code></pre>
<p>saved 3 bytes in this example.</p>
</div>
<div id="pu21" class="pu"><p>Starting with PowerShell Core 6, you can also use ranges for characters:</p>

<pre><code>'a'..'z'
</code></pre>

<p>which can replace the much more cumbersome</p>

<pre><code>0..25|%{[char]($_+97)}
</code></pre>
</div>
<div id="pu22" class="pu"><h3>Reversing an array</h3>

<p>Comes in handy in a lot of <a href="/questions/tagged/ascii-art" class="post-tag" title="show questions tagged &#39;ascii-art&#39;" rel="tag">ascii-art</a> challenges where the output is mirrored in some fashion.</p>

<p>Suppose you have</p>

<pre><code>$a=1,2,3,4,5
</code></pre>

<p>The traditional reversal method is long, boring, and doesn't leave the array on the pipeline for immediate use.</p>

<pre><code>[array]::reverse($a)
</code></pre>

<p>Indexing directly into the array in reverse order saves a few bytes, since it leaves the results on the pipeline, but is still rather long:</p>

<pre><code>$a[($a.count-1)..0]
</code></pre>

<p>Instead, try a loop</p>

<pre><code>$a|%{$a[-++$i]}
</code></pre>
</div>
<div id="pu23" class="pu">

<h1>Shortening Property Names</h1>

<p>Sadly, unlike parameters, properties/methods (anything accessed with a dot <code>.</code>) cannot usually be shortened down to its unambiguous form.</p>

<p>But certain cmdlets can operate on property names and take wildcards, and there are little-known parameter sets of <code>%</code> and <code>?</code> that can be useful.</p>

<p>Usually we pass in a scriptblock and refer to the item with <code>$_</code>, but there's another form of these that takes a property name, and it accepts a wildcard.</p>

<pre class="lang-powershell prettyprint-override"><code>$o|select Le*  
$o|%{$_.Length}
</code></pre>

<p>With a property like <code>.Length</code> we can't use the v3 magic that would normally work on an array because <code>Length</code> is a property of the array itself, so the above two could be used to get the lengths of the individual members. The <code>select</code> comes in a little bit shorter.</p>

<p>But <code>%</code> can take a property name directly and return that value:</p>

<pre class="lang-powershell prettyprint-override"><code>$a|% Length
</code></pre>

<p>Which can be shortened with wildcards. The wildcard must resolve to a single property (or method, more on that later), so it will throw a helpful error if it doesn't, indicating exactly which members it could resolve to.</p>

<p>In the case of <code>Length</code>, <code>Le*</code> is typically the shortest. Even on a single string, this method is 1 byte shorter than just using the property.</p>

<pre class="lang-powershell prettyprint-override"><code>$a.Length                # 9   #(doesn't work on array)
$a|%{$_.Length}          # 15
$a|% Le*                 # 8
</code></pre>

<p>But depending on what you're doing with this, this can be worse. You can do <code>$a.Length*5</code> but to do it with the pipeline expression you'd have to wrap it <code>($a|% Le*)*5</code>; might still be worth it if it's against an array, but the point is it's not always appropriate as a straight substitution.</p>

<p>It works with methods too, and you can leave off the <code>()</code> which makes a full name the same length, but same restriction as above about sometimes having to wrap it. <s>The method must have an overload that takes no parameters</s> (you can pass arguments by placing them after the method name, which is really nice):</p>

<pre class="lang-powershell prettyprint-override"><code>$a.ToUpper()             # 12
$a|% *per                #  9
</code></pre>

<p>With arguments:</p>

<pre class="lang-powershell prettyprint-override"><code>'gaga'-replace'g','r'    # 21
'gaga'|% *ce g r         # 16
</code></pre>

<p>These aren't strictly the same in that the <code>-replace</code> operator does a regex replace, but if you're just doing a string replace, it can (now) be shorter to use the method; it helps that the strings are cmdlet arguments instead of method arguments so they don't need to be quoted.</p>

<h2>Where-Object Properties</h2>

<p><code>?</code> can take (partial) property names as well, and apply an "operator" to it (in the form of switch parameters). Again this can be shorter than using the standard <code>Where-Object</code> scriptblock approach if the property name is sufficiently long and unique.</p>

<pre class="lang-powershell prettyprint-override"><code>$a|?{$_.Length-gt5}      # 19
$a|? Le* -GT 5           # 14

($a|% Le*)-gt5           # 14 - Lengths, not objs
</code></pre>
</div>
<div id="pu24" class="pu"><p>Converting floating-point numbers to integers in PowerShell is a bit of a minefield. By default the conversion does <a href="http://c2.com/cgi/wiki?BankersRounding" rel="nofollow noreferrer">Bankers Rounding</a> which doesn't always trim off the decimal and leave the smaller whole number, or always round .5 up to the next number like people do casually, it rounds evens one way and odds another way - this can be surprising, e.g. </p>

<pre><code>PS C:\&gt; [int]1.5
2

PS C:\&gt; [int]2.5
2
</code></pre>

<p>and break codegolf calculations. Many other common languages do truncation-rounding, therefore golf questions often require truncation. You might reach for <code>[Math]::Floor()</code> as the next best thing, but beware this only behaves the same as truncation for positive numbers, but it takes negative numbers lower - further away from zero. <code>[Math]::Truncate()</code> is what you need to bring PS behaviour in line with other language's default rounding, but it's a lot of characters.</p>

<p>Regex replacing digits after the decimal point can help save a couple of characters:</p>

<pre><code>[Math]::Truncate(1.5)
[Math]::Floor(1.5)
1.5-replace'\..*'

[Math]::Truncate($a)
[Math]::Floor($a)
$a-replace'\..*'
$a.split('.')[0]        # literal character split, not regex pattern split
</code></pre>
</div>
<div id="pu25" class="pu"><p>When using a number as an argument to an operator that would otherwise require a string, you can use the number directly. Compare</p>

<pre><code>...-join'0'
</code></pre>

<p>vs.</p>

<pre><code>...-join0
</code></pre>

<p>Works with <code>-split</code> as well. The argument is always converted to a string first.</p>
</div>
<div id="pu26" class="pu"><h3>Use Boolean logic in place of if-counters in a loop</h3>

<p>Suppose you're adding all even numbers from 1 to 10 ... <code>2+4+6+8+10=30</code></p>

<pre><code>1..10|%{if($_%2-eq0){$o+=$_}};$o
</code></pre>

<p>You could use Boolean negation to shorten it to</p>

<pre><code>1..10|%{if(!($_%2)){$o+=$_}};$o
</code></pre>

<p>to save a byte, but how about instead use implicit casting of Booleans to ints, and roll the conditional into the accumulator</p>

<pre><code>1..10|%{$o+=$_*!($_%2)};$o
</code></pre>

<p>Saves 6 bytes in this example.</p>
</div>
<div id="pu27" class="pu"><p>Automatic variables have booleans for True and False as <code>$true</code> and <code>$false</code> but you can get similar results using the logical not operator <code>!</code> and the integers 0 and 1( or any non-zero integer.) </p>

<pre><code>PS C:\Users\matt&gt; !1
False

PS C:\Users\matt&gt; !0
True
</code></pre>

<p>Near all PowerShell expressions can be evaluated as booleans. So as long as you are aware of how certain data is evaluated you can get booleans and never need to explicitly cast them. Be aware of the LHS value when doing these.</p>

<ul>
<li>Integer 0 is false and non-zero integers are evaluated to true. </li>
<li>non-zero length strings are true and empty or null (and nulls themselves) strings are false. </li>
</ul>

<p>There are other examples but you can easily test by doing a cast </p>

<pre><code>PS C:\Users\matt&gt; [bool]@(0)
False
</code></pre>
</div>
<div id="pu28" class="pu"><p>Casting to string:</p>

<pre><code>[string]$x
</code></pre>

<p>vs.</p>

<pre><code>"$x"
</code></pre>

<p>Casting to string like this can also be used to flatten an array of strings, instead of joining it:</p>

<pre><code>$a = @('a','b','c')
$a -join ' '
</code></pre>

<p>vs.</p>

<pre><code>$a = @('a','b','c')
"$a"
</code></pre>

<p>Casting a string to a numeric type:</p>

<pre><code>[int]$x     [float]$x
</code></pre>

<p>vs.</p>

<pre><code>+$x
</code></pre>

<p>Also very useful to know that PowerShell <em>always</em> takes the type of the left operand to determine the final type of an expression and conversions to apply:</p>

<pre><code>'1'+2    -&gt; '12'
1+'2'    -&gt; 3
</code></pre>

<p>which can help determining where needless casts are.</p>
</div>
<div id="pu29" class="pu"><p>Powers of 10 literals with scientific notation:</p>

<pre><code>4e6 = 4000000
</code></pre>

<p>Powers of 2 literals:</p>

<pre><code>4KB = 4096
4MB = 4194304
4GB = 4294967296

# TB and PB suffixes also exist, but less useful for golf.
</code></pre>

<p>Could come in handy.</p>
</div>
<div id="pu30" class="pu"><p>Declaring an anonymous function should come up alot. There are multiple variations of this that are covered here <a href="https://stackoverflow.com/questions/10995667/lambda-expression-in-powershell">https://stackoverflow.com/questions/10995667/lambda-expression-in-powershell</a> involving scripts blocks. I use a similar one to this</p>

<pre class="lang-ps prettyprint-override"><code>$a={iex([int[]][char[]]$args[0]-join"+")}
&amp;$a 'abcd'
</code></pre>

<p>This would save a few character from declaring a function with a name and goes better if used more than once. The one above converts a string into a char array then into an int array. Then creates a string joined with + so that Invoke-Expression will add all the values. </p>
</div>
<div id="pu31" class="pu"><p>Use the <code>$ofs</code> <a href="https://technet.microsoft.com/en-us/library/hh847768.aspx" rel="noreferrer">special variable</a> to change the <strong>O</strong>utput <strong>F</strong>ield <strong>S</strong>eparator used when stringifying an array. Useful if you're needing to transform arrays to strings multiple times.</p>

<p>For example:</p>

<pre><code>$a=1,2,3,4
$a-join',';$a-join','
$ofs=',';"$a";"$a"
</code></pre>

<p>Saves 2+<em>n</em> characters on the 2nd <code>-join</code>, where <em>n</em> is the length of the separator, and saves an additional 5+<em>n</em> for the 3rd <code>-join</code> and each thereafter.</p>
</div>
<div id="pu32" class="pu"><p>If you need to silence errors, the obvious variant would be</p>

<pre><code>try{ &lt;# something that throws errors #&gt; }catch{}
</code></pre>

<p>However, this is way too long. A shorter variant is to run the <code>try</code> block as a script block and just redirect the errors into an unset variable (<code>$null</code> would be the usual one, but that's still too long):</p>

<pre><code>.{ &lt;# something that throws errors #&gt; }2&gt;$x
</code></pre>

<p>This saves five valuable bytes (if not the world).</p>
</div>
<div id="pu33" class="pu"><p>If you are assigning an array that you know will only have two values, don't use indexing.</p>

<p>Something like this:</p>

<pre><code>$a="apple","orange"
$a[0] # apple
$a[1] # orange
</code></pre>

<p>Can easily be turned into this:</p>

<pre><code>$a,$o="apple","orange"
$a # apple
$o # orange
</code></pre>

<p>This can also be useful for if you just need to the first element of an array:</p>

<pre><code>$a,$b=1..10
$a # 1
$b # 2..10
</code></pre>
</div>
<div id="pu34" class="pu"><p>You can skip spaces <em>a lot</em> in PowerShell. If it feels like it might not be needed, it quite possibly isn't. This is particularly useful in comparisons.</p>

<p>Example:</p>

<pre><code>$x-eq$i-and$x-ne9
</code></pre>

<p>vs.  </p>

<pre><code>$x -eq $i -and $x -ne 9
</code></pre>

<hr>

<p>If you need to branch your script based on the result of a single test which may have multiple outcomes, <code>switch</code> can sometimes match or beat an if statement.</p>

<p>Example (switch vs. if/else - tie):</p>

<pre><code>if($x%2-eq0){'even'}else{'odd'}
</code></pre>

<p>vs.</p>

<pre><code>switch($x%2){0{'even'}1{'odd'}}
</code></pre>

<p>Or (switch vs. if/elseif/else - switch wins by 15):</p>

<pre><code>if($x%2-eq0){'even'}elseif($x%2-eq1){'odd'}else{'error'}
</code></pre>

<p>vs.</p>

<pre><code>switch($x%2){0{'even'}1{'odd'}2{'error'}}
</code></pre>

<p>If the switch is <em>actually</em> based on certain math results, like the modulo operation above, you can replace the switch entirely with an array. Here, it saves another 13 characters and is even shorter than the original two-option if/else statement. (Thanks to <a href="https://codegolf.stackexchange.com/questions/12177/collatz-conjecture/15220?noredirect=1#comment29076_15220">Danko Durbic</a> for this bit.)</p>

<pre><code>('even','odd','error')[$x%2]
</code></pre>

<p>If you will be using a particular command a lot, especially one without a pre-existing short-hand alias, set up a single-character alias early on.</p>

<p>Example:</p>

<pre><code>nal g Get-Random;g 10;g 10;g 10
</code></pre>

<p>vs.</p>

<pre><code>Get-Random 10;Get-Random 10;Get-Random 10
</code></pre>
</div>
<div id="pu35" class="pu"><p>Consider storing repeated script blocks in variables, instead of using functions.</p>

<p>I was going to use this to save some characters in <a href="https://codegolf.stackexchange.com/a/15386/9387">my Rock, Paper, Scissors implementation</a> before I realized that re-writing the function as a variable made even the variable unnecessary. This could still be useful for other scripts though, where you're actually running the same code multiple times.</p>

<pre><code>function Hi{echo 'Hello, World!'};Hi
</code></pre>

<p>vs.</p>

<pre><code>$Hi={echo 'Hello, World!'};&amp;$Hi
</code></pre>
</div>
<div id="pu36" class="pu"><p>Encapsulating the command that defines a variable in parenthesis allows you to feed the variable's definition directly to other commands.</p>

<p>For example, you can set $x and then set $y based on the value of $x in one shot with this:</p>

<pre><code>$y=($x=1)+1
</code></pre>

<p>Instead of this:</p>

<pre><code>$x=1;$y=$x+1
</code></pre>

<p>You can set $h and output it with this:</p>

<pre><code>($h='Hello World!')
</code></pre>

<p>Instead of this:</p>

<pre><code>$h='Hello World!';$h
</code></pre>
</div>
<div id="pu37" class="pu"><p>A switch can act like a loop, when given an array. For example:</p>

<pre><code>$FooBarMeh='a','b','c'
switch ($FooBarMeh)
{
    'a'{'FOO'}
    'b'{'BAR'}
    default{'MEH'}
}
</code></pre>

<p>Will output:</p>

<blockquote>
  <p>FOO<br>
  BAR<br>
  MEH</p>
</blockquote>

<p>I'm not totally sure where this will be useful, but I expect it will be handy for someone some time.</p>
</div>
<div id="pu38" class="pu"><p>Replace <code>[math]::pow</code> with multiplication. Instead of </p>

<pre><code>[math]::pow($a,$b)
</code></pre>

<p>you can write</p>

<pre><code>"$a*"*$b+1|iex
</code></pre>

<p>This works for integer exponents >= 0.</p>
</div>
<div id="pu39" class="pu"><p>If you need to run a loop, and you know <em>exactly</em> how many times it needs to run every time, consider piping an array of contiguous integers into <code>ForEach-Object</code> via the <code>%</code> alias instead of using <code>for</code>.</p>

<p><code>for($x=1;$x-le10;$x++){</code>...<code>}</code></p>

<p>vs</p>

<p><code>1..10|%{</code>...<code>}</code></p>
</div>
<div id="pu40" class="pu"><p>Don't forget that you don't always need to provide the full name of a parameter, and some parameters are positional.</p>

<pre><code>Get-Random -InputObject (0..10)
</code></pre>

<p>...can be trimmed to...</p>

<pre><code>Get-Random -I (0..10)
</code></pre>

<p>...because "I", in this case, is enough to uniquely identify <code>InputObject</code> from the other valid parameters for this command.</p>

<p>You could trim it further to...</p>

<pre><code>Get-Random (0..10)
</code></pre>

<p>...because <code>InputObject</code> is a positional parameter.</p>

<p>Piping is usually shorter than feeding objects as a parameter, especially when it can remove the need for parenthesis. Let's trim our random number generator further...</p>

<pre><code>0..10|Get-Random
</code></pre>

<p>Also be on the lookout for other ways to accomplish the same thing, even if you can't change the command. For the above case, you could do this:</p>

<pre><code>Get-Random 11
</code></pre>

<p>Or, incorporating <a href="https://codegolf.stackexchange.com/a/778/9387">another suggestion</a>*:</p>

<pre><code>Random 11
</code></pre>

<p>**Note: Omitting <code>Get-</code> from a command name can bloat the run time by about 50,000%. Not bad if you only need the command once, but be careful using it in long loops.*</p>

<p>And that's how can knock a simple command down to a third of its size.</p>
</div>
<div id="pu41" class="pu"><p>Absolute value</p>

<p>With</p>

<pre><code>$n=-123
</code></pre>

<p>Instead of</p>

<pre><code>[math]::abs($n)
</code></pre>

<p>use</p>

<pre><code>$n-replace'-'
</code></pre>

<p>Of course, the savings are cancelled if parentheses are needed.</p>
</div>
<div id="pu42" class="pu"><p>The <code>Get</code> verb is implied. This can shorten any <code>Get-Frob</code> to just <code>Frob</code>. Frequent contenders are <code>date</code> or <code>random</code>.</p>

<p>Note that this <em>won't</em> work properly in some cases because you might have GNU utilities in your path (or other native programs that clash). Order of command lookup in that case seems to prefer the native program before it considers cmdlets with the <code>Get-</code> removed:</p>

<pre><code>PS Home:\&gt; date

Freitag, 15. November 2013 07:13:45


PS Home:\&gt; $Env:Path += ';D:\Users\Joey\Apps\GnuWin32\bin'
PS Home:\&gt; date
Fr Nov 15 07:14:13 W. Europe Standard Time 2013
</code></pre>
</div>
<div id="pu43" class="pu"><p>If you need an <code>if</code>/<code>else</code> at the end of the program (maybe to handle a special case differently), then instead of</p>

<pre><code>if(foo){a}else{b}
</code></pre>

<p>do</p>

<pre><code>if(foo){a;exit}b
</code></pre>

<p>which saves a character.</p>
</div>
<div id="pu44" class="pu"><p><code>for</code> loops can have anything between 0 and three statements in their header:</p>

<p>Endless loop:</p>

<pre><code>for(){}
</code></pre>

<p>Loop with initialization:</p>

<pre><code>for($n=0){}
</code></pre>

<p>Loop with initialization and end condition:</p>

<pre><code>for($n=0;$n-lt7){}
</code></pre>

<p>In such cases the additional semicolons at the end may be omitted (it's explicitly stated in the <a href="http://www.microsoft.com/download/en/details.aspx?id=9706" rel="noreferrer">language specification</a>, so it's not an implementation detail) in contrast to C-like languages which always require exactly three statements.</p>

<p>This also makes <code>while</code> a bit shorter. Compare</p>

<pre><code>while(...){}
</code></pre>

<p>and</p>

<pre><code>for(;...){}
</code></pre>

<p>With the added bonus that you can stick in a previous line (if there is one) into the <code>for</code> as well without extra cost (and even saving a character).</p>
</div>
<div id="pu45" class="pu"><p>Semicolons and line breaks are interchangeable. Golfed code is often more readable if not jammed into a single line. And the length is still the same (provided you use U+000A as line break which PowerShell handles without problems).</p>
</div>
<div id="pu46" class="pu"><p><code>Invoke-Expression</code> and <code>Get-Random</code> can also get pipeline input instead of arguments.</p>

<p>For <code>iex</code> this allows to save parentheses on some expressions:</p>

<pre><code>iex 1..5-join'+'   # won't work
iex(1..5-join'+')  # does work, but has extra parentheses
1..5-join'+'|iex   # doesn't need the parentheses
</code></pre>

<p>In case of <code>random</code> this allows a common case to be optimized a bit:</p>

<pre><code>random -mi 10 31   # gets a random integer between 10 and 30
10..30|random      # much better :-)
(random 21)+10     # if needed in another expression that doesn't require extra
                   # parentheses
</code></pre>

<p>The latter way of using it simply selects an item from a list. The <code>-c</code> argument can be given to allow more than a single selection.</p>
</div>
<div id="pu47" class="pu"><p>Want to find the maximum or minimum of a collection of values? Tried</p>

<pre><code>(...|measure -ma).Maximum
</code></pre>

<p>or</p>

<pre><code>(...|measure -mi).Minimum
</code></pre>

<p>already?</p>

<p>Just sort and use the last or first item:</p>

<pre><code>(...|sort)[-1]  # maximum
(...|sort)[0]   # minimum
</code></pre>
</div>
<div id="pu48" class="pu"><p>Use aliases whenever possible. There are a bunch of useful ones:</p>

<pre><code>?        Where-Object
%        ForEach-Object
gu       Get-Unique
sort     Sort-Object
iex      Invoke-Expression
</code></pre>
</div>
<div id="pu49" class="pu"><p>Finding a sum the long way:</p>

<pre><code>(...|measure -s).Sum
</code></pre>

<p>A shorter way:</p>

<pre><code>...|%{$s+=$_};$s
</code></pre>

<p>And even shorter:</p>

<pre><code>...-join'+'|iex
</code></pre>
</div>
<div id="pu50" class="pu"><p>Comparison operators work on collections of values by returning matching values:</p>

<pre><code>1..5 -gt 2
</code></pre>

<p>will yield <code>3</code>, <code>4</code> and <code>5</code>. In some cases this can help to save an otherwise longer <code>|?{$_...}</code>.</p>

<p><code>-match</code> is a comparison operator too.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/191/">191</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




