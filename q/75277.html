<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::75277</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>298</td><td>Python 3</td><td>160325T094842Z</td><td><a href="https://codegolf.stackexchange.com/questions/75277/evaluate-the-riemann-zeta-function-at-a-complex-number/76246#76246">Sherlock</a></td></tr>
<tr d-ix="1"><td>292</td><td>Axiom</td><td>170420T011709Z</td><td><a href="https://codegolf.stackexchange.com/questions/75277/evaluate-the-riemann-zeta-function-at-a-complex-number/117058#117058">user5898</a></td></tr>
<tr d-ix="2"><td>385</td><td>Python</td><td>160314T185801Z</td><td><a href="https://codegolf.stackexchange.com/questions/75277/evaluate-the-riemann-zeta-function-at-a-complex-number/75540#75540">R.T.</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://docs.python.org/3/" rel="nofollow noreferrer">Python 3</a>, <s>303</s> <s>297</s> 298 bytes</h1>

<p>This answer is based on <a href="https://codegolf.stackexchange.com/a/75540/47581">R.T.'s Python answer</a> with several modifications:</p>
<ul>
<li>First, <code>Binomial(n, k)</code> is defined as <code>p = p * (n-k) / (k+1)</code> which changes <code>Binomial(n,k)</code> to <code>Binomial(n,k+1)</code> with every pass of the for loop.</li>
<li>Second, <code>(-1)**k * Binomial(n,k)</code> became <code>p = p * (k-n) / (k+1)</code> which flips the sign at every step of the for loop.</li>
<li>Third, the <code>while</code> loop has been changed to immediately check if <code>a*a + b*b &lt; E</code>.</li>
<li>Fourth, the bitwise not operator <code>~</code> is used in several places where they would aid in golfing, using identities such as <code>-n-1 == ~n</code>, <code>n+1 == -~n</code>, and <code>n-1 == ~-n</code>. This only works for ints, however, and not floats.</li>
</ul>
<p>Several other small modifications were made for better golfing, such as putting the <code>for</code> loop on one line and the call to <code>print</code> on one line with the code before it.</p>
<p>Golfing suggestions welcome. <a href="https://tio.run/##TVA7b8IwEN75FTfaZxvitF2wrhIDQwYYsiIGpwSwQpzIuGrC0L@exqr6WO6@7x7fPfoxXjv/NE2u7bsQobXxCvYO@8WpPsODBenklnStnjO@XkBJBXnKjKWK9AI@ru5Wg0UrKqxet3MBpExmetKmpRzx08@xcxegAechWH@pmZZe5Hy9o37VIAbTI7FGaeX5qjGRlMP98tZdWMONFbSb2Vt3Z5Gb6pvdnZ9ZmoXUmiqZUpA1haDKeJEW26TZTKvA/wvm3Ayk1eZPcaTNr6A50YCDGHE0oY7vwbMSB1XgyFcnOeNRFDjMeErnlBKKdNHhkEvIjhIOWoJOXumfwPIloWP6CkAfnI/swVIj59MX" rel="nofollow noreferrer" title="Python 3 â€“ Try It Online">Try it online!</a></p>
<p><strong>Edit:</strong> -6 bytes from a number of small changes.</p>
<p><strong>Edit:</strong> +1 byte from fixing an error with float handling, with thanks to <a href="https://codegolf.stackexchange.com/users/120478/mostlywright">mostlyWright</a> for pointing out the error.</p>
<pre class="lang-python prettyprint-override"><code>import math as N
def z(r,i,E=1e-40):
 R=I=n=0;a=b=1
 while a*a+b*b&gt;E:
  a=b=0;p=1;m=2**~n
  for k in range(1,n+2):M=p/k**r;p*=(k-1-n)/k;t=-i*N.log(k);a+=M*N.cos(t);b+=M*N.sin(t)
  a*=m;b*=m;R+=a;I+=b;n+=1
 A=2**(1-r;t=-i*N.log(2);x=1-A*N.cos(t);y=A*N.sin(t);d=x*x+y*y;return(R*x-I*y)/d,(R*y+I*x)/d
</code></pre>
</div>
<div id="pu1" class="pu"><h1>Axiom, <s>413 315</s> 292 bytes</h1>

<pre><code>p(n,a,b)==(x:=log(n^b);y:=n^a;[y*cos(x),y*sin(x)]);z(a,b)==(r:=[0.,0.];e:=10^-digits();t:=p(2,1-a,-b);y:=(1-t.1)^2+t.2^2;y=0=&gt;[];m:=(1-t.1)/y;q:=t.2/y;n:=0;repeat(w:=2^(-n-1);abs(w)&lt;e=&gt;break;r:=r+w*reduce(+,[(-1)^k*binomial(n,k)*p(k+1,-a,-b) for k in 0..n]);n:=n+1);[r.1*m-q*r.2,m*r.2+r.1*q])
</code></pre>

<p>This would implement too the equation 21 from <a href="http://mathworld.wolfram.com/RiemannZetaFunction.html" rel="nofollow noreferrer">http://mathworld.wolfram.com/RiemannZetaFunction.html</a> 
The above should be the one iterpreted Axiom function z(a,b) here 16x slower than this below function Zeta(a,b)[that should be the one compiled] all ungolfed and commented
[1 second for Zeta() against 16 seconds for z() for one value of 20 digits afther the float point]. For the digit question, one would choose the precision by calling digits(); function, for example digits(10);z(1,1) should print 10 digits after the point, but digits(50);z(1,1) should print 50 digits after the point.</p>

<pre><code>-- elevImm(n,a,b)=n^(a+i*b)=r+i*v=[r,v]
elevImm(n:INT,a:Float,b:Float):Vector Float==(x:=log(n^b);y:=n^a;[y*cos(x),y*sin(x)]::Vector Float);

--                      +oo               n
--                      ---              ---
--             1        \       1        \            n 
--zeta(s)= ---------- * /     ------  *  /    (-1)^k(   )(k+1)^(-s)
--          1-2^(1-s)   ---n  2^(n+1)    ---k         k  
--                       0                0


Zeta(a:Float,b:Float):List Float==
  r:Vector Float:=[0.,0.]; e:=10^-digits()

  -- 1/(1-2^(1-s))=1/(1-x-i*y)=(1-x+iy)/((1-x)^2+y^2)=(1-x)/((1-x)^2+y^2)+i*y/((1-x)^2+y^2)    

  t:=elevImm(2,1-a,-b);
  y:=(1-t.1)^2+t.2^2;
  y=0=&gt;[] 
  m:=(1-t.1)/y; 
  q:=t.2/y
  n:=0
  repeat
     w:=2^(-n-1)
     abs(w)&lt;e=&gt;break  --- this always terminate because n increase
     r:=r+w*reduce(+,[(-1)^k*binomial(n,k)*elevImm(k+1,-a,-b) for k in 0..n])
     n:=n+1
  -- (m+iq)(r1+ir2)=(m*r1-q*r2)+i(m*r2+q*r1)
  [r.1*m-q*r.2,m*r.2+r.1*q]

this is one test for the z(a,b) function above:

(10) -&gt; z(2,0)
   (10)  [1.6449340668 482264365,0.0]
                                              Type: List Expression Float
(11) -&gt; z(1,1)
   (11)  [0.5821580597 520036482,- 0.9268485643 3080707654]
                                              Type: List Expression Float
(12) -&gt; z(-1,0)
   (12)  [- 0.0833333333 3333333333 3,0.0]
                                              Type: List Expression Float
(13) -&gt; z(1,0)
   (13)  []
</code></pre>
</div>
<div id="pu2" class="pu"><h1>Python - 385</h1>

<p>This is a straightforward implementation of Equation 21 from <a href="http://mathworld.wolfram.com/RiemannZetaFunction.html">http://mathworld.wolfram.com/RiemannZetaFunction.html</a> This uses Python's convention for optional arguments; if you want to specify a precision, you can pass a third argument to the function, otherwise it uses 1e-24 by default.</p>

<pre><code>import numpy as N
def z(r,i,E=1e-24):
 R=0;I=0;n=0;
 while(True):
  a=0;b=0;m=2**(-n-1)
  for k in range(0,n+1):
   M=(-1)**k*N.product([x/(x-(n-k))for x in range(n-k+1,n+1)]);A=(k+1)**-r;t=-i*N.log(k+1);a+=M*A*N.cos(t);b+=M*A*N.sin(t)
  a*=m;b*=m;R+=a;I+=b;n+=1
  if a*a+b*b&lt;E:break
 A=2**(1-r);t=-i*N.log(2);a=1-A*N.cos(t);b=-A*N.sin(t);d=a*a+b*b;a=a/d;b=-b/d
 print(R*a-I*b,R*b+I*a)
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/75277/">75277</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




