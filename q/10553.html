<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::10553</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>024</td><td>C gcc 24 bytes</td><td>230820T134323Z</td><td><a href="https://codegolf.stackexchange.com/questions/10553/build-a-random-number-generator-that-passes-the-diehard-tests/264402#264402">The Empt</a></td></tr>
<tr d-ix="1"><td>nan</td><td>ECMAScript 6</td><td>230501T163705Z</td><td><a href="https://codegolf.stackexchange.com/questions/10553/build-a-random-number-generator-that-passes-the-diehard-tests/260601#260601">LeoDog89</a></td></tr>
<tr d-ix="2"><td>nan</td><td>ObjectiveC</td><td>180609T194149Z</td><td><a href="https://codegolf.stackexchange.com/questions/10553/build-a-random-number-generator-that-passes-the-diehard-tests/166566#166566">Albert R</a></td></tr>
<tr d-ix="3"><td>344</td><td>BrainFlak</td><td>171220T004158Z</td><td><a href="https://codegolf.stackexchange.com/questions/10553/build-a-random-number-generator-that-passes-the-diehard-tests/151252#151252">user6318</a></td></tr>
<tr d-ix="4"><td>nan</td><td>C</td><td>161214T070707Z</td><td><a href="https://codegolf.stackexchange.com/questions/10553/build-a-random-number-generator-that-passes-the-diehard-tests/103131#103131">user1502</a></td></tr>
<tr d-ix="5"><td>nan</td><td>Mathematica</td><td>160119T064944Z</td><td><a href="https://codegolf.stackexchange.com/questions/10553/build-a-random-number-generator-that-passes-the-diehard-tests/69673#69673">2012rcam</a></td></tr>
<tr d-ix="6"><td>nan</td><td></td><td>141115T010758Z</td><td><a href="https://codegolf.stackexchange.com/questions/10553/build-a-random-number-generator-that-passes-the-diehard-tests/41525#41525">Andrew P</a></td></tr>
<tr d-ix="7"><td>nan</td><td></td><td>140906T211640Z</td><td><a href="https://codegolf.stackexchange.com/questions/10553/build-a-random-number-generator-that-passes-the-diehard-tests/37414#37414">Richard </a></td></tr>
<tr d-ix="8"><td>nan</td><td>Ruby</td><td>140224T233727Z</td><td><a href="https://codegolf.stackexchange.com/questions/10553/build-a-random-number-generator-that-passes-the-diehard-tests/22053#22053">YenTheFi</a></td></tr>
<tr d-ix="9"><td>nan</td><td></td><td>130125T220241Z</td><td><a href="https://codegolf.stackexchange.com/questions/10553/build-a-random-number-generator-that-passes-the-diehard-tests/10560#10560">primo</a></td></tr>
<tr d-ix="10"><td>nan</td><td>Python</td><td>130128T162245Z</td><td><a href="https://codegolf.stackexchange.com/questions/10553/build-a-random-number-generator-that-passes-the-diehard-tests/10583#10583">Keith Ra</a></td></tr>
<tr d-ix="11"><td>nan</td><td>Python</td><td>130127T000025Z</td><td><a href="https://codegolf.stackexchange.com/questions/10553/build-a-random-number-generator-that-passes-the-diehard-tests/10572#10572">Keith Ra</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>C (gcc) 24 bytes, 24/(pending) = (pending) score</h1>
<pre class="lang-c prettyprint-override"><code>main(){printf(&quot;%u&quot;,.5);}
</code></pre>
<p><a href="https://tio.run/##S9ZNT07@/z83MTNPQ7O6oCgzryRNQ0m1VElHz1TTuvb/fwA" rel="nofollow noreferrer">Try it online!</a></p>
<p>C misbehaves when printing a float as an integer…</p>
</div>
<div id="pu1" class="pu"><h1>ECMAScript 6, <strike>31 30</strike> 25 / 15 = 1.66</h1>
<p>This is Keith Randall's solution implemented in ES6:</p>
<pre class="lang-js prettyprint-override"><code>e=3;R=_=&gt;e=e**3%(2**32-5)
</code></pre>
<ul>
<li>Removed semicolon (thanks <a href="https://codegolf.stackexchange.com/users/114446/the-thonnu">The Thonnu</a>!)</li>
<li>Drop unnecessary comma operator and use _ for param (an assignment statement <a href="https://stackoverflow.com/questions/16027247/value-returned-by-the-assignment">will return the new value</a>)</li>
</ul>
</div>
<div id="pu2" class="pu"><h1>Objective-C, 40/1 = 40</h1>
<p>Pretty clever approach, exploiting <code>.hash</code> to somewhat cheat here, but I like it</p>
<pre><code>for(int v=9;v=@(v).hash;printf(&quot;%i&quot;,v));
</code></pre>
</div>
<div id="pu3" class="pu"><h1><a href="https://github.com/DJMcMayhem/Brain-Flak" rel="nofollow noreferrer">Brain-Flak</a>, 344/(pending)</h1>

<pre><code>&lt;&gt;((()()){})&lt;&gt; push the amount of iterations to do for the PRNG
(((((((((((((((((((((((((((((((((((()()()){}()){})){}{}){()()()()({}[()])}{})){}{})){}{})()){}{})()){}{})){}{})){}{}){}())){}{})){}{})()){}{})()){}{})){}{})){}{})()){}{})()){}{}) push M (one of the values for the Blum Blum Shub PRNG
((((((((((((()()()){}){}){})){}{}){()({}[()])}{}){}())){}{})()){}{}) push s see above
&lt;&gt;{({}[()])&lt;&gt;starts the loop
(({({})({}[()])}{}) squares the current number
(&lt;&gt;))&lt;&gt;{(({})){({}[()])&lt;&gt;}{}}{}&lt;&gt;([{}()]({}))mods by M
&lt;&gt;}{}&lt;&gt;loop ends
</code></pre>

<p><a href="https://tio.run/##jVE7DsMgDN05hUd76A0QN@gJogxUoUrUBFIgE8rZKYG0@ahDwBjJ7/k9Ix5Wdvr27OUrRi4QkZAozMQFjJNrwbcK5GAm7cE8ofPKSt8Z7cAbaAzDC4tWzSKcTsqhVNMOc4VU0/yDSsbTvc9Z6ir5jJVn3dnfEdfYZtxNt3M9ajnGRfgyueiNGcF5aX3yWOoHFXDvSVrFkAuipQ@z39aeSCnSV1SLYZ3hwTQsI6u60k2MHw" rel="nofollow noreferrer" title="Brain-Flak – Try It Online">Try it online!</a></p>

<p>This works fine but the diehard tests links are all broken :( so until we get new ones i do not have a final score</p>

<p>This uses the Blum Blum Shub PRNG so it should pass most the cases. The numbers used are large enough no patterns will appear within the 16 MB of test cases</p>
</div>
<div id="pu4" class="pu"><p><strong>C, 38/15 = 2.533</strong></p>

<pre><code>long long x;f(){return(x+=x*x+9)&gt;&gt;32;}
</code></pre>

<p>I couldn't get the Diehard tests working on my machine, but it passes the PractRand suite for up to 8GB of output so I assume it would pass them all.</p>
</div>
<div id="pu5" class="pu"><h1>Mathematica, 32 / 15 = 2.133</h1>
<pre><code>x=3;Mod[x=Mod[x^2,28!-67],2^32]&amp;
</code></pre>
<p>A straightforward implementation of <a href="https://en.wikipedia.org/wiki/Blum_Blum_Shub" rel="nofollow noreferrer">BBS</a>.</p>
<p>Binary file generated with:</p>
<pre><code>f = %; (* assigns anonymous function declared in the previous expression to f *)
Export[&quot;random.bin&quot;, Array[f, 2^22], &quot;UnsignedInteger32&quot;];
</code></pre>
<p>Summary of results:</p>
<pre><code> 1. BIRTHDAY SPACINGS TEST           .684805
 2. OVERLAPPING 5-PERMUTATION TEST   .757608/.455899
 3. BINARY RANK TEST                 .369264/.634256
 4. BINARY RANK TEST                 .838396
 5. THE BITSTREAM TEST                (no summary p-value)    
 6. OPSO, OQSO and DNA                (no summary p-value)
 7. COUNT-THE-1's TEST               .649382/.831761
 8. COUNT-THE-1's TEST                (no summary p-value)
 9. PARKING LOT TEST                 .266079
10. MINIMUM DISTANCE TEST            .493300
11. 3DSPHERES TEST                   .492809
12. SQEEZE                           .701241
13. OVERLAPPING SUMS test            .274531
14. RUNS test                        .074944/.396186/.825835/.742302
15. CRAPS TEST                       .403090/.403088/.277389
</code></pre>
<p><a href="https://googledrive.com/host/0B0VNJlWZGkwNfmlvUjNOQUxoZmVuTWFfeFRnUk5wRVhuRVJWcTA0YjVGaDIwdzhnSUYyNWs/random.bin" rel="nofollow noreferrer">Full <code>random.bin</code> here.</a></p>
<p><a href="https://gist.github.com/2012rcampion/ed6287fc82adff9e8a1d" rel="nofollow noreferrer">Full log file here.</a></p>
</div>
<div id="pu6" class="pu"><h1>C# 144 / 15 = 9.6</h1>

<pre><code>uint a=15,b=26,y;uint q(int n){y=(a*1414549U+876619U)^(b*889453U+344753U);b=a;a=y&gt;&gt;12;return(a%256)&lt;&lt;n;}uint r(){return q(24)|q(16)|q(8)|q(0);}
</code></pre>

<p>This passed all of the tests.</p>

<p>With not too many more characters it passes TestU01.</p>

<p>Result: <a href="http://codepad.org/iny6usjV" rel="nofollow">http://codepad.org/iny6usjV</a></p>

<pre><code>    uint a = 15;
    uint b = 26;

    byte prng8()
    {
        uint y = ((a * 1414549U + 876619U) ^ (b * 889453U + 344753U)) &gt;&gt; 12;
        b = a;
        a = y;
        return (byte)y;
    }

    uint prng32()
    {
        return ((uint)prng8() &lt;&lt; 24) | ((uint)prng8() &lt;&lt; 16) | ((uint)prng8() &lt;&lt; 8) | (uint)prng8();
    }
</code></pre>
</div>
<div id="pu7" class="pu"><h1>C# - 103 / 14 = 7.36</h1>

<pre><code>double j=999;uint N(){uint i=0,n=0;for(;i++&lt;4;n=n*256+(uint)j%256)for(j/=277;j&lt;100000;j*=j);return n;}
</code></pre>

<h2>Results</h2>

<p>Passes all except test #6<br>
See results at <a href="http://codepad.org/k1NSoyQW" rel="nofollow">http://codepad.org/k1NSoyQW</a></p>

<h2>Explanation</h2>

<p>C# just can't compete with Ruby and Python for terseness, as usual, but I enjoyed trying. There are certainly other values that will work just as well (i.e., the initial value for j=999, and the divisor=277).  I picked these after brief experimentation.</p>

<h2>With file-creation wrapper</h2>

<pre><code>class R
{
    public static void Main(string[] args)
    {
        var r = new R();
        using (var f = new System.IO.FileStream(".\\out.bin", System.IO.FileMode.Create, System.IO.FileAccess.Write, System.IO.FileShare.Read))
        using (var b = new System.IO.BinaryWriter(f))
        {
            for (long i = 0; i &lt; 12 * 1024 * 1024; i += 4)
            {

                b.Write(r.N());
            }
        }
    }

    double j = 999;

    uint N()
    {
        uint i = 0, n = 0;
        for (; i++ &lt; 4; n = n * 256 + (uint)j % 256)
            for (j /= 277; j &lt; 100000; j *= j) ;
        return n;
    }

}
</code></pre>
</div>
<div id="pu8" class="pu"><h1>Ruby, 32/15 = 2.1333</h1>

<p>This is Keith Randall's solution, implemented in Ruby.</p>

<pre><code>$v=3;def R;$v=$v**3%(2**32-5)end
</code></pre>
</div>
<div id="pu9" class="pu"><h2>Perl 28 / 13 &approx; 2.15</h2>

<pre><code>sub r{$s^=~($s^=$s/7215)&lt;&lt;8}
</code></pre>

<p><em>log file <a href="http://codepad.org/uab3DWX0" rel="nofollow noreferrer">here</a></em></p>

<h2>Perl 29 / 13 &approx; 2.23</h2>

<pre><code>sub r{$s^=~($s^=$s&lt;&lt;8)/60757}
</code></pre>

<p><em>log file <a href="http://codepad.org/P0YiOL29" rel="nofollow noreferrer">here</a></em></p>

<p>These are something of a variation on a <a href="http://de.wikipedia.org/wiki/Xorshift" rel="nofollow noreferrer">Xorshift</a>, using floating point division instead of a right shift. They both pass 13 of 15 tests, failing only tests 6 and 7. </p>

<p>I'm not exactly sure how long the cycle is, but because the following code doesn't terminate in any short period of time, it's likely the full <em>2<sup>32</sup></em>:</p>

<pre><code>$start = r();
$i++ while $start != r();
print $i;
</code></pre>

<hr>

<h2>Perl 39 / 10 = 3.9</h2>

<pre><code>$s=$^T;sub r{~($s=$s*$s%4294969373)||r}
</code></pre>

<p><em>Note: if you're looking for a Blum-Blum-Shub-esque PRNG, <a href="https://codegolf.stackexchange.com/a/10583/4098">Keith Randall's solution</a> is far better than either of these.</em></p>

<p>As with my original solution below, this is also an implementation of the Blum Blum Shub, with one major difference. I uses a modulus slightly larger than <em>2<sup>32</sup></em> (<em>M = 50971 &bull; 84263</em>), and whenever a value is encountered that it is not a valid 32-bit integer (that is, larger than <em>2<sup>32</sup></em>), it returns the next value in the rotation instead. In essense, these values are pruned out, leaving the rest of the rotation undisturbed, resulting in a nearly uniform distribution.</p>

<p>It seems to have helped. In addition to passing the same 9 tests as before, it now also convincingly passes the Minimum Distance test. A sample log file can be found <a href="http://codepad.org/1OByLxUh" rel="nofollow noreferrer">here</a>.</p>

<hr>

<h2>Perl 33 / 9 &approx; 3.67 (Invalid?)</h2>

<pre><code> $s=$^T;sub r{$s=$s*$s%4294951589}
</code></pre>

<p><em>Note: this solution might be considered invalid, as the top-most 0.00037% of the range will never be observed.</em></p>

<p>A quick and dirty implementation of the <a href="http://en.wikipedia.org/wiki/Blum_Blum_Shub" rel="nofollow noreferrer">Blum Blum Shub</a>. I claim the following results:</p>

<pre><code> 1. passed - Birthday Spacings
 2. FAILED - Overlapping Permutations
 3. passed - Ranks of 31x31 and 32x32 Matrices
 4. passed - Ranks of 6x8 Matrices
 5. FAILED - Monkey Tests on 20-bit Words
 6. FAILED - Monkey Tests OPSO, OQSO, DNA
 7. FAILED - Count the 1s in a Stream of Bytes
 8. passed - Count the 1s for Specific Bytes
 9. passed - Parking Lot Test
10. FAILED - Minimum Distance Test
11. passed - Random Spheres Test
12. FAILED - The Squeeze Test
13. passed - Overlapping Sums Test
14. passed - Runs Test
15. passed - The Craps Test
</code></pre>

<p>A sample log file can be found <a href="http://codepad.org/3yt3cwnf" rel="nofollow noreferrer">here</a>, feel free to dispute any of the results. The file for diehard can be generated in the following manner:</p>

<pre><code>print pack('N', r()) for 1..4194304
</code></pre>

<p>and then piping the output into a file. Minimum Distance looks like it might have passed, but if you run it multiple times it's always very close to <em>1.0</em>, which indicates failure.</p>

<hr>

<h2>Details</h2>

<p>In general, the Blum Blum Shub is a terrible PRNG, but it's performance can be improved by choosing a good modulus. The <em>M</em> I've chosen is <em>7027 &bull; 611207</em>. Both of these prime factors, <em>p</em> and <em>q</em>, have modular residue <em>3 (mod 4)</em>, and <em>gcd(&phi;(p-1), &phi;(q-1)) = 2</em>, which is as low as it can be.</p>

<p>Although these are the only criteria listed on the wiki page, it doesn't seem to be enough. Almost all of the modulo I tried failed every test. But there's a handful that will pass some of the tests, and the one I've chosen seems to be exceptionally good, for whatever reason.</p>

<p>As a final note, Test 5 on its own seems to be a fairly good indicator of how good the PRNG is. If it doesn't <em>almost</em> pass Test 5, it will fail the rest of them spectacularly.</p>

<hr>

<h2>BONUS: Perl 62 / 14 &approx; 4.43</h2>

<pre><code>$t=$^T;sub r{$t|=(($s=$s/2|$t%2&lt;&lt;31)^($t/=2))&lt;&lt;31for 1..37;$t}
</code></pre>

<p>Just for geekery, this is a 32-bit version of the PRNG used in the original Tetris for NES. Amazingly, it passes 14 of the 15 tests!</p>

<pre><code> 1. passed - Birthday Spacings
 2. passed - Overlapping Permutations
 3. passed - Ranks of 31x31 and 32x32 Matrices
 4. passed - Ranks for 6x8 Matrices
 5. passed - Monkey Tests on 20-bit Words
 6. passed - Monkey Tests OPSO, OQSO, DNA
 7. FAILED - Count the 1s in a Stream of Bytes
 8. passed - Count the 1s for Specific Bytes
 9. passed - Parking Lot Test
10. passed - Minimum Distance Test
11. passed - Random Spheres Test
12. passed - The Squeeze Test
13. passed - Overlapping Sums Test
14. passed - Runs Test
15. passed - The Craps Test
</code></pre>

<p>Sample log file can before <a href="http://codepad.org/v7zzpHcf" rel="nofollow noreferrer">here</a>.</p>

<p>Admittedly, the <code>1..37</code> bit isn't an exact transcription. In the orginal version, the entropy routine is updated 60 times per second, and then queried at random intervals, largely dependent on user input. For anyone who cares to disassemble the ROM, the entropy routine begins at <code>0xAB47</code>.</p>

<p>Python-style pseudo-code:</p>

<pre><code>carry = entropy_1 &amp; 1
entropy_1 &gt;&gt;= 1
entropy_2 = (entropy_2 &gt;&gt; 1) | (carry &lt;&lt; 31)
carry = (entropy_1 &amp; 1) ^ (entropy_2 &amp; 1)
entropy_1 |= carry &lt;&lt; 31
</code></pre>
</div>
<div id="pu10" class="pu"><h2>Python, 46 / 15 = 3.0666</h2>

<pre><code>v=3
def R():global v;v=v**3%(2**32-5);return v
</code></pre>

<p>Uses modular exponentiation to generate randomness.  2**32-5 is the largest prime less than 2^32.
(Same deal with not being able to run test #2.)</p>
</div>
<div id="pu11" class="pu"><h2>Python, 41 / 15 = 2.73333</h2>

<pre><code>v=0
def R():global v;v=hash(`v`);return v
</code></pre>

<p>Kinda cheating using the built-in hash function, but it <em>is</em> built-in, so no more cheating than using other builtins, like <code>len</code>.  On the flip side, it pains me to have to pay for the <code>global v;</code> statement...</p>

<p>Passes all the Diehard tests (I had a problem with test #2, it SEGVs on my OSX machine.  For my score, I'm assuming it will pass).</p>

<p>Here's a driver to generate the 16MB file:</p>

<pre><code>import sys
for i in xrange(1&lt;&lt;22):
  r=R()
  sys.stdout.write('%c%c%c%c'%(r&amp;255, r&gt;&gt;8&amp;255, r&gt;&gt;16&amp;255, r&gt;&gt;24&amp;255))
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/10553/">10553</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




