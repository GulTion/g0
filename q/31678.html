<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::QNNN</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
  <!-- TXXX -->
<tr d-ix="0"><td>nan</td><td>Wolfram Mathematica 10↑↑3.1955 characters</td><td>230811T043653Z</td><td><a href="https://codegolf.stackexchange.com/questions/31678/negate-a-number/264006#264006">FarSeenN</a></td></tr>
<tr d-ix="1"><td>nan</td><td>Tcl</td><td>140619T201517Z</td><td><a href="https://codegolf.stackexchange.com/questions/31678/negate-a-number/32068#32068">jimmy230</a></td></tr>
<tr d-ix="2"><td>865</td><td>C#</td><td>140619T131441Z</td><td><a href="https://codegolf.stackexchange.com/questions/31678/negate-a-number/32033#32033">bacchusb</a></td></tr>
<tr d-ix="3"><td>548</td><td>CJam</td><td>140616T071756Z</td><td><a href="https://codegolf.stackexchange.com/questions/31678/negate-a-number/31827#31827">Dennis</a></td></tr>
</table>
<div id="pu0" class="pu"><h2>Wolfram Mathematica 10↑↑3.1955 characters</h2>
<p>Bowling-ed:</p>
<pre><code>ToExpression[FromCharacterCode[StringLength[&quot;¡¢£¤¥¦§...&quot;]~IntegerDigits~Nest[Hyperfactorial, 10, 2]]]
</code></pre>
<p>This is closely based on my answer to <a href="https://codegolf.stackexchange.com/a/243992/84870">Biggest Irreducible Hello World</a></p>
<p>Where the string is the length-6 DeBruijn Sequence of every unicode character over 128. This guarantees that it never repeats any set of 6 in itself, or outside the code since 6 never show up. Since there are only points over 128, even if there are valid symbols, none of them can read user input.</p>
<p>Golfed / decoded:</p>
<pre><code>Print[-Input[]]
</code></pre>
<p>Which is converted to it's character code (80, 114, 105...) and read back as a base-Nest[Hyperfactorial, 10, 2] number. This cannot be broken down to any number besides 109, which is not at least 117 for 'u'.</p>
<p>This means the string length is (k!)^k^(n-1)/k^n, where k is the number of unique characters, and n is the length of each non-repeating group (6).</p>
<p>Oddly enough, I think this is the hard limit to this question. If it wasn't for the 6-character restriction, or unicode only have 1 million characters, then the answer would have been a tad over</p>
<pre><code>80 * Nest[Hyperfactorial, 10, 9]]^15
</code></pre>
<p>or</p>
<pre><code>10↑↑11.289
</code></pre>
</div>
<div id="pu1" class="pu"><h1>Tcl, 1073741823 (1G-1 bytes, cheating)</h1>

<p>This is (obviously) cheating. It can be even larger in some languages like Bash, which doesn't load the whole program when it starts. Tcl runs very slow at starting, and finally refuses to run the program if the file size is about 2147483647 bytes or more.</p>

<pre><code>set b binary
$b scan [$b format i [expr {[gets stdin]-1^3+[file size $argv0]*4}]] i a
puts $a
exit
#!!!!!#"!!!!#%!!!!#&amp;!!!!#'!!!!#(!!!!#)!!!!#*!!!!#+!!!!#,!!!!#-!!!!#.!!!!#/!!!!#0!!!!#1!!!!#2!!!!#3!!!!#4!!!!#5!!!!#6!!!!#7!!!!#8!!!!#9!!!!#:!!!!#&lt;!!!!#=!!!!#&gt;!!!!#?!!!!#@!!!!#A!!!!#B!!!!#C!!!!#D!!!!#E!!!!#F!!!!#G!!!!#H!!!!#I!!!!#J!!!!#K!!!!#L!!!!#M!!!!#N!!!!#O!!!!#P!!!!#Q!!!!#R!!!!#S!!!!#T!!!!#U!!!!#V!!!!#W!!!!#X!!!!#Y!!!!#Z!!!!#[!!!!#^!!!!#_!!!!#`!!!!#a!!!!#b!!!!#c!!!!#d!!!!#e!!!!#f!!!!#g!!!!#h!!!!#i!!!!#j!!!!#k!!!!#l!!!!#m!!!!#n!!!!#o!!!!#p!!!!#q!!!!#r!!!!#s!!!!#t!!!!#u!!!!#v!!!!#w!!!!#x!!!!#y!!!!#z!!!!#{!!!!#|!!!!#~!!!!#!"!!!#""!!!#%"!!!#&amp;"!!!#'"!!!#("!!!#)"!!!#*"!!!#+"!!!#,"!!!#-"!!!#."!!!#/"!!!#0"!!!#1"!!!#2"!!!#3"!!!#4"!!!#5"!!!#6"!!!#7"!!!#8"!!!#9"!!!#:"!!!#&lt;"!!!#="!!!#&gt;"!!!#?"!!!#@"!!!#A"!!!#B"!!!#C"!!!#D"!!!#E"!!!#F"!!!#G"!!!#H"!!!#I"!!!#J"!!!#K"!!!#L"!!!#M"!!!#N"!!!#O"!!!#P"!!!#Q"!!!#R"!!!#S"!!!#T"!!!#U"!!!#V"!!!#W"!!!#X"!!!#Y"!!!#Z"!!!#["!!!#^"!!!#_"!!!#`"!!!#a"!!!#b"!!!#c"!!!#
(...1073740323 more bytes...)
|%#m+Y|%#n+Y|%#o+Y|%#p+Y|%#q+Y|%#r+Y|%#s+Y|%#t+Y|%#u+Y|%#v+Y|%#w+Y|%#x+Y|%#y+Y|%#z+Y|%#{+Y|%#|+Y|%#~+Y|%#!,Y|%#",Y|%#%,Y|%#&amp;,Y|%#',Y|%#(,Y|%#),Y|%#*,Y|%#+,Y|%#,,Y|%#-,Y|%#.,Y|%#/,Y|%#0,Y|%#1,Y|%#2,Y|%#3,Y|%#4,Y|%#5,Y|%#6,Y|%#7,Y|%#8,Y|%#9,Y|%#:,Y|%#&lt;,Y|%#=,Y|%#&gt;,Y|%#?,Y|%#@,Y|%#A,Y|%#B,Y|%#C,Y|%#D,Y|%#E,Y|%#F,Y|%#G,Y|%#H,Y|%#I,Y|%#J,Y|%#K,Y|%#L,Y|%#M,Y|%#N,Y|%#O,Y|%#P,Y|%#Q,Y|%#R,Y|%#S,Y|%#T,Y|%#U,Y|%#V,Y|%#W,Y|%#X,Y|%#Y,Y|%#Z,Y|%#[,Y|%#^,Y|%#_,Y|%#`,Y|%#a,Y|%#b,Y|%#c,Y|%#d,Y|%#e,Y|%#f,Y|%#g,Y|%
</code></pre>

<p>It computes the result with its own file size. So deleting anything will change the behavior.</p>

<p>The above program is generated by the C++ program below.</p>

<pre><code>#include&lt;fstream&gt;
#include&lt;string&gt;
#include&lt;cstring&gt;

std::ofstream f("a.tcl");
const long long size = 0x3fffffffLL;

const std::string init = "set b binary\n"
             "$b scan [$b format i [expr {[gets stdin]-1^3+[file size $argv0]*4}]] i a\n"
             "puts $a\n"
             "exit\n";
const std::string charset = "!\"%&amp;'()*+,-./0123456789:&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[^_`abcdefghijklmnopqrstuvwxyz{|~";
const int ncharset = 88;

int main() {
    f&lt;&lt;init;
    long long p = init.length();

    int b[5] = {};
    char ch[6] = "!!!!!";

    while(p &lt; size) {
        f&lt;&lt;"#";
        p++;
        if(size-p &gt; 5) {
            f.write(ch, 5);
            p += 5;
        }
        else {
            f.write(ch, size-p);
            break;
        }
        int i=0;
        while(b[i] == ncharset-1) {
            ch[i] = charset[b[i]=0];
            i++;
        }
        ch[i] = charset[++b[i]];
    }
    f&lt;&lt;std::flush;
    return 0;
}
</code></pre>

<p>The 7-zipped version of the complete program has only 18MB. Maybe I can upload it somewhere if someone request for it.</p>

<p>I chose Tcl because it has only a small number of special characters. So I could be sure one cannot implement the same functionality by selecting some characters not to delete. I guess Lisp is better on this.</p>
</div>
<div id="pu2" class="pu"><h2>C# 865</h2>
<p>Uses DateTime parsing since a negative will throw an exception. Since Console was already used the answer is output to a Form. Also C# has string and String object.</p>
<p>Edit: removed some duplicate char sequences.</p>
<pre><code>using System;
using System.ComponentModel;
using System.Windows.Forms;
using System.Diagnostics;
using System.Globalization;
namespace Golf
{ 
    class Code
    {
        String num;
        bool isPos;
        Code() { }
        void In()
        {
            num = Console.ReadLine();
        }

        void Out()
        {
            try
            {
                DateTime.Parse(this.num);
                isPos = true;
            }
            catch (Exception)//if negative throw exception
            {
                isPos = false;
            }
            int res;
            double pi = Math.PI;
            if(Int32.TryParse(num, out res))
            {
                res = (int)((isPos) ? Math.Cos(pi) * res : Math.Sin(3 * pi / 2) * res);
            }

            Form f = new Form();
            Label l = new Label();
            l.Text = res.ToString();
            f.Controls.Add(l);
            f.ShowDialog();
        }

        public static void Main(string[] args)
        {
            Code code = new Code();
            code.In();
            code.Out();          
        }

    }
}
</code></pre>
</div>
<div id="pu3" class="pu"><h1>CJam, 278,548 characters</h1>

<p>Stack Exchange has a 30,000 character limit, so I've uploaded my code to <a href="https://docs.google.com/file/d/0Byb-iITM2Kk2VHBfV0hFSTltM0U" rel="noreferrer" title="negate.cjam - Google Drive">Google Drive</a>.</p>

<p>The <a href="http://cjam.aditsu.net/" rel="noreferrer" title="CJam interpreter">online interpreter</a> chokes when decoding the lookup tables (<em>Maximum call stack size exceeded</em>), so I suggest using the <a href="http://sourceforge.net/projects/cjam/files/" rel="noreferrer" title="CJam - Browse Files at SourceForge.net">standard interpreter</a> (requires Java).</p>

<h3>I/O</h3>

<p>Input should be an integer (in whatever format CJam understands). Output is in British English.</p>

<pre><code>$ cjam negate.cjam &lt;&lt;&lt; 9990001
negative nine million nine hundred and ninety thousand and one
$ cjam negate.cjam &lt;&lt;&lt; -1001000000
one milliard and one million
$ cjam negate.cjam &lt;&lt;&lt; 0
zero
</code></pre>

<h3>Validity</h3>

<p>All code is functional, so removing parts should not be possible. Note that all linefeeds are part of strings and cannot be removed.</p>

<p>There are no repeated sequences of six characters:</p>

<pre><code>$ tr \\n \\t &lt;negate.cjam | grep -P '(.{6}).*\1' | wc -c
0
</code></pre>

<h3>How it works</h3>

<p>I've started with a <a href="https://docs.google.com/file/d/0Byb-iITM2Kk2Y0hxRE9FYVhkX2s" rel="noreferrer" title="hardcoded.txt - Google Drive">list of the first one thousand natural numbers</a> and a <a href="https://docs.google.com/file/d/0Byb-iITM2Kk2ZlIyeVpYWnl5OEU" rel="noreferrer" title="powers.txt - Google Drive">list of the first three thousand three hundred and thirty-four powers of one thousand</a>.</p>

<p>Sadly, both lists repeat the same 6 character sequences over and over again, so I had to encode them in a way that would avoid those repeated sequences. The following CJam code accomplishes that task:</p>

<pre><code>q
2G#b
94b
{32+}%
{c}%
" !\"#$%&amp;'()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}"
"}|{zyxwvutsrqponmlkjihgfedcba`_^]~[ZYXWVUTSRQPONMLKJIHGFEDCBA@?&gt;=&lt;;:9876543210/.-,+*)('&amp;%$#
! "
er
</code></pre>

<p>It reads the list from STDIN (<code>q</code>), converts the resulting string into a base 65536 number (<code>2G#b</code>), converts the resulting integer into an array by considering it a base 94 number (<code>94b</code>), adds 32 to each integer in the array (<code>{32+}%</code>) to avoid unprintable characters, converts the array into a string (<code>{c}%</code>) and performs a character transliteration (<code>"…""…"er</code>) to get rid of characters that require escaping. This required a little trial-and-error; the natural choice (<code>95b</code>) resulted in repeated sequences.</p>

<p>The final code does the following:</p>

<pre><code>{                             " Define a decoding function for the lists.               ";
  "…""…"er{32-}%94b2G#b{c}%   " Perform the steps from above in reverse order.          ";
  "
  "/                          " Split the result by linefeeds.                          ";
}:D;

"…":H;"…":P;                  " Store the encoded lists in variables.                   ";

q~                            " Interpret the input from STDIN.                         ";
__                            " Duplicate twice.                                        ";
0&lt;!{}{-1*}?                   " If the input is negative, multiply the last copy by -1. ";
`_                            " Stringify and duplicate the last copy.                  ";
,3%3\-"0"*\+                  " Prepend 0's to make the string length a multiple of 3.  ";
3/-1%                         " Split into string of three characters and reverse.      ";
-1:C;                         " Initialize variable C to -1. ";
{                             " For each substring:                                     ";
  ~                           " Interpret it (i.e., cast to integer).                   ";
  H=_                         " Retrieve the correspond English number from H.          ";
  'z'e'r"o"+++=               " Push 1 if the number is zero.                           ";
  C):C;                       " Increment C.                                            ";
  {;}{" "+CP=+}?              " Remove 0 or append the corresponding modifier from P.   ";
 }%
-1%_                          " Reverse the array and duplicate it.                     ";
,1&gt;                           " If the array has more than one element…                 ";
{
  )_"and"/,1=                 " …and the last element doesn't contain the string 'and'… ";
  'a'n'd" "+++*\+a+           " …prepend the  string 'and ' to it.                      ";
}{_,0={H0=a+}*}?              " If the array is empty, replace it with [ 'zero' ].      ";
\0&gt;                           " If the input was positive,                              ";
{
  'n'e'g'a't'i'v"e"+++++++a\+ " prepend the string 'negative'.                          ";
}{}?
" "*                          " Join the array of strings with spaces.                  ";
"
"                             " Append a linefeed.                                      ";
</code></pre>
</div>
<!-- TYYY -->

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/QNNN/">QNNN</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




