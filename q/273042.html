<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::273042</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>106</td><td>JavaScript ES6</td><td>240513T113604Z</td><td><a href="https://codegolf.stackexchange.com/questions/273042/how-far-are-you/273077#273077">Arnauld</a></td></tr>
<tr d-ix="1"><td>066</td><td>Charcoal</td><td>240512T135732Z</td><td><a href="https://codegolf.stackexchange.com/questions/273042/how-far-are-you/273068#273068">Neil</a></td></tr>
<tr d-ix="2"><td>105</td><td>Ruby</td><td>240510T224217Z</td><td><a href="https://codegolf.stackexchange.com/questions/273042/how-far-are-you/273056#273056">Level Ri</a></td></tr>
<tr d-ix="3"><td>025</td><td>Jelly</td><td>240510T183545Z</td><td><a href="https://codegolf.stackexchange.com/questions/273042/how-far-are-you/273054#273054">Jonathan</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>JavaScript (ES6), 106 bytes</h1>
<p>Same formulas (and same test case) as all other answers so far.</p>
<p>Expects <code>(longitude1, longitude2, latitude1, latitude2)</code>.</p>

<pre class="lang-javascript prettyprint-override"><code>with(Math)f=(p,q,r,s,R=12742)=&gt;[R*sin(t=acos(cos(r*=x=PI/180)*cos(s*=x)*cos(x*=q-p)+sin(r)*sin(s))/2),R*t]
</code></pre>
<p><a href="https://tio.run/##JYuxDoIwFAB/hbGvvpa2oMBQdwcTw2ocGgTBEApto/x9FR0uuVxyT/MyvnHDHNhk722M7yH05GxCD50mMy7o0GOtpSpyBfp4rakfJhK0aawnG47qVV9OqSwF0C34b/jbSvXCZthth4Pf6AFSBVjTcIuNnbwdWz7aB@kIk0XJ9xkmUlRcVJjkGZcSE3ZQXOQA8QM" rel="nofollow noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a></p>
<h3>Formulas</h3>
<p>Given the longitudes <span class="math-container">\$\lambda_1\$</span>, <span class="math-container">\$\lambda_2\$</span> and the latitudes <span class="math-container">\$\phi_1\$</span>, <span class="math-container">\$\phi_2\$</span>:</p>
<p><span class="math-container">$$t = \frac{1}{2}\arccos{(\cos{\phi_1}\cos{\phi_2}\cos{(\lambda_2-\lambda_1)}+\sin{\phi_1}\sin{\phi_2})}\\
d = R\sin t\\
s = Rt$$</span></p>
<p>where <span class="math-container">\$R=2\times 6371=12742\$</span></p>
<h3>Degrees to radians conversions</h3>
<p>In order to avoid extra parentheses, we use the <code>*=</code> operator for all conversions with carefully ordered operations:</p>
<pre class="lang-javascript prettyprint-override"><code>cos(r *= x = PI / 180) * // define the conversion ratio x
                         // and apply the conversion to r
cos(s *= x) *            // apply the conversion to s
cos(x *= q - p) +        // x can now be trashed:
                         // this time we multiply x by q - p
sin(r) *                 // r has already been converted
sin(s)                   // s has already been converted
</code></pre>
</div>
<div id="pu1" class="pu"><h1><a href="https://github.com/somebody1234/Charcoal" rel="nofollow noreferrer">Charcoal</a>, 66 bytes</h1>
<pre><code>⊞θ⁻⊟θ⊟θ≔ΣＥ⪪.imag.real⁵ΠＥ…θ⁺²κＵＶ⁺ＩＸＩ1j∕λ⁹⁰ιθＩ×⁶³⁷¹⟦▷math.acosθ₂⁻²⊗θ
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=LVC7TsQwEBQt4iMsV47kWMnlXhEVylGeFHGIJkrhS8zF4MSJH0H3LTRXgOCX4GuwE7bZlXZmdmbfv6uGqkpScbl8WvMcbn-vbnKrGzRgsOed1SiXPRoCDOYeBLfXd1rzU4cOtkV72qNDL7hBkPCWnohiVEAMVp6gZG0rM2GycyVY1ngJtxBOdoHBa-BRZ9PI7n6kwlLD0LTLqDbu7htT8wjjF-igOz7ymiGBQRoFnsuDqTAYnKtc8c7M-EfeMo3WySbGoPDST1Qh2FLTEFpJDT0Bg8NgqWIPUjqLU1JnaSftUbB6Clr6sB_6WOn_13wVMBwFLH9gUSwTEjv1cL0g0dL1eLMlqwSDOEpJlJblzPgD" rel="nofollow noreferrer">Attempt This Online!</a> Link is to verbose version of code. Takes input as an array of two latitudes and two longitudes. Explanation: Port of @LevelRiverSt's Ruby answer.</p>
<pre><code>⊞θ⁻⊟θ⊟θ
</code></pre>
<p>Subtract one longitude from the other.</p>
<pre><code>≔ΣＥ⪪.imag.real⁵ΠＥ…θ⁺²κＵＶ⁺ＩＸＩ1j∕λ⁹⁰ιθ
</code></pre>
<p>Obtain the sine and cosine of each angle by dividing by 90, raising <code>i</code> to the resulting power, and extracting the real or imaginary part as appropriate. Multiply all three cosines and the sines of the latitudes together, then take the sum. This results in the cosine of the angle between the two points.</p>
<pre><code>Ｉ×⁶³⁷¹⟦▷math.acosθ₂⁻²⊗θ
</code></pre>
<p>Take the arccosine to obtain the angle and also subtract the the doubled cosine from <code>2</code> and take the square root of the result. Multiply both values by the Earth's radius to obtain the desired output.</p>
<p>Would be 56 bytes in a future version of Charcoal with a function that obtains the real and/or imaginary part of a complex number:</p>
<pre><code>⊞θ⁻⊟θ⊟θ≔ΣＥ²ΠＥ…θ⁺²ι§⪪ＸＩ1j∕λ⁹⁰Ｉ1jιθＩ×⁶³⁷¹⟦▷math.acosθ₂⁻²⊗θ
</code></pre>
<p>Don't <a href="https://ato.pxeger.com/run?1=RVC7TsMwFN35CsuTLblR0pS2EVOVMjBUighiiTK4jiFGTpz4EeBbWDqA4Jf6JV1xEiSmo6vz0Dn344fVVDNF5en05ezTYnu-ZM7UqCfgIFpnUKY61GMCZsT45mpnjHhuUe4adKAdWnpOq8oxO53pO5M8rUe1J6RP8AKBfcLO3rUVf0N5J4X1ua9co5Qai2D0Aj2_F4OoOJIEJOGo_-fwlIBH7H2BTIvWztYH0XCD1vEmIqC4Hah8pBrBhto6oEwZOBoIyHtHNb9XylecRvlKe-WOklfTpnLc9WmOzPw94buAi0HC8gyLYhUHkU9frJdBuPIYbbbBdUxAFCZBmJTl7PgF" rel="nofollow noreferrer">Attempt This Online!</a> because ATO doesn't have a new enough version of Charcoal yet. Link is to verbose version of code.</p>
<p>Would be only 52 bytes if <code>AtIndex</code> could split a complex number into real and imaginary parts:</p>
<pre><code>⊞θ⁻⊟θ⊟θ≔ΣＥ²ΠＥ…θ⁻³ι§ＸＩ1j∕λ⁹⁰ιθＩ×⁶³⁷¹⟦▷math.acosθ₂⁻²⊗θ
</code></pre>
</div>
<div id="pu2" class="pu"><h1><a href="https://www.ruby-lang.org/" rel="nofollow noreferrer">Ruby</a>, 105 bytes</h1>

<pre class="lang-ruby prettyprint-override"><code>-&gt;z,p,q{a,b,c,d,e=(z&lt;&lt;p-q).flat_map{|j|(1i**j/=90r).rect}
p Math.acos(m=a*c*e+b*d)*r=6371,(2-m*2)**0.5*r}
</code></pre>
<p>4 bytes saved thanks to Dingus.</p>
<p><a href="https://tio.run/##DcdJDoIwFADQPadgCd/f@stoE@oNPAEhpgyiRGKpuJDh7NW3e/ZTf12vHDsvaHBaNdbYYIudCpaiMGwK@e2p5@uozboNWyAeAMNRSbIht10z757xL3q@c9283sGoNDTQHWpoQ7Aqi3OBQcRGiEIA4inY3fVlSUgVEkqqvP@SmAuBPssiTkmFTOQnnsboC5KcZOV@" rel="nofollow noreferrer" title="Ruby – Try It Online">Try it online!</a></p>
<h1><a href="https://www.ruby-lang.org/" rel="nofollow noreferrer">Ruby</a>, 109 bytes</h1>
<p>A function taking 3 arguments: an array of latitudes, followed by the longitudes as separate arguments.</p>

<pre class="lang-ruby prettyprint-override"><code>-&gt;z,p,q{a,b,c,d,e=(z&lt;&lt;p-q).map{|j|(1i**j/=90.0).rect}.flatten
p Math.acos(m=a*c*e+b*d)*r=6371,(2-m*2)**0.5*r}
</code></pre>
<p><a href="https://tio.run/##DcdJEoIwEADAO6/gSMbJOGGVKuIPfAHFISyilChEPMjydrRvbT/ld2/1Ls8zDjguBkussMZGe3OWDXIU1JthWbvVU3eA7qhTJhZkm2ra6Pow09Q8ncG9mOlGpnq9vV4bqKA5lFALsDoOEoWeL3vwBQBTBHbb2zxn5AIZUy6c/8KAlEJXxj5xWKBUyYmiAF3FKXFa7D8" rel="nofollow noreferrer" title="Ruby – Try It Online">Try it online!</a></p>
<p>It uses essentially the same formula as Jonathan Allen's answer, which can be found at <a href="https://en.wikipedia.org/wiki/Haversine_formula" rel="nofollow noreferrer">Haversine formula</a> . Ruby syntax for trig functions requires either <code>include Math</code> at the beginning of the program or <code>Math.</code> before every instance of a trig function. Therefore extensive use is made of complex numbers, which are available by default. The formula works as follows.</p>
<p>The cosine of the angle between the two points is calculated as a dot product (for a pair of vectors of magnitude 1, the dot product is equal to cosine of the angle between them):</p>
<p><code>u1*u2 + v1*v2 + z1*z2</code></p>
<p>In order to do this the latitude information for each point must first be converted from an angle into vectors <code>r1+z1i</code> and <code>r2+z2i</code>.</p>
<p>The longitudes may be converted to <code>u+vi</code> coordinates <code>r1*(x1+y1i)</code> and <code>r2*(x2+y2i)</code> but by rotating the coordinate system (subtracting longitude 1 from both longitudes 1 and 2) longitude 1 becomes effectively zero, hence there is no <code>y</code> contribution and the x contribution becomes 1. The dot product is therefore</p>
<p><code>cos theta = (r1*1)*(r2*x2) + 0 + z1*z2</code> or equivalently
<code>a*1*c*e + b*d</code></p>
<p>To avoid using the longwinded <code>Math.sin</code> function, the sine of half the angle can be found using the identity <code>sin(theta/2) = (1/2-(cos theta)/2)**0.5</code>. Because we want to know double this value, the code considers coefficients 4 times larger <code>(2-m*2)</code> to give the required value directly.</p>
<p><strong>Commented code</strong></p>
<pre class="lang-ruby prettyprint-override"><code>-&gt;z,p,q{                        #Take input as an array of latitudes, plus longitudes as separate arguments
a,b,c,d,e=                      #Set up 5 variables for the complex numbers (the 6th will be discarded)
(z&lt;&lt;p-q).map{|j|                #Calculate the difference between longitudes and append to array. Iterate through 3 elements
(1i**j/=90.0).rect              #For each element convert angle into rectangular coordinates by raising i to a power
}.flatten                       #Flatten the array of 3 pairs and assign to a,b,c,d,e
p Math.acos(m=a*c*e+b*d)*r=6371,#Calculate the cosine of the angle and the surface distance
(2-m*2)**0.5*r}                 #Convert the cosine into the straight line distance.
</code></pre>
</div>
<div id="pu3" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="nofollow noreferrer">Jelly</a>, 25 <a href="https://github.com/DennisMitchell/jelly/wiki/Code-page" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>I;°ḊÆS,ÆẠƲP€SÆAHÆSḤ,Ʋ×⁽ßx
</code></pre>
<p>A dyadic Link that accepts the longitudes on the left and the latitudes, in the same order, on the right and yields the two distances, <code>[direct, surface]</code> in kilometres.</p>
<p><strong><a href="https://tio.run/##AVcAqP9qZWxsef//STvCsOG4isOGUyzDhuG6oMayUOKCrFPDhkFIw4ZT4bikLMayw5figb3Dn3j///9bLTE3OC41MywgMTA5LjA5Xf9bNDMuMTEsIC02Mi4wNF0" rel="nofollow noreferrer" title="Jelly – Try It Online">Try it online!</a></strong></p>
<h3>How?</h3>
<p>Labelling the two longitudes as <span class="math-container">\$\lambda_i\$</span> and the two latitudes as <span class="math-container">\$\phi_i\$</span>, the angle between the lines from each of the two points and the centre of the sphere, the <em><strong>central angle</strong></em>, is<sup>[<a href="https://en.wikipedia.org/wiki/Great-circle_distance" rel="nofollow noreferrer" title="Wikipedia">1</a>]</sup>:</p>
<p><span class="math-container">$$\Delta\sigma = \arccos{(\cos{|\lambda_1-\lambda_2|}\cos{\phi_1}\cos{\phi_2}+\sin{\phi_1}\sin{\phi_2})}$$</span></p>
<p>Note: Since <span class="math-container">\$\cos\$</span> is symmetric around the y-axis, we can use <span class="math-container">\$\lambda_2-\lambda_1\$</span> in place of <span class="math-container">\$|\lambda_1-\lambda_2|\$</span>.</p>
<p>The shortest distance between two points in Euclidean space is a straight line, so we have an isosceles triangle with the equal side lengths being the sphere's radius, <span class="math-container">\$r=6371\$</span> kilometres, so the direct path in space is (using <span class="math-container">\$\text{opposite}=\text{hypotenuse}\sin\alpha\$</span>):</p>
<p><span class="math-container">$$d = 2r \sin \frac{\Delta\sigma}{2}$$</span></p>
<p>The shortest distance between two points on a sphere is the minor arc of the great circle on which they lie. This is the arc projected by the angle <span class="math-container">\$\Delta\sigma\$</span> and thus has length:</p>
<p><span class="math-container">$$s = r \Delta\sigma$$</span></p>
<p>The code takes <span class="math-container">\$(\lambda_1, \lambda_2)\$</span> on the left and <span class="math-container">\$(\phi_1, \phi_2)\$</span> on the right and produces <span class="math-container">\$(d, s)\$</span>:</p>
<pre><code>I;°ḊÆS,ÆẠƲP€SÆAHÆSḤ,Ʋ×⁽ßx - Link: Longitudes; Latitudes
I                         - forward difference {Longitudes} -&gt; [l2 - l1]
 ;                        - concatenate {Latitudes} -&gt; [l2 - l1, p1, p2]
  °                       - convert from degrees to radians
         Ʋ                - last four links as a monad f(X=that):
   Ḋ                      -   dequeue {X} -&gt; [p1, p2]
    ÆS                    -   sine -&gt; [sin(p1), sin(p2)]
       ÆẠ                 -   cosine {X} -&gt; [cos(l2 - l1), cos(p1), cos(p2)]
      ,                   -   pair -&gt; [[sin(p1), sin(p2)],
                                       [cos(l2 - l1), cos(p1), cos(p2)]]
          P€              - product of each
            S             - sum
             ÆA           - arccosine -&gt; CentralAngle
                    Ʋ     - last four links as a monad - f(CentralAngle):
               H          -   halve
                ÆS        -   sine
                  Ḥ       -   double
                   ,      -   pair -&gt; [2 × sin(CentralAngle / 2),
                                       CentralAngle]
                      ⁽ßx - 6371
                     ×    - multiply -&gt; [6371 × 2 × sin(CentralAngle / 2),
                                         6371 × CentralAngle]
                                      = [direct, surface]
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/273042/">273042</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




