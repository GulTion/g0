<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::64076</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>108</td><td>Ruby</td><td>240514T090243Z</td><td><a href="https://codegolf.stackexchange.com/questions/64076/integer-complexity/273087#273087">G B</a></td></tr>
<tr d-ix="1"><td>208</td><td>Haskell</td><td>211217T223553Z</td><td><a href="https://codegolf.stackexchange.com/questions/64076/integer-complexity/239714#239714">Benji</a></td></tr>
<tr d-ix="2"><td>229</td><td>Julia</td><td>151117T163352Z</td><td><a href="https://codegolf.stackexchange.com/questions/64076/integer-complexity/64123#64123">Glen O</a></td></tr>
<tr d-ix="3"><td>096</td><td>CJam</td><td>151117T034216Z</td><td><a href="https://codegolf.stackexchange.com/questions/64076/integer-complexity/64086#64086">Dennis</a></td></tr>
<tr d-ix="4"><td>060</td><td>Pyth</td><td>151117T052259Z</td><td><a href="https://codegolf.stackexchange.com/questions/64076/integer-complexity/64090#64090">isaacg</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://www.ruby-lang.org/" rel="nofollow noreferrer">Ruby</a>, 108 bytes</h1>

<pre class="lang-ruby prettyprint-override"><code>g=-&gt;n{n&lt;6?[?1]*n*?+:(2..n**0.5).map{|c|&quot;(#{g[c]})*(#{g[n/c]})&quot;+(n%c&lt;1?'':&quot;+#{g[n%c]}&quot;)}.min{|c|c.count(?1)}}
</code></pre>
<p><a href="https://tio.run/##HYxBDoIwEAC/YmqQbRvX1kQOBN2HEA7aQ@OBhSg9kNK3V@ltMsnMJ7zWnP39/ODIXUM92UGxIt3CFZGVMniTOD7nuLlNwDH63g1JqkJ82Vlo4Mp1luq6Fbr46u@FTDi@ee8cuinwAmRlSnkOy/cABtEaU9Zw8jL/AA" rel="nofollow noreferrer" title="Ruby – Try It Online">Try it online!</a></p>
</div>
<div id="pu1" class="pu"><h1><a href="https://www.haskell.org/" rel="nofollow noreferrer">Haskell</a>, 208 bytes</h1>

<pre class="lang-hs prettyprint-override"><code>import Data.List;f n=mapM putStrLn[show x++&quot;=&quot;++m x|x&lt;-[1..n]];m 1=&quot;1&quot;;m n=head$sortOn(filter(&gt;'0'))[let b=m$div n x;q=last b&gt;'0'in concat[&quot;(&quot;,m x,&quot;)&quot;,['('|q],b,[')'|q]]|x&lt;-[2..n-1],mod n x&lt;1]++[m(n-1)++&quot;+1&quot;]
</code></pre>
<p><a href="https://tio.run/##HY4xb8MgFIT3/oqnp0gGQayQ1aFTx1QZMiIGEtsyKmDH0MZD/rvz3OlOd9J3N7j804Wwrj5O41zgyxVXn30uTQ9JRzd9w/RbrmU@J5OH8QmLEKhRiAjLazntjarrZG0TQWlUSJr00Ll2l4l2Saz3oXQz@6wOFecmdAVuOu5a/wcJluahg8sUbbVPcB/T3RWDDCXhJXKUpmLV62HljRzfnP1fPdLqXlkZx3YDnZQVwkRGGad/QqFdoyOihh6Oh4/1DQ" rel="nofollow noreferrer" title="Haskell – Try It Online">Try it online!</a></p>
</div>
<div id="pu2" class="pu"><h1>Julia, 229 bytes</h1>

<pre><code>n-&gt;(F=i-&gt;K[i]&gt;0?E[i]:"("E[i]")";C=[1;3:n+1];K=0C;E=fill("1",n);for s=1:n for i=1:s÷2 (D=C[i]+C[s-i])&lt;C[s]?(C[s]=D;E[s]=E[i]"+"E[s-i];K[s]=0):s%i&gt;0||(D=C[i]+C[j=s÷i])&lt;C[s]&amp;&amp;(C[s]=D;E[s]=F(i)F(j);K[s]=1)end;println("$s="E[s])end)
</code></pre>

<p>This is actually pretty fast. Assigning the function to <code>f</code> and running <code>@time f(15535)</code> gives the output (last two lines only)</p>

<pre><code>15535=1+(1+1+1)(1+1+1)(1+(1+1+1)(1+(1+(1+1)(1+1+1))(1+(1+1+1)(1+1+1)(1+1+1)(1+1+1))))
32.211583 seconds (263.30 M allocations: 4.839 GB, 4.81% gc time)
</code></pre>

<p>and for <code>@time f(45197)</code>, it gives</p>

<pre><code>45197=1+1+(1+1+1)(1+1+1+1+1)(1+(1+1)(1+1)(1+1+1)(1+(1+1)(1+1+1+1+1)(1+(1+1)(1+1)(1+1)(1+1+1))))
289.749564 seconds (2.42 G allocations: 43.660 GB, 4.91% gc time)
</code></pre>

<p>So, what's the code doing? Simple - <code>C</code> holds the current one-<code>C</code>ount for the number, <code>K</code> is an indicator array keeping track of whether the expression is, fundamentally, a sum or a product, for the purposes of dealing with bracketing, and <code>E</code> holds the <code>E</code>xpression itself. Working its way up from <code>s=1</code> through to <code>n</code>, the code searches for the minimal representation of number <code>s</code> in terms of lower values, by looking for either a sum or a product. If it's a product, then it checks the two components and puts brackets around them if they're sums. That check is done in function <code>F</code>, to save bytes (because it has to be done twice, for the two factors).</p>
</div>
<div id="pu3" class="pu"><h1>CJam, <s>105</s> <s>102</s> <s>98</s> 96 bytes</h1>

<pre><code>q~{)'=1$2,{:I{I1$-'+}%3/1&gt;Imf'*+aImp!*+{)\{j}%\+}:F%{e_"+*"-:+}$0=}j2,{F)_'*={;{'(\')}%1}&amp;*}jN}/
</code></pre>

<p>Try it online in the <a href="http://cjam.aditsu.net/#code=q~%7B)&#39;%3D1%242%2C%7B%3AI%7BI1%24-&#39;%2B%7D%253%2F1%3EImf&#39;*%2BaImp!*%2B%7B)%5C%7Bj%7D%25%5C%2B%7D%3AF%25%7Be_%22%2B*%22-%3A%2B%7D%240%3D%7Dj2%2C%7BF)_&#39;*%3D%7B%3B%7B&#39;(%5C&#39;)%7D%251%7D%26*%7DjN%7D%2F&amp;input=20" rel="nofollow">CJam interpreter</a>.</p>

<h3>Test run</h3>

<p>The online interpreter is too slow for the larger test cases. Even with the Java interpreter, the larger test cases will take a <em>long</em> time and require a significant amount of memory.</p>

<pre><code>$ time cjam integer-complexity.cjam &lt;&lt;&lt; 157
1=1
2=1+1
3=1+1+1
4=1+1+1+1
5=1+1+1+1+1
6=(1+1)(1+1+1)
7=1+(1+1)(1+1+1)
8=(1+1)(1+1)(1+1)
9=(1+1+1)(1+1+1)
10=1+(1+1+1)(1+1+1)
11=1+1+(1+1+1)(1+1+1)
12=(1+1)(1+1)(1+1+1)
13=1+(1+1)(1+1)(1+1+1)
14=(1+1)(1+(1+1)(1+1+1))
15=(1+1+1)(1+1+1+1+1)
16=(1+1)(1+1)(1+1)(1+1)
17=1+(1+1)(1+1)(1+1)(1+1)
18=(1+1)(1+1+1)(1+1+1)
19=1+(1+1)(1+1+1)(1+1+1)
20=(1+1)(1+1)(1+1+1+1+1)
21=(1+1+1)(1+(1+1)(1+1+1))
22=1+(1+1+1)(1+(1+1)(1+1+1))
23=1+1+(1+1+1)(1+(1+1)(1+1+1))
24=(1+1)(1+1)(1+1)(1+1+1)
25=1+(1+1)(1+1)(1+1)(1+1+1)
26=(1+1)(1+(1+1)(1+1)(1+1+1))
27=(1+1+1)(1+1+1)(1+1+1)
28=1+(1+1+1)(1+1+1)(1+1+1)
29=1+1+(1+1+1)(1+1+1)(1+1+1)
30=(1+1)(1+1+1)(1+1+1+1+1)
31=1+(1+1)(1+1+1)(1+1+1+1+1)
32=(1+1)(1+1)(1+1)(1+1)(1+1)
33=1+(1+1)(1+1)(1+1)(1+1)(1+1)
34=(1+1)(1+(1+1)(1+1)(1+1)(1+1))
35=(1+1+1+1+1)(1+(1+1)(1+1+1))
36=(1+1)(1+1)(1+1+1)(1+1+1)
37=1+(1+1)(1+1)(1+1+1)(1+1+1)
38=(1+1)(1+(1+1)(1+1+1)(1+1+1))
39=(1+1+1)(1+(1+1)(1+1)(1+1+1))
40=(1+1)(1+1)(1+1)(1+1+1+1+1)
41=1+(1+1)(1+1)(1+1)(1+1+1+1+1)
42=(1+1)(1+1+1)(1+(1+1)(1+1+1))
43=1+(1+1)(1+1+1)(1+(1+1)(1+1+1))
44=(1+1)(1+1)(1+1+(1+1+1)(1+1+1))
45=(1+1+1)(1+1+1)(1+1+1+1+1)
46=1+(1+1+1)(1+1+1)(1+1+1+1+1)
47=1+1+(1+1+1)(1+1+1)(1+1+1+1+1)
48=(1+1)(1+1)(1+1)(1+1)(1+1+1)
49=1+(1+1)(1+1)(1+1)(1+1)(1+1+1)
50=(1+1)(1+1+1+1+1)(1+1+1+1+1)
51=(1+1+1)(1+(1+1)(1+1)(1+1)(1+1))
52=(1+1)(1+1)(1+(1+1)(1+1)(1+1+1))
53=1+(1+1)(1+1)(1+(1+1)(1+1)(1+1+1))
54=(1+1)(1+1+1)(1+1+1)(1+1+1)
55=1+(1+1)(1+1+1)(1+1+1)(1+1+1)
56=(1+1)(1+1)(1+1)(1+(1+1)(1+1+1))
57=(1+1+1)(1+(1+1)(1+1+1)(1+1+1))
58=1+(1+1+1)(1+(1+1)(1+1+1)(1+1+1))
59=1+1+(1+1+1)(1+(1+1)(1+1+1)(1+1+1))
60=(1+1)(1+1)(1+1+1)(1+1+1+1+1)
61=1+(1+1)(1+1)(1+1+1)(1+1+1+1+1)
62=(1+1)(1+(1+1)(1+1+1)(1+1+1+1+1))
63=(1+1+1)(1+1+1)(1+(1+1)(1+1+1))
64=(1+1)(1+1)(1+1)(1+1)(1+1)(1+1)
65=1+(1+1)(1+1)(1+1)(1+1)(1+1)(1+1)
66=(1+1)(1+1+1)(1+1+(1+1+1)(1+1+1))
67=1+(1+1)(1+1+1)(1+1+(1+1+1)(1+1+1))
68=(1+1)(1+1)(1+(1+1)(1+1)(1+1)(1+1))
69=1+(1+1)(1+1)(1+(1+1)(1+1)(1+1)(1+1))
70=(1+1)(1+1+1+1+1)(1+(1+1)(1+1+1))
71=1+(1+1)(1+1+1+1+1)(1+(1+1)(1+1+1))
72=(1+1)(1+1)(1+1)(1+1+1)(1+1+1)
73=1+(1+1)(1+1)(1+1)(1+1+1)(1+1+1)
74=(1+1)(1+(1+1)(1+1)(1+1+1)(1+1+1))
75=(1+1+1)(1+1+1+1+1)(1+1+1+1+1)
76=(1+1)(1+1)(1+(1+1)(1+1+1)(1+1+1))
77=1+(1+1)(1+1)(1+(1+1)(1+1+1)(1+1+1))
78=(1+1)(1+1+1)(1+(1+1)(1+1)(1+1+1))
79=1+(1+1)(1+1+1)(1+(1+1)(1+1)(1+1+1))
80=(1+1)(1+1)(1+1)(1+1)(1+1+1+1+1)
81=(1+1+1)(1+1+1)(1+1+1)(1+1+1)
82=1+(1+1+1)(1+1+1)(1+1+1)(1+1+1)
83=1+1+(1+1+1)(1+1+1)(1+1+1)(1+1+1)
84=(1+1)(1+1)(1+1+1)(1+(1+1)(1+1+1))
85=1+(1+1)(1+1)(1+1+1)(1+(1+1)(1+1+1))
86=(1+1)(1+(1+1)(1+1+1)(1+(1+1)(1+1+1)))
87=(1+1+1)(1+1+(1+1+1)(1+1+1)(1+1+1))
88=(1+1)(1+1)(1+1)(1+1+(1+1+1)(1+1+1))
89=1+(1+1)(1+1)(1+1)(1+1+(1+1+1)(1+1+1))
90=(1+1)(1+1+1)(1+1+1)(1+1+1+1+1)
91=1+(1+1)(1+1+1)(1+1+1)(1+1+1+1+1)
92=1+1+(1+1)(1+1+1)(1+1+1)(1+1+1+1+1)
93=(1+1+1)(1+(1+1)(1+1+1)(1+1+1+1+1))
94=1+(1+1+1)(1+(1+1)(1+1+1)(1+1+1+1+1))
95=(1+1+1+1+1)(1+(1+1)(1+1+1)(1+1+1))
96=(1+1)(1+1)(1+1)(1+1)(1+1)(1+1+1)
97=1+(1+1)(1+1)(1+1)(1+1)(1+1)(1+1+1)
98=(1+1)(1+(1+1)(1+1+1))(1+(1+1)(1+1+1))
99=(1+1+1)(1+1+1)(1+1+(1+1+1)(1+1+1))
100=(1+1)(1+1)(1+1+1+1+1)(1+1+1+1+1)
101=1+(1+1)(1+1)(1+1+1+1+1)(1+1+1+1+1)
102=(1+1)(1+1+1)(1+(1+1)(1+1)(1+1)(1+1))
103=1+(1+1)(1+1+1)(1+(1+1)(1+1)(1+1)(1+1))
104=(1+1)(1+1)(1+1)(1+(1+1)(1+1)(1+1+1))
105=(1+1+1)(1+1+1+1+1)(1+(1+1)(1+1+1))
106=1+(1+1+1)(1+1+1+1+1)(1+(1+1)(1+1+1))
107=1+1+(1+1+1)(1+1+1+1+1)(1+(1+1)(1+1+1))
108=(1+1)(1+1)(1+1+1)(1+1+1)(1+1+1)
109=1+(1+1)(1+1)(1+1+1)(1+1+1)(1+1+1)
110=1+1+(1+1)(1+1)(1+1+1)(1+1+1)(1+1+1)
111=(1+1+1)(1+(1+1)(1+1)(1+1+1)(1+1+1))
112=(1+1)(1+1)(1+1)(1+1)(1+(1+1)(1+1+1))
113=1+(1+1)(1+1)(1+1)(1+1)(1+(1+1)(1+1+1))
114=(1+1)(1+1+1)(1+(1+1)(1+1+1)(1+1+1))
115=1+(1+1)(1+1+1)(1+(1+1)(1+1+1)(1+1+1))
116=(1+1)(1+1)(1+1+(1+1+1)(1+1+1)(1+1+1))
117=(1+1+1)(1+1+1)(1+(1+1)(1+1)(1+1+1))
118=1+(1+1+1)(1+1+1)(1+(1+1)(1+1)(1+1+1))
119=(1+(1+1)(1+1+1))(1+(1+1)(1+1)(1+1)(1+1))
120=(1+1)(1+1)(1+1)(1+1+1)(1+1+1+1+1)
121=1+(1+1)(1+1)(1+1)(1+1+1)(1+1+1+1+1)
122=(1+1)(1+(1+1)(1+1)(1+1+1)(1+1+1+1+1))
123=(1+1+1)(1+(1+1)(1+1)(1+1)(1+1+1+1+1))
124=(1+1)(1+1)(1+(1+1)(1+1+1)(1+1+1+1+1))
125=(1+1+1+1+1)(1+1+1+1+1)(1+1+1+1+1)
126=(1+1)(1+1+1)(1+1+1)(1+(1+1)(1+1+1))
127=1+(1+1)(1+1+1)(1+1+1)(1+(1+1)(1+1+1))
128=(1+1)(1+1)(1+1)(1+1)(1+1)(1+1)(1+1)
129=1+(1+1)(1+1)(1+1)(1+1)(1+1)(1+1)(1+1)
130=(1+1)(1+1+1+1+1)(1+(1+1)(1+1)(1+1+1))
131=1+(1+1)(1+1+1+1+1)(1+(1+1)(1+1)(1+1+1))
132=(1+1)(1+1)(1+1+1)(1+1+(1+1+1)(1+1+1))
133=(1+(1+1)(1+1+1))(1+(1+1)(1+1+1)(1+1+1))
134=1+(1+(1+1)(1+1+1))(1+(1+1)(1+1+1)(1+1+1))
135=(1+1+1)(1+1+1)(1+1+1)(1+1+1+1+1)
136=1+(1+1+1)(1+1+1)(1+1+1)(1+1+1+1+1)
137=1+1+(1+1+1)(1+1+1)(1+1+1)(1+1+1+1+1)
138=(1+1)(1+1+1)(1+1+(1+1+1)(1+(1+1)(1+1+1)))
139=1+(1+1)(1+1+1)(1+1+(1+1+1)(1+(1+1)(1+1+1)))
140=(1+1)(1+1)(1+1+1+1+1)(1+(1+1)(1+1+1))
141=1+(1+1)(1+1)(1+1+1+1+1)(1+(1+1)(1+1+1))
142=(1+1)(1+(1+1)(1+1+1+1+1)(1+(1+1)(1+1+1)))
143=(1+1+(1+1+1)(1+1+1))(1+(1+1)(1+1)(1+1+1))
144=(1+1)(1+1)(1+1)(1+1)(1+1+1)(1+1+1)
145=1+(1+1)(1+1)(1+1)(1+1)(1+1+1)(1+1+1)
146=(1+1)(1+(1+1)(1+1)(1+1)(1+1+1)(1+1+1))
147=(1+1+1)(1+(1+1)(1+1+1))(1+(1+1)(1+1+1))
148=(1+1)(1+1)(1+(1+1)(1+1)(1+1+1)(1+1+1))
149=1+(1+1)(1+1)(1+(1+1)(1+1)(1+1+1)(1+1+1))
150=(1+1)(1+1+1)(1+1+1+1+1)(1+1+1+1+1)
151=1+(1+1)(1+1+1)(1+1+1+1+1)(1+1+1+1+1)
152=(1+1)(1+1)(1+1)(1+(1+1)(1+1+1)(1+1+1))
153=(1+1+1)(1+1+1)(1+(1+1)(1+1)(1+1)(1+1))
154=1+(1+1+1)(1+1+1)(1+(1+1)(1+1)(1+1)(1+1))
155=(1+1+1+1+1)(1+(1+1)(1+1+1)(1+1+1+1+1))
156=(1+1)(1+1)(1+1+1)(1+(1+1)(1+1)(1+1+1))
157=1+(1+1)(1+1)(1+1+1)(1+(1+1)(1+1)(1+1+1))

real    0m3.896s
user    0m4.892s
sys     0m0.066s
</code></pre>

<p>Given enough time, it would produce these solutions for the next test cases:</p>

<pre><code>444=(1+1)(1+1)(1+1+1)(1+(1+1)(1+1)(1+1+1)(1+1+1))
1223=1+1+(1+1+1)(1+1+(1+1+1)(1+1+1))(1+(1+1)(1+1)(1+1+1)(1+1+1))
</code></pre>
</div>
<div id="pu4" class="pu"><h1>Pyth, 60 bytes</h1>

<pre><code>LjWqeb\1b`()L?tbho/N\1++'tb"+1"m+y'/bdy'df!%bTr2b1VSQ++N\='N
</code></pre>

<p><a href="https://pyth.herokuapp.com/?code=LjWqeb%5C1b%60%28%29L%3Ftbho%2FN%5C1%2B%2B%27tb%22%2B1%22m%2By%27%2Fbdy%27df%21%25bTr2b1VSQ%2B%2BN%5C%3D%27N&amp;input=1223&amp;debug=0">Demonstration</a></p>

<p>The online compiler can reach 1223 before the time out, thanks to Pyth's automatic function memoization.</p>

<pre><code>1223=((1+1+1)(1+1+1)(1+1+1)(1+1+1)(1+1+1)+1)(1+1+1+1+1)+1+1+1
</code></pre>

<p>In abbrieviated notaion,</p>

<pre><code>1223=(3^5+1)*5+3
</code></pre>

<p>This uses a recursive function <code>'</code>, which calculates all possbile products and sums which could give the desired output, finds the shortest string with each final operation, then compares them by <code>1</code> count and returns the first one.</p>

<p>It uses a helper function, <code>y</code>, which parenthesizes an expression only if it needs to be parenthesized.</p>

<p>Offline, I am running the program with the input <code>15535</code>, and it is nearly complete. Results are printed incrementally, so it is easy to see the progress.</p>

<p>Final lines of the output:</p>

<pre><code>15535=((((1+1+1)(1+1+1)(1+1+1)(1+1+1)+1)((1+1+1)(1+1)+1)+1)(1+1+1)+1)(1+1+1)(1+1+1)+1

real    7m8.430s
user    7m7.158s
sys 0m0.945s
</code></pre>

<p>In abbreviated notation,</p>

<pre><code>15535=(((3^4+1)*(3*2+1)+1)*3+1)*3^2+1
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/64076/">64076</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




