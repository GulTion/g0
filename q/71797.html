<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::71797</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>336</td><td>Rust</td><td>220907T133054Z</td><td><a href="https://codegolf.stackexchange.com/questions/71797/make-a-long-type-signature/251762#251762">mousetai</a></td></tr>
<tr d-ix="1"><td>100</td><td>Rust</td><td>220908T073159Z</td><td><a href="https://codegolf.stackexchange.com/questions/71797/make-a-long-type-signature/251786#251786">alephalp</a></td></tr>
<tr d-ix="2"><td>100</td><td>C#</td><td>220908T154957Z</td><td><a href="https://codegolf.stackexchange.com/questions/71797/make-a-long-type-signature/251804#251804">Acer</a></td></tr>
<tr d-ix="3"><td>000</td><td>Haskell with extensions</td><td>190314T014952Z</td><td><a href="https://codegolf.stackexchange.com/questions/71797/make-a-long-type-signature/181496#181496">dfeuer</a></td></tr>
<tr d-ix="4"><td>099</td><td>C# Visual C# Interactive Compiler</td><td>190427T041308Z</td><td><a href="https://codegolf.stackexchange.com/questions/71797/make-a-long-type-signature/184846#184846">Gymhgy</a></td></tr>
<tr d-ix="5"><td>099</td><td>Idris</td><td>190324T195426Z</td><td><a href="https://codegolf.stackexchange.com/questions/71797/make-a-long-type-signature/182126#182126">univalen</a></td></tr>
<tr d-ix="6"><td>098</td><td>Go 1.0 without reflect</td><td>190103T093753Z</td><td><a href="https://codegolf.stackexchange.com/questions/71797/make-a-long-type-signature/178297#178297">dolmen</a></td></tr>
<tr d-ix="7"><td>nan</td><td>Haskell</td><td>180807T232121Z</td><td><a href="https://codegolf.stackexchange.com/questions/71797/make-a-long-type-signature/170171#170171">Anders K</a></td></tr>
<tr d-ix="8"><td>nan</td><td>Haskell</td><td>190103T083017Z</td><td><a href="https://codegolf.stackexchange.com/questions/71797/make-a-long-type-signature/178294#178294">Bubbler</a></td></tr>
<tr d-ix="9"><td>nan</td><td>Ceylon</td><td>161129T213809Z</td><td><a href="https://codegolf.stackexchange.com/questions/71797/make-a-long-type-signature/101546#101546">Paŭlo Eb</a></td></tr>
<tr d-ix="10"><td>nan</td><td>Java</td><td>160212T153735Z</td><td><a href="https://codegolf.stackexchange.com/questions/71797/make-a-long-type-signature/71829#71829">SuperJed</a></td></tr>
<tr d-ix="11"><td>979</td><td>C</td><td>160212T131343Z</td><td><a href="https://codegolf.stackexchange.com/questions/71797/make-a-long-type-signature/71810#71810">LegionMa</a></td></tr>
<tr d-ix="12"><td>2218</td><td>Haskell</td><td>160212T080217Z</td><td><a href="https://codegolf.stackexchange.com/questions/71797/make-a-long-type-signature/71800#71800">xnor</a></td></tr>
<tr d-ix="13"><td>782</td><td>Haskell</td><td>160212T074355Z</td><td><a href="https://codegolf.stackexchange.com/questions/71797/make-a-long-type-signature/71799#71799">ASCII-on</a></td></tr>
<tr d-ix="14"><td>363</td><td>C#</td><td>160212T070706Z</td><td><a href="https://codegolf.stackexchange.com/questions/71797/make-a-long-type-signature/71798#71798">ASCII-on</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://www.rust-lang.org" rel="nofollow noreferrer">Rust</a>, 99 bytes, score=46,137,336</h1>
<pre class="lang-rust prettyprint-override"><code>fn b&lt;T&gt;(a:T)-&gt;Result&lt;T,T&gt;{Ok(a)}b(b(b(b(b(b(b(b(b(b(b(b(b(b(b(b(b(b(b(b(b(b(0))))))))))))))))))))))
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=jZLfToMwFMYT7-QpKhdLm7FF3c3Skb7ATExM423DsGw4KKQ9aCbhEXwCb3ahD6VPY8fAMLZknl7A-cP361f68akLA9ufi3fQQQyIb3J5J9USVqh0kI1IoaUEkdQ1TNCIocLEb3LmVI4Tp3nic9r5ypt3M9bVizKNHqQpEvC5N2dn9FE5RUPEKT3oDtH8sFK12-iT4sntOUDd3oWWUGiFJrO6Up12duRlwM9a6BOO7dx0mFYn17ECARYksqjHxyIGmVLLJVb5sh5N1BV2y8r1-tJjyIQBO7LEpCaMAyMWG5CmzXW4KtTa4Emby5e2lQY5NvBEqVWgNNJZKgqIpk03zJJEhkCp3_zNRxn6AzvKPCQYa0UK9aqtTpM9Z7HCrucSMmuspoGtkOaMDnzjQflleaPpd2jnFj5nOKCcjNjf7eGsvF_jgFQL_P91TU7GHvVV7Ta2f99u989f" rel="nofollow noreferrer">Attempt This Online!</a></p>
</div>
<div id="pu1" class="pu"><h1>Rust, 100 bytes, Score <span class="math-container">\$\approx 2.22128\times 10^{78}\$</span></h1>
<p>The score is <span class="math-container">\$8+\underbrace{6\times(6\times(\cdots(6\times2+7)\cdots)+7)+7}_{100 \text{ levels}}=\$</span> <code>2221283319900241080728746908337396589826288615608046563246444685656290281023085</code>.</p>
<p>The type is <code>Option&lt;((...(u8,u8,u8,u8,u8,u8),...))&gt;</code>, with 100 levels of nested tuples, where each tuple contains 6 identical items.</p>
<pre class="lang-rust prettyprint-override"><code>type A&lt;T&gt;=(T,T,T,T,T,T);type B&lt;T&gt;=A&lt;A&lt;A&lt;A&lt;A&lt;T&gt;&gt;&gt;&gt;&gt;;type C&lt;T&gt;=B&lt;B&lt;B&lt;B&lt;B&lt;T&gt;&gt;&gt;&gt;&gt;;None::&lt;C&lt;C&lt;C&lt;C&lt;u8&gt;&gt;&gt;&gt;&gt;
</code></pre>
</div>
<div id="pu2" class="pu"><h1><a href="http://www.mono-project.com/docs/about-mono/releases/5.0.0/#csc" rel="nofollow noreferrer">C#</a>, 100 bytes, score = <span class="math-container">\$3.7996944224×10^{21}\$</span></h1>

<pre class="lang-cs prettyprint-override"><code>class X&lt;A,B,C,D,E,F,G&gt;{class Y:X&lt;Y,Y,Y,Y,Y,Y,Y&gt;{Y.Y.Y.Y.Y.Y.Y.Y.Y.Y.Y.Y.Y.Y.Y.Y.Y.Y.Y.Y.Y.Y.Y.Y y;}}
</code></pre>
<hr />
<p>Solution inspired by <a href="https://codegolf.stackexchange.com/a/69200/113454">this answer</a>.</p>
<p>There are two variables that contribute to the length of the type signature of the variable <code>y</code>: the number of generic type arguments on <code>X</code> and the number of nested class accesses in <code>Y</code>.</p>
<p>The following formula represents the length of the generated type signature not counting whitespace:</p>
<p><span class="math-container">\$ L\ =\ \frac{x^{y}\cdot((x-1)(2x^{2}+5x+4)+x+4)-(x+4)}{(x-1)} \$</span></p>
<p>where <code>x</code> is the number of generic type arguments on <code>X</code> (e.g. for <code>X&lt;A,B,C,D&gt;</code>, <code>x = 4</code>) and <code>y</code> is the number of <code>.Y</code>s</p>
<p>Using Desmos and trial and error, I found the maximum length value where <code>x</code> and <code>y</code> would fit in 100 bytes was at <code>x=7</code> <code>y=23</code>.</p>
<p><a href="https://tio.run/##Sy7WTS7O/P8/OSexuFghwsZRx0nHWcdFx1XHTcfdrhoiHGkVYROpgwTtqiP1SIIKlda1tf//AwA" rel="nofollow noreferrer" title="C# (Visual C# Interactive Compiler) – Try It Online">Try it online!</a></p>
</div>
<div id="pu3" class="pu"><h1><a href="https://www.haskell.org/" rel="nofollow noreferrer">Haskell</a> with extensions, <span class="math-container">\$\ggg A(A(A(A(220,0),0),0),0)\$</span></h1>

<pre class="lang-hs prettyprint-override"><code>Z::Z#Z#Z#Z#Z#Z#Z#Z#Z?Z
data a?b=Z|S(a?b)
type family m#n where Z#n=S n;S m#Z=m#S m;S m#S n=m#(S m#n)
</code></pre>
<p><a href="https://tio.run/##XY1Ba8MwDIXv@RUCXxJo/kCH6WFjMHpYICsDs4uaqK6ZrYbIpQvb/vo8db0NHd73nsTTEeWdYiyfrYGI7M/oCbpTXLaBR1k9YMYbvSwTPWIKMdDNPE80Yz7NstrxSEMYcR/piSUjD3py33Vg2u/qw8Jbceu1M/9m46pR2wE3e@u@@lq1qbIWw@H6ZoFkGC5HmgmcYdsD3/WaOZuM6h9rpq6@IjclYWA7nWeqm/IzHCJ6Ke1rCiKBfSvBM2bdyi8" rel="nofollow noreferrer">Try it online!</a></p>
<p>Requires <code>-XDataKinds</code>, <code>-XPolyKinds</code>, <code>-XTypeOperators</code>, <code>-XUndecidableInstances</code>, and <code>-XTypeFamilies</code>.</p>
<p>Many thanks to Ørjan Johansen, who realized that making the natural number constructor infix and building the arguments a bit differently saved two bytes, making just enough room for another iteration of <code>#</code>.</p>
<p>Obviously, the type checker will give up trying to check this program. To get a general sense of what the signature would look like (if it were small enough to fit in the observable universe), try the much smaller</p>
<pre class="lang-hs prettyprint-override"><code>Z::S(S Z)#Z?Z
</code></pre>
<h2>Explanation</h2>
<p>The <code>#</code> type family is closely related the <a href="https://en.m.wikipedia.org/wiki/Ackermann_function" rel="nofollow noreferrer">Ackermann–Péter function</a>, commonly written <span class="math-container">\$A\$</span>, but <code>#</code> grows faster. The Ackermann–Péter function is defined</p>
<blockquote>
<p><span class="math-container">\$A(0,n)=n+1\$</span></p>
<p><span class="math-container">\$A(m,0)=A(m-1,1)\$</span> when <span class="math-container">\$m &gt; 0\$</span></p>
<p><span class="math-container">\$A(m,n)=A(m-1, A(m, n-1))\$</span> when <span class="math-container">\$ m, n &gt; 0 \$</span></p>
</blockquote>
<p><code>#</code>, on the other hand, we can call <span class="math-container">\$B\$</span>, and write</p>
<blockquote>
<p><span class="math-container">\$B(0,n)=n+1\$</span></p>
<p><span class="math-container">\$B(m,0)=B(m-1,m)\$</span> when <span class="math-container">\$m &gt; 0\$</span></p>
<p><span class="math-container">\$B(m,n)=B(m-1, B(m, n-1))\$</span> when <span class="math-container">\$m,n &gt; 0\$</span></p>
</blockquote>
<p>Only the second case is different. The termination proof is identical to the standard one for <span class="math-container">\$A\$</span>, and it should be clear that <span class="math-container">\$B(m,n) \ge A(m,n)\$</span> for all <span class="math-container">\$m\$</span> and <span class="math-container">\$n\$</span>.</p>
<p>Here we calculate a unary representation of</p>
<blockquote>
<p><span class="math-container">\$r = B(B(B(B(B(B(B(B(0,0),0),0),0),0),0),0),0) \$</span></p>
</blockquote>
<p>By direct calculation, <span class="math-container">\$B(B(B(B(0,0),0),0),0)=220\$</span>, so</p>
<blockquote>
<p><span class="math-container">\$r = B(B(B(B(220,0),0),0),0)\$</span>.</p>
</blockquote>
<p>Note that <span class="math-container">\$A(A(A(A(0,0),0),0),0)\$</span> is only <span class="math-container">\$5\$</span>, so we've bumped things up a good bit to start out. I don't have a very clear sense of just how much faster <span class="math-container">\$B\$</span> grows than <span class="math-container">\$A\$</span>, but considering how the calculation proceeds, it seems likely to grow quite a lot faster.</p>
<p>The number of digits in even <span class="math-container">\$A(6,0)\$</span> is too large to express practically in decimal, so this is ... rather ridiculously large.</p>
<p>The definition of the natural numbers, <code>(?)</code>, is a bit non-standard. To save space, we use <code>(?)</code> as both a natural number type (at the type level) and a proxy type (at the term level).</p>
<p>I believe that either <code>TypeFamilies</code> or (more verbosely and obfuscatedly) <code>FunctionalDependencies</code> are necessary to get the type-level computation required to reach truly large types. <code>UndecidableInstances</code> is needed to work around Haskell's very primitive termination checking. The other extensions are only needed to compress the code into the small available space.</p>
</div>
<div id="pu4" class="pu"><h1><a href="http://www.mono-project.com/docs/about-mono/releases/5.0.0/#csc" rel="nofollow noreferrer">C# (Visual C# Interactive Compiler)</a>, 99 bytes, Score 841</h1>



<pre class="lang-cs prettyprint-override"><code>(1,(1,(1,(1,(1,(1,(1,(1,(1,(1,(1,(1,(1,(1,(1,(1,(1,(1,(1,(1,(1,(1,(1,(1,1,1))))))))))))))))))))))))
</code></pre>

<p><a href="https://tio.run/##Sy7WTS7O/F@WWKSQbqvxX8NQhyoICDVxgP@aeu6pJSGVBakamtZc4UWZJak@mXmpGumoPL2Q/OCSosy8dA1NPZ/UvPSSDAVtBSWF5IzEomKFnPy8dCVN6/8A" rel="nofollow noreferrer" title="C# (Visual C# Interactive Compiler) – Try It Online">Try it online!</a></p>

<p>Outputs</p>

<pre class="lang-cs prettyprint-override"><code>System.ValueTuple`2[System.Int32,System.ValueTuple`2[System.Int32,System.ValueTuple`2[System.Int32,System.ValueTuple`2[System.Int32,System.ValueTuple`2[System.Int32,System.ValueTuple`2[System.Int32,System.ValueTuple`2[System.Int32,System.ValueTuple`2[System.Int32,System.ValueTuple`2[System.Int32,System.ValueTuple`2[System.Int32,System.ValueTuple`2[System.Int32,System.ValueTuple`2[System.Int32,System.ValueTuple`2[System.Int32,System.ValueTuple`2[System.Int32,System.ValueTuple`2[System.Int32,System.ValueTuple`2[System.Int32,System.ValueTuple`2[System.Int32,System.ValueTuple`2[System.Int32,System.ValueTuple`2[System.Int32,System.ValueTuple`2[System.Int32,System.ValueTuple`2[System.Int32,System.ValueTuple`2[System.Int32,System.ValueTuple`2[System.Int32,System.ValueTuple`3[System.Int32,System.Int32,System.Int32]]]]]]]]]]]]]]]]]]]]]]]]
</code></pre>
</div>
<div id="pu5" class="pu"><h1>Idris, >hyper(hyper(hyper(hyper(999999999, 99, 99), 99,99),99,99),99,99)</h1>

<pre><code>f:Nat-&gt;Type
f Z=()
f(S n)=hyper n n n~=~f n
the$f$hyper(hyper(hyper(hyper 999999999 9 9) 9 9)9 9)9 9
</code></pre>

<h2>Explanation:</h2>

<p>We're defining a function f, computing a type f(0) is just the unit type, while f(S(n)) computes to the equality type applied to the function argument "hypered" by itself and to f applied to n. The last line basically is a function expecting a value of a type like (27 = (4 = (2 = (1 = ()))))) (for n=4).</p>

<h1>Simple Example</h1>

<pre><code>f 3 = (27 = (4 = (2 = (1 = ()))))
</code></pre>
</div>
<div id="pu6" class="pu"><h1>Go 1.0 without <code>reflect</code>, 98</h1>

<p>Go 1.x types are statically defined. Here is my first try:</p>

<pre><code>[][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][]string{}
</code></pre>

<p><a href="https://play.golang.org/p/MC8pTVC1K6D" rel="nofollow noreferrer">On the Go playground</a>:</p>

<pre><code>package main;import "fmt"
func main() {

    x := [][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][]string{}

    fmt.Printf("%d %T\n", len(fmt.Sprintf("%T", x)), x)
}
</code></pre>

<h1>Go 1.9 using type aliases, 2389</h1>

<pre><code>type(I=interface{f();g()};S=struct{p,q,r,s,t,u,v,w,x,y,z I});map[S]map[S]map[S]map[S]map[S]map[S]S{}
</code></pre>

<p><a href="https://play.golang.org/p/K6H6WqF04fI" rel="nofollow noreferrer">On the Go playground</a>:</p>

<pre><code>package main;import("fmt";"strings")
func main() {

    type(I=interface{f();g()};S=struct{p,q,r,s,t,u,v,w,x,y,z I});x:=map[S]map[S]map[S]map[S]map[S]map[S]S{}

    fmt.Printf("%d %T\n", len(strings.Replace(fmt.Sprintf("%T", x), " ", "", -1)), x)
}
</code></pre>

<p>Result:</p>

<pre><code>2389 map[struct { p interface { main.f(); main.g() }; q interface { main.f(); main.g() }; r interface { main.f(); main.g() }; s interface { main.f(); main.g() }; t interface { main.f(); main.g() }; u interface { main.f(); main.g() }; v interface { main.f(); main.g() }; w interface { main.f(); main.g() }; x interface { main.f(); main.g() }; y interface { main.f(); main.g() }; z interface { main.f(); main.g() } }]map[struct { p interface { main.f(); main.g() }; q interface { main.f(); main.g() }; r interface { main.f(); main.g() }; s interface { main.f(); main.g() }; t interface { main.f(); main.g() }; u interface { main.f(); main.g() }; v interface { main.f(); main.g() }; w interface { main.f(); main.g() }; x interface { main.f(); main.g() }; y interface { main.f(); main.g() }; z interface { main.f(); main.g() } }]map[struct { p interface { main.f(); main.g() }; q interface { main.f(); main.g() }; r interface { main.f(); main.g() }; s interface { main.f(); main.g() }; t interface { main.f(); main.g() }; u interface { main.f(); main.g() }; v interface { main.f(); main.g() }; w interface { main.f(); main.g() }; x interface { main.f(); main.g() }; y interface { main.f(); main.g() }; z interface { main.f(); main.g() } }]map[struct { p interface { main.f(); main.g() }; q interface { main.f(); main.g() }; r interface { main.f(); main.g() }; s interface { main.f(); main.g() }; t interface { main.f(); main.g() }; u interface { main.f(); main.g() }; v interface { main.f(); main.g() }; w interface { main.f(); main.g() }; x interface { main.f(); main.g() }; y interface { main.f(); main.g() }; z interface { main.f(); main.g() } }]map[struct { p interface { main.f(); main.g() }; q interface { main.f(); main.g() }; r interface { main.f(); main.g() }; s interface { main.f(); main.g() }; t interface { main.f(); main.g() }; u interface { main.f(); main.g() }; v interface { main.f(); main.g() }; w interface { main.f(); main.g() }; x interface { main.f(); main.g() }; y interface { main.f(); main.g() }; z interface { main.f(); main.g() } }]map[struct { p interface { main.f(); main.g() }; q interface { main.f(); main.g() }; r interface { main.f(); main.g() }; s interface { main.f(); main.g() }; t interface { main.f(); main.g() }; u interface { main.f(); main.g() }; v interface { main.f(); main.g() }; w interface { main.f(); main.g() }; x interface { main.f(); main.g() }; y interface { main.f(); main.g() }; z interface { main.f(); main.g() } }]struct { p interface { main.f(); main.g() }; q interface { main.f(); main.g() }; r interface { main.f(); main.g() }; s interface { main.f(); main.g() }; t interface { main.f(); main.g() }; u interface { main.f(); main.g() }; v interface { main.f(); main.g() }; w interface { main.f(); main.g() }; x interface { main.f(); main.g() }; y interface { main.f(); main.g() }; z interface { main.f(); main.g() } }
</code></pre>

<h1>Go 1 using <a href="https://golang.org/pkg/reflect/" rel="nofollow noreferrer"><code>reflect</code></a>, 65532</h1>

<p>There is <a href="https://github.com/golang/go/blob/ed15e82413c7b16e21a493f5a647f68b46e965ee/src/reflect/type.go#L533" rel="nofollow noreferrer">a limit in package <code>reflect</code></a> on the length of type names: <code>len(name) &lt;= 1&lt;&lt;16-1</code></p>

<p>I've been able to reach a type name of 65532 bytes so far with this block:</p>

<pre><code>t:=reflect.TypeOf(0);u:=t;for i:=0;i&lt;8191;i++{t=reflect.MapOf(u,t)};reflect.New(t).Interface()
</code></pre>

<p><a href="https://play.golang.org/p/gr7ayLr2M9P" rel="nofollow noreferrer">Full code on the Go playground</a>:</p>

<pre><code>package main;import("fmt";"reflect")
func main() {

    t:=reflect.TypeOf(0);u:=t;for i:=0;i&lt;8191;i++{t=reflect.MapOf(u,t)};x:=reflect.New(t).Interface()

    fmt.Printf("%d %T\n", len(fmt.Sprintf("%T", x)), x)
}
</code></pre>

<p><hr/>
Notes: <code>x:=</code> is never counted.</p>
</div>
<div id="pu7" class="pu"><h1>Haskell, 9·2<sup>663552</sup> − 3 (≈ 1.02·10<sup>199750</sup>)</h1>

<p>A small (“small”) improvement over <a href="https://codegolf.stackexchange.com/questions/71797/make-a-long-type-signature/71800#71800">xnor’s 5⋅2<sup>262144</sup> + 5</a>.  This is 99 bytes.</p>



<pre class="lang-hs prettyprint-override"><code>f=(:).(:)
g=f.f.f.f
h=g.g.g.g
i=h.h.h.h
j=i.i.i.i
k=j.j.j.j
l=k.k.k.k
m=l.l.l
n=m.m.m
o=n.n.n
o.o.o
</code></pre>

<h3>How it works</h3>

<p>We have</p>

<pre class="lang-hs prettyprint-override"><code>(:)         :: a -&gt; [a] -&gt; [a]
(:).(:)     :: a -&gt; [[a] -&gt; [a]] -&gt; [[a] -&gt; [a]]
(:).(:).(:) :: a -&gt; [[[a] -&gt; [a]] -&gt; [[a] -&gt; [a]]] -&gt; [[[a] -&gt; [a]] -&gt; [[a] -&gt; [a]]]
</code></pre>

<p>and so on, with the length roughly doubling for each <code>(:)</code>. The given expression <code>o.o.o</code> works out to <code>(:).(:).(:).….(:)</code> with 2·4<sup>6</sup>·3<sup>4</sup> = 663552 copies of <code>(:)</code>.</p>

<h1>Haskell with <code>FlexibleContexts</code> and <code>NoMonomorphismRestriction</code>, (200·4<sup>331776</sup> + 75·331776 + 16)/9 ≈ 2.53·10<sup>199750</sup></h1>

<p>A small improvement over <a href="https://codegolf.stackexchange.com/questions/71797/make-a-long-type-signature/178294#178294">Bubbler’s 12·2<sup>663552</sup> + 9·663552 − 4 ≈ 1.36·10<sup>199750</sup></a>, which also relies on these extensions.  The wording of the challenge sort of suggests it might be okay to rely on them (“For example <code>Num [a]</code> and <code>Eq [a]</code> are allowed, even without a defined instance”); I’m not sure.  This is 100 bytes.</p>

<pre class="lang-hs prettyprint-override"><code>f=(/).(:)
g=f.f.f.f
h=g.g.g.g
i=h.h.h.h
j=i.i.i.i
k=j.j.j.j
l=k.k.k.k
m=l.l.l
n=m.m.m
o=n.n.n
-o.o.o
</code></pre>

<h3>How it works</h3>

<p>We have</p>

<pre class="lang-hs prettyprint-override"><code>-(/).(:) :: (Fractional ([a] -&gt; [a]), Num (a -&gt; ([a] -&gt; [a]) -&gt; [a] -&gt; [a])) =&gt; a -&gt; ([a] -&gt; [a]) -&gt; [a] -&gt; [a]
-(/).(:).(/).(:) :: (Fractional ([a] -&gt; [a]), Fractional ([([a] -&gt; [a]) -&gt; [a] -&gt; [a]] -&gt; [([a] -&gt; [a]) -&gt; [a] -&gt; [a]]), Num (a -&gt; ([([a] -&gt; [a]) -&gt; [a] -&gt; [a]] -&gt; [([a] -&gt; [a]) -&gt; [a] -&gt; [a]]) -&gt; [([a] -&gt; [a]) -&gt; [a] -&gt; [a]] -&gt; [([a] -&gt; [a]) -&gt; [a] -&gt; [a]])) =&gt; a -&gt; ([([a] -&gt; [a]) -&gt; [a] -&gt; [a]] -&gt; [([a] -&gt; [a]) -&gt; [a] -&gt; [a]]) -&gt; [([a] -&gt; [a]) -&gt; [a] -&gt; [a]] -&gt; [([a] -&gt; [a]) -&gt; [a] -&gt; [a]]
-(/).(:).(/).(:).(/).(:) :: (Fractional ([a] -&gt; [a]), Fractional ([([a] -&gt; [a]) -&gt; [a] -&gt; [a]] -&gt; [([a] -&gt; [a]) -&gt; [a] -&gt; [a]]), Fractional ([([([a] -&gt; [a]) -&gt; [a] -&gt; [a]] -&gt; [([a] -&gt; [a]) -&gt; [a] -&gt; [a]]) -&gt; [([a] -&gt; [a]) -&gt; [a] -&gt; [a]] -&gt; [([a] -&gt; [a]) -&gt; [a] -&gt; [a]]] -&gt; [([([a] -&gt; [a]) -&gt; [a] -&gt; [a]] -&gt; [([a] -&gt; [a]) -&gt; [a] -&gt; [a]]) -&gt; [([a] -&gt; [a]) -&gt; [a] -&gt; [a]] -&gt; [([a] -&gt; [a]) -&gt; [a] -&gt; [a]]]), Num (a -&gt; ([([([a] -&gt; [a]) -&gt; [a] -&gt; [a]] -&gt; [([a] -&gt; [a]) -&gt; [a] -&gt; [a]]) -&gt; [([a] -&gt; [a]) -&gt; [a] -&gt; [a]] -&gt; [([a] -&gt; [a]) -&gt; [a] -&gt; [a]]] -&gt; [([([a] -&gt; [a]) -&gt; [a] -&gt; [a]] -&gt; [([a] -&gt; [a]) -&gt; [a] -&gt; [a]]) -&gt; [([a] -&gt; [a]) -&gt; [a] -&gt; [a]] -&gt; [([a] -&gt; [a]) -&gt; [a] -&gt; [a]]]) -&gt; [([([a] -&gt; [a]) -&gt; [a] -&gt; [a]] -&gt; [([a] -&gt; [a]) -&gt; [a] -&gt; [a]]) -&gt; [([a] -&gt; [a]) -&gt; [a] -&gt; [a]] -&gt; [([a] -&gt; [a]) -&gt; [a] -&gt; [a]]] -&gt; [([([a] -&gt; [a]) -&gt; [a] -&gt; [a]] -&gt; [([a] -&gt; [a]) -&gt; [a] -&gt; [a]]) -&gt; [([a] -&gt; [a]) -&gt; [a] -&gt; [a]] -&gt; [([a] -&gt; [a]) -&gt; [a] -&gt; [a]]])) =&gt; a -&gt; ([([([a] -&gt; [a]) -&gt; [a] -&gt; [a]] -&gt; [([a] -&gt; [a]) -&gt; [a] -&gt; [a]]) -&gt; [([a] -&gt; [a]) -&gt; [a] -&gt; [a]] -&gt; [([a] -&gt; [a]) -&gt; [a] -&gt; [a]]] -&gt; [([([a] -&gt; [a]) -&gt; [a] -&gt; [a]] -&gt; [([a] -&gt; [a]) -&gt; [a] -&gt; [a]]) -&gt; [([a] -&gt; [a]) -&gt; [a] -&gt; [a]] -&gt; [([a] -&gt; [a]) -&gt; [a] -&gt; [a]]]) -&gt; [([([a] -&gt; [a]) -&gt; [a] -&gt; [a]] -&gt; [([a] -&gt; [a]) -&gt; [a] -&gt; [a]]) -&gt; [([a] -&gt; [a]) -&gt; [a] -&gt; [a]] -&gt; [([a] -&gt; [a]) -&gt; [a] -&gt; [a]]] -&gt; [([([a] -&gt; [a]) -&gt; [a] -&gt; [a]] -&gt; [([a] -&gt; [a]) -&gt; [a] -&gt; [a]]) -&gt; [([a] -&gt; [a]) -&gt; [a] -&gt; [a]] -&gt; [([a] -&gt; [a]) -&gt; [a] -&gt; [a]]]
</code></pre>

<p>and so on, with the length roughly quadrupling for each <code>(/).(:)</code>. The given expression <code>-o.o.o</code> works out to <code>-(/).(:).(/).(:).….(/).(:)</code> with 4<sup>6</sup>·3<sup>4</sup> = 331776 copies of <code>(/).(:)</code>.</p>
</div>
<div id="pu8" class="pu"><h1>Haskell, 12·2<sup>663552</sup> + 9·663552 - 4</h1>

<p>Yet another small improvement over <a href="https://codegolf.stackexchange.com/a/170171/78410">Anders Kaseorg's answer</a>.</p>

<pre><code>f=(/).(/)
g=f.f.f.f
h=g.g.g.g
i=h.h.h.h
j=i.i.i.i
k=j.j.j.j
l=k.k.k.k
m=l.l.l
n=m.m.m
o=n.n.n
o.o.o
</code></pre>

<h3>How it works</h3>

<pre><code>(/) -- score 27
   :: Fractional a =&gt; a -&gt; a -&gt; a
(/).(/) -- score 62
   :: (Fractional a, Fractional (a -&gt; a)) =&gt; a -&gt; (a -&gt; a) -&gt; a -&gt; a
(/).(/).(/) -- score 119
   :: (Fractional a, Fractional (a -&gt; a), Fractional ((a -&gt; a) -&gt; a -&gt; a)) =&gt;
      a -&gt; ((a -&gt; a) -&gt; a -&gt; a) -&gt; (a -&gt; a) -&gt; a -&gt; a
(/).(/).(/).(/) -- score 224
   :: (Fractional a, Fractional (a -&gt; a),
       Fractional ((a -&gt; a) -&gt; a -&gt; a),
       Fractional (((a -&gt; a) -&gt; a -&gt; a) -&gt; (a -&gt; a) -&gt; a -&gt; a)) =&gt;
      a
      -&gt; (((a -&gt; a) -&gt; a -&gt; a) -&gt; (a -&gt; a) -&gt; a -&gt; a)
      -&gt; ((a -&gt; a) -&gt; a -&gt; a)
      -&gt; (a -&gt; a)
      -&gt; a
      -&gt; a
</code></pre>

<p>Just changed function composition <code>(.)</code> to fractional division <code>(/)</code>. The <code>Fractional x</code> part in the function signature explodes along with the main part, giving slightly higher constant multiplier.</p>
</div>
<div id="pu9" class="pu"><h1>Ceylon, 38843546786070481 (~ 4·10<sup>16</sup>)</h1>

<pre><code>[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
</code></pre>

<p>This are 49 nested one-tuples, with an empty tuple innermost.
The short name of this type is actually the same as the value in this case, but the fully expanded name is much longer.</p>

<p>The Ceylon compiler is working forever when trying to compile this (The compiler was still running after 180 minutes) – I'll have to try calculating the theoretical type length.</p>

<p>The problem here is that a one-element-tuple type <code>[X]</code> is actually represented in Ceylon's type system as <code>Tuple&lt;X, X, []&gt;</code> (first parameter is a supertype for all element types, second is the type of the first element, and third the type of all except the first elements, which is here an empty tuple (the <code>empty</code> object, the single instance satisfying the interface <code>Empty</code>)).</p>

<p>So <code>[]</code> is <code>empty</code>, <code>[[]]</code> is <code>Tuple&lt;[], [], []&gt;</code> = <code>Tuple&lt;empty, empty, empty&gt;</code>, <code>[[[]]]</code> is <code>Tuple&lt;[[]], [[]], []&gt;</code> = <code>Tuple&lt;Tuple&lt;[], [], []&gt;, Tuple&lt;[], [], []&gt;, []&gt;</code>. And the full name includes the package names, so we have actually <code>ceylon.language::Tuple&lt;ceylon.language::Tuple&lt;ceylon.language::empty, ceylon.language::empty, ceylon.language::empty&gt;, ceylon.language::Tuple&lt;ceylon.language::empty, ceylon.language::empty, ceylon.language::empty&gt;, ceylon.language::empty&gt;</code> just for three levels. And we want to go to 50.</p>

<p>As <code>ceylon.language::empty</code> is 22 characters long, and each <code>ceylon.language::Tuple&lt;?,?,ceylon.language::empty&gt;</code> adds 47 to twice the result from the previous step, we get <code>f(1) = 22</code>, and <code>f(n) = 2 · f(n-1) + 47</code>. This simplifies to <code>f(n) = 69 · 2^(n - 1) - 47</code>, and entering 50 gives us 38843546786070481. Of course, this is much larger than what would fit in the memory of my computer (8·10<sup>9</sup> bytes).</p>

<p>Of course, the compiler could be smart and not try to have the whole type name in memory until its name is requested.</p>

<p>Here is the full program trying to print the type:</p>

<pre class="lang-ceylon prettyprint-override"><code>import ceylon.language.meta {
    type
}
"Run the module `codegolf.signature71797`."
shared void run() {
    value x = [[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]];
    print(type(x));
}
</code></pre>
</div>
<div id="pu10" class="pu"><h1>Java, score 17301488</h1>

<p>Requires the method <code>&lt;T&gt;java.util.Map&lt;T,T&gt;f(T t){return null;}</code>, which has been counted towards the 100-byte limit.</p>

<p><code>f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(1)))))))))))))))))))</code></p>

<p>The compile-time type signature of this should match <a href="https://drive.google.com/file/d/0B66Q2_YrkhNnQTJkX1ZZb3RjNU0/view?usp=sharing" rel="noreferrer">this.</a></p>
</div>
<div id="pu11" class="pu"><h1>C, 979</h1>

<pre><code>#define a int,int,int
#define b a,a,a,a
#define c b,b,b
#define d c,c,c
#define e d,d,d
int(*f)(e);
</code></pre>

<p><code>f</code> has the signature:</p>

<pre><code>int(*)(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
</code></pre>
</div>
<div id="pu12" class="pu"><h2>Haskell, ~2^(2^18)</h2>
<pre class="lang-haskell prettyprint-override"><code>f x=(x,x)
g=f.f.f.f
h=g.g.g.g
i=h.h.h.h
j=i.i.i.i
k=j.j.j.j
l=k.k.k.k
m=l.l.l.l
n=m.m.m.m
n.n.n.n$0
</code></pre>
<p>Each application of <code>f</code> roughly double the type signature by transforming the type signature <code>T</code> to <code>(T,T)</code>. For example, the fourfold composition <code>f.f.f.f$0</code> has type</p>
<pre><code>Num a =&gt; ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a))))
</code></pre>
<p>Each line quadraples the number of applications of <code>f</code>, giving <code>4^9 = 2^18</code> at the end. So, the type signature has size of the order of <code>2^(2^18)</code>.</p>
</div>
<div id="pu13" class="pu"><h1>Haskell, 782</h1>
<p>Expression:</p>
<pre><code>sum.sum.sum.sum.sum.sum.sum.sum.sum.sum.sum.sum.sum.sum.sum.sum.sum.sum.sum.sum.sum.sum.sum.sum.sum
</code></pre>
<p>Type signature:</p>
<pre><code>:: (Num [[[[[[[[[[[[[[[[[[[[[[[[c]]]]]]]]]]]]]]]]]]]]]]]], Num [[[[[[[[[[[[[[[[[[[[[[[c]]]]]]]]]]]]]]]]]]]]]]], Num [[[[[[[[[[[[[[[[[[[[[[c]]]]]]]]]]]]]]]]]]]]]], Num [[[[[[[[[[[[[[[[[[[[[c]]]]]]]]]]]]]]]]]]]]], Num [[[[[[[[[[[[[[[[[[[[c]]]]]]]]]]]]]]]]]]]], Num [[[[[[[[[[[[[[[[[[[c]]]]]]]]]]]]]]]]]]], Num [[[[[[[[[[[[[[[[[[c]]]]]]]]]]]]]]]]]], Num [[[[[[[[[[[[[[[[[c]]]]]]]]]]]]]]]]], Num [[[[[[[[[[[[[[[[c]]]]]]]]]]]]]]]], Num [[[[[[[[[[[[[[[c]]]]]]]]]]]]]]], Num [[[[[[[[[[[[[[c]]]]]]]]]]]]]], Num [[[[[[[[[[[[[c]]]]]]]]]]]]], Num [[[[[[[[[[[[c]]]]]]]]]]]], Num [[[[[[[[[[[c]]]]]]]]]]], Num [[[[[[[[[[c]]]]]]]]]], Num [[[[[[[[[c]]]]]]]]], Num [[[[[[[[c]]]]]]]], Num [[[[[[[c]]]]]]], Num [[[[[[c]]]]]], Num [[[[[c]]]]], Num [[[[c]]]], Num [[[c]]], Num [[c]], Num [c], Num c) =&gt; [[[[[[[[[[[[[[[[[[[[[[[[[c]]]]]]]]]]]]]]]]]]]]]]]]] -&gt; c
</code></pre>
</div>
<div id="pu14" class="pu"><h1>C#, 363</h1>

<p>Expression:</p>

<pre><code>new{a=new{a=new{a=new{a=new{a=new{a=new{a=new{a=new{a=new{a=new{a=new{a=new{a=new{a=""}}}}}}}}}}}}}}
</code></pre>

<p>Type signature:</p>

<pre><code>&lt;&gt;f__AnonymousType0#1`1[&lt;&gt;f__AnonymousType0#1`1[&lt;&gt;f__AnonymousType0#1`1[&lt;&gt;f__AnonymousType0#1`1[&lt;&gt;f__AnonymousType0#1`1[&lt;&gt;f__AnonymousType0#1`1[&lt;&gt;f__AnonymousType0#1`1[&lt;&gt;f__AnonymousType0#1`1[&lt;&gt;f__AnonymousType0#1`1[&lt;&gt;f__AnonymousType0#1`1[&lt;&gt;f__AnonymousType0#1`1[&lt;&gt;f__AnonymousType0#1`1[&lt;&gt;f__AnonymousType0#1`1[&lt;&gt;f__AnonymousType0#1`1[System.String]]]]]]]]]]]]]]
</code></pre>

<p><a href="http://csharppad.com/gist/487852bf2e208a896377" rel="nofollow">Try it online!</a></p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/71797/">71797</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




