<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::263827</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>234</td><td>Ruby nl</td><td>230809T061513Z</td><td><a href="https://codegolf.stackexchange.com/questions/263827/is-it-a-valid-go-type/263909#263909">Value In</a></td></tr>
<tr d-ix="1"><td>1277</td><td>Go</td><td>230808T191507Z</td><td><a href="https://codegolf.stackexchange.com/questions/263827/is-it-a-valid-go-type/263895#263895">bigyihsu</a></td></tr>
<tr d-ix="2"><td>250</td><td>JavaScript ES6</td><td>230808T112020Z</td><td><a href="https://codegolf.stackexchange.com/questions/263827/is-it-a-valid-go-type/263881#263881">Arnauld</a></td></tr>
<tr d-ix="3"><td>241</td><td>Regex PCRE</td><td>230807T135046Z</td><td><a href="https://codegolf.stackexchange.com/questions/263827/is-it-a-valid-go-type/263832#263832">mousetai</a></td></tr>
<tr d-ix="4"><td>193</td><td>Raku</td><td>230807T151536Z</td><td><a href="https://codegolf.stackexchange.com/questions/263827/is-it-a-valid-go-type/263839#263839">Sean</a></td></tr>
<tr d-ix="5"><td>nan</td><td>BNFC + Haskell + Bash + coreutils</td><td>230807T161837Z</td><td><a href="https://codegolf.stackexchange.com/questions/263827/is-it-a-valid-go-type/263842#263842">matteo_c</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://www.ruby-lang.org/" rel="nofollow noreferrer">Ruby</a> <code>-nl</code>, <s>239</s> 234 bytes</h1>
<p>Uses the replacement strategy from Arnauld's <a href="https://codegolf.stackexchange.com/a/263881/52194">Javascript answer</a> as a full program using the <code>-nl</code> flag to loop the code over each line of input. Since Ruby doesn't let you inject <code>undefined</code> by leaving out arguments, the relevant replacements to force disqualification use <code>X</code> instead.</p>
<p>I had a slightly different regex strategy for solving the <code>func</code> issue but it turns out using the regexes from that answer was shorter.</p>
<pre class="lang-ruby prettyprint-override"><code>sub'T',?X
1until$_==(gsub /\[([1-9]\d*)?\]|map\[T\]|chan\s/,?*;sub /\w\s\w/,?X;sub /\s/,'';sub /bool|u?int|float(32|64)|complex(64|128)|byte|rune|string|\*T|struct{(T(;T)*)?}|func\((T(,T)*)?\)(T|\(T(,T)*\)|(?=[,;})\]])|$)/,?T)
p$_==?T
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=dVNdbtpAEH7oU32KUYTErmWamBBKZCFfwg-RdleRIYaQGoPAVoq6Pklf-pCqZ2qP0FN0Zn8wVMGSd2e--Wb8zez6-9uumR1-iatBVV6pty30Hn829WIw-f1338z6WT9KH4K4qepV2XucTtkSUbiWgol4cK_kU8hTqfQ630qRoTF_ziu5v47SMLHEV7mXr-g_OB9j_b61Z5tNqZt0VdV6UW7ymt0O9XjE9Xyz3pbFVzYe6Xg44Xp2qAu9a6pC7-vdqlpqGWZkNvP6G8tYknEU0epFU80lQyAygOQs09K5kmuWTkWUtFwqxXWPo6SMB1vqKc1sxz_c9ufDgqQFKCxwWlBHEJIf-occoawgNIQyAMQ3oD4KUCIe3ioIQdyNPytAAMTkHmMQUiMBzktggs8nF0wJIio4gf3bsRW5JFDRsMEHHYGGgmZiuQnx2sDhcLSIAWbo41EC4QlqEjqi2whNTnNDYb_ezadF0FVEk1Q5uXZrAzofxu2GNaKGFnqpOHctX4gyG47ONlfLp3AwS4cJdaLiP4J3A9vFpYUYVMRqh7NNvQfaeseLgfnFstgBQGBmA2St1vlyVeW7A1A8NBgeun3QyvdPi-Xzy5cSHaHMrbCRQezqkoMX7NPobqzczC2lO6LInwV92ndsJutKeO4xeH7LfPxCuAXTqddmPXHMtcPAqZDSG9XRMiprTOTZ_-0f" rel="nofollow noreferrer">Attempt This Online!</a></p>
</div>
<div id="pu1" class="pu"><h1><a href="https://go.dev" rel="nofollow noreferrer">Go</a>, <s>1279</s> 1277 bytes</h1>
<pre class="lang-go prettyprint-override"><code>import(.&quot;regexp&quot;;.&quot;strings&quot;;U&quot;unicode&quot;)
func P(s string)(string,bool){S,M,C,t,Z:=U.IsSpace,MustCompile,CutPrefix,0,0&lt;1
T,X:=func(){for len(s)&gt;0&amp;&amp;S(rune(s[0])){s=TrimSpace(s[1:])}},!Z
N:=func(){T();s=s[1:];T()}
T()
if len(s)&lt;1{return s,X}
if k:=M(`^(bool|u?int|float(32|64)|complex(64|128)|byte|rune|string)($|[]});,\s])`).FindStringIndex(s);k!=nil&amp;&amp;k[0]&lt;1{s=s[k[1]-1:];T();return s,Z}
if s[0]=='*'{return P(s[1:])}
if s[0]=='['{N();k:=M(&quot;^[1-9][0-9]+&quot;).FindStringIndex(s);if k!=nil{s=s[k[1]:];N();return P(s)};N();return P(s)}
if r,o:=C(s,&quot;map&quot;);o{s=r;N();s,o=P(s);if!o{return s,X};if s[0]==']'{N()};return P(s)}
if r,o:=C(s,&quot;chan&quot;);o{s=r;if!S(rune(s[0])){return s,X};T();return P(s)}
if r,o:=C(s,&quot;struct&quot;);o{s=r;T();if s[0]!='{'{return s,X};N();for s[0]!='}'{s,o=P(s);if!o{return s,X};if s[0]=='}'{break};if s[0]!=';'{return s,X};N()};N();return s,Z}
if r,o:=C(s,&quot;func&quot;);o{s=r;T();if s[0]!='('{return s,X};N();for s[0]!=')'{s,o=P(s);if!o{return s,X};if s[0]==')'{break};if s[0]!=','{return s,X};N()};N();if len(s)&lt;1||M(`^[]});,\s]`).MatchString(s){return s,Z}
if s[0]=='('{N();for s[0]!=')'{s,o=P(s);if!o{return s,X};t++;if s[0]==')'{break};if s[0]!=','{return s,X};N()};if t&lt;1{return s,X};N()}
if M(`^[iufcmbrsc*[]`).MatchString(s){return P(s)};return s,len(s)&lt;1}
return s,X}
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=vVbNbuM2EL70Yj0FLXRj0mEMO5t1s9aqPQRYYA8JDDgLLKJoG0WRHNWy5IoUkEDSk_QSLLDv0GfpY_ReoDPUj2XHDoIealgkNTP8-HH-7D--zeOnP1eOu3DmHlk6QaQFy1WcSN1fSv17Kv2j079--KeU0YGeeHPvYaUbA13IJIjmQjc-62kUuPGdpzPNTyOXTKkgpZbRcua3cRyybMbP-RmX_Gpifh58EjM41uPnqZBn8XIVhB4_S-U08fzggQ_58MNIu-RfJiZiUpb5cUJCL6KC_Tw8OJjRJI08KqyhzVgmzMskWCo8EI0mNisK3r3SLprdl5QZwlQ6A9aFBoMW-BXih1GWeDJNIiL4lwLli4l5Tm--UiSep78Ekcz9MHYkfXucj09Y7gLj0Hug45N8dHzK8ttH6eVIKa9v_mNu2QUz-LWw2Q0bfAyiu5lSfYruYKNgxqJrRkF4cLCASwADpLewRvZRxdFoKF0pSnhX0-z1ezXXaX3XltbqZRewVdHXv1qjo_e2NYThUN9JAW-qWDSnw9kX67PhCFY8E-B5CY8n5hkVXF86K50ZMSAkylLw2JyW4N247VdjTdNWNIsXUN17J2pgAWkz4G3UyxfZQThSVzZIaFzR6Jq9rLeBhOwxzSpt0ctecxcwu008Z1G0gI1nwBterEO6polpuockfZEkex1JtoMk30OyVRZ5jlXQJDLk8bkj3fsyi8Ai252jtMzC19KUh4f_gSpo5WbhKjnSUKSD1HeXt4lw-9Z-4mWCNxj1vQutBVt3wb9Vd8MeSRnJtA5klrx_JBOTzFZhIOmN6jXQKniKAz6q79VNcGMqeyWttzCihrXMsqGurNLW3jKoXzUsErJ3QAsEKVsg2ZjsXUIN6WoKuGxv0Nq0Pr736w--WHZJCxaWrQRkNCQ2sYhtjY7f2qRPrHfjn5SAWKfvUdfH6lVsYEO9H1-JgkBDm7TE9bO2Vv5Agra6XK2sDKDGM1gapa2BdoVWyUmzQgui-vj4xCD9llRtWBtWE0qN9l5IpdK_jX8KEFaIsGzFrJwKrXLtntyortyEVQ03nOjX0P00reM7ofB25ZiyrHKpZt3otvxcqvdoC5VFdTY1sS1pA3EoQFTCAz_9iabuCv8RnHkQOckjyvuQCPB1xJ0_v_9tEWqWZZd5cTRqUgUSY3DybmxXvmpFhNfu2_ICDbZ9sZSDKaDJMKK6acJvPtYfLEDbwV7zKycSXZU4EfyZqcoTCrUjOIlRMaUSTDvQIbqxUqwxfaoHkRsniefKCXkjriMCH0eSN7_D8QDMicC9BfEgIlubkVC80JVew29bw54z_6iiupd5FfTdzP9P4lXre3oq538B" rel="nofollow noreferrer">Attempt This Online!</a></p>
<p>An <em>extremely</em> straight-forward recursive solution. The parser makes use of the fact that Go types are mainly right-recursive, with an unambiguous prefix determining the parser state.</p>
<p>Most definitely can be golfed down by using a different algorithm, or making it iterative.</p>
<p>(Fun fact: the builtin <code>go/parser</code> package fails some test cases due to the recursive anonymous <code>struct</code>s. It expects typenames or field names there. Though, in normal usage with gofmt, nested anonymous structs tends to not happen.)</p>
<ul>
<li>-2 bytes: account for &quot;dangling&quot; leftovers, move true/false into variables (@The Thonnu)</li>
</ul>
<h3>Ungolfed</h3>
<pre class="lang-go prettyprint-override"><code>func parse(s string) (string, bool) {
    trimSpace := func() {
        for len(s) &gt; 0 &amp;&amp; unicode.IsSpace(rune(s[0])) {
            s = strings.TrimSpace(s[1:])
        }
    }
    nextChar := func() {
        trimSpace()
        s = s[1:]
        trimSpace()
    }
    trimSpace()
    // false on empty
    if len(s) == 0 {
        return s, false
    }
    // primitive types
    if k := regexp.MustCompile(`^(bool|u?int|float(32|64)|complex(64|128)|byte|rune|string)($|[]});,\s])`).FindStringIndex(s); k != nil &amp;&amp; k[0] &lt; 1 {
        s = s[k[1]-1:]
        trimSpace()
        return s, true
    }
    // pointer
    if s[0] == '*' {
        return parse(s[1:])
    }
    // slice/array
    if s[0] == '[' {
        nextChar()
        // look for a positive int
        k := regexp.MustCompile(&quot;^[1-9][0-9]+&quot;).FindStringIndex(s)
        if k != nil {
            s = s[k[1]:]
            nextChar()
            return parse(s)
        }
        nextChar()
        // contained type
        return parse(s)
    }
    // maps
    if rest, ok := strings.CutPrefix(s, &quot;map&quot;); ok {
        s = rest
        nextChar()
        // key
        s, ok = parse(s)
        if !ok {
            return s, false
        }
        // account for primitive
        if s[0] == ']' {
            nextChar()
        }
        // value
        return parse(s)

    }
    // chan
    if rest, ok := strings.CutPrefix(s, &quot;chan&quot;); ok {
        s = rest
        // required space
        if !unicode.IsSpace(rune(s[0])) {
            return s, false
        }
        trimSpace()
        // contained type
        return parse(s)
    }
    // struct
    if rest, ok := strings.CutPrefix(s, &quot;struct&quot;); ok {
        s = rest
        trimSpace()
        if s[0] != '{' {
            return s, false
        }
        nextChar()
        // semicolon-separated list of types
        for s[0] != '}' {
            // type
            s, ok = parse(s)
            if !ok {
                return s, false
            }
            // when 1 type, next is a '}'
            if s[0] == '}' {
                break
            }
            // semicolon
            if s[0] != ';' {
                return s, false
            }
            nextChar()
        }
        nextChar()
        return s, true
    }
    // func
    if rest, ok := strings.CutPrefix(s, &quot;func&quot;); ok {
        s = rest
        trimSpace()
        // comma-separated args
        if s[0] != '(' {
            return s, false
        }
        nextChar()
        for s[0] != ')' {
            // type
            s, ok = parse(s)
            if !ok {
                return s, false
            }
            // when 1 type, next is a ')'
            if s[0] == ')' {
                break
            }
            // comma
            if s[0] != ',' {
                return s, false
            }
            nextChar()
        }
        nextChar()
        // return type
        // can be nothing, 1 type, or parened comma-separated types
        // nothing
        if len(s) == 0 || regexp.MustCompile(`^[]});,\s]`).MatchString(s) {
            return s, true
        }
        // multiple types
        if s[0] == '(' {
            nextChar()
            typeCount := 0
            for s[0] != ')' {
                // type
                s, ok = parse(s)
                if !ok {
                    return s, false
                }
                typeCount++
                // when 1 type, next is a ')'
                if s[0] == ')' {
                    // nextChar()
                    break
                }
                // comma
                if s[0] != ',' {
                    return s, false
                }
                nextChar()
            }
            // no non-empty paren return type
            if typeCount == 0 {
                return s, false
            }
            nextChar()
        }
        // 1 type
        if regexp.MustCompile(`^[iufcmbrsc*[]`).MatchString(s) {
            return parse(s)
        }
        return s, len(s) == 0
    }
    return s, false
}
</code></pre>
</div>
<div id="pu2" class="pu"><h1>JavaScript (ES6), 250 bytes</h1>
<p><em>Thanks to <a href="https://codegolf.stackexchange.com/users/106545/bbrk24">@Bbrk24</a> and <a href="https://codegolf.stackexchange.com/users/52194/value-ink">@Value Ink</a> for reporting bugs</em></p>
<p>Returns a Boolean value.</p>
<pre class="lang-javascript prettyprint-override"><code>f=(s,t)=&gt;s!=(s=s[R='replace'](T='T',t)[R](/chan |\[([1-9]\d*)?\]|map\[T\]/g,'*')[R](/\w \w/)[R](/ /,'')[R](/bool|u?int|float(32|64)|complex(64|128)|byte|rune|string|\*T|struct{(T(;T)*)?}|func\((T(,T)*)?\)(T|\(T(,T)*\)|(?=[,;})\]])|$)/,T))?f(s,T):s==T
</code></pre>
<p><a href="https://tio.run/##jVXbctowEH3nK7aZztjyOKEkKb0wbp7aD@j4TdaDMQKUGsmV5FBa8@2pLsYYGpMyY0va3XO82huP@VOuCskqfc3Fgj4/L5NQxRolX9Qbs0sU/p4EklZlXtCAhGkSpIFR4@8kHBfrnEOT4RBPrj@RbBGhh4w0m7zKcJqR8SoOosBbZlvItmO/h3EctOK5EGVTPzCum2Upch3e3TbTe9QUYlOV9Fc4vW8mtx9RM99p2sia00ZpyfiqyaLUbutC/wnTcJYi8@l9s6x5kYVGEDtBhsK0ydpjhprwIcHxbI8yQlDzFo2NGD0szW1T9FklSfpcCK5ESW9KsQoDnMpar3ckQLMRHgFcWWevYrsz/vpN66fx0Z@jThMdfp0EE@/74YTJUQWTd0AAA8GT2zsCEeD30w9OAPjjJ6uL7O29tYkvNtATOisDx2ghBM51h@eII/Zor0RcFg/K1sAG1mxn3nZm7faerVXC6dHagkvh9H4GUU/qoGfW7WJVsz5BhL0zx7DujbClNVvrZOu9X1pam/cQ9faGLa7tyz72M6gfkAGT0NvEJ0uf9YBD4F5HGSY9z84MDse2YNz1hl6dmaXzl4KThbwkPPcQxe3ShtafZn7Zo6sRGd0shfyaF@tQQfIF@mVv2gEhU/Gjk17IOP6Wl6rXDMZVuqLyKoaB33gMNf/BxZZDJdmGafZEnZ82m8OwYSDb5CvGc7kbAg8CuY4ufdACI9gyvQYuQO8q6hv0IsahNkwpk3IbQJ0zThc9dK4Wy9X68Uf5Mk3P2Q6DiR8JF75oWpspUydPeckWYLIIuZT5DkrKV3rtWK4n3WQYYuF0ldvo2IJThoFeZjQz6eb@/ZS0jfgPr2F0qtepjs0eH7r6lK0XVEU3rBCl4DCnekupmVF0M6fSxUv1@xi5Zn7h0v0UlcKtlXGR91zpOM6n6kvguTR/gkfwAHZ/ChYV5R04/ifrtvFfy/qBStKfNZOmzLZrpqmqWm8sBb6U9H5ULegM7yeDHSTDLnDBr@mm0jsfQb2miv02nkiqa@lvA4KXO1cw7y7XseWrTERdCVri31QKaCeK6mjMhaCb2el/ja3nvw" rel="nofollow noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a></p>
<h3>How?</h3>
<p>At each iteration:</p>
<ul>
<li><p>If we find a <code>&quot;T&quot;</code> and this is the first iteration, we replace it with <code>&quot;undefined&quot;</code> to invalidate the input.</p>
</li>
<li><p>We replace all occurrences of <code>/chan /</code>, <code>/\[([1-9]\d*)?\]/</code> and <code>/map\[T\]/</code> with <code>&quot;*&quot;</code>. They all boil down to a valid prefix of another type.</p>
</li>
<li><p>If we find <code>/\w \w/</code>, we replace it with <code>&quot;undefined&quot;</code> to invalidate the input.</p>
</li>
<li><p>If we find a space somewhere else, we remove it.</p>
</li>
<li><p>We then look for the first valid type and replace it with <code>&quot;T&quot;</code>:</p>
<ul>
<li>primitive types: <code>/bool|u?int|float(32|64)|complex(64|128)|byte|rune|string/</code></li>
<li>a type preceded with <code>*</code>: <code>/\*T/</code></li>
<li>a <code>struct</code> type: <code>/struct{(T(;T)*)?}/</code></li>
<li>a <code>func</code> type: <code>/func\((T(,T)*)?\)(T|\(T(,T)*\)|(?=[,;})\]])|$)/</code></li>
</ul>
</li>
</ul>
<p>The <code>func</code> type is the trickiest one because we must not ignore a <em>return</em> statement that is not yet fully simplified. That's why we make sure that <code>func(...)</code> is followed by either a valid <em>return</em> statement or the end of the line or one of <code>,;}]</code>.</p>
<p>This process is repeated recursively until there's nothing more to replace. If the input string is valid, we should end up with a single <code>&quot;T&quot;</code>.</p>
<h3>Example 1</h3>
<pre class="lang-go prettyprint-override"><code>func(int,uint,int,bool)(string,string,string)
func(T,uint,int,bool)(string,string,string)
func(T,T,int,bool)(string,string,string)
func(T,T,T,bool)(string,string,string)
func(T,T,T,T)(string,string,string)
func(T,T,T,T)(T,string,string)
func(T,T,T,T)(T,T,string)
func(T,T,T,T)(T,T,T)
T
</code></pre>
<h3>Example 2</h3>
<pre class="lang-go prettyprint-override"><code>map[map[map[int]string]map[bool]chan map[int]int]struct{int;string;bool}
map[map[map[T]string]map[bool]*map[int]int]struct{int;string;bool}
map[map[*T]map[bool]*map[int]int]struct{int;string;bool}
map[map[T]map[bool]*map[int]int]struct{int;string;bool}
map[*map[T]*map[int]int]struct{int;string;bool}
map[***map[T]int]struct{int;string;bool}
map[****T]struct{int;string;bool}
map[***T]struct{int;string;bool}
map[**T]struct{int;string;bool}
map[*T]struct{int;string;bool}
map[T]struct{int;string;bool}
*struct{T;string;bool}
*struct{T;T;bool}
*struct{T;T;T}
*T
T
</code></pre>
</div>
<div id="pu3" class="pu"><h2>Regex (PCRE), 241 bytes</h2>
<pre><code>^(bool|u?int|float(32|64)|complex(64|128)|byte|rune|string|&amp;\s*(?1)|\*\s*(?1)|\[\s*\d*\s*\]\s*(?1)|map\s*\[\s*(?1)\s*\]\s*(?1)|chan (?1)|struct\s*\{\s*(|((?1);\s*)*\s*(?1)\s*;?\s*)\}|func\(\s*(((?1),\s*)*(?1),?\s*)?\)\s*(\s*(?1)|\((?6)\))?)$
</code></pre>
<p>Fixed to handle <code>func()()</code> case</p>
<p><a href="https://regex101.com/r/vanW2f/1" rel="noreferrer">Try it on regex 101</a></p>
</div>
<div id="pu4" class="pu"><h1><a href="https://raku.org/" rel="nofollow noreferrer">Raku</a>, <s>205</s> 193 bytes</h1>
<pre><code>*~~/^$(/:s \s*[bool|u?int|float[32|64]|complex[64|128]|byte|rune|string|\*&lt;~~&gt;|\[
\d* \]&lt;~~&gt;|map \[&lt;~~&gt;\]&lt;~~&gt;|chan\s+&lt;~~&gt;|struct \{ &lt;~~&gt;*%\; \}|func \(&lt;~~&gt;*%\,\)[&lt;~~&gt;|
\( &lt;~~&gt;*%\, \) ]?]\s*/)$/
</code></pre>
<p><a href="https://tio.run/##dVJtU@JADP7ur8g4eLRrlQOxp/ZOfshujqnYIh60TF9mjmHLX8fNvtBWhZnuJk@ehOTZbJNiHR43O/iRwp8jOxxGfwfe6KkEUTL@kudrWc9WWSXTdR5X/G4iwynKRb7ZrpP/PJzK8eQB5cuuSmRRZ4ksq2KVLaVgvw@HZyn4hXhlIFB7m3gLgpNpgcVbnInyWtsqsV5UIPZALrsSEYhGpnW2AOFZKBC@TpcXwnO0AIQPOEPV7sgfjI4RlPEOLvez1BvM/eYJBvNLSPMChjTMMIChmoYuO4PqnzxmUeZ@1udoJjI2RwfD@CcgcEA@ntwhMOD34S8NAH94pBgjPYirxuYqrVOIENC1iI7Qj7ivzUFyqX0kxcAFLUHJtldmZLgR8RqqZUPQdYgH@inDaQSsg@q0HtdeFIi66YybNloBGwXaosqk9mzf5tJF6SU9/2SpSkFNB330F34rwhmCZxhB72oruiwf9NFiHDsdfSI4Vy@EHurcYUlUyowCvQu/A@22Jcuk0G2SRBrbxMtVFhc7S2Bmu8wZl6/p8u39n95VzvG0cjfj7i6qtbud3odode@/ceBeoyunrzVtS1j6Kfx1Tw3jDKFxmlF/xw8" rel="nofollow noreferrer" title="Perl 6 – Try It Online">Try it online!</a></p>
<p>This is an anonymous function that matches its argument against the giant regex following the leftmost <code>~~</code>.  That regex is of the form</p>
<pre><code>/^$(/.../)$/
</code></pre>
<p>It interpolates the inner regex <code>$(/.../)</code> into the outer one.  The outer regex requires that the overall match be anchored at the beginning and end of the string.</p>
<p>The inner regex matches a Go type.  It is recursive, calling itself using the expression <code>&lt;~~&gt;</code>.</p>
</div>
<div id="pu5" class="pu"><h1><a href="https://bnfc.readthedocs.io/" rel="noreferrer">BNFC</a> + <a href="https://www.haskell.org" rel="noreferrer">Haskell</a> + <a href="https://www.gnu.org/software/bash/" rel="noreferrer">Bash</a> + coreutils, 175 + 96 = 271 bytes</h1>
<pre><code>bool&quot;
int&quot;
uint&quot;
float32&quot;
float64&quot;
complex64&quot;
complex128&quot;
byte&quot;
rune&quot;
string&quot;
*&quot;T
[&quot;&quot;]&quot;T
[&quot;Integer&quot;]&quot;T
map&quot;&quot;[&quot;T&quot;]&quot;T
chan &quot;T
struct&quot;&quot;{&quot;[T]&quot;}&quot;
Q
QT
Q&quot;(&quot;[T2]&quot;)&quot;Z2&quot;,&quot;Z&quot;;&quot;;_.T2::=T
</code></pre>
<p>Compile with</p>
<pre class="lang-bash prettyprint-override"><code>sed 's/Q/func&quot;&quot;(&quot;[T2]&quot;)&quot;/g;s/Z/;separator T/g'|awk '{print&quot;A&quot;NR&quot;.T::=\&quot;&quot;$0&quot;;&quot;}'&gt;g;bnfc -m g;make
</code></pre>
<p>Produces an executable named <code>TestG</code> which accepts input from <code>stdin</code> and exits with code <code>0</code> if the parse was successfull, <code>1</code> otherwise.</p>
<p>Possibly can be golfed more with a better use of sed and awk.</p>
<hr />
<p>Script to test it:</p>
<pre class="lang-bash prettyprint-override"><code>cat truthy falsy | sed &quot;s|//.*||&quot; | xargs -d &quot;\n&quot; -I {} sh -c 'echo &quot;{}&quot; | ./TestG &gt;/dev/null ; echo $? &quot;{}&quot;'
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/263827/">263827</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




