<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::198779</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>008</td><td>Itr</td><td>230808T054206Z</td><td><a href="https://codegolf.stackexchange.com/questions/198779/computing-a-specific-coefficient-in-a-product-of-polynomials/263862#263862">bsoelch</a></td></tr>
<tr d-ix="1"><td>023</td><td>05AB1E</td><td>200204T131409Z</td><td><a href="https://codegolf.stackexchange.com/questions/198779/computing-a-specific-coefficient-in-a-product-of-polynomials/198941#198941">Kevin Cr</a></td></tr>
<tr d-ix="2"><td>016</td><td>Brachylog</td><td>200518T080751Z</td><td><a href="https://codegolf.stackexchange.com/questions/198779/computing-a-specific-coefficient-in-a-product-of-polynomials/204903#204903">Unrelate</a></td></tr>
<tr d-ix="3"><td>006</td><td>Sledgehammer</td><td>200517T152621Z</td><td><a href="https://codegolf.stackexchange.com/questions/198779/computing-a-specific-coefficient-in-a-product-of-polynomials/204870#204870">the defa</a></td></tr>
<tr d-ix="4"><td>029</td><td>Pari/GP</td><td>200226T074737Z</td><td><a href="https://codegolf.stackexchange.com/questions/198779/computing-a-specific-coefficient-in-a-product-of-polynomials/200137#200137">alephalp</a></td></tr>
<tr d-ix="5"><td>068</td><td>R</td><td>200225T171944Z</td><td><a href="https://codegolf.stackexchange.com/questions/198779/computing-a-specific-coefficient-in-a-product-of-polynomials/200104#200104">Giuseppe</a></td></tr>
<tr d-ix="6"><td>018</td><td>J</td><td>200202T043141Z</td><td><a href="https://codegolf.stackexchange.com/questions/198779/computing-a-specific-coefficient-in-a-product-of-polynomials/198795#198795">Jonah</a></td></tr>
<tr d-ix="7"><td>016</td><td>Husk</td><td>200204T152005Z</td><td><a href="https://codegolf.stackexchange.com/questions/198779/computing-a-specific-coefficient-in-a-product-of-polynomials/198947#198947">Kevin Cr</a></td></tr>
<tr d-ix="8"><td>015</td><td>Jelly</td><td>200202T083236Z</td><td><a href="https://codegolf.stackexchange.com/questions/198779/computing-a-specific-coefficient-in-a-product-of-polynomials/198799#198799">Nick Ken</a></td></tr>
<tr d-ix="9"><td>007</td><td>Jelly</td><td>200202T011858Z</td><td><a href="https://codegolf.stackexchange.com/questions/198779/computing-a-specific-coefficient-in-a-product-of-polynomials/198784#198784">Jonathan</a></td></tr>
<tr d-ix="10"><td>042</td><td>Haskell</td><td>200202T020642Z</td><td><a href="https://codegolf.stackexchange.com/questions/198779/computing-a-specific-coefficient-in-a-product-of-polynomials/198786#198786">xnor</a></td></tr>
<tr d-ix="11"><td>015</td><td>MATL</td><td>200202T032145Z</td><td><a href="https://codegolf.stackexchange.com/questions/198779/computing-a-specific-coefficient-in-a-product-of-polynomials/198788#198788">Luis Men</a></td></tr>
<tr d-ix="12"><td>055</td><td>JavaScript Node.js</td><td>200202T033046Z</td><td><a href="https://codegolf.stackexchange.com/questions/198779/computing-a-specific-coefficient-in-a-product-of-polynomials/198789#198789">tsh</a></td></tr>
<tr d-ix="13"><td>067</td><td>Python</td><td>200202T022756Z</td><td><a href="https://codegolf.stackexchange.com/questions/198779/computing-a-specific-coefficient-in-a-product-of-polynomials/198787#198787">xnor</a></td></tr>
<tr d-ix="14"><td>131</td><td>Python 2</td><td>200202T005805Z</td><td><a href="https://codegolf.stackexchange.com/questions/198779/computing-a-specific-coefficient-in-a-product-of-polynomials/198783#198783">Chas Bro</a></td></tr>
<tr d-ix="15"><td>052</td><td>Charcoal</td><td>200202T011924Z</td><td><a href="https://codegolf.stackexchange.com/questions/198779/computing-a-specific-coefficient-in-a-product-of-polynomials/198785#198785">Neil</a></td></tr>
<tr d-ix="16"><td>020</td><td>Mathematica</td><td>200202T001031Z</td><td><a href="https://codegolf.stackexchange.com/questions/198779/computing-a-specific-coefficient-in-a-product-of-polynomials/198780#198780">RGS</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://github.com/bsoelch/OneChar.js/blob/main/ItrLang.md" rel="nofollow noreferrer">Itr</a>, 8  bytes</h1>
<p><code>##C*µS#@</code></p>
<p>Input: two list of coefficients for the polynomials followed by the index of the coefficents</p>
<p><a href="https://bsoelch.github.io/OneChar.js/?lang=Itr&amp;src=IyNDKrVTI0A=&amp;in=WzEsMyw1XSBbNSwzLDJdIDI=" rel="nofollow noreferrer">online interpreter</a></p>
<h2>Explanation</h2>
<pre><code>##       ; read the two coefficient lists for standard input
  C*µS   ; multiply them as polynomials
  C*     ; go through the diagonals of the Cartesian product, multiplying the two elements in the pairs
    µS   ; sum up the diagonals
      #@ ; get int specified coefficient
         ; implicit output
</code></pre>
</div>
<div id="pu1" class="pu"><h1><a href="https://github.com/Adriandmen/05AB1E/wiki/Commands" rel="nofollow noreferrer">05AB1E</a>, <s>32</s> <s>24</s> 23 <a href="https://github.com/Adriandmen/05AB1E/wiki/Codepage" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>Å»δ*εā_«N(._}øO}θIÅ0«Iè
</code></pre>
<p>Definitely not the right language to use for this challenge (no builtins for convolution, polynomials, getting all diagonals of a matrix, etc.).. But with some -rather long- workarounds, it still works (although is too slow for the last test cases).</p>
<p>Input as a list of list of coefficients where index encodes exponent, as well as the integer <span class="math-container">\$k\$</span> as second input.</p>
<p>Inspired by <a href="https://codegolf.stackexchange.com/a/198795/52210"><em>@Jonah</em>'s J answer</a>.<br />
-8 bytes by porting two approaches I've used in <a href="https://codegolf.stackexchange.com/a/198947/52210">my Husk answer</a>.</p>
<p><a href="https://tio.run/##yy9OTMpM/f//cOuh3ee2aJ3beqQx/tBqPw29@NrDO/xrz@3wPNxqcGi15@EV//9HRxvqGOuYxupEmwJpo9hYLmMA" rel="nofollow noreferrer">Try it online</a> or <a href="https://tio.run/##yy9OTMpM/V9Waa@k8KhtkoKSfeX/w62Hdp/bonVu65HG@EOr/dwON9bWHt7hX3tux3@d/9HR0YY6xjqmsTrRpkDaKDZWRwFdSAfIB0PskgY6IGgSGxsLAA" rel="nofollow noreferrer">verify some more test cases (outputs all coefficients without the indexing part)</a>.</p>
<p><strong>Explanation:</strong></p>

<pre class="lang-python prettyprint-override"><code>Å»        # Left reduce the (implicit) input-list of lists of integers by:
          #  1) Calculate the multiplication table of the current two lists:
  δ       #   Apply double-vectorized:
   *      #    Multiply
          #  2) Take the sums of each diagonal:
  ε       #   Map each inner list to:
   ā      #    Push a list in the range [1,list-length] (without popping the list itself)
    _     #    Convert each to 0, so we'll have a list of 0s of the same length
     «    #    Append this list of 0s to the current list
      NF  #    Loop the 0-based map-index amount of times:
        Á #     And rotate the current list that many times towards the right
  }}      #   End the loop and map
    ø     #   Zip/transpose; swapping rows/columns
          #   (We now have a list of all diagonals)
     O    #   And take the sum of each inner list
}θ        # After the reduce-by is done, pop and push the final resulting list
  ∞_«     # Append an infinite amount of trailing 0s
     Iè   # And then use the second input to (0-based) index into this list
          # (after which the result is output implicitly)
</code></pre>
</div>
<div id="pu2" class="pu"><h1><a href="https://github.com/JCumin/Brachylog" rel="nofollow noreferrer">Brachylog</a>, 16 bytes</h1>

<pre><code>⟨∋ᵐ{tᵐ+}⟩ᶠhᵐ²×ᵐ+
</code></pre>

<p><a href="https://tio.run/##SypKTM6ozMlPN/pfXa6koGunoFRu/6htw6Ompoe7Omsfbp3w/9H8FY86uoGs6hIgoV37aP7Kh9sWZADZhzYdng4S@v8/WiEaCAx1DGJ1oo11DIGkqY5RbKwOUNgUSdAIJAgUNQDLkKDBkFQNRqRqMCZVgwmpGkxRNIBEdaJNdEwgGhBcnWgLHQuIIIKrE21opmNoBjbHjErmmFPJHAsqmWNJJXMMqeUxQ2r5zJBaXjMyiFWIBQA" rel="nofollow noreferrer" title="Brachylog – Try It Online">Try it online!</a></p>

<p>Takes input as a list of lists of <code>[coefficient, exponent]</code> pairs, paired with <code>k</code>. Could be trivially modified to accept index-as-exponent coefficient lists by replacing <code>∋</code> with <code>i</code>, which is in fact what I did originally before I made an error writing out the test cases and switched for my own convenience.</p>

<pre><code>⟨       ⟩           Call the first element of the input L and the last element k.
         ᶠ          Find every
 ∋                  selection of a [coefficient, exponent] pair
  ᵐ                 from each polynomial in L
   {   }            such that k is
      +             the sum of
    tᵐ              the exponents.
          hᵐ²       Extract the coefficients from each selection,
             ×ᵐ     multiply the coefficients extracted from each selection,
               +    and output the sum of the products.
</code></pre>

<p><a href="https://tio.run/##SypKTM6ozMlPN/pfXa6koGunoFRu/6htw6Ompoe7Omsfbp3wv/rR/BWPOrqBzOoSIKFd@2j@ygwg4/D02ofbFmj//x@tEA0EhjoGsTrRxjqGQNJUxyg2VgcobIokaAQSBIoagGVI0GBIqgYjUjUYk6rBhFQNpigaQKI60SY6JhANCK5OtIWOBUQQwdWJNjTTMTQDm2NGJXPMqWSOBZXMsaSSOYbU8pghtXxmSC2vGRnEKsQCAA" rel="nofollow noreferrer" title="Brachylog – Try It Online"><code>{⟨∋ᵐ{tᵐ+}⟩hᵐ×}ᶠ+</code></a> is an equally valid solution at the same length, but I'm not sure I remember ever superscripting <code>ᵐ</code> before this, so I'm just going with the version that does that.</p>
</div>
<div id="pu3" class="pu"><h1>Sledgehammer, 6 bytes</h1>
<pre><code>⣈⠲⡎⡒⢢⣑
</code></pre>
<p>Only works in the interactive app (that requires excessive amounts of tinkering to get it to actually decompress the Braille code itself, but it's possible), because of a bug where the console app doesn't call <code>postprocess</code> and ends up replacing all occurrences of <code>#, #1, #2, ##</code> by <code>s1, s2, s3, ss1</code>.</p>
<p>Accepts input as, for example, <code>{&quot;(1 + 2x1^2 + 4x1^4)(2x1^2 + 4x1^4 + 8x1^8)(4x1^4 + 8x1^8 + 16x1^16)&quot;, 20}</code> - <code>x1</code> is the variable the first undefined variable used gets replaced with.</p>
<p>Obtained from the Mathematica code <code>Coefficient[ToExpression@#, z, #2]</code> (where <code>ToExpression</code> is <code>eval</code> and <code>Coefficient</code> simply gets the right coefficient, and <code>z</code> gets replaced by <code>x1</code> as part of the compression).</p>
</div>
<div id="pu4" class="pu"><h1><a href="http://pari.math.u-bordeaux.fr/" rel="nofollow noreferrer">Pari/GP</a>, 29 bytes</h1>

<pre><code>f(k,p)=polcoeff(vecprod(p),k)
</code></pre>

<p><a href="https://tio.run/##rY/NCoMwEIRfZfGU2Agm/tQe2hcJKYg1RSp1kVDs06erlBZvOeSyszt8zDLYzkN2R@8tewjkZ5zGbuqtZa@@w3m6MeTiwX2LOL6Zg@wCOA9Px7TT0ghwWhkDyeonYNnf5FyA1jkNCQco0oVmlS5XJaD6GWo1jFmhUFCFgkUoWIaCVShYf8HNIS1J6cvuJG1IG7E/SWVNi6y3pGO0pCZa0ilakoxXT8brJ@MVVHmcKMP9Bw" rel="nofollow noreferrer" title="Pari/GP – Try It Online">Try it online!</a></p>
</div>
<div id="pu5" class="pu"><h1><a href="https://www.r-project.org/" rel="nofollow noreferrer">R</a>, 68 bytes</h1>



<pre class="lang-r prettyprint-override"><code>function(P,k)Re(Reduce(function(x,y)convolve(x,y,,"o"),P,!0:k)[k+1])
</code></pre>

<p><a href="https://tio.run/##K/qfpmCj@z@tNC@5JDM/TyNAJ1szKFUjKDWlNDlVAy5coVOpmZyfV5afU5YK4ujoKOUraeoE6CgaWGVrRmdrG8Zq/k/TyMksLtFI1jDVMdYx1NRJ1jACMkw1NXUMNP8DAA" rel="nofollow noreferrer" title="R – Try It Online">Try it online!</a></p>

<p>Convolution is the key to success here, too, since it's a port of <a href="https://codegolf.stackexchange.com/a/198788/67312">Luis' answer</a>.</p>

<p>Takes input as a <code>list()</code> of vectors <code>c()</code> of coefficients in <em>decreasing</em> order, because R's convolve documentation says:</p>

<blockquote>
  <p>Note that the usual definition of convolution of two sequences <code>x</code> and <code>y</code> is given by <code>convolve(x, rev(y), type = "o")</code>.</p>
</blockquote>
</div>
<div id="pu6" class="pu"><h1><a href="http://jsoftware.com/" rel="nofollow noreferrer">J</a>, <sup><s>21</s></sup> <sup><s>19</s></sup> 18 bytes</h1>

<pre><code>{ ::0[:+//.@(*/)/&gt;
</code></pre>

<p><a href="https://tio.run/##rZHBCsIwEETvfsXgpVZts5u0MaYoguDJk1ePYhEvfoAfH5O0SoUcQ9gw2bfMDuTp5nXRY2dRYA2C9VXVOF7OJ/eGtXS1KyHqw2IpSrF35ex@e7zQogqDPRjKPzpfCnJgbALkL/xjSgcmk0xyYCrJmAJrkiyiNoliEh0R@a2EpvPXKKMimG4Uk9avMxzWk02bbHZKBj@TN942mx3raMj5AirTxO@nDI7uAw" rel="nofollow noreferrer" title="J – Try It Online">Try it online!</a></p>

<p><em>-1 byte thanks to FrownyFrog</em></p>

<p>J has a nice geometric idiom for multiplying polynomials, which we 
represent as lists of coefficients, with explicit zeroes where needed:</p>

<pre><code>+//.@(*/)
</code></pre>

<p>Let's see how this works using the example:</p>

<pre><code>1 3 5 +//.@(*/) 5 3 2
</code></pre>

<p>First it creates a multiplication table <code>*/</code>:</p>

<pre><code> 5  3  2
15  9  6
25 15 10
</code></pre>

<p>And <code>@:</code> then it computes the sums along each diagonal <code>+//.</code> using the Oblique <code>/.</code> adverb:</p>

<p><a href="https://i.stack.imgur.com/XEQMf.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/XEQMf.png" alt="diagonals"></a></p>

<p>This works because moving down a diagonal is equivalent to decrementing the
power of one <em>x</em> while incrementing the power of another, meaning that the
numbers along a diagonal represent all the components of some a factor <code>x^n</code>
for some <code>n</code>.</p>

<p>The rest of the solution is just mechanics for the problem as stated:</p>

<pre><code>{ ::0[: &lt;polynomial idiom&gt; /&gt;
</code></pre>

<p>Since we can have an arbitrary number of polynomials, we represent them as a list of boxes (each box containing one polynomial) and take that as the right arg.  The left arg is the index we want.</p>

<p>Now <code>{ ::0 ...</code> is a dyadic hook asking for the index specified by the left arg, after transforming the right arg by everything in <code>...</code>.  And, if you can't find the index, return 0 <code>::0</code>.</p>

<p>Finally <code>[: &lt;polynomial idiom&gt; /&gt;</code> says to first unbox <code>&gt;</code> the right arg lists, filling any missing coefficients with 0.  Then reduce <code>/</code> that list using the polynomial multiplication idiom.</p>
</div>
<div id="pu7" class="pu"><h1><a href="https://github.com/barbuz/Husk/wiki/Commands" rel="nofollow noreferrer">Husk</a>, <s>18</s> 16 <a href="https://github.com/barbuz/Husk/wiki/Codepage" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>!→⁰+→G(mΣ∂Ṫ*)²∞0
</code></pre>
<p>First Husk answer. This took so much longer to complete than I thought it would. I'm glad there is <a href="https://github.com/barbuz/Husk/wiki/Tutorial" rel="nofollow noreferrer">a tutorial</a> with good explanation of how the input-order and super-numbers work, otherwise I had to give up. I never programmed in Haskell, and maybe I'm just too used to the left-to-right stack-based 05AB1E, but Husk isn't exactly straight-forward due to its strong-typed nature and right-to-left execution (including input-arguments) imho..<br />
But, it works, which is what counts in the end. :)</p>
<p>First input-argument is a list of lists of coefficients where index encodes exponent, like the third input example in the challenge description. Second argument is the coefficient integer <span class="math-container">\$k\$</span>.</p>
<p><a href="https://tio.run/##yygtzv7/X/FR26RHjRu0gZS7Ru65xY86mh7uXKWleWjTo455Bv///4@ONtQx0DECYpNYnWgDGFvHAAwtoGIGyGI6BijQ0Cw29r@RAQA" rel="nofollow noreferrer">Try it online.</a></p>
<p><strong>Explanation:</strong></p>

<pre class="lang-python prettyprint-override"><code>             ²    # Use the first argument,
     G(     )     # and left-reduce it by:
          Ṫ       #  Apply double-vectorized:
           *      #   Multiply
                  #  (This basically results in the multiplication table of the lists)
         ∂        #  Take the diagonals of this multiplication table
       m          #  Map over these diagonal-lists:
        Σ         #   And sum each together
    →             # Only leave the last list after the reduce-by
              ∞0  # Push an infinite list of 0s: [0,0,0,...]
   +              # Merge the two lists together
  ⁰               # Push the second argument `k`
 →                # Increase it by 1 (since Husk uses 1-based indexing instead of 0-based)
!                 # And use it to index into the list we created
                  # (after which the result is output implicitly)
       
                  
</code></pre>
</div>
<div id="pu8" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="nofollow noreferrer">Jelly</a>, <s>19</s> 15 bytes</h1>

<pre><code>×þŒJ§SƙFƲ¥/ṫ‘}Ḣ
</code></pre>

<p><a href="https://tio.run/##y0rNyan8///w9MP7jk7yOrQ8@NhMt2ObDi3Vf7hz9aOGGbUPdyz6/z/aUMdYxzRWJ9oUSBvFgvgGOkZAbAIUM4CxdQzA0AIqZoAspmOAAg3NYv8bGQAA" rel="nofollow noreferrer" title="Jelly – Try It Online">Try it online!</a></p>

<p>A dyadic link taking <code>k</code> as the left argument and the list of polynomials as a list of lists of coefficients as the right argument. Returns an integer. If <code>k</code> could be 1-indexed, <code>‘}</code> could be deleted for 13 bytes. </p>

<p>Adapted to use @JonathanAllan’s revised method for dealing with larger <code>k</code>; be sure to upvote his (still shorter) answer too!</p>
</div>
<div id="pu9" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="nofollow noreferrer">Jelly</a>, <s>&nbsp;22 17&nbsp;</s> 7 <a href="https://github.com/DennisMitchell/jelly/wiki/Code-page" rel="nofollow noreferrer">bytes</a></h1>

<p>-10 bytes by realising I'd implemented convolution - go upvote <a href="https://codegolf.stackexchange.com/a/198788/53748">Luis Mendo's MATL answer</a> too, as that was what made me realise this.</p>

<pre><code>æc/ṫ‘}Ḣ
</code></pre>

<p>A dyadic link accepting a list of coefficient lists on the left and the exponent on the right.</p>

<p><strong><a href="https://tio.run/##y0rNyan8///wsmT9hztXP2qYUftwx6L///9HRxvqKBjrKJjG6ihEm4KZRrGx/00B" rel="nofollow noreferrer" title="Jelly – Try It Online">Try it online!</a></strong> Or see the <a href="https://tio.run/##y0rNyan8///wsmT9hztXP2qYUftwx6L/h5frP2pa8/9/NBAY6igY6yiYxuooRJuCmUaxQLZBLJcOTklDfJJG@CSN8Uma4JM0hUka6BgBsQlI2gDG0TEAQwuYoAGyoI4BCjQ0AxlnRl3jzKlrnAV1jbOkrnGGVPatIZW9a0hl/xoZxMb@NwMA" rel="nofollow noreferrer" title="Jelly – Try It Online">test suite</a>.</p>

<h3>How?</h3>

<pre><code>æc/ṫ‘}Ḣ - Link: list of lists, Ps; integer, E
  /     - reduce (Ps) by:
æc      -   convolution
     }  - use right argument (E) for:
    ‘   -   increment -&gt; E+1
   ṫ    - tail from (1-indexed) index (E+1)
      Ḣ - head (if given an empty list yields 0)
</code></pre>

<hr>

<p>The 17 (without the convolution atom) was:</p>

<pre><code>×€Œd§ṙLC${Ṛð/ṫ‘}Ḣ
</code></pre>
</div>
<div id="pu10" class="pu"><h1><a href="https://www.haskell.org/" rel="nofollow noreferrer">Haskell</a>, 42 bytes</h1>



<pre class="lang-hs prettyprint-override"><code>n%((h:t):l)=h*n%l+(n-1)%(t:l)
0%[]=1
_%_=0
</code></pre>

<p><a href="https://tio.run/##VY3BCgIhFEX3fsVbJGjp8BwiYsgvERlkqBxyHtK47NszCQaKw13cs7g3hvVxTalW4kLEocghSRv3xNNBkDaSi9IMQ@68NWzko8WawIJzRqHqW45egcOtKPxy3iT@SoV/mJP3bAkztb38nKnADlx7hhfQRTvsuh69r@/plsJ9rXrK@QM" rel="nofollow noreferrer" title="Haskell – Try It Online">Try it online!</a></p>

<p>An infix function taking a number <code>n</code> and a lists of lists of coefficients with lowest exponents first.</p>

<p>Here's the key recursive idea. Instead of actually multiplying out the polynomials to get one big polynomial, we only just try to extract the coefficient. Algorithmically, this isn't faster than multiplying out coefficient, but in terms of brevity, it saves us from needing to product lists for the intermediate or final product.</p>

<p>When multiply <span class="math-container">\$p(x)\cdot q(x)\$</span>, we can split up <span class="math-container">\$p(x)\$</span> into its constant and remaining terms as <span class="math-container">\$p(x)=p_0(x) +x \cdot p_{\mathrm{rest}}(x)\$</span>. Then, the coefficient of <span class="math-container">\$x^n\$</span> in <span class="math-container">\$p(x)\cdot q(x)\$</span> can be written as:</p>

<p><span class="math-container">$$
\begin{align}
[p(x)\cdot q(x)]_n &amp;= [(p_0 +x \cdot p_{\mathrm{rest}}(x)) \cdot q(x)]_n \\
&amp;= [p_0 \cdot q(x)]_n + [x \cdot p_{\mathrm{rest}}(x) \cdot q(x)]_n \\
&amp;= p_0 \cdot q(x)_n + [p_{\mathrm{rest}}(x) \cdot q(x)]_{n-1} \\
\end{align}
$$</span></p>

<p>We can continue expanding this out recursively until we get <span class="math-container">\$p=0\$</span>, where the remaining result is zero. If <span class="math-container">\$q(x)\$</span> is itself expressed as a product of polynomials, we continue to extract coefficients from there. The base case is that the empty product is <span class="math-container">\$1\$</span>, so its <span class="math-container">\$x^0\$</span> coefficient is <span class="math-container">\$1\$</span> and the rest are zero.</p>
</div>
<div id="pu11" class="pu"><h1><a href="https://github.com/lmendo/MATL" rel="noreferrer">MATL</a>, <s>18</s> 15 bytes</h1>

<pre><code>Y:iWB1G"Y+]2GQ)
</code></pre>

<p>Input is a cell array of numerical vectors with the polynomial coefficients, followed by an integer (<code>k</code>).</p>

<p><a href="https://tio.run/##y00syfn/P9IqM9zJ0F0pUjvWyD1Q8///6mhDBWMF01iFaFMgbRRby2UAAA" rel="noreferrer">Try it online!</a> Or <a href="https://tio.run/##y00syfmf8D/SKjPcydBdKVI71sg9UPO/S1RFyP/qaEMFYwXTWIVoUyBtFFvLZcCFKWaIRcwIi5gxFjETLGKmYDEDBSMgNgGKG8DYCgZgaAEVM0AWUzBAgYZmQIPMqGWQObUMsqCWQZbUMsiQan4zpJrnDKnmOyMDLgA" rel="noreferrer">verify all test cases</a>.</p>

<h3>Explanation</h3>

<p>Polynomial multiplication is convolution of their coefficients. And</p>

<blockquote>
  <p><a href="https://codegolf.stackexchange.com/a/79313/36398">convolution is the key to success</a></p>
</blockquote>

<pre><code>Y:     % Implicit input: cell array of numeric vectors. Unbox into its constituents
iWB    % Input k. 2 raised to that. Convert to binary. Gives [1 0...0] with k zeros
1G     % Push first input (cell array of numeric vectors) again
"      % For each. This runs n iterations, where n is the number of polynomials
  Y+   %   Convolution
]      % End
       % The first convolution uses one of the polynomials in the input and the
       % [1 0...0] vector. This doesn't alter the actual coefficients, but adds k 
       % zeros. Thus the final product polynomial will contain k zeros after the
       % highest-degree nonzero coefficient. This ensures that k doesn't exceed
       % the number of existing coefficients
2G     % Push second input (k) again
Q      % Add 1
)      % Index. This retrieves the k-th degree coefficient. Implicit display
</code></pre>
</div>
<div id="pu12" class="pu"><h1><a href="https://nodejs.org" rel="nofollow noreferrer">JavaScript (Node.js)</a>, 55 bytes</h1>



<pre class="lang-javascript prettyprint-override"><code>f=(k,[p,...t],s=0)=&gt;p?p.map((n,i)=&gt;s+=f(k-i,t)*n)&amp;&amp;s:!k
</code></pre>

<p><a href="https://tio.run/##tZBNCsIwEEb33sJNSXQaktbWKkQPErIotZXamgRTvH4MRcGCiywMwzA/PN7iu9XP2jaP3kyp0pfWuY6jAYQBQsgkwXKK@cmcDbnXBiEFvT/tlndoSHuY8EbhJLHH9eAaraweWzLqK@oQBSEY5FBIEIWfmZQYr5YMC2CyACYPYHYBTBHAlDNDIfO98xz97EDnqt4/@v0DuihW/hDvY4mrWOJDLDGLlgWLFgaLlkZG/2Z2Lw" rel="nofollow noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a></p>

<p>The first argument is <code>k</code>. The second argument is "a list of lists of coefficients where index encodes exponent", like <code>[[1, 3, 5], [5, 3, 2]]</code>.</p>
</div>
<div id="pu13" class="pu"><h1><a href="https://docs.python.org/2/" rel="nofollow noreferrer">Python</a>, 67 bytes</h1>



<pre class="lang-python prettyprint-override"><code>f=lambda n,p,*q:p&gt;[]and(f(n,*q)if q else n==0)*p[0]+f(n-1,p[1:],*q)
</code></pre>

<p><a href="https://tio.run/##VY7NCsIwEITP5in22NQVNkFECvEN@gQhh0gTLdRt@nPx6WMsFJRhDvPNHCa91@fIOudoBv@6dx4YE9ZTk27Wee6qWHGJso8wQRiWAGwMyTpZcsfSnRQmqxr33eTWWKuQUBefHYKlPSBtuu6QfiHSn9TFOSHiOANDzzB7foRKK9mIQ5p7XmG71Mr8AQ" rel="nofollow noreferrer" title="Python 2 – Try It Online">Try it online!</a></p>

<p>Takes input like <code>f(3,[1,2,3],[4,5,6])</code>, with the polynomials as separate arguments. The idea for the recursion if the same as in my <a href="https://codegolf.stackexchange.com/a/198786/20260">Haskell answer</a>. But, since Python doesn't have as nice pattern matching, we need to check for empty lists explicitly.</p>
</div>
<div id="pu14" class="pu"><h1><a href="https://docs.python.org/2/" rel="nofollow noreferrer">Python 2</a>, <s>139</s> 131 bytes</h1>



<pre class="lang-python prettyprint-override"><code>lambda k,L:sum(reduce(lambda a,(i,c):a*c[i],zip(p,L),1)for p in product(*map(range,map(len,L)))if sum(p)==k)
from itertools import*
</code></pre>

<p><a href="https://tio.run/##dU9BboMwEDzXr9gbNuwBEyAEib4gP3BBcgm0VgBbDpFoP09t2lT0UK2snRnt7ozNx/yup2Ttq5d1kOPrRcIVz@XtPlLbXe5tR39UiVRhy0oZtkLV@KkMNXhmyFmvLRhQExir3cZMw1EaauX01qFHQze5QcZUD/6sYVV1ZaS3egQ1d3bWeriBGo22c7gaq6YZAsqjwxJlS5MwmnmYeBgQ76W813ae5iwSWVyX5Ol7TyEE1XOA0LuwQnA8YFYjiMyBpK4Z2cYI@XWBCPxl19KlSRndEdeKpSkY3RHXeL40PN9HETkescAT8iPyAvkJk/8igc8UY@Je6nPFD4LxVsVDjPcixn@K5/4n6xc" rel="nofollow noreferrer" title="Python 2 – Try It Online">Try it online!</a></p>

<p>Takes as inputs <code>k</code> and then polynomials as a list of lists of coefficents <code>[c0, c1, c2, ...]</code>. Forms all tuples of indexes into the polynomials that sum to the desired coefficent; and then sums up the products of the corresponding coefficients.</p>
</div>
<div id="pu15" class="pu"><h1><a href="https://github.com/somebody1234/Charcoal" rel="nofollow noreferrer">Charcoal</a>, 52 bytes</h1>

<pre><code>≔⟦Ｅ²ι⟧ζＦη«≔⟦⟧υＦιＦζ⊞υＥκ⎇ν×μ§λ¹⁺μ§λ⁰≔υζ»Ｉ∨ΣＥΦυ⁼§ι⁰θ⊟ι⁰
</code></pre>

<p><a href="https://tio.run/##XU/BasMwDD03X6GjDBo0oZRCTmVssMNYYLuZHEyXNWaO09rx2Dr27Z6U0kGng95DT7wn7XoTdqNxOW9jtHuP@tEcsCKwqiU4qbp4GwNgr@C7WFxWWEmsLGbJKpjxpKBJscdEIBbvBC9d8CZ8oWdqhy7iQLCdHvxr94mOoFSKoHHp/3yppOq/uHS@46dogvUT3po44VPA5zSgBN1bN3VBtu6OybiIFysrVgTHOWY88KHCxL3OWVdLAq0195Lf0fxxJbgiWLVCrieMG4LNWbmaMJZrNlm3XPnmw/0C" rel="nofollow noreferrer" title="Charcoal – Try It Online">Try it online!</a> Link is to verbose version of code. Takes input using the last suggestion but with the exponent first, then the coefficient. Explanation:</p>

<pre><code>≔⟦Ｅ²ι⟧ζ
</code></pre>

<p>Initialise a variable to the polynomial <code>1</code>.</p>

<pre><code>Ｆη«
</code></pre>

<p>Loop over the input polynomials.</p>

<pre><code>≔⟦⟧υ
</code></pre>

<p>Accumulate terms in a temporary variable.</p>

<pre><code>ＦιＦζ
</code></pre>

<p>Loop over the Cartesian product of both sets of terms.</p>

<pre><code>⊞υＥκ⎇ν×μ§λ¹⁺μ§λ⁰
</code></pre>

<p>Multiply the coefficients and add the exponents.</p>

<pre><code>≔υζ
</code></pre>

<p>Move the resulting terms back to the original variable. (Charcoal doesn't have any flattening operators, and this is the golfiest way of flattening manually.)</p>

<pre><code>»Ｉ∨ΣＥΦυ⁼§ι⁰θ⊟ι⁰
</code></pre>

<p>Filter for the terms with the desired exponent and sum the coefficients, unless there weren't any, in which case the result is <code>0</code>.</p>
</div>
<div id="pu16" class="pu"><h1>Mathematica, 20 bytes</h1>

<p>A nice benchmark for other answers:</p>

<pre><code>Coefficient[#2,x,#]&amp;
</code></pre>

<p>Takes the symbolic expressions as input.</p>

<p>You can <a href="https://tio.run/##rY@xCsMgFEX3foUQKEod8oxaO3TqD3QPChKUOiSF4uDfWwMNuEpd3uU8DhfuauPLrTaGxWaP7vnxdt6HJbgtzgOjiQ76nJ@fUNDPI0UY0AVNqRyRDCNYHMh21Pp0uNDgsgZ3anB5gysaXPlz938JngwnuIISKhlFcAUlQCYDsi669ipSvYpuvYqg2zboNg66rWPjn035Cw" rel="noreferrer">try it online!</a></p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/198779/">198779</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




