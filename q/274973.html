<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::274973</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>006</td><td>05AB1E</td><td>240814T224409Z</td><td><a href="https://codegolf.stackexchange.com/questions/274973/erase-the-loops/274989#274989">Kevin Cr</a></td></tr>
<tr d-ix="1"><td>007</td><td>Vyxal</td><td>240814T221128Z</td><td><a href="https://codegolf.stackexchange.com/questions/274973/erase-the-loops/274987#274987">emanresu</a></td></tr>
<tr d-ix="2"><td>013</td><td>Charcoal</td><td>240814T212135Z</td><td><a href="https://codegolf.stackexchange.com/questions/274973/erase-the-loops/274986#274986">Neil</a></td></tr>
<tr d-ix="3"><td>061</td><td>Python</td><td>240814T183637Z</td><td><a href="https://codegolf.stackexchange.com/questions/274973/erase-the-loops/274984#274984">shape wa</a></td></tr>
<tr d-ix="4"><td>017</td><td>sed 4.2.2</td><td>240814T182151Z</td><td><a href="https://codegolf.stackexchange.com/questions/274973/erase-the-loops/274983#274983">Digital </a></td></tr>
<tr d-ix="5"><td>009</td><td>Jelly</td><td>240814T175309Z</td><td><a href="https://codegolf.stackexchange.com/questions/274973/erase-the-loops/274982#274982">Jonathan</a></td></tr>
<tr d-ix="6"><td>014</td><td>Haskell + hgl</td><td>240814T143415Z</td><td><a href="https://codegolf.stackexchange.com/questions/274973/erase-the-loops/274976#274976">Wheat Wi</a></td></tr>
<tr d-ix="7"><td>019</td><td>Perl 5 p</td><td>240814T163746Z</td><td><a href="https://codegolf.stackexchange.com/questions/274973/erase-the-loops/274980#274980">Xcali</a></td></tr>
<tr d-ix="8"><td>045</td><td>Python</td><td>240814T160801Z</td><td><a href="https://codegolf.stackexchange.com/questions/274973/erase-the-loops/274979#274979">Albert.L</a></td></tr>
<tr d-ix="9"><td>012</td><td>Retina 0.8.2</td><td>240814T155417Z</td><td><a href="https://codegolf.stackexchange.com/questions/274973/erase-the-loops/274978#274978">Neil</a></td></tr>
<tr d-ix="10"><td>044</td><td>JavaScript ES6</td><td>240814T150830Z</td><td><a href="https://codegolf.stackexchange.com/questions/274973/erase-the-loops/274977#274977">Arnauld</a></td></tr>
<tr d-ix="11"><td>011</td><td>Japt v2.0a0</td><td>240814T141527Z</td><td><a href="https://codegolf.stackexchange.com/questions/274973/erase-the-loops/274974#274974">noodle p</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://github.com/Adriandmen/05AB1E/wiki/Commands" rel="nofollow noreferrer">05AB1E</a>, 6 <a href="https://github.com/Adriandmen/05AB1E/wiki/Codepage" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>ΔćD?¡θ
</code></pre>
<p>Port of <a href="https://codegolf.stackexchange.com/a/274982/52210"><em>@JonathanAllan</em>'s Jelly answer</a>, so make sure to upvote that answer as well!</p>
<p><a href="https://tio.run/##yy9OTMpM/f//3JQj7S72hxae2/H/f2JSclJSckpqYmpqMgA" rel="nofollow noreferrer">Try it online</a> or <a href="https://tio.run/##yy9OTMpM/V9Waa@k8KhtkoKSfeX/c1OOtLvYH1p4bsf/2kPb7P9HK1Uo6ShVAAGQysyHQCDT0MjYxNjIECRXWQVBEFEjQ2NDYyMgOzEpOSkpOSU1MTU1WSkWAA" rel="nofollow noreferrer">verify all test cases</a>.</p>
<p><strong>Explanation:</strong></p>

<pre class="lang-python prettyprint-override"><code>Δ       # Loop until the result no longer changes:
 ć      #  Extract head; push remainder-string and first character separately
        #  (which will use the implicit input-string in the first iteration)
  D?    #  Duplicate it; and pop and output this character (without newline)
    ¡   #  Split the string on this character
     θ  #  Pop and leave just the last part for the next iteration
</code></pre>
</div>
<div id="pu1" class="pu"><h1><a href="https://github.com/Vyxal/Vyxal/tree/version-2" rel="nofollow noreferrer">Vyxal</a>, 7 bytes</h1>
<pre><code>hṡt)↔∩h
</code></pre>
<p><a href="https://vyxal.pythonanywhere.com/?v=2&amp;c=1#WyJBIiwiIiwiaOG5oXQp4oaU4oipaCIsIiIsInhcbnh4eHhcbmlvaW9pb2lvXG5cIjEyMzQzMjFcIlxueHl6eHl6eHl6XG5cIjEyMzIxMzEzMlwiXG5hYmNiYmNkZWFlZWMiXQ==" rel="nofollow noreferrer">Try it Online!</a></p>
<p>Port of <a href="https://codegolf.stackexchange.com/a/274982/100664">Jonathan Allan's Jelly answer</a>, go upvote that!</p>
<pre><code>    ↔   # Collect while the result is unique
---)    # Last four elements as a lambda
 ṡ      # Split
h       # On first character
  t     # And get the last item
     ∩h # Take the head of each collected string
</code></pre>
</div>
<div id="pu2" class="pu"><h1><a href="https://github.com/somebody1234/Charcoal" rel="nofollow noreferrer">Charcoal</a>, 13 bytes</h1>
<pre><code>ＷΦθ¬λ«ι≔⊟⪪θιθ
</code></pre>
<p><a href="https://tio.run/##FcqxDkBADADQma@4sU34ApPFKBJfcFcNTRrHuTCIby/m92jxiaJXs2sRZQedaOYEe@X6mEER0d1lMSRZMwg2ZdEeh8wrDHGDcVPJfxXEyu2fPmY@UAg0sWcmq099AQ" rel="nofollow noreferrer" title="Charcoal – Try It Online">Try it online!</a> Link is to verbose version of code. Explanation: Effectively a port of @JonathanAllan's Jelly answer.</p>
<pre><code>ＷΦθ¬λ«
</code></pre>
<p>Repeat while the string has a first character.</p>
<pre><code>ι
</code></pre>
<p>Output that character.</p>
<pre><code>≔⊟⪪θιθ
</code></pre>
<p>Truncate the string after the last occurrence of that character by splitting and taking the last piece.</p>
</div>
<div id="pu3" class="pu"><h1><a href="https://www.python.org" rel="nofollow noreferrer">Python</a>, 61 bytes</h1>
<pre class="lang-python prettyprint-override"><code>f=lambda s,i=0:i&lt;len(s)and f(s[:i]+s[s.rfind(s[i]):],i+1)or s
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=NY_NDoIwDMfvPkVvYwGMAw9mEV-EcNjYFpvgIGwmIOFJvHDRd_JtBMF_m7S_NunH8930_lrbaXrdvYlPn8xklbhJJcBFmB04nittA0eFVWACl3MsQpe7fWvQqpmxoLyIMGS0bsFtQ7xZANBCTjoSAelmLRHr1ZacJekxTdiv3T9W3-oJS1maLCBkKWWptNC6JAXfwaymResDQwY3QnyBYT6LjoSuu_-PfAE" rel="nofollow noreferrer">Attempt This Online!</a></p>
<p>Goes one by one through characters of the string, collapsing the range between the current character and its final occurrence. Using <code>abcbabadeefcbfggg</code> as an example:</p>
<pre><code>abcbabadeefcbfggg -&gt; adeefcbfggg -&gt; adeefcbfggg -&gt; adefcbfggg -&gt; adefggg -&gt; adefg
^                     ^               ^               ^              ^
      ^               ^                ^                 ^             ^
</code></pre>
<p>Makes use of the same observations that Wheat Wizard and Jonathan Allan have made:</p>
<ul>
<li>It does not matter whether the &quot;earliest&quot; pair is based on the first or second element:</li>
</ul>
<pre><code>cAdBeBfAg -&gt; cAg &lt;=&gt; cAdBeBfAg -&gt; cAdBfAg -&gt; cAg
 ^     ^                ^ ^        ^   ^
</code></pre>
<ul>
<li>Assuming the &quot;earliest&quot; pair is based on the first element, it does not matter whether the first element is paired with the earliest or latest second element:</li>
</ul>
<pre><code>bAcAdAe -&gt; bAe &lt;=&gt; bAcAdAe -&gt; bAdAe -&gt; bAe
 ^   ^              ^ ^        ^ ^
</code></pre>
<p>Ungolfed:</p>
<pre class="lang-python prettyprint-override"><code>def f(s):
    i = 0
    while i &lt; len(s):
        j = s.rfind(s[i])
        # remove s[i:j]
        # s:              adefcbfggg -&gt; adefggg
        # s[i] and s[j]:     ^  ^
        # s[i:j]:            ^^^
        s = s[:i] + s[j:]
        i += 1
    return s
</code></pre>
</div>
<div id="pu4" class="pu"><h1><a href="https://www.gnu.org/software/sed/" rel="nofollow noreferrer">sed 4.2.2</a>, 17</h1>
<pre><code>:
s/(.).*\1/\1/
t
</code></pre>
<p><a href="https://tio.run/##K05N@f/fiqtYX0NPU08rxlAfiLhK/v@v4KoAAq7MfAjkMjQyNjE2MuSqqKyCIJCIkaGxobERV2JSclJSckpqYmpqMte//IKSzPy84v@6rgA" rel="nofollow noreferrer" title="sed 4.2.2 – Try It Online">Try it online!</a></p>
</div>
<div id="pu5" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="nofollow noreferrer">Jelly</a>, 9 <a href="https://github.com/DennisMitchell/jelly/wiki/Code-page" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>ṣị@ṪɗƬ1ZḢ
</code></pre>
<p>A monadic Link that accepts a list and yields the erased list.</p>
<p><strong><a href="https://tio.run/##ASsA1P9qZWxsef//4bmj4buLQOG5qsmXxqwxWuG4ov///yJhYmNiYmNkZWFlZWMi" rel="nofollow noreferrer" title="Jelly – Try It Online">Try it online!</a></strong> Or see the <a href="https://tio.run/##y0rNyan8///hzsUPd3c7PNy56uT0Y2sMox7uWPT/4e4th7bqHG7PetQwR8HWTuFRw1zNyP//1dXVY7gquCqAgCszHwK5DI2MTYyNDLkqKqsgCCRiZGhsaGzElZiUnJSUnJKamJqaDNQMAA" rel="nofollow noreferrer" title="Jelly – Try It Online">test-suite</a>.</p>
<h4>How?</h4>
<p>I think this is right, if not do let me know of a counterexample.</p>
<p>Rather than iteratively collapsing the string between the &quot;first pair&quot; to become that character (as defined), we can instead iteratively remove everything between the first character and its last occurrence, inclusive (even if it only appears once) and record the first character of the <em>input</em> at each step.</p>
<p>I think this works because one of these things is true at each step:</p>
<ol>
<li>The first character doesn't reappear</li>
<li>The &quot;first pair&quot; is the same as this choice</li>
<li>This choice wraps the &quot;first pair&quot;, so the collapsed string would be removed at a later step anyway</li>
</ol>

<pre><code>ṣị@ṪɗƬ1ZḢ - Link: list, A
     Ƭ    - collect, starting with A, while distinct under:
    ɗ 1   -   last three links as a dyad - f(Current, 1):
 ị@       -     {1} index into {Current} -&gt; first element of Current
ṣ         -     split {Current} at {that}
   Ṫ      -     tail
       Z  - transpose
        Ḣ - head
</code></pre>
</div>
<div id="pu6" class="pu"><h1><a href="https://www.haskell.org" rel="nofollow noreferrer">Haskell</a> + <a href="https://gitlab.com/wheatwizard/haskell-golfing-library" rel="nofollow noreferrer">hgl</a>, <s>31</s> <s>30</s> <s>29</s> <s>28</s> 14 bytes</h1>
<pre><code>ysk$yS$hdS&lt;*h'
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=TY7PCoJAEMbvPsUgQn_Ig2uHDnrpCQSPEbG6Iy6urukKbQ_RC3TxEl17Hd-mpQ1rZmDm-803MPdnSfsKhRinPa9b2Sk4D1TwgiODpEMxMHS-i8TxfWikAtkAVRI0Kkf3FcSgdQ4R9NVjUIW_exWxwZ5OvZKl0bpcWDzdasob42bSAahPsGw7c1WsjAI4gHtxP9PGTCZmwaXNGQQk3IYk-Ln11da_gwRhEJKZ0CzPspwhRcwtPNqvxtH2Nw" rel="nofollow noreferrer">Attempt This Online!</a></p>
<h2>Explanation</h2>
<p>We are using a parser to do this <code>ysk</code> will repeatedly apply a parser until reaching a fixed point, it prioritizes parses towards the front of the input by default so we just need to write a parser which closes a loop.</p>
<p>As I point out in <a href="https://codegolf.stackexchange.com/questions/274973/erase-the-loops/274976#comment591483_274973">my comment</a> it doesn't matter if you prioritize loops by their start or end location.</p>
<p>Then the loop itself is <code>yS$hdS&lt;*h'</code>, i.e. parse a character, parse some number of characters, parse the same character again returning only the last parse.</p>
<h1>Reflection</h1>
<p>THis answer is pretty tight, but there was definitely some room for improvement on hgl that we see could see in earlier versions of this answer.</p>
<ul>
<li>This might be shorter with a regex if hgl flavored regexes could handle back-references. Implementing that is a big undertaking, but I always have to mention it.</li>
<li>There's probably good cause to have <code>Rv h'</code> as a built-in, and might as well add <code>Rv h_</code> too.</li>
<li>There could be a function to sandwich a parser between two copies of another parser. Basically
<pre><code>f x y = x &lt;&gt; y &lt;&gt; x
</code></pre>
And it should probably have preloaded variants for <code>h'</code> and <code>h_</code>.</li>
</ul>
</div>
<div id="pu7" class="pu"><h1><a href="https://www.perl.org/" rel="nofollow noreferrer">Perl 5</a> <code>-p</code>, 19 bytes</h1>

<pre class="lang-perl prettyprint-override"><code>s/(.).*\1/$1/&amp;&amp;redo
</code></pre>
<p><a href="https://tio.run/##JYgxDoAgEMD2e4cxaiJwoM/wBy4CN5gYIeCAPt5TY9upkdI2MmfZiFZ0M8oKZV0n8oG5QHmBNfwCajMYjVDO6@87Gg0aDYt11jpPC5G7QzzWsGfup1EoVNzH7QE" rel="nofollow noreferrer" title="Perl 5 – Try It Online">Try it online!</a></p>
</div>
<div id="pu8" class="pu"><h1><a href="https://www.python.org" rel="nofollow noreferrer">Python</a>, 45 bytes</h1>
<pre class="lang-python prettyprint-override"><code>lambda x:re.sub(r&quot;(.).*\1&quot;,r&quot;\1&quot;,x)
import re
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=VY5BCsIwEEX3OcXQVSJpMYkLEfQEPUJBkphiQJsQI6Rdews3BdE7eRsttaJ_hlk8_oO5Pnwb967pb_W6up9jnS-f-UEe1U5CWgVTnM4KhwwXpJhVLKMhG24iyB69CxGC-UiidgFKsA04bxo8JysElm6pgzWUxckfbMQEgQ-2ibjGllBHRrV_XhL8JN9AQumdf2LdOBOxDjEuFoKzb4mh1HbjTlrbDS3OBBN8agmOpNJK6Z2RxuiBSaPHZ14" rel="nofollow noreferrer">Attempt This Online!</a></p>
<p>I no longer think the non-greediness of my first attempt below is necessary nor that overlap may be a problem.</p>
<h3><a href="https://www.python.org" rel="nofollow noreferrer">Python</a>, 47 bytes</h3>
<pre class="lang-python prettyprint-override"><code>lambda x:re.sub(r&quot;(.).*?(?=\1)&quot;,&quot;&quot;,x)
import re
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=VY5BCsIwEEX3OcXQVSJpNYkLEaoX8AiCJDXFQNuEGCF17S3cCKJ36m201Ir-P6vH-zDXp2vDwTa3e5lvH6dQpotuWsla7SXEpdfZ8aSwT3BGsskar_MtIwlNEhoJMrWzPoDXn5korYcNmAas0w2ekSUCQ3fUQg6b7OgqEzBB4LxpAi6xIdSSYXrrLhF-kq4govjOPzF26EiMRYyLueDsKzEU2_Nw46w99xZnggk-WoIjqQqlir2WWhc9k7oYnnkB" rel="nofollow noreferrer">Attempt This Online!</a></p>
<h3>How?</h3>
<p>Similar to other regex based answers. Things that may or may not be Python specific: <code>re.sub</code> only finds non-overlapping matches. Therefore we use a look ahead assertion for the second copy of the repeat element so it remains available for further matches. <code>*?</code> is a non greedy version of <code>*</code>. Here it makes sure the match stretches only to the first reoccurrence of the  repeat element.</p>
</div>
<div id="pu9" class="pu"><h1><a href="https://github.com/m-ender/retina/wiki/The-Language/a950ad7d925ec9316e3e2fb2cf5d49fd15d23e3d" rel="nofollow noreferrer">Retina 0.8.2</a>, 12 bytes</h1>
<pre><code>+`(.).*\1
$1
</code></pre>
<p><a href="https://tio.run/##K0otycxL/P9fO0FDT1NPK8aQS8Xw//8Krgog4MrMh0AuQyNjE2MjQ66KyioIAokYGRobGhtxJSYlJyUlp6QmpqYmAwA" rel="nofollow noreferrer" title="Retina 0.8.2 – Try It Online">Try it online!</a> Link includes test cases. Makes the same assumption that the order of collapsing does not matter. Explanation: Trivial port of @noodleman's answer.</p>
<p>17 bytes to follow the challenge description exactly:</p>
<pre><code>+r`\2.*((.).*)
$1
</code></pre>
<p><a href="https://tio.run/##K0otycxL/P9fuyghxkhPS0NDT1NPS5NLxfD//wquCiDgysyHQC5DI2MTYyNDrorKKggCiRgZGhsaG3ElJiUnJSWnpCampiYDAA" rel="nofollow noreferrer" title="Retina 0.8.2 – Try It Online">Try it online!</a> Link includes test cases. Explanation: The <code>r</code> indicates right-to-left matching, so as many characters from the right as possible are matched that still allow a pair of identical characters to be matched.</p>
</div>
<div id="pu10" class="pu"><h1>JavaScript (ES6), 44 bytes</h1>

<pre class="lang-javascript prettyprint-override"><code>f=s=&gt;s==(s=s.replace(/(.).*\1/,&quot;$1&quot;))?s:f(s)
</code></pre>
<p><a href="https://tio.run/##hc3BCsIwDAbgu08xgodWtCWtJ6H6Il66LpPJsGMR2fbydbBDZQr@ySXwkf/uX55D33TPwyNWlFLt2J3ZOcGOVU9d6wMJLZRUuyvqPWwRpLzwqRYsU4gPji2pNt5ELWCAIkfKQuti2KzNHPhjmrgMZNPENUJjj9YgfDzCr7JxWhZy2Tj9@GTQojVZzcda@TKUZajIEwVYlKeQ3g" rel="nofollow noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a></p>
</div>
<div id="pu11" class="pu"><h1><a href="https://github.com/ETHproductions/japt" rel="nofollow noreferrer">Japt</a> v2.0a0, 11 <a href="https://en.wikipedia.org/wiki/ISO/IEC_8859-1" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>e/(.).*\1/Ï
</code></pre>
<p><a href="https://petershaggynoble.github.io/Japt-Interpreter/?v=2.0a0&amp;code=ZS8oLikuKlwxL88&amp;input=ImFiY2JiY2RlYWVlYyI" rel="nofollow noreferrer">Try it</a></p>
<p>Explanation: Recursively replace matches of the RegEx <code>/(.).*\1/g</code>--which matches a character, many different characters, and that same first character--with the first character.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/274973/">274973</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




