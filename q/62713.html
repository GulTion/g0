<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::62713</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>031</td><td>Pyt</td><td>240719T144918Z</td><td><a href="https://codegolf.stackexchange.com/questions/62713/biplex-an-important-useless-operator/274263#274263">Kip the </a></td></tr>
<tr d-ix="1"><td>091</td><td>JavaScript Node.js</td><td>240719T081621Z</td><td><a href="https://codegolf.stackexchange.com/questions/62713/biplex-an-important-useless-operator/274261#274261">l4m2</a></td></tr>
<tr d-ix="2"><td>102</td><td>Raku Perl 6 rakudo</td><td>240719T074717Z</td><td><a href="https://codegolf.stackexchange.com/questions/62713/biplex-an-important-useless-operator/274260#274260">bb94</a></td></tr>
<tr d-ix="3"><td>nan</td><td></td><td>160208T015007Z</td><td><a href="https://codegolf.stackexchange.com/questions/62713/biplex-an-important-useless-operator/71400#71400">Dennis</a></td></tr>
<tr d-ix="4"><td>619</td><td>Brainfuck</td><td>151109T034946Z</td><td><a href="https://codegolf.stackexchange.com/questions/62713/biplex-an-important-useless-operator/63384#63384">BrainSte</a></td></tr>
<tr d-ix="5"><td>192</td><td>C++</td><td>151111T163745Z</td><td><a href="https://codegolf.stackexchange.com/questions/62713/biplex-an-important-useless-operator/63612#63612">MegaTom</a></td></tr>
<tr d-ix="6"><td>046</td><td>GolfScript</td><td>151112T180412Z</td><td><a href="https://codegolf.stackexchange.com/questions/62713/biplex-an-important-useless-operator/63680#63680">Dennis</a></td></tr>
<tr d-ix="7"><td>113</td><td>Wolfram Language</td><td>151111T232357Z</td><td><a href="https://codegolf.stackexchange.com/questions/62713/biplex-an-important-useless-operator/63640#63640">Ian John</a></td></tr>
<tr d-ix="8"><td>186</td><td>ShapeScript</td><td>151110T045225Z</td><td><a href="https://codegolf.stackexchange.com/questions/62713/biplex-an-important-useless-operator/63509#63509">Dennis</a></td></tr>
<tr d-ix="9"><td>194</td><td>CoffeeScript</td><td>151111T201926Z</td><td><a href="https://codegolf.stackexchange.com/questions/62713/biplex-an-important-useless-operator/63627#63627">MegaTom</a></td></tr>
<tr d-ix="10"><td>127</td><td>Ruby</td><td>151109T223105Z</td><td><a href="https://codegolf.stackexchange.com/questions/62713/biplex-an-important-useless-operator/63484#63484">MegaTom</a></td></tr>
<tr d-ix="11"><td>027</td><td>APL</td><td>151109T045722Z</td><td><a href="https://codegolf.stackexchange.com/questions/62713/biplex-an-important-useless-operator/63389#63389">Dennis</a></td></tr>
<tr d-ix="12"><td>079</td><td>Minkolang 0.10</td><td>151104T021200Z</td><td><a href="https://codegolf.stackexchange.com/questions/62713/biplex-an-important-useless-operator/62873#62873">El&#39;e</a></td></tr>
<tr d-ix="13"><td>021</td><td>J</td><td>151104T143249Z</td><td><a href="https://codegolf.stackexchange.com/questions/62713/biplex-an-important-useless-operator/62923#62923">Dennis</a></td></tr>
<tr d-ix="14"><td>150</td><td>Javascript</td><td>151107T130855Z</td><td><a href="https://codegolf.stackexchange.com/questions/62713/biplex-an-important-useless-operator/63212#63212">Naouak</a></td></tr>
<tr d-ix="15"><td>255</td><td>C#</td><td>151106T080609Z</td><td><a href="https://codegolf.stackexchange.com/questions/62713/biplex-an-important-useless-operator/63100#63100">edc65</a></td></tr>
<tr d-ix="16"><td>122</td><td>Python 3</td><td>151106T062159Z</td><td><a href="https://codegolf.stackexchange.com/questions/62713/biplex-an-important-useless-operator/63095#63095">El&#39;e</a></td></tr>
<tr d-ix="17"><td>161</td><td>Haskell</td><td>151104T115051Z</td><td><a href="https://codegolf.stackexchange.com/questions/62713/biplex-an-important-useless-operator/62908#62908">Xwtek</a></td></tr>
<tr d-ix="18"><td>158</td><td>JavaScript ES6</td><td>151104T145852Z</td><td><a href="https://codegolf.stackexchange.com/questions/62713/biplex-an-important-useless-operator/62928#62928">edc65</a></td></tr>
<tr d-ix="19"><td>176</td><td>JavaScript ES6</td><td>151103T162748Z</td><td><a href="https://codegolf.stackexchange.com/questions/62713/biplex-an-important-useless-operator/62731#62731">user8165</a></td></tr>
<tr d-ix="20"><td>197</td><td>Python 3</td><td>151104T144638Z</td><td><a href="https://codegolf.stackexchange.com/questions/62713/biplex-an-important-useless-operator/62925#62925">Morgan T</a></td></tr>
<tr d-ix="21"><td>050</td><td>Octave</td><td>151104T083332Z</td><td><a href="https://codegolf.stackexchange.com/questions/62713/biplex-an-important-useless-operator/62900#62900">alephalp</a></td></tr>
<tr d-ix="22"><td>141</td><td>Julia</td><td>151104T060615Z</td><td><a href="https://codegolf.stackexchange.com/questions/62713/biplex-an-important-useless-operator/62896#62896">Alex A.</a></td></tr>
<tr d-ix="23"><td>038</td><td>Simplex v.0.7</td><td>151103T162555Z</td><td><a href="https://codegolf.stackexchange.com/questions/62713/biplex-an-important-useless-operator/62729#62729">Conor O&</a></td></tr>
<tr d-ix="24"><td>025</td><td>Pyth</td><td>151103T134602Z</td><td><a href="https://codegolf.stackexchange.com/questions/62713/biplex-an-important-useless-operator/62717#62717">Jakube</a></td></tr>
<tr d-ix="25"><td>027</td><td>CJam</td><td>151103T120952Z</td><td><a href="https://codegolf.stackexchange.com/questions/62713/biplex-an-important-useless-operator/62714#62714">Martin E</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://github.com/mudkip201/pyt" rel="nofollow noreferrer">Pyt</a>, 31 bytes</h1>
<pre><code>2⁴⁸Đ←+ɓąƖĐŁ⑴⊤·ĐĐŁř1=¬*ž↕∈Ɩǰ2Ĩ⇹%
</code></pre>
<p><a href="https://tio.run/##AXYAif9weXT//zLigbTigbjEkOKGkCvJk8SFxpbEkMWB4pG04oqkwrfEkMSQxYHFmTE9wqwqxb7ihpXiiIjGlsewMsSo4oe5Jf//WzIzNDExMDM5NDUsIDI5NjkxMTI1MDYsIDE4NDkwNzg5NDksIDE0MzA2MzkxODld" rel="nofollow noreferrer" title="Pyt – Try It Online">Try it online!</a></p>
<pre><code>2⁴⁸Đ                              push 2^32 twice
    ←                             get input
     +                            add 2^32 to input (to ensure same-length bit strings)
      ɓ                           get binary strings
       ąƖ                         convert each to list of bits
         ĐŁ⑴⊤·                   get # of occurrences of each bit
               ĐĐŁř=¬*            get rid of the pesky fake first entry
                      ž           remove zeroes
                       ↕          get minimum and maximum
                        ∈         is each bitsum either min or max?
                         Ɩǰ       cast to integer, then concatenate
                           2Ĩ     interpret as binary number
                             ⇹    flip top two on the stack
                              %   modulo 2^32
</code></pre>
<p>The last two steps only come into play when there is only one number in the input.</p>
</div>
<div id="pu1" class="pu"><h1><a href="https://nodejs.org" rel="nofollow noreferrer">JavaScript (Node.js)</a>, 91 bytes</h1>

<pre class="lang-javascript prettyprint-override"><code>f=A=&gt;A.some((x,i)=&gt;t=A[k=i-1]&amp;~x)?f(A,A[k]^=t,A[k+1]^=t):(A.some(x=&gt;t=x),A[k+1]^A[k]|t)&gt;&gt;&gt;0
</code></pre>
<p><a href="https://tio.run/##jZDNasMwEITvfoqcipQqiVZ/lgJS0XMYB0JqF7dJFGJTdCh9dVcqySFFh552mNnZhe99/7kfD9fhMq3O4bWb59566/x6DKcOoUgGbN1kffNhhxW0T98Rv/TIk2S0Ozvl@QxZ4S26lWIuRHyP8ubXhJ1zdD6E8xiO3foY3lCPGmgxrv54rOABYUQWfMGMMKpmphQyIQVTNWWKLJhWnANITsmCKw2CUslNqcQFAOVGyFQyygAwSdMB0MLQWqd3SQtOFTegfw9Um2VVQBZ3yDdDBvPA7gHef5BVy838Aw" rel="nofollow noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a></p>
<p>Bubble sort</p>
</div>
<div id="pu2" class="pu"><h1><a href="https://raku.org" rel="nofollow noreferrer">Raku (Perl 6) (rakudo)</a>, 102 bytes</h1>
<pre class="lang-perl prettyprint-override"><code>{{[+] map 2***,grep @^b.max|@b.grep(*&gt;0).min,:k,@b}([Z+] map *.polymod(2 xx.max.base(2).chars),|$_,0)}
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=LU5bTsMwEPzPKVZVhezgWn7HpqLKOagAOdAAKmmihEqJ0pyEn3wU7sRtcNr87M7Ozszu97n2--P4W3Rwk9__HL_ylf3L-357-wiFr0DEcUze6l0F6VNGC9-e0oxOM4o3DNPi40Du9iTNBrR9mC0xrcrPrihfkYC2nTw0880OCUxf3n3dYHJaPhOGh_naeR3lZQ0IcYIJIHGpnIAgoCeohFPOJMLp615pJUzChAkSa6TkXEtGQBrLFWNauotKKs6ZdEoHlTOOc6FZcHCrHEtsSAxYSWak49ZhDKsNLA_QRwCN72ARcGD6PJDDYh3Nv47jtf8D" rel="nofollow noreferrer">Attempt This Online!</a></p>
</div>
<div id="pu3" class="pu"><h1>Jelly</h1>
<p><strong>14 bytes</strong></p>
<pre><code>BUSµḟ0Ṣ.ịe€@UḄ
</code></pre>
<p><a href="http://jelly.tryitonline.net/#code=QlVTwrXhuJ8w4bmiLuG7i2XigqxAVeG4hA&amp;input=&amp;args=WzIzNDExMDM5NDUgLDI5NjkxMTI1MDYgLDE4NDkwNzg5NDkgLDE0MzA2MzkxODld" rel="nofollow noreferrer">Try it online!</a></p>
<h3>How it works</h3>
<pre><code>BUSµḟ0Ṣ.ịe€@UḄ    Main link. Input: A (list)

B                 Convert each item in A to binary.
 U                Reverse each array of binary digits.
  S               Add them across columns.

   µ              Monadic chain. Argument: S (list of column sums)
    ḟ0            Remove all occurrences of 0.
      Ṣ           Sort the remaining sums.
       .ị         Take the elements with indices around 0.5.
                  Indices are 1-bases, so this selects the last and the first one.
             U    Yield S, reversed.
            @     Reverse the arguments.
         e€       Test each item in the left list for membership in the right one.
              Ḅ   Convert from binary to integer.                
            
</code></pre>
</div>
<div id="pu4" class="pu"><h1><a href="http://esolangs.org/wiki/Brainfuck" rel="noreferrer">Brainfuck</a>, 619 bytes</h1>
<p>First answer in far too long here, so I thought I'd do a good one!</p>
<pre><code>&gt;-&gt;-&gt;-&gt;&gt;&gt;,----------[--&lt;++++++[&gt;------&lt;-]&gt;&gt;&gt;&gt;,----------]-&lt;&lt;&lt;+[-&lt;&lt;&lt;+]-&gt;&gt;,&lt;++++[&gt;--------&lt;-]&gt;[&lt;++++[&gt;+++++&lt;-]&gt;++[--&lt;++++++[&gt;------&lt;-]&gt;&gt;&gt;+&gt;]&lt;-[+&gt;-&lt;&lt;+[-&lt;&lt;&lt;+]-&lt;&lt;+[-&gt;+[-&gt;[-[-&gt;&gt;&gt;+&lt;&lt;&lt;]&lt;&lt;&lt;+]+[--&gt;&gt;&gt;++]-&lt;+]&lt;&lt;&lt;+[-[-&gt;+&lt;]&lt;&lt;&lt;+]-&gt;&gt;+&gt;]&lt;-[+&gt;-&gt;&gt;&gt;&gt;+[-&gt;&gt;&gt;+]-&gt;+[-&lt;[-[-&gt;&gt;&gt;+&lt;&lt;&lt;]&lt;&lt;&lt;+]+[--&gt;&gt;&gt;++]-&gt;+]-&lt;+&lt;&lt;&lt;+[-[-&gt;+&lt;]&lt;&lt;&lt;+]-&gt;&gt;]]&gt;,&lt;++++[&gt;--------&lt;-]&gt;]&gt;+[-&gt;&gt;&gt;+]&gt;-&gt;-&gt;&gt;-[+&lt;&lt;&lt;&lt;&lt;&lt;+[-&lt;-&lt;&lt;+]-&gt;&gt;[+&gt;&gt;&gt;[&gt;&gt;&gt;]&gt;+[&lt;&lt;-&gt;&gt;[-&gt;&gt;&gt;+]-&gt;&gt;&gt;[-]+&lt;&lt;&lt;&lt;&lt;+[-&lt;&lt;&lt;+]+&gt;-&gt;]&lt;]&gt;-&gt;&gt;+&gt;-]&lt;[&lt;&lt;&lt;&lt;&lt;+[-&lt;+&lt;&lt;+]-&gt;&gt;[-]&gt;+[-&gt;&gt;&gt;+]-&gt;&gt;-]&gt;-[+&lt;&lt;&lt;&lt;&lt;&lt;+[-&lt;+&lt;&lt;+]-&gt;&gt;[-&gt;&gt;&gt;[&gt;&gt;&gt;]&gt;+[&lt;&lt;&lt;-&gt;&gt;&gt;[-&gt;&gt;&gt;+]-&gt;&gt;&gt;[-]+&lt;&lt;&lt;&lt;&lt;&lt;+[-&lt;&lt;&lt;+]+&gt;&gt;+&gt;]&lt;]&gt;-&gt;&gt;&gt;-]&lt;&lt;&lt;&lt;-&lt;&lt;&lt;&lt;+[-&gt;[-]&lt;[-&gt;+&lt;]&lt;[-&gt;&gt;[-]+&lt;&lt;]&lt;&lt;+]&gt;-[+&gt;&gt;&gt;-]++[-&gt;++++++[-&lt;++++++++&gt;]&lt;.&gt;&gt;&gt;+]
</code></pre>
<p>Did... Did I win?</p>
<p>This program expects newlines (ASCII <code>10</code>) after every binary number, and requires a space (ASCII <code>32</code>) at the end.</p>
<p>Test runs:</p>
<pre><code>Me$ bf bpx.bf
1
10
101
 
111

Me$ bf bpx.bf
11111111111111111111111111111111
 
11111111111111111111111111111111

Me$ bf bpx.bf
10010010010010010010010010010010
10101010101010101010101010101010
11011011011011011011011011011011
 
11100011100011100011100011100011

Me$ bf bpx.bf
10001011100010100110100101001001
10110000111110010000111110111010
1101110001101101011010010100101
1010101010001011101001001010101
 
11
</code></pre>
<p>(Newlines added after each case with <code>++++++++++.</code> added at the end of the program)</p>
<h1>Explanation</h1>
<p>Still a work in progress, but a slow one. For lack of time, I've just copied the notes I made whilst writing this program, which will suffice for an explanation for now:</p>
<pre><code>[Biplex Calculator]

[

Bitsum writing philosophy: 

Start with [0 255 255 255 ...].
The 255s will be markers that we can 'search' for to get back to the start.
After that, the next byte should be a 0, fairly permanently. (The first reference 0)
It is useful to have 0-bytes handy for general calculations. 
The next byte is where we will read the first digit of any binary number. (The first read)
The next byte holds the first bitsum.
Afterward, the next byte is 0, the following byte is the place
to read the second binary digit, the following byte is the second bitsum,
and so on.
I'll use the terminology nth reference 0, nth read, and nth bitsum to refer to
each part of the triplet of bytes.

The location three places after the final bitsum will be 255,
and the location three places after the final read will be 255.
We can move entire numbers by lining up these 255s after every binary number.

]


&gt;-&gt;-&gt;-&gt;&gt;&gt;~                  [0 255 255 255 0 0 0 0 0                ]

[From the first bitsum, read input to create an initial set of bitsums                  ]
,----------
[
    --&lt;++++++[&gt;------&lt;-]            [Convert the input '1' or '0' into a bit        ]
    &gt;&gt;&gt;&gt;,---------- 
]~                      
-&lt;&lt;&lt;+[-&lt;&lt;&lt;+]-&gt;&gt;                 [Mark 255 after the last bit, then go back to first read]

,&lt;++++[&gt;--------&lt;-]             [Check for space, using the first reference 0       ]
&gt;
[
    &lt;++++[&gt;+++++&lt;-]             [Check for \n                       ]
    &gt;++
    [
        --&lt;++++++[&gt;------&lt;-]        [It wasn't \n, so convert the input into a bit      ]
        &gt;&gt;&gt;+&gt;               [Write 1 to the next reference 0, and go to next read   ]
    ]
    &lt;-
    [
        +&gt;              [It was \n                      ]
        -&lt;              [Mark 255 on this (nth) read and go to (n-1)th bitsum   ]
        &lt;+[-&lt;&lt;&lt;+]           [Search for a 255 off to the left           ]

        [We've either struck our marker, or the last bitsum. We need to check.          ]
        -&lt;&lt;+
        [
            -           [We hit the last bitsum. Move the bitsums right.    ]
            &gt;+
            [
                -&gt;[-[-&gt;&gt;&gt;+&lt;&lt;&lt;]&lt;&lt;&lt;+] [Move until we reach the start          ]
                +[--&gt;&gt;&gt;++]      [From the start, move to our last bitsum    ]
                [Repeat this move until the read here is a 255              ]
                -&lt;+
            ]
            [We now need to go to the first reference zero, and put a 1 there       ]
            &lt;&lt;&lt;+[-[-&gt;+&lt;]&lt;&lt;&lt;+]-&gt;&gt;+&gt;      [Add bits to bitsums and end on first read  ]
        ]
        &lt;-
        [
            +&gt;-&gt;&gt;&gt;&gt;+[-&gt;&gt;&gt;+]     [Go to the 255 after our reads              ]
            -&gt;+
            [
                -&lt;[-[-&gt;&gt;&gt;+&lt;&lt;&lt;]&lt;&lt;&lt;+] [Move until we reach the start          ]
                +[--&gt;&gt;&gt;++]      [From the start, move to the 255 after our reads]
                [Repeat this move until we see the 255 bitsum               ]
                -&gt;+
            ]
            [We now need to go to the first read                        ]
            -&lt;+&lt;&lt;&lt;+[-[-&gt;+&lt;]&lt;&lt;&lt;+]-&gt;&gt;     [Add bits to bitsums and end on first read  ]
        ]
        &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;~&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
    ]
    
    [We're at the reference 0 to the left of our next read                      ]
    &gt;,&lt;++++[&gt;--------&lt;-]            [Check for space, using the first reference 0       ]
    &gt;
]

[

Let BN be the nth bitsum. Then our situation at the moment is:

[0 255 255 255 0 0 B1 0 0 B2 ... 0 0 BN 0 0 255] 
                 ^
I'm just happy nothing's exploded yet.

]

[Next goal: Mark the minimums                                       ]

&gt;+[-&gt;&gt;&gt;+]&gt;-&gt;-&gt;&gt;~            [Zero the 255 and put 2 255s after it, then move after it   ]

-[
    +&lt;&lt;&lt;&lt;&lt;&lt;
    +[-&lt;-&lt;&lt;+]               [Subtract one from each bitsum              ]
    -&gt;&gt;
    [
        +&gt;&gt;&gt;[&gt;&gt;&gt;]           [Find the first 0 bitsum                ]
        &gt;+
        [
            &lt;&lt;-&gt;&gt;[-&gt;&gt;&gt;+]-&gt;&gt;&gt;[-]     [Mark the zero as a minimum, and set a flag     ]
            +&lt;&lt;&lt;&lt;&lt;+[-&lt;&lt;&lt;+]+&gt;-&gt;
        ]
        &lt;
    ]
    &gt;-&gt;&gt;+&gt;-
]~

[Hey, that worked. Weird. Alright, moving on...                             ]
[Reset the bitsums to what they were before we messed them all up                   ]

&lt;[&lt;&lt;&lt;&lt;&lt;+[-&lt;+&lt;&lt;+]-&gt;&gt;[-]&gt;+[-&gt;&gt;&gt;+]-&gt;&gt;-]&gt;~

[After the stuff up there, that's not too bad.                              ]
[Now it's time to mark the maximums, in virtually the opposite way we did the minimums.         ]

-[
    +&lt;&lt;&lt;&lt;&lt;&lt;
    +[-&lt;+&lt;&lt;+]               [Add one to each bitsum                 ]
    -&gt;&gt;
    [
        -&gt;&gt;&gt;[&gt;&gt;&gt;]           [Find the first 0 bitsum                ]
        &gt;+
        [
            &lt;&lt;&lt;-&gt;&gt;&gt;[-&gt;&gt;&gt;+]-&gt;&gt;&gt;[-]   [Mark the zero as a maximum, and set a flag     ]
            +&lt;&lt;&lt;&lt;&lt;&lt;+[-&lt;&lt;&lt;+]+&gt;&gt;+&gt;
        ]
        &lt;
    ]
    &gt;-&gt;&gt;&gt;-
]~

[Alright, now OR the maxs and mins, take care of leading zeros, output, and cross fingers       ]
&lt;&lt;&lt;&lt;-&gt;&gt;~&lt;&lt;&lt;&lt;&lt;&lt;~+[-&gt;[-]&lt;[-&gt;+&lt;]&lt;[-&gt;&gt;[-]+&lt;&lt;]&lt;&lt;+]&gt;-[+&gt;&gt;&gt;-]++[-&gt;++++++[-&lt;++++++++&gt;]&lt;.&gt;&gt;&gt;+]
</code></pre>
</div>
<div id="pu5" class="pu"><h1>C++, 192 bytes</h1>
<p>Accepts input a 32 bit unsigned integer array, and a count of items in that array.</p>
<pre><code>typedef unsigned long U;U b(U*a,int c){U x[32],t,i,j,M=0,m=c,r=0;for(i=0;i&lt;32;x[i++]=t,m=t&amp;&amp;m&gt;t?t:m,M=M&lt;t?t:M)for(t=j=0;j&lt;c;)t+=a[j++]&gt;&gt;i&amp;1;for(i=0;i&lt;32;++i)r|=(x[i]==m||x[i]==M)&lt;&lt;i;return r;}
</code></pre>
<p>Ungolfed :</p>
<pre><code>unsigned long b(unsigned long*a, int c){
    unsigned long x[32],t,i,j,M=0,m=c,r=0;
    for(i=0;i&lt;32;x[i++]=t){
        m = (t &amp;&amp; m &gt; t)?t:m;
        M = M &lt; t ? t:M;
        for(t=j=0;j&lt;c;){
            t+=a[j++]&gt;&gt;i&amp;1;
        }
    }
    for(i=0;i&lt;32;++i)
        r|=(x[i]==m||x[i]==M)&lt;&lt;i;
    return r;
}
</code></pre>
</div>
<div id="pu6" class="pu"><h1>GolfScript, 46 bytes</h1>

<pre><code>~{2base-1%}%zip{{+}*}%-1%.$0-)\1&lt;|`{&amp;,}+%2base
</code></pre>

<p>Try it online on <a href="http://golfscript.apphb.com/?c=OyAiWzIzNDExMDM5NDUgMjk2OTExMjUwNiAxODQ5MDc4OTQ5IDE0MzA2MzkxODldIiAjIFNpbXVsYXRlIGlucHV0IGZyb20gU1RESU4uCgp%2BezJiYXNlLTElfSV6aXB7eyt9Kn0lLTElLiQwLSlcMTx8YHsmLH0rJTJiYXNl" rel="nofollow">Web GolfScript</a>.</p>

<h3>Test cases</h3>

<pre><code>$ golfscript biplex.gs &lt;&lt;&lt; '[1]'
1
$ golfscript biplex.gs &lt;&lt;&lt; '[2]'
2
$ golfscript biplex.gs &lt;&lt;&lt; '[1 2 5]'
7
$ golfscript biplex.gs &lt;&lt;&lt; '[4294967295]'
4294967295
$ golfscript biplex.gs &lt;&lt;&lt; '[2454267026 2863311530 3681400539]'
3817748707
$ golfscript biplex.gs &lt;&lt;&lt; '[2341103945 2969112506 1849078949 1430639189]'
3
</code></pre>
</div>
<div id="pu7" class="pu"><h1>Wolfram Language, 113 bytes</h1>

<p>This version takes input from a popup window, with the numbers being input in the form "{x,y,z,...}", (no quotes).</p>

<pre><code>FromDigits[#/.{Max[#]-&gt;1,Min[#/.{0-&gt;Nothing}]-&gt;1,_Integer-&gt;0},2]&amp;@Total[PadLeft[IntegerDigits[#,2],33]&amp;/@Input[]]
</code></pre>

<p>Input:</p>

<p><img src="https://i.sstatic.net/WIi1t.png" alt="popup window dynamic"></p>

<p>Output:</p>

<p><img src="https://i.sstatic.net/OM2bi.png" alt="output"></p>

<p>Takes input in a dynamic Manipulate as a string of the form "{x,y,z}" with x, y, and z being base 10 integers (with or without leading zeroes). The output is also in base 10.</p>

<pre><code>Manipulate[FromDigits[#/.{Max[#]-&gt;1,Min[#/.{0-&gt;Nothing}]-&gt;1,_Integer-&gt;0},2]&amp;@Total[PadLeft[IntegerDigits[#,2],33]&amp;/@ToExpression@i],{i,"{1}"}]
</code></pre>

<p><img src="https://wolfr.am/8apzjEPd" alt="example"></p>

<p>There are other ways to input this in a way that would save on character counts, but I think this solution is an elegant use of a dynamic GUI that performs the computation</p>

<p>If you want to run this in the cloud, we can use CloudDeploy:</p>

<pre><code>o=CloudDeploy[FormPage[{"i"-&gt;"String"},(FromDigits[#/.{Max[#]-&gt;1,Min[#/.{0-&gt;Nothing}]-&gt;1,_Integer-&gt;0},2]&amp;@Total[PadLeft[IntegerDigits[#,2],33]&amp;/@ToExpression@#i])&amp;]];SetOptions[o,Permissions-&gt;{All-&gt;{"Read","Execute"},"Owner"-&gt;{"Read","Write","Execute"}}];o
</code></pre>

<p>The Cloud deploy brings the character count up to 256 however...</p>

<p>The input to the FormPage is also a string of the form "{x,y,z}" with x, y, and z being base 10 integers.</p>

<p>I cloud-deployed this myself and you can try it out at <a href="https://www.wolframcloud.com/objects/97b512df-64f8-4cae-979b-dba6d9622781" rel="nofollow noreferrer">https://www.wolframcloud.com/objects/97b512df-64f8-4cae-979b-dba6d9622781</a></p>

<p><img src="https://i.sstatic.net/C8BbN.png" alt="cloud example"></p>
</div>
<div id="pu8" class="pu"><h1><a href="https://github.com/DennisMitchell/ShapeScript" rel="nofollow">ShapeScript</a>, 186 bytes</h1>

<pre><code>'"1
"$0?_1-"+"*":2"@~@"0
"~"0
"$"
"~+'1?_*!"2"$"0"~"
"$""~":"1?'@1?"+"$_1&gt;"+"*+@1?"0"+$""~'1?_*!#"0"+@":+"'1?1?"0"+$_2&lt;"+"*+'1?_*!"0"+$"1"~@$"1"~":"$""~"+"$""~'"
"@+"
0"$""~'1?_*!"
"$""~
</code></pre>

<p>An important, useless language for an important, useless operator.</p>

<p>I/O is in binary. The program expects each number on a separate line, each ending with a linefeed.</p>

<p><a href="http://shapescript.tryitonline.net/#code=JyIxCiIkMD9fMS0iKyIqIjoyIkB-QCIwCiJ-IjAKIiQiCiJ-KycxP18qISIyIiQiMCJ-IgoiJCIifiI6IjE_J0AxPyIrIiRfMT4iKyIqK0AxPyIwIiskIiJ-JzE_XyohIyIwIitAIjorIicxPzE_IjAiKyRfMjwiKyIqKycxP18qISIwIiskIjEifkAkIjEifiI6IiQiIn4iKyIkIiJ-JyIKIkArIgowIiQiIn4nMT9fKiEiCiIkIiJ-&amp;input=MTAwMDEwMTExMDAwMTAxMDAxMTAxMDAxMDEwMDEwMDEKMTAxMTAwMDAxMTExMTAwMTAwMDAxMTExMTAxMTEwMTAKMTEwMTExMDAwMTEwMTEwMTAxMTAxMDAxMDEwMDEwMQoxMDEwMTAxMDEwMDAxMDExMTAxMDAxMDAxMDEwMTAxCg==" rel="nofollow">Try it online!</a></p>

<h3>Test cases</h3>

<pre><code>$ echo -e '1' | shapescript biplex.shape; echo
1
$ echo -e '10' | shapescript biplex.shape; echo
10
$ echo -e '1\n10\n101' | shapescript biplex.shape; echo
111
$ echo -e '11111111111111111111111111111111' | shapescript biplex.shape; echo11111111111111111111111111111111
$ echo -e '10010010010010010010010010010010\n10101010101010101010101010101010\n11011011011011011011011011011011' | shapescript biplex.shape; echo
11100011100011100011100011100011
$ echo -e '10001011100010100110100101001001\n10110000111110010000111110111010\n1101110001101101011010010100101\n1010101010001011101001001010101' | shapescript biplex.shape; echo
11
</code></pre>
</div>
<div id="pu9" class="pu"><h1>CoffeeScript, 194 bytes</h1>

<p>Takes input as coma separated binary numbers, outputs in binary. </p>

<pre><code>a=(s.split('').reverse()for s in prompt().split(','))
for i in b=[0..31]
 b[i]=0
 b[i]+=+c[31-i]||0for c in a
m=1/M=0
for d in b
 M=d if d&gt;M;m=d if m&gt;d&amp;&amp;d
alert +(+(d in[m,M])for d in b).join ''
</code></pre>

<p><a href="http://coffeescript.org/#try:a%3D(s.split(&#39;&#39;).reverse()for%20s%20in%20prompt().split(&#39;%2C&#39;))%0Afor%20i%20in%20b%3D%5B0..31%5D%0A%20b%5Bi%5D%3D0%0A%20b%5Bi%5D%2B%3D%2Bc%5B31-i%5D%7C%7C0for%20c%20in%20a%0Am%3D1%2FM%3D0%0Afor%20d%20in%20b%0A%20M%3Dd%20if%20d%3EM%3Bm%3Dd%20if%20m%3Ed%26%26d%0Aalert%20%2B(%2B(d%20in%5Bm%2CM%5D)for%20d%20in%20b).join%20&#39;&#39;" rel="nofollow">Try it.</a></p>
</div>
<div id="pu10" class="pu"><h1>Ruby, 127 bytes</h1>
<pre><code>def f l;a=[];32.times{|i|a[i]=0;l.each{|n|;a[i]+=n[i]}};a.map{|b|a.reject{|c|c==0}.minmax.index(b)?1:0}.reverse.join.to_i 2;end
</code></pre>
<p>Takes an array as input.</p>
</div>
<div id="pu11" class="pu"><h1>APL, 27 bytes</h1>

<pre><code>{2⊥S∊(⌈/,⌊/)0~⍨S←+/⍵⊤⍨32⍴2}
</code></pre>

<p>This is a monadic function that takes a list of decimal integers and returns their decimal biplex.</p>

<p>Try it online in the <a href="http://ngn.github.io/apl/web/#code=%7B2%u22A5S%u220A%28%u2308/%2C%u230A/%290%7E%u2368S%u2190+/%u2375%u22A4%u236832%u23742%7D%20%A8%20%28%2C1%29%20%28%2C2%29%20%281%202%205%29%20%28%2C4294967295%29%20%282454267026%202863311530%203681400539%29%20%282341103945%202969112506%201849078949%201430639189%29" rel="nofollow">ngn/apl demo</a>.</p>

<h3>How it works</h3>

<pre><code>                     32⍴2  Create a list of 32 2's.
                  ⍵⊤⍨      Base-encode the right argument.
                +/         Add the corresponding binary digits.
              S←           Save the sums in S.
           0~⍨             Remove 0's.
    (⌈/,⌊/)                Apply minimum (⌊/), maximum (⌈/) and concatenate.
  S∊                       Check which binary digits are in the extrema list.
2⊥                         Convert from base 2 to integer.
</code></pre>
</div>
<div id="pu12" class="pu"><h2><a href="https://github.com/elendiastarman/Minkolang" rel="noreferrer">Minkolang 0.10</a>, <s>109</s> 79 bytes</h2>
<pre><code>(n1$(d2%$r2:d)99*I-DmI2:[+1R]$I)rI$d$(s0(x0gd,)Ik3R2g1-X0I3-[2*2gd0c=$r1c=++]N.
</code></pre>
<p>Input and output are in decimal. <a href="http://play.starmaninnovations.com/minkolang/old?code=%28n1%24%28d2%25%24r2%3Ad%2999%2AI-DmI2%3A%5B%2B1R%5D%24I%29rI%24d%24%28s0%28x0gd%2C%29Ik3R2g1-X0I3-%5B2%2A2gd0c%3D%24r1c%3D%2B%2B%5DN%2E&amp;input=2341103945%2C+2969112506%2C+1849078949%2C+1430639189" rel="noreferrer">Try it here.</a></p>
<h3>Explanation</h3>
<pre><code>(                            $I)    Loop until input is empty
 n                                  Read in number from input
  1$(       d)                      Start a while loop with only the top of stack
     d2%                            Next least-significant bit (modulo by 2)
        $r                          Swap top two values
          2:                        Divide by 2
              99*I-D                Pad with 0s
                                    (when the while loop exits, top of stack is 0)
                    m               Merge (interleave) stack
                     I2:[   ]       For each pair...
                         +1R        Add and rotate stack to the right
                                    &lt;&lt;This does the work of computing bitsums&gt;&gt;

r       Reverse stack
 I      Push length of stack
  $d    Duplicate whole stack
        &lt;&lt;This lets me sort the bitsums without affecting the original order&gt;&gt;

$(                      Start while loop with &lt;top of stack&gt; elements
  s                     Sort
   0(     )             Push a 0 and start another while loop
     x                  Dump top of stack
      0g                Get front of stack and put it on top
        d,              Duplicate and &lt;not&gt; for end-while condition check
           Ik           Push length of stack and break out of while loop
             3R         Rotate [min, max, length] to front
               2g1-     Get length and put it on top, then subtract 1
                   X    Dump that many elements off the top of stack
                        &lt;&lt;Now I have min and max&gt;&gt;

0                        Initialize decimal with 0    
 I3-[               ]    For as many bits as there are...
     2*                  Multiply by 2
       2gd               Get the next most significant bit and put it on top
          0c=            Copy min and check for equality
             $r          Swap top two elements of stack
               1c=       Copy max and check for equality
                  ++     Add 1 if bitsum item is equal to min or max, 0 otherwise
N.                       Output as integer and stop
</code></pre>
<hr />
<h3>Old version:</h3>
<pre><code>$nI[(d2%i1+0a+i1+0A00ai`4&amp;i00A2:d)x]00a1+[i1+0a]s0(x0gd,)rI2-[x]00a1+[i1+0ad0c=$r1c=+]0gx0gx0(xd,)0I1-[2*+]N.
</code></pre>
<p><a href="http://play.starmaninnovations.com/minkolang/?code=%24nI%5B%28d2%25i1%2B0a%2Bi1%2B0A00ai%604%26i00A2%3Ad%29x%5D00a1%2B%5Bi1%2B0a%5Ds0(x0gd%2C)rI2-%5Bx%5D00a1%2B%5Bi1%2B0ad0c%3D%24r1c%3D%2B%5D0gx0gx0(xd%2C)0I1-%5B2*%2B%5DN%2E&amp;input=2341103945%2C%202969112506%2C%201849078949%2C%201430639189" rel="noreferrer">Try it here!</a></p>
<h3>Explanation</h3>
<p>The crux of it is that the <strong>array</strong> feature is heavily used (<code>a A</code>) to store the bitsums, of which the minimum and maximum are found, then <code>1</code>s and <code>0</code>s are outputted appropriately, with dumping of leading <code>0</code>s in two places.</p>
<pre><code>$n                                      Read in whole input as integers
  I[(                             x]    Convert each number to binary
     d2%                                Get next least significant bit (modulo by 2)
        i1+0a                           Get current value in array for that position
             +                          Add
              i1+0A                     Put current value in array for that position
                   00ai`                Get first value of array (bitsum length)
                      i`                Greater than loop counter?
                        4&amp;i00A          If not, put loop counter there
                              2:        Divide by 2
                                d)      If 0, exit loop

00a                Get first value of array (maximum length
   1+              Add one
     [i1+0a]       Get bitsum values from array and push on stack
            s      Sort
0(                 Push a 0 (for dump) and start a while loop -- dumps leading 0s
  x                Dump top of stack
   0g              Get bottom of stack
     d,            Duplicate and &lt;not&gt; it
       )           Exit loop when top of stack is non-zero (i.e., the minimum)
        r          Reverse stack (so now it's [min, max, &lt;stuff&gt;])
         I2-[x]    Dump everything else

00a1+[               ]    Get bitsum length and loop that many times
      i1+0a               Get bitsum value at current position
           d              Duplicate
            0c=           Copy front of stack and check for equality
               $r         Swap
                 1c=      Copy next-to-front of stack and check for equality
                    +     Add (so it's 1 if it's equal to min or max, 0 otherwise)

0gx0gx       Dump front two elements of stack (the min and max)
0(xd,)       Dump leading 0s
0            Push 0 for conversion to decimal
 I1-[   ]    For each bit...
     2*+     Multiply by 2 and add
N.           Output as integer and stop
</code></pre>
</div>
<div id="pu13" class="pu"><h1>J, <s>31</s> <s>30</s> <s>24</s> <s>23</s> 21 bytes</h1>

<pre><code>+/(e.&gt;./,&lt;./@#~@)&amp;.#:
</code></pre>

<p>This is a tacit, monadic verb that takes a list of decimal integers and returns their decimal biplex.</p>

<p><em>Thanks to @Zgarb for his suggestions, which saved 4 bytes directly and paved the way for 2 more!</em></p>

<p><em>Thanks to @randomra for golfing off 2 more bytes!</em></p>

<h3>Test cases</h3>

<pre><code>   biplex =: +/(e.&gt;./,&lt;./@#~@)&amp;.#:

   biplex ,1
1
   biplex ,2
2
   biplex 1 2 5
7
   biplex ,4294967295
4294967295
   biplex 2454267026 2863311530 3681400539
3817748707
   biplex 2341103945 2969112506 1849078949 1430639189
3
</code></pre>

<h3>How it works</h3>

<pre><code>                 &amp;.    Dual. Apply the verb to the right, the verb to the left,
                       and finally the inverse of the verb to the right.
                   #:  Convert the input list from integer to base 2.
  (            @)      Define an adverb, i.e., an operator that takes a verb as
                       its left argument.
+/                     Call it with "reduce by sum". This calculates the sum of
                       the corresponding binary digits of all integers before
                       executing the remainder of the adverb's body, i.e, this:
             #~          Replicate the sum N a total of N times, i.e., turn
                         0 1 2 3 into 1 2 2 3 3 3. This eliminates zeroes.
         &lt;./@            Calculate the minimum of the result.
     &gt;./                 Calculate the maximum of the sums.
        ,                Append; wrap both extrema into a list.
   e.                    Check if each of the sums is in the list of extrema.
                         This yields 1 if yes and 0 if no.
                       (from &amp;.) Convert from base 2 to integer.
</code></pre>
</div>
<div id="pu14" class="pu"><h1>Javascript, <strike>154</strike> 150 bytes</h1>
<pre><code>t=i=&gt;(m=0,r=[],i.map(n=&gt;{for(j=31;j+1;r[k=31-j]=(r[k]|0)+((n&gt;&gt;&gt;j)%2),--j);}),r.map(n=&gt;m=(n==Math.min(...r.filter(x=&gt;x))|n==Math.max(...r)?1:0)+m*2),m)
</code></pre>
<p>Thanks for edc65 method for min/max calculation, it shortened my code by 4 bytes.</p>
<h1>Explanation</h1>
<pre><code>t=i=&gt;(
    m=0,//m=&gt;output
    r=[],//Bitsum then final number in binary
    i.map(
        n=&gt;
        {
            //Decimal to binary + bitsum
            for(j=31;j+1;r[k=31-j]=(r[k]|0)+((n&gt;&gt;&gt;j)%2),--j);
        }),
    //Output formatting
    r.map(
        n=&gt;
            m=(n==Math.min(...r.filter(x=&gt;x))|n==Math.max(...r)?1:0)+m*2
        ),
    m
)
</code></pre>
</div>
<div id="pu15" class="pu"><h1>C#, 255</h1>
<p>A complete program, input as command line arguments - space separated - in decimal.</p>

<pre class="lang-cs prettyprint-override"><code>using System.Linq;class P{static void Main(string[]l){var n=new uint[32];uint i,r=0,b;foreach(var v in l)for(i=0,b=uint.Parse(v);b!=0;b/=2)n[i++]+=b&amp;1;b=1;foreach(var v in n){r+=(v==n.Max()|v== n.Min(x=&gt;x&gt;0?x:n.Max()))?b:0;b+=b;}System.Console.Write(r);}}
</code></pre>
<p>More readable:</p>
<pre class="lang-cs prettyprint-override"><code>using System.Linq;

class P
{
    static void Main(string[] l)
    {
        var n = new uint[32];
        uint i, r = 0, b;

        foreach (var v in l)
            for (i = 0, b = uint.Parse(v); b != 0; b /= 2) n[i++] += b &amp; 1;
        b = 1;
        foreach (var v in n)
        {
            r += (v == n.Max() | v == n.Min(x =&gt; x &gt; 0 ? x : n.Max())) ? b : 0;
            b += b;
        }
        System.Console.Write(r);
    }
}
</code></pre>

</div>
<div id="pu16" class="pu"><h2>Python 3, <s>181</s> <s>126</s> 122 bytes</h2>
<p>(I took out most of the byte count slashes because it was getting a bit ridiculous.) 21 bytes off thanks to <strong>Sp3000</strong>!</p>
<pre><code>*z,=map(sum,zip(*[map(int,t.zfill(99))for t in input().split()]))
k=0
for x in z:k=k*10+(x in[min(z)or 1,max(z)])
print(k)
</code></pre>
<p>Slightly less golfed:</p>
<pre><code>s=input().split()
k=list(map(lambda t:list(map(int,t))[::-1],s))
z=list(map(sum,zip(*k)))
y=z[:]
while min(y)==0:y.remove(0)
a,b=min(y),max(y)
f=''.join(map(lambda x:str(1*(x in[a,b])),z[::-1]))
print(int(f))
</code></pre>
<p>Input is expected in binary with only spaces separating the numbers. Output is in binary as well.</p>
</div>
<div id="pu17" class="pu"><h1>Haskell, <s>198</s> <s>182</s> <s>178</s> 161 character</h1>
<p>I'm still beginner at golfing. Only 80 reputation comes from answer.</p>
<pre><code>m=map
v=reverse
(b:x)&amp;(c:y)=(b+c):x&amp;y
[]&amp;a=a
b&amp;_=b
l=(show=&lt;&lt;).v.(\a-&gt;m(fromEnum.(`elem`[maximum a,minimum$(replicate=&lt;&lt;id)=&lt;&lt;a]))a).foldl1(&amp;).m(m(read.(:[])).v)
</code></pre>
<p>How does it work.</p>
<p>Instead of padding, I reverse the array then I add using user defined (&amp;). I don't use foldl1(zipWith(+)) that is shorter because zipWith will delete the superflous item. Then I find the maximum and nonzero minimum, that also required user defined function. Then I match the item with the maximum and nonzero minimum, 1 if match, 0 if it doesn't match. Then we reverse and turn it into binary number.</p>
<p>TODO:</p>
<ol>
<li>Using <code>Data.List</code></li>
</ol>
</div>
<div id="pu18" class="pu"><h1>JavaScript (ES6), 158</h1>

<p>A function with a numeric array parameter, returning a number. With the same byte count it could get a string array parameter (containing base 2 rapresentations) and return a base 2 string - just move the <code>.toString(2)</code> at the end after <code>r</code>.</p>

<p><div class="snippet" data-lang="js" data-hide="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>f=l=&gt;(l.map(v=&gt;[...v.toString(2)].reverse().map((x,i)=&gt;t[i]=~~t[i]-x),t=[]),t.map(v=&gt;(r+=v==Math.min(...t)|v==Math.max(...t.filter(x=&gt;x))&amp;&amp;b,b+=b),r=0,b=1),r)

// More readable

u=l=&gt;(
  t=[],
  l.map(v =&gt;
    [...v.toString(2)]
    .reverse()
    .map((x,i) =&gt; t[i] = ~~t[i] - x)
  ),
  r=0,b=1,
  t.map(v =&gt; (
    r += v==Math.min(...t) | v==Math.max(...t.filter(x=&gt;x)) &amp;&amp; b, b+=b
  )),
  r
)

// Test
console.log=s=&gt;O.innerHTML+=s+'\n'

;[
 [[1], 1]
,[[2], 2]
,[[1, 2, 5], 7]
,[[4294967295], 4294967295]
,[[2454267026, 2863311530, 3681400539], 3817748707]
,[[2341103945, 2969112506, 1849078949, 1430639189], 3]
].forEach(t =&gt;{ 
  r=f(t[0])
  x=t[1]
  console.log('Test '+(r==x?'OK':'Fail (Expected: ' + x +')')
  +'\nInput: '+t[0]+'\nResult: ' +r+'\n')                       
})  </code></pre>
<pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;pre id=O&gt;&lt;/pre&gt;</code></pre>
</div>
</div>
</p>
</div>
<div id="pu19" class="pu"><h1>JavaScript (ES6), <strike>215</strike> <strike>185</strike> 176 bytes</h1>

<pre class="lang-js prettyprint-override"><code>f=a=&gt;{s=[];for(i of a)for(b=i.toString(2),d=l=b.length;d--;)s[x=l-d-1]=(s[x]|0)+(b[d]|0);q=255;for(r of s)d=r&gt;d?r:d,q=r&lt;q?r||q:q;o="";s.map(r=&gt;o=(r==q|r==d)+o);return+("0b"+o)}
</code></pre>

<h2>Usage</h2>

<pre class="lang-js prettyprint-override"><code>f([2454267026, 2863311530, 3681400539])
=&gt; 3817748707
</code></pre>

<h2>Explanation</h2>

<pre class="lang-js prettyprint-override"><code>f=a=&gt;{

  // Create an array of bitsums
  s=[];                   // s = bitsums
  for(i of a)             // iterate through the passed array of numbers
    for(
      b=i.toString(2),    // b = number as binary string
      d=l=b.length;       // l = number of digits in b
      d--;                // iterate through each digit of the binary string
    )
      s[x=l-d-1]=         // add to the digit of the bitsum array
        (s[x]|0)+         // get the current value of the bitsum array (or 0 if null)
        (b[d]|0);         // add the result to the bitsum array

  // Get the maximum and minimum bitsums
  q=255;                  // q = min bitsum
  //d=0;                  // d = max bitsum
  for(r of s)             // iterate through the bitsums
    d=r&gt;d?r:d,            // set d to maximum
    q=r&lt;q?r||q:q;         // set q to minimum

  // Calculate the result
  // (unfortunately JavaScript only supports bitwise operations on signed 32-bit
  // integers so the temporary binary string is necessary)
  o="";                   // o = output
  s.map(r=&gt;               // iterate through the bitsum digits
    o=(r==q|r==d)+o       // add a 1 to the string if the digit is equal to min or max
  );
  return+("0b"+o)         // convert the binary string to a number
}
</code></pre>
</div>
<div id="pu20" class="pu"><h1>Python 3, 197</h1>
<pre><code>import itertools
o='0'
d=[sum(map(int,n))for n in itertools.zip_longest(*map(reversed,input().split(' ')),fillvalue=o)]
m=max(d),min(d)or 1
print(''.join((o,'1')[g in m]for g in d[::-1]).lstrip(o))
</code></pre>
<p>It takes in space delimited binary numbers.</p>
<p>Ungolfed version:</p>
<pre><code>import itertools
nums = map(reversed, input().split(' '))
digits = []
for num in itertools.zip_longest(*nums, fillvalue='0'):
    current_digit = sum(map(int,num))
    digits.append(current_digit)
bit_max = max(digits)
bit_min = min(digits) or min(digits) + 1
print(''.join(('0','1')[digit in(bit_max,bit_min)]for digit in digits[::-1]).lstrip('0'))
</code></pre>
</div>
<div id="pu21" class="pu"><h1>Octave, 50 bytes</h1>

<pre><code>@(a)["" ((b=sum(a-48))==max(b)|b==min(b(b&gt;0)))+48]
</code></pre>

<p><strong>Example:</strong></p>

<pre><code>octave:1&gt; g = @(a)["" ((b=sum(a-48))==max(b)|b==min(b(b&gt;0)))+48] ;
octave:2&gt; g(["10010010010010010010010010010010"; "10101010101010101010101010101010"; "11011011011011011011011011011011"])
ans = 11100011100011100011100011100011
</code></pre>
</div>
<div id="pu22" class="pu"><h1>Julia, 141 bytes</h1>



<pre class="lang-julia prettyprint-override"><code>A-&gt;(s=reduce(.+,map(i-&gt;digits(i,2,maximum(map(i-&gt;ndigits(i,2),A))),A));parse(Int,reverse(join([1(i∈extrema(filter(j-&gt;j&gt;0,s)))for i=s])),2))
</code></pre>

<p>Ungolfed:</p>

<pre class="lang-julia prettyprint-override"><code>function biplex(A::AbstractArray)
    # Get the maximum number of binary digits in each element
    # of the input array
    L = maximum(map(i -&gt; ndigits(i, 2), A))

    # Create an array of arrays of binary digits corresponding
    # to the inputs
    B = map(i -&gt; digits(i, 2, L), A)

    # Get the bitsums
    S = reduce(.+, B)

    # Replace the minimum and maximum bitsums with ones and
    # the rest with zeros
    s = [1 * (i in extrema(filter(j -&gt; j &gt; 0, S))) for i in S]

    # Join this into a string and parse it as a base 2 integer
    # Reverse is required because digits() returns the digits
    # in reverse order
    p = parse(Int, reverse(join(s)), 2)

    return p
end
</code></pre>
</div>
<div id="pu23" class="pu"><h1><a href="http://conorobrien-foxx.github.io/Simplex/" rel="nofollow">Simplex v.0.7</a>, 38 bytes</h1>

<p><em>Simpl</em>ified comments. Input in Binary, no interpreter working at the moment. Hopefully the comments are sufficient.</p>

<pre><code>hj&amp;=j&amp;Lun?&amp;RvRpp]{Ri}^XKRJ@jqLhR@LhuTo
h               ]                        ~~ define macro 0
 j&amp;                                      ~~ insert a new byte and write register to it
   =                                     ~~ equal to the previous byte?
    j&amp;                                   ~~ insert a new byte and write register to it
      L                                  ~~ return to equality
       u    v                            ~~ go up/down a strip
        n?&amp;                              ~~ write the register iff byte = 0
           R                             ~~ go right
             Rpp                         ~~ remove two bytes
                 {Ri}                    ~~ take input until input = 0
                     ^X                  ~~ take the sum of the strip
                       K                 ~~ split that sum into digits
                        RJ@              ~~ take the max; write to register
                           jq            ~~ take the min
                             Lh          ~~ call macro 0
                               R@        ~~ set min to register
                                 Lh      ~~ apply macro 0
                                   uTo   ~~ output result 
</code></pre>
</div>
<div id="pu24" class="pu"><h1>Pyth, <s>26</s> 25 bytes</h1>

<pre><code>JsM.T_MjR2Qi_}RhM_BS-J0J2
</code></pre>

<p>Try it online: <a href="http://pyth.herokuapp.com/?code=JsM.T_MjR2Qi_%7DRhM_BS-J0J2&amp;input=[2454267026%2C+2863311530%2C+3681400539]&amp;test_suite_input=[1]%0A[2]%0A[1%2C+2%2C+5]%0A[4294967295]%0A[2454267026%2C+2863311530%2C+3681400539]%0A[2341103945%2C+2969112506%2C+1849078949%2C+1430639189]&amp;debug=0">Demonstration</a> or <a href="http://pyth.herokuapp.com/?code=JsM.T_MjR2Qi_%7DRhM_BS-J0J2&amp;input=[2454267026%2C+2863311530%2C+3681400539]&amp;test_suite=1&amp;test_suite_input=[1]%0A[2]%0A[1%2C+2%2C+5]%0A[4294967295]%0A[2454267026%2C+2863311530%2C+3681400539]%0A[2341103945%2C+2969112506%2C+1849078949%2C+1430639189]&amp;debug=0">Test Suite</a></p>

<h3>Explanation</h3>

<pre><code>JsM.T_MjR2Q
       jR2Q      convert each input number to binary (lists of 1s and 0s)
     _M          reverse each list
   .T            transpose (with top justify)
 sM              sum up each list (numbers of 1s at each position)
J                store this list in J

i_}RhM_BS-J0J2
         -J0     J without 0s
        S        sorted
      _B         create the list [sorted, reverse(sorted)]
    hM           take the first elments of each (bitsum-min and bitsum-max)
  }R        J    check for each value in J, if it is part of ^
 _               reverse this list of booleans
i            2   convert from binary to base 10 and print
</code></pre>
</div>
<div id="pu25" class="pu"><h2>CJam, 27 bytes</h2>

<pre><code>q~2fbWf%:.+_0-$(\W&gt;|fe=W%2b
</code></pre>

<p>Takes input as a base-10 CJam-style list. <a href="http://cjam.aditsu.net/#code=q~2fbWf%25%3A.%2B_0-%24(%5CW%3E%7Cfe%3DW%252b&amp;input=2454267026%202863311530%203681400539%5D" rel="nofollow">Test it here.</a> Alternatively, <a href="http://cjam.aditsu.net/#code=qN%2F%7B%22%3D%3E%22%2F0%3D&#39;%2C-%3AQ%3B%0A%0AQ~2fbWf%25%3A.%2B_0-%24(%5CW%3E%7Cfe%3DW%252b%0A%0A%5DoNo%7D%2F&amp;input=%5B1%5D%20%3D%3E%201%0A%5B2%5D%20%3D%3E%202%0A%5B1%2C%202%2C%205%5D%20%3D%3E%207%0A%5B4294967295%5D%20%3D%3E%204294967295%0A%5B2454267026%2C%202863311530%2C%203681400539%5D%20%3D%3E%203817748707%0A%5B2341103945%2C%202969112506%2C%201849078949%2C%201430639189%5D%20%3D%3E%203" rel="nofollow">run all test cases</a> (the script discards the expected output and converts the input format as necessary).</p>

<h3>Explanation</h3>

<pre><code>q~    e# Read and evaluate input.
2fb   e# Convert each number to base 2.
Wf%   e# Reverse each digit list, to align digits in case there are numbers with different 
      e# widths.
:.+   e# Add up the bit planes.
_0-   e# Make a copy and remove zeroes.
$     e# Sort the bit plane sums.
(\W&gt;| e# Get the first and last element. We use set union instead of addition so that the
      e# resulting array will contain only one value if min = max.
fe=   e# For each element in the bit plane sums, count how often it appears in the min/max
      e# array, which is either 1 or 0.
W%    e# Reverse the digits again (to undo the initial reversing).
2b    e# Interpret as base-2 digits.
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/62713/">62713</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




