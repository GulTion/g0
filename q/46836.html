<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::46836</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>240</td><td>Rust</td><td>240322T003757Z</td><td><a href="https://codegolf.stackexchange.com/questions/46836/total-number-of-topological-sorts/272025#272025">ceilingc</a></td></tr>
<tr d-ix="1"><td>170</td><td>C++ gcc</td><td>240319T075422Z</td><td><a href="https://codegolf.stackexchange.com/questions/46836/total-number-of-topological-sorts/271959#271959">ceilingc</a></td></tr>
<tr d-ix="2"><td>074</td><td>JavaScript Node.js</td><td>240312T074859Z</td><td><a href="https://codegolf.stackexchange.com/questions/46836/total-number-of-topological-sorts/271737#271737">l4m2</a></td></tr>
<tr d-ix="3"><td>607</td><td>Rust</td><td>240308T031018Z</td><td><a href="https://codegolf.stackexchange.com/questions/46836/total-number-of-topological-sorts/271626#271626">138 Aspe</a></td></tr>
<tr d-ix="4"><td>005</td><td>Nekomata + n</td><td>240308T033829Z</td><td><a href="https://codegolf.stackexchange.com/questions/46836/total-number-of-topological-sorts/271627#271627">alephalp</a></td></tr>
<tr d-ix="5"><td>058</td><td>Python</td><td>150219T025125Z</td><td><a href="https://codegolf.stackexchange.com/questions/46836/total-number-of-topological-sorts/46863#46863">xnor</a></td></tr>
<tr d-ix="6"><td>025</td><td>CJam</td><td>150220T202837Z</td><td><a href="https://codegolf.stackexchange.com/questions/46836/total-number-of-topological-sorts/46918#46918">aditsu q</a></td></tr>
<tr d-ix="7"><td>051</td><td>Mathematica</td><td>150218T171040Z</td><td><a href="https://codegolf.stackexchange.com/questions/46836/total-number-of-topological-sorts/46837#46837">Martin E</a></td></tr>
<tr d-ix="8"><td>085</td><td>Haskell</td><td>150218T210139Z</td><td><a href="https://codegolf.stackexchange.com/questions/46836/total-number-of-topological-sorts/46850#46850">nimi</a></td></tr>
<tr d-ix="9"><td>027</td><td>Pyth</td><td>150218T220806Z</td><td><a href="https://codegolf.stackexchange.com/questions/46836/total-number-of-topological-sorts/46852#46852">isaacg</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://www.rust-lang.org/" rel="nofollow noreferrer">Rust</a>, <s>241</s> 240 bytes</h1>

<pre class="lang-rust prettyprint-override"><code>extern crate itertools;use itertools::Itertools;fn f(n:usize,e:&amp;Vec&lt;[u32;2]&gt;)-&gt;u32{let mut v=vec![0;n];for i in 0..n{v[i]=i}let mut c=0;for p in v.iter().permutations(n){let mut d=1;for i in e{if p[i[0]as usize]&lt;p[i[1]as usize]{d=0}}c+=d}c}
</code></pre>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=ddd5ae6f71aee1a0d4392a066410fe24" rel="nofollow noreferrer">Try it online!</a></p>
<p>Rust port of this <a href="https://codegolf.stackexchange.com/questions/46836/total-number-of-topological-sorts/271959#271959">C++ answer</a>. Slightly less golfed</p>
<pre class="lang-rust prettyprint-override"><code>extern crate itertools;
use itertools::Itertools;
fn f(n:usize,e:&amp;Vec&lt;[u32;2]&gt;)-&gt;u32{
 let mut v=vec![0;n];
 for i in 0..n{
  v[i]=i
 }
 let mut c=0;
 for p in v.iter().permutations(n){
  let mut d=1;
  for i in e{
   if p[i[0]as usize]&lt;p[i[1]as usize]{
    d=0
   }
  }
  c=c+d
 }
 c
}
</code></pre>
</div>
<div id="pu1" class="pu"><h1><a href="https://gcc.gnu.org/" rel="nofollow noreferrer">C++ (gcc)</a>, <s>274 252 193 176</s> 170 bytes</h1>

<pre class="lang-cpp prettyprint-override"><code>#import&lt;regex&gt;
int f(int n,int m,int*e,int*f){int V[n],c,d=n,i;for(;d--;)V[d]=d;do for(c=1,i=m;i--;)c*=V[e[i]]&lt;V[f[i]];while(d-=c,std::next_permutation(V,V+n));return~d;}
</code></pre>
<p><a href="https://tio.run/##bY7dasQgEIXv9ykCvdi4nUBN0x9W3cfIjQ0l6LgVVhNcQxdC@uppzJYtlDL4jZyjZ0b1fXFUap7vrOu7EHnAI14OG@tjZvJED4kucYcrDRmTVEvfgAItlhfMdCFnuigYqaVuhGa6y5KmBAUrHLPJUjtRS5S2aXgtTers88OeMNeFUHCOer/3eInvPQY3xDbazuc11PeeEBYwDsF/aTYtq3p1GjRy251jwNYdNq61PifjJkuLIZWNGB/gWnSpR3ia2NU0q0mhTOLCKt2SuY5X3RA5N/kzvAJSMJRwvn3z25/PWP5NLm@55W9utZ7qn9QXwBJMeUud5m8" rel="nofollow noreferrer" title="C++ (gcc) – Try It Online">Try it online!</a></p>
<p>This generates every permutation and filters out the invalid ones.</p>
<p>Slightly less golfed.</p>
<pre class="lang-cpp prettyprint-override"><code>#import&lt;regex&gt;
int f(int n,int m,int*e,int*f){
 int V[n],c,d=n,i;
 for(;d--;)
  V[d]=d;
 do{
  c=1;
  for(i=m;i--;)
   c*=V[e[i]]&lt;V[f[i]];
  d-=c;
 }while(std::next_permutation(V,V+n));
 return~d;
}
</code></pre>
</div>
<div id="pu2" class="pu"><h1><a href="https://nodejs.org" rel="nofollow noreferrer">JavaScript (Node.js)</a>, 74 bytes</h1>

<pre class="lang-javascript prettyprint-override"><code>f=(a,s=0,p)=&gt;a.map(t=&gt;s+=t&amp;&amp;!t.some(p=u=&gt;a[u])&amp;&amp;f(a.map(u=&gt;t!=u&amp;&amp;u)))|s+!p
</code></pre>
<p><a href="https://tio.run/##RYqxDsIgFEX3fgUs5L0UiVo7mdcfIQykgtG0hQg4@e9I7OB2zj33ad82za9HzIct3FytnsDKREcZkSarVhsh05R6ykLwrFJYHUQqreliUAgP@6ktmVMRoiDiJ/U81jlsKSxOLeEOHnTH9Emys2SDZKORTRtffrDbHwfTGcRr/QI" rel="nofollow noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a></p>
<ul>
<li><code>a</code>: Input array. For recurse reason, <code>false</code> means used</li>
<li><code>s</code>: Sum to return</li>
<li><code>p</code>: active if unused elements exist</li>
</ul>
</div>
<div id="pu3" class="pu"><h1><a href="https://www.rust-lang.org" rel="nofollow noreferrer">Rust</a>, 607 bytes</h1>
<p>Golfed version by <a href="https://codegolf.stackexchange.com/users/52904/ceilingcat">@ceilingcat</a>, greatly appreciated.</p>
<p><a href="https://tio.run/##TVLLauswEN3nK1QvhERlY@fRgh11lS4CwYsWuhEiuKnsCmzF2LLvpa6/PR2pTe8VzHCkeZw5g7qht5dLadAToeHDizpt9Wr5MNXKomaw6JU/206bKk2N@kNo1tu3NNXnNAWgDaFRp4q3Y62NItjn0@w1gooGQn1ba0sCFNCoKVryaYbGWdQWXa8grv626gQJAaXR6VzX7kJnGOWRNOnQ6w/F8hQLmEeyCsB1OMkOP@Fd6kiFvltLZr7fQARcJ12GCec70UiAqOH8MLkLT2ZV9@obx1l57pBG2qA4ioxLzIWWnMcYNzjZbvU2@V2E5Xlkz8dRnWALUIdHqMMV5E9WjKjokaeXIVC47rccVHy6JgxbVrED2zFDZzgu6lQ2hVugJyg5bD9zyPBSxPLazT0Rx14x53Pvd5QTGONGeCczI5lH8S8KkwyIjfSDouOPwFIk0rPtr2xkYCM02wNjmLA9xMOEZpUY/smJ2qF/JyPN8v9F3oLIFr6Frc0NCaY5YI8kZjhnuGLEUVPo5/@DE03ny@UO3S8StARbga0RuM1iidZgm8UKbb4A" rel="nofollow noreferrer">Try it online!</a></p>
<pre class="lang-rust prettyprint-override"><code>fn R()-&gt;Vec&lt;i32&gt;{let mut b=String::new();std::io::stdin().read_line(&amp;mut b);b.trim().split(&quot; &quot;).map(|num|num.parse().expect(&quot;&quot;)).collect()}fn E(m:usize,N:&amp;[i32],g:&amp;[Vec&lt;i32&gt;],L:usize,D:&amp;mut[i64],n:usize)-&gt;i64{if-1==D[m]{if m==L{D[m]=1}else{D[m]=0;for i in 0..n{if N[i]==0&amp;&amp;m&amp;1&lt;&lt;i&lt;1{let mut t=N.to_vec();for&amp;v in&amp;g[i]{t[v as usize]-=1}D[m]+=E(m|1&lt;&lt;i,&amp;t,g,L,D,n)}}}}D[m]}fn main(){let f=R();let n=f[0]as usize;let(mut g,mut N,mut D)=(vec![vec![];n],vec![0;n],vec![-1;1&lt;&lt;n]);for _ in 0..f[1]{let I=R();let(u,v)=(I[0]-1,I[1]-1);g[u as usize].push(v);N[v as usize]+=1}println!(&quot;{}&quot;,E(0,&amp;N,&amp;g,(1&lt;&lt;n)-1,&amp;mut D,n))}
</code></pre>
<hr />
<p>Use the algorithm in <a href="https://pastebin.com/AjsmEaky" rel="nofollow noreferrer">@masked_huh's C++ code</a> in the comment of <a href="https://codeforces.com/blog/entry/10911" rel="nofollow noreferrer">this CodeForces post</a>.</p>
<p>Ungolfed version. <a href="https://ato.pxeger.com/run?1=dVTNjpswED71wlNMckCgJShsflrBsse-QKVeEIrYxGStgoOwYavu5kl62UN76wttn6YzhhCTTS3hQPz5m_E33_jnr7qR6vX1d6Py2ae_H_40koFUuzDkh8iycgE1y3YbLpR0XJjdw1e2veOL23t4tgBHwRSUjYKHJs9ZDTF8UTUX-zAU7MlxI43hhzBESi4c19dsBRfMsc_bXJ99r9hWOdPPGS_YDtRBhwUCTnuWDuojfYk8siq42jw9csVklW2Z42pQN_wyq5wX0ZQvgJNfZbVEwJUgeoUwD6yeuiOK7aEoCO1ax16GrVNm8lsIfL30gItdCHaCSqQe7On1JAx-Z0WxabnE3HY9fFchhA6c4CciRAiN5D-YlhT_6tXkOSITCgOZ7BApTGKYBT2ARs1UU4v3wE6m44lIL8axmYxB8j5MDEF0GSM4cY5qnQmJ6Hm3lh9q4CgHzH1fGAEwA9Qo4SnlMAfbBi0f4G8Ad3fAXb3gGlvMGIqVFQZBCl8dNi2K70YjIMW1Wwps7ynKmIYGUSStccLZ6IhnsU6DznUTD5WGlyFVD2xiw0qPikt1xVoamR1Nva5pjDE6NL70zioz6gyjn3JeS6WbBGKz_aIB4QgPShQQnDM2madDJM_gSIK03zkqInqWHHty7T2SocqTRE9pBCKNRnht-KH5e_D8PY6crmHr5QCbBRFoJU3wZZPQaToQNgUVarDXprdXaRSZGP6n0KAS5dN4Oq1Wq9Xr5MFYGBrNhT3ai-990pwL6VeNfHRaYzt53fTaTXylebrGIX_N0VG4BedLR9mdiGdb6anCS1UVYuJMn49Tj4hw9dhd2v3d_foGa_hoBXCLzwKfJeC0sm5hic_KWsCqA_4D" rel="nofollow noreferrer">Attempt This Online!</a></p>
<pre class="lang-rust prettyprint-override"><code>use std::io;

fn read_ints() -&gt; Vec&lt;i32&gt; {
    let mut buffer = String::new();
    io::stdin().read_line(&amp;mut buffer).expect(&quot;Failed to read line&quot;);
    buffer.trim().split_whitespace()
          .map(|num| num.parse().expect(&quot;Failed to parse number&quot;))
          .collect()
}

fn rec(mask: i64, ind: &amp;[i32], g: &amp;[Vec&lt;i32&gt;], all_visited: i64, dp: &amp;mut [i64], n: usize) -&gt; i64 {
    if dp[mask as usize] != -1 {
        return dp[mask as usize];
    }
    if mask == all_visited {
        dp[mask as usize] = 1;
        return 1;
    }

    let mut ans = 0;
    for i in 0..n {
        if ind[i] == 0 &amp;&amp; (mask &amp; (1 &lt;&lt; i) == 0) {
            let mut temp = ind.to_vec();
            for &amp;v in &amp;g[i] {
                temp[v as usize] -= 1;
            }
            ans += rec(mask | (1 &lt;&lt; i), &amp;temp, g, all_visited, dp, n);
        }
    }

    dp[mask as usize] = ans;
    ans
}

fn main() {
    let first_line = read_ints();
    let (n, m) = (first_line[0] as usize, first_line[1]);
    
    let mut g: Vec&lt;Vec&lt;i32&gt;&gt; = vec![vec![]; n];
    let mut ind: Vec&lt;i32&gt; = vec![0; n];
    let mut dp: Vec&lt;i64&gt; = vec![-1; 1 &lt;&lt; n];
    let all_visited: i64 = (1 &lt;&lt; n) - 1;

    for _ in 0..m {
        let line = read_ints();
        let (mut u, mut v) = (line[0], line[1]);
        u -= 1;
        v -= 1;
        g[u as usize].push(v);
        ind[v as usize] += 1;
    }

    let ans = rec(0, &amp;ind, &amp;g, all_visited, &amp;mut dp, n);
    
    println!(&quot;{}&quot;, ans);
}
</code></pre>
</div>
<div id="pu4" class="pu"><h1><a href="https://github.com/AlephAlpha/Nekomata" rel="nofollow noreferrer">Nekomata</a> + <code>-n</code>, 5 bytes</h1>
<pre><code>↕ᵚ{S=
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=m70iLzU7PzexJHFNtJJurpKOgpJunlLsgqWlJWm6FisftU19uHVWdbDtkuKk5GKo6IKbxmYK0dEGOoaxOkDSCEwag0lTIGkIFjHUMQGSxmC2KVA2FqIXAA" rel="nofollow noreferrer">Attempt This Online!</a></p>
<p>Takes input as a vertex count and a list of edges, e.g., <code>6 [[0,1],[0,2],[0,3],[0,5],[1,2],[1,4],[3,2],[5,3]]</code>.</p>
<pre><code>↕ᵚ{S=
↕       Find a permutation of [0, ..., vertex count - 1]
 ᵚ{     For each element in the edges list:
   S        Find a subset of the permutation
    =       that is equal to the edge
</code></pre>
<p><code>-n</code> counts the number of solutions.</p>
</div>
<div id="pu5" class="pu"><h1>Python, 58</h1>
<pre class="lang-python prettyprint-override"><code>f=lambda G,V:V&lt;{0}or sum(f(G,V-{v})*(V-G[v]==V)for v in V)
</code></pre>
<p>The input consists of an adjacency dictionary <code>G</code> and a vertex set <code>V</code>.</p>
<pre class="lang-python prettyprint-override"><code>G = {0:{1,2,3,5}, 1:{2,4}, 2:set(), 3:{2}, 4:set(), 5:{3}, 6:set()}
V = {0,1,2,3,4,5,6}
</code></pre>
<p>The code is recursive. The set <code>V</code> stores all nodes that still need visiting. For each potential next node, we check its suitability by seeing if no remaining vertices point to it, with <code>V-G[v]==V</code> checking that <code>V</code> and <code>G[v]</code> are disjoint. For all suitable such vertices, we add the number of topological sorts with it removed. As a base case, the empty set gives 1.</p>
</div>
<div id="pu6" class="pu"><h1>CJam - 25</h1>

<pre><code>q~{_f{1$-_j@j@&amp;!*}_!+:+}j
</code></pre>

<p>With great help from user23013 :)</p>

<p><a href="http://cjam.aditsu.net/#code=q~%7B_f%7B1%24-_j%40j%40%26!%2A%7D_!%2B%3A%2B%7Dj&amp;input=%5B0%201%202%203%204%205%5D%5B%5B1%202%203%205%5D%5B2%204%5D%5B%5D%5B2%5D%5B%5D%5B3%5D%5D" rel="nofollow noreferrer">Try it online</a></p>

<p><strong>Explanation:</strong></p>

<p>The general algorithm is the same as in <a href="https://codegolf.stackexchange.com/a/46863/7416">xnor's Python solution</a>.<br>
The key here is the <code>j</code> operator, which does memoized recursion. It takes a parameter, a value or array for the initial value(s) (as in f(0), f(1), etc) and a block to define the recursion. The <code>j</code> operator is used again inside the block for doing recursive (and memoized) calls to the same block. It can also be used with multiple parameters, but it's not the case here.<br>
user23013's great innovation is to use j with different data types, making use of the adjacency list as the array of initial values.</p>

<pre><code>q~             read and evaluate the input (vertex list followed by adjacency list)
{…}j           run the block on the vertex list, doing memoized recursion
                and using the adjacency list for initial values
    _          copy the vertex list
    f{…}       for each vertex and the vertex list
        1$-    copy the vertex and remove it from the list
                Python: "V-{v}"
        _j     copy the reduced list and call the j block recursively
                this solves the problem for the reduced vertex list
                Python: "f(G,V-{v})"
        @j     bring the vertex to the top of the stack and call the j block recursively
                in this case, it's called with a vertex rather than a list
                and the memoized value is instantly found in the list of initial values
                effectively, this gets the list of vertices adjacent to the current vertex
                Python: "G[v]"
        @&amp;     bring the reduced list to the top of the stack and intersect
        !*     multiply the number of topological sorts of the reduced vertex list
                with 1 if the intersection was empty and 0 if not
                Python: equivalent to "*(V-G[v]==V)"
               after this loop we get an array of sub-results for the reduced vertex lists
    _!+        add 1 or 0 to the array if the array was empty or not
                because we want to get 1 for the empty array
                Python: equivalent to "V&lt;{0}or"
    :+         add the numbers in the array
                Python: "sum(…)"
</code></pre>
</div>
<div id="pu7" class="pu"><h1>Mathematica, <s>80</s> <s>57</s> 51 bytes</h1>

<pre><code>Count[Permutations@#,l_/;l~Subsets~{2}~SubsetQ~#2]&amp;
</code></pre>

<p>Very straight-forward implementation of the definition. I'm just generating all permutations and count how many of them are valid. To check if a permutation is valid, I get all pairs of vertices in the permutation. Conveniently, <code>Subsets[l,{2}]</code> not only gives me all pairs, it also maintains the order they are found in in <code>l</code> - just what I need.</p>

<p>The above is a function that expects the vertex list and edge list, like</p>

<pre><code>f[{1, 2, 3, 4, 5, 6}, {{1, 2}, {1, 3}, {1, 4}, {1, 6}, {2, 3}, {2, 5}, {4, 3}, {6, 4}}]
</code></pre>

<p>if you call the function <code>f</code>.</p>

<p>I'll try to golf this, or maybe use another approach later.</p>
</div>
<div id="pu8" class="pu"><h1>Haskell, <strike>102</strike> <strike>107</strike> <strike>100</strike> <strike>89</strike> 85 bytes</h1>

<pre><code>import Data.List
(%)=elemIndex
n#l=sum[1|p&lt;-permutations[0..n],and[u%p&lt;v%p|[u,v]&lt;-l]]
</code></pre>

<p>The input is the highest vertex number (starting with 0) and an edge list, where an edge is a two element list. Usage example: <code>5 # [[0,1], [0,2], [0,3], [0,5], [1,2], [1,4], [3,2], [5,3]]</code></p>

<p>How it works: count all permutations <code>p</code> of the vertices for which all edges <code>[u,v]</code> satisfy: position of <code>u</code> in <code>p</code> is less than position of <code>v</code> in <code>p</code>. That's a direct implementation of the definition.</p>

<p>Edit: my first version returned the topological sorts themselves and not how many there are. Fixed it.</p>

<p>Edit II: didn't work for graphs with not connected vertices. Fixed it. </p>
</div>
<div id="pu9" class="pu"><h1>Pyth, 27 bytes</h1>
<pre><code>Mlf!sm}_dHfq2lYyTfqSZUZ^UGG
</code></pre>
<p>Defines a 2 input function, <code>g</code>. First input is the number of vertices, second is the list of directed edges.</p>
<p>To test:</p>
<pre><code>Code:
Mlf!sm}_dHfq2lYyTfqSZUZ^UGGghQeQ

Input:
6, [ [0, 1], [0, 2], [0, 3], [0, 5], [1, 2], [1, 4], [3, 2], [5, 3] ]
</code></pre>
<p><a href="http://pyth.herokuapp.com/" rel="nofollow noreferrer">Try it here.</a></p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/46836/">46836</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




