<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::58985</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>405</td><td>Scala 3</td><td>240322T012012Z</td><td><a href="https://codegolf.stackexchange.com/questions/58985/invert-a-minesweeper-board/272026#272026">138 Aspe</a></td></tr>
<tr d-ix="1"><td>053</td><td>Uiua</td><td>240321T221344Z</td><td><a href="https://codegolf.stackexchange.com/questions/58985/invert-a-minesweeper-board/272022#272022">Joao-3</a></td></tr>
<tr d-ix="2"><td>028</td><td>Vyxal 3 j</td><td>240320T220508Z</td><td><a href="https://codegolf.stackexchange.com/questions/58985/invert-a-minesweeper-board/272004#272004">pacman25</a></td></tr>
<tr d-ix="3"><td>076</td><td>Octave</td><td>150930T001744Z</td><td><a href="https://codegolf.stackexchange.com/questions/58985/invert-a-minesweeper-board/59100#59100">beaker</a></td></tr>
<tr d-ix="4"><td>119</td><td>Ruby</td><td>150929T091607Z</td><td><a href="https://codegolf.stackexchange.com/questions/58985/invert-a-minesweeper-board/58993#58993">Level Ri</a></td></tr>
<tr d-ix="5"><td>038</td><td>Pyth</td><td>150929T084643Z</td><td><a href="https://codegolf.stackexchange.com/questions/58985/invert-a-minesweeper-board/58992#58992">Jakube</a></td></tr>
<tr d-ix="6"><td>057</td><td>CJam</td><td>150929T051017Z</td><td><a href="https://codegolf.stackexchange.com/questions/58985/invert-a-minesweeper-board/58986#58986">Dennis</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://www.scala-lang.org/" rel="nofollow noreferrer">Scala 3</a>, 405 bytes</h1>
<p>A port of <a href="https://codegolf.stackexchange.com/a/58993/110802">@Level River St's Ruby answer</a> in Scala.</p>
<p>405 bytes, it can be golfed more.</p>
<hr />
<p>Golfed version. <a href="https://ato.pxeger.com/run?1=VVHBTtwwEBXX_QqTw2KbJNo4FxTWkThw4FBxqDgRhEyc3aT12qvEsLGifAYnJAQHeukXtV9T2wlqa0Wemfdm7Peclx9dyQRLf94GkVQH1srg7terevhWlRp8YY0EwwIAXm3AzhaQtdsuAxdty8ztV902cnuHMnAjGw2o7wTgiQnwoFjLLRJgTBKCU1LINE2x_XAhE0wslKaFJH7hpJCOIsT1EexoggN_2N5eoYWEGvojEbLo-PGoN9HZ76NnJ0vDLpuUoDnSwUkQtIu7vWg0DAoZoHOH1VTEopJbXfvyYMu6Yvx6rxsl4x3bw_uZR_G20tftpegquEILuNIK1FGCXNNgaO6BwyfQ01xAg2CPdkyX9VCyrjrBJzQvoQj70KBYq0kbcBS4p3mAg3GMd98n-G82qR0Xzpqdzv576rDPrqQOjduR2yarim5UO3CzjkCUACssOef9P0WzAeaUm5yulkuXrD9fYbnsT3nvcZesrQlLo5kdTVMJDnkfWmyh4lI9Su29zZh37Qagm0bH1Hoe57_zPse3tyn-AQ" rel="nofollow noreferrer">Attempt This Online!</a></p>
<pre class="lang-scala prettyprint-override"><code>def t(s:String):String={val l=s.split(&quot;\n&quot;);val h=l.length;val w=l.headOption.map(_.length).getOrElse(0)
(0to h-1).map{y=&gt;(0to w-1).map{x=&gt;l(y)(x)match{case'*'=&gt;c(l,x,y).toString case _=&gt;&quot;*&quot;}}.mkString}.mkString(&quot;\n&quot;)}
def c(l:Array[String],x:Int,y:Int):Int={val o=for{dy&lt;- -1 to 1;dx&lt;- -1 to 1;if y+dy&gt;=0&amp;&amp;y+dy&lt;l.length&amp;&amp;x+dx&gt;=0&amp;&amp;x+dx&lt;l(y+dy).length}yield(dx,dy)
o.count{case(dx,dy)=&gt;l(y+dy)(x+dx)!='*'}}
</code></pre>
<p>Ungolfed version. <a href="https://ato.pxeger.com/run?1=ZVRLbtswEN105VNMtYhFNlZsaVMYdoC26KKLIEDaruoioCVKYiNRBkmlEgKdpJts2kP1NB1Sn9iuIEjkzJsf3wN__dExK1j0_Py7Nuni7d9X82r_g8cGbpiQ8DQDSHgKJW58pjK9hndKsfbbZ6OEzL6TNXyVwsDWIQEeWQH7iqkELR6l4SqkUbiTURRRfOlOrmiIpijaydA9dLWT1hWGFhdS6w6p55IdsIQppG8UkzqtVPneZvZdfkIQ0s2G9s4Q2GXfHxkXJw0WQnKNFh3oQyGM7-2kRyZvzkWW24kcLCi4zEw-eX-KxOSTM-csuT0YUcmgZAf_fkCTIOPmVn0sNPeXZOaC_SXU0ogxP7EB8AQtbK-d_wjhaoyA5gUAfVW_JX5DkBIT58NU_RMzzWFO5xgBcYW5bhzcBV1CcwktCUw1HMjVFXywGNC1UrhIrFHW5Z4rDSIFYeYaGJQYfF7iHhdYwqOezfKlVhL4I1ctyEoubADEvCgAyauGDJf4LUX8YGuYnMNdvW-hqDIRT7m7YdUF5UPf4ux0O9E0sX4-45k2ceQ1fJIG53Z_4r4nSqjSVHNjtYDimc4yaWGzgMUKsP_VaGv-t-EptfDGwq-3sISLi3G7OdGOdTTW0Uy4YbsZCXVh5FhrHbSCFwn4CfKGvl5EQ7-BmxzF4egYIS9CsaPFOVOjTscCfl-XDDAHeb11kpnk4Jg0ec8UMyA00mqOldA5Drr-vhiujfH6-Ac" rel="nofollow noreferrer">Attempt This Online!</a></p>
<pre class="lang-scala prettyprint-override"><code>object Main {
  def main(args: Array[String]): Unit = {
    val board = &quot;**212*32\n333*33**\n1*22*333\n222222*1\n*33*2232\n2**22*2*&quot;
    println(transformBoard(board))
  }

  def transformBoard(s: String): String = {
    val lines = s.split(&quot;\n&quot;)
    val height = lines.length
    val width = lines.headOption.map(_.length).getOrElse(0)

    (0 until height).map { y =&gt;
      (0 until width).map { x =&gt;
        lines(y)(x) match {
          case '*' =&gt; countMines(lines, x, y).toString // Count surrounding numbers if it's a mine
          case _   =&gt; &quot;*&quot; // Turn every non-mine cell into a mine, mimicking the Ruby logic
        }
      }.mkString
    }.mkString(&quot;\n&quot;)
  }

  def countMines(lines: Array[String], x: Int, y: Int): Int = {
    val offsets = for {
      dy &lt;- -1 to 1
      dx &lt;- -1 to 1
      if y + dy &gt;= 0 &amp;&amp; y + dy &lt; lines.length &amp;&amp; x + dx &gt;= 0 &amp;&amp; x + dx &lt; lines(y + dy).length
    } yield (dx, dy)

    offsets.count { case (dx, dy) =&gt;
      val char = lines(y + dy)(x + dx)
      char != '*' // Count everything that is not a mine
    }
  }
}
</code></pre>
</div>
<div id="pu1" class="pu"><h1><a href="https://uiua.org" rel="nofollow noreferrer">Uiua</a>, 53 bytes</h1>
<pre><code>⍜☇≡(⟨@*◌|⊢°⋕/+¬⟩°⊂=@*)1⍉≡(↘⊟.¯1↻)☇1⊞⊟.0_1_¯1¤⬚@*↙+1△.
</code></pre>
<p><a href="https://uiua.org/pad?src=0_10_0-dev_1__U29sdXRpb24g4oaQIOKNnOKYh-KJoSjin6hAKuKXjHziiqLCsOKLlS8rwqzin6nCsOKKgj1AKikx4o2J4omhKOKGmOKKny7CrzHihrsp4piHMeKKnuKKny4wXzFfwq8xwqTirJpAKuKGmSsx4pazLgoKU29sdXRpb24gWyIxMTEiCiAgICAgICAgICAiMSoxIgogICAgICAgICAgIjExMSJdClNvbHV0aW9uIFsiLiJdClNvbHV0aW9uIFsiKjExKjEuMSoqMS4uLjEqKioxLi4uLi4xKioqKioxLi4uLi4uLi4uLiJdClNvbHV0aW9uIFsiKioyMTIqMzIiCiAgICAgICAgICAiMzMzKjMzKioiCiAgICAgICAgICAiMSoyMiozMzMiCiAgICAgICAgICAiMjIyMjIyKjEiCiAgICAgICAgICAiKjMzKjIyMzIiCiAgICAgICAgICAiMioqMjIqMioiXQo=" rel="nofollow noreferrer">Try it in the pad!</a></p>
<p>Port of <a href="https://codegolf.stackexchange.com/a/58986/111474">Dennis's CJam answer</a>.</p>
</div>
<div id="pu2" class="pu"><h1><a href="https://github.com/Vyxal/Vyxal/tree/version-3" rel="nofollow noreferrer">Vyxal 3</a> <code>j</code>, 28 bytes</h1>
<pre><code>ᵛƛ•=[ð|•]:Þȯᵛᵛ•CZᵗZᵛᵛ₳•c¿•]“
</code></pre>
<p><a href="https://vyxal.github.io/latest.html#WyJqIiwiIiwi4bWbxpvigKI9W8OwfOKAol06w57Ir+G1m+G1m+KAokNa4bWXWuG1m+G1m+KCs+KAomPCv+KAol3igJwiLCIiLCJbW1wiKlwiLCBcIipcIiwgXCIyXCIsIFwiMVwiLCBcIjJcIiwgXCIqXCIsIFwiM1wiLCBcIjJcIl0sIFtcIjNcIiwgXCIzXCIsIFwiM1wiLCBcIipcIiwgXCIzXCIsIFwiM1wiLCBcIipcIiwgXCIqXCJdLCBbXCIxXCIsIFwiKlwiLCBcIjJcIiwgXCIyXCIsIFwiKlwiLCBcIjNcIiwgXCIzXCIsIFwiM1wiXSwgW1wiMlwiLCBcIjJcIiwgXCIyXCIsIFwiMlwiLCBcIjJcIiwgXCIyXCIsIFwiKlwiLCBcIjFcIl0sIFtcIipcIiwgXCIzXCIsIFwiM1wiLCBcIipcIiwgXCIyXCIsIFwiMlwiLCBcIjNcIiwgXCIyXCJdLCBbXCIyXCIsIFwiKlwiLCBcIipcIiwgXCIyXCIsIFwiMlwiLCBcIipcIiwgXCIyXCIsIFwiKlwiXV1cbiIsIjMuNC4yIl0=" rel="nofollow noreferrer">Try it Online!</a></p>
<p>wish vectorize modifier deep vectorized</p>
<p>input is a 2d list of characters</p>
<pre><code>ᵛƛ•=[ð|•]:Þȯᵛᵛ•CZᵗZᵛᵛ₳•c¿•]“­⁡​‎‎⁪⁡⁪⁠⁪⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁡⁪‏‏​⁡⁠⁡‌⁢​‎‎⁪⁡⁪⁠⁪⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁡⁪‏‏​⁡⁠⁡‌⁣​‎‎⁪⁡⁪⁠⁪⁢⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁡⁪‏‏​⁡⁠⁡‌⁤​‎‎⁪⁡⁪⁠⁪⁣⁢⁪‏‏​⁡⁠⁡‌⁢⁡​‎‎⁪⁡⁪⁠⁪⁣⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁣⁤⁪‏‏​⁡⁠⁡‌⁢⁢​‎‎⁪⁡⁪⁠⁪⁤⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁤⁤⁪‏⁠⁪⁪‏​⁡⁠⁡‌⁢⁣​‎‎⁪⁡⁪⁠⁪⁢⁡⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁡⁢⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁡⁣⁪‏‏​⁡⁠⁡‌⁢⁤​‎‎⁪⁡⁪⁠⁪⁢⁡⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁢⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁢⁢⁪‏⁠⁪⁪⁠‎⁪⁡⁪⁠⁪⁢⁣⁣⁪‏‏​⁡⁠⁡‌⁣⁡​‎‎⁪⁡⁪⁠⁪⁢⁢⁣⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁢⁤⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁣⁡⁪‏⁠‎⁪⁡⁪⁠⁪⁢⁣⁢⁪‏‏​⁡⁠⁡‌⁣⁢​‎‎⁪⁡⁪⁠⁪⁢⁣⁤⁪‏‏​⁡⁠⁡‌­
ᵛƛ      ]                     # ‎⁡map over each character
  •=[                         # ‎⁢is it a mine?
     ð|•]                     # ‎⁣if yes, replace with a space. if no, replace with a mine
         :                    # ‎⁤push two copies of the inverse mines
          Þȯ                  # ‎⁢⁡grid neighbors
            ᵛᵛ•C              # ‎⁢⁢counts of mines around each cell
                ZᵗZ           # ‎⁢⁣zip each mine count with the inverted mine locations
                   ᵛᵛ₳    ]   # ‎⁢⁤reduce each pair by
                      •c¿•    # ‎⁣⁡if it contains a mine, set it to a mine, otherwise take the number
                           “  # ‎⁣⁢join on nothing, j flag joins on newlines
💎
</code></pre>
<p>Created with the help of <a href="https://vyxal.github.io/Luminespire" rel="nofollow noreferrer">Luminespire</a>.</p>
</div>
<div id="pu3" class="pu"><h1>Octave, 76</h1>

<pre><code>m=@(s)char(conv2(b=(cell2mat(strsplit(s)'))~='*',ones(3),'same').*~b-6*b+48)
</code></pre>

<h3>Explanation</h3>

<ul>
<li><p>Convert input string to matrix of strings using <code>strsplit</code> and
<code>cell2mat</code>.</p></li>
<li><p>Get the logical matrix containing <code>1</code> where there is no <code>*</code> in the
original matrix.</p></li>
<li><p>Take its convolution with a 3x3 matrix of 1's.</p></li>
<li><p>Mask it with the inverse logical matrix and put <code>*</code> in place of the
mask.</p></li>
<li><p>Note: Cells with no mine neighbors are represented as <code>0</code>.</p></li>
</ul>

<h3>Execution</h3>

<pre><code>&gt;&gt; m(['**100' 10 '34321' 10 '*2**1'])   %// `10` is newline
ans =

24***
*****
3*44*

&gt;&gt; m(['24***' 10 '*****' 10 '3*44*'])
ans =

**100
34321
*2**1
</code></pre>
</div>
<div id="pu4" class="pu"><h1>Ruby, 119</h1>
<pre><code>-&gt;s{w=1+s.index('
')
s.size.times{|c|t=0;9.times{|i|(s+?**w*2)[c+i/3*w-w+i%3-1]&lt;?0||t+=1}
print [t,?*,'
'][s[c]&lt;=&gt;?*]}}
</code></pre>
<p>Ungolfed in test program:</p>
<pre><code>f=-&gt;s{
  w=1+s.index(&quot;\n&quot;)                          #width of board
  s.size.times{|c|                           #iterate through input
    t=0;                                     #number of digits surrounding current cell
    9.times{|i|                              #iterate through 3x3 box (centre must be * if this ever gets printed.)
      (s+&quot;*&quot;*w*2)[c+i/3*w-w+i%3-1]&lt;&quot;0&quot;||t+=1 #copy of s has plenty of * appended to avoid index errors
    }                                        #add 1 every time a number is found.
  print [t,&quot;*&quot;,&quot;\n&quot;][s[c]&lt;=&gt;&quot;*&quot;]             #if * print t. if after * in ACSII it's a number, print *. if before, it's \n, print \n
  }
}


f['**212*32
333*33**
1*22*333
222222*1
*33*2232
2**22*2*']
</code></pre>
</div>
<div id="pu5" class="pu"><h1>Pyth, <s>39</s> 38 bytes</h1>

<pre><code>j.es.eh-+K\*l-s:RtWYY+Y2:+K.zk+k3KZb.z
</code></pre>

<p>Try it online: <a href="http://pyth.herokuapp.com/?code=j.es.eh-%2BK%5C*l-s%3ARtWYY%2BY2%3A%2BK.zk%2Bk3KZb.z&amp;input=**212*32%0A333*33**%0A1*22*333%0A222222*1%0A*33*2232%0A2**22*2*&amp;debug=0">Demonstration</a></p>

<p>The main algorithm is really straightforward. I simply iterate over each cell, take the surrounding 3x3 box (or smaller when the cell is at the border) and print a star or the number of non-stars in that box. </p>

<h3>Explanation:</h3>

<pre><code>j.es.eh-+K\*l-s:RtWYY+Y2:+K.zk+k3KZb.z  implicit: .z = list of input strings
 .e                                 .z  map each index k, line b of .z to:
    .e                             b      map each index Y, char Z of b to:
         K\*                                assign "*" to K
                         +K.z               insert K at the front of .z
                        :    k+k3           slice from k to k+3
               :RtWYY+Y2                    take the slice from Y-1 or 0 
                                            to Y+2 for each line
              s                             join, this gives the 3x3 rectangle
                                             (or smaller on the border)
             -                   K          remove all "*"s
            l                               take the length
        +K                                   "*" + ^
       -                          Z         remove Z from this string
      h                                     and take the first char
                                            (if cell=mine take the number, 
                                             otherwise take the number)
  s                                       join the chars of one line
j                                       join by newlines
</code></pre>
</div>
<div id="pu6" class="pu"><h1>CJam, <s>58</s> 57 bytes</h1>

<pre><code>0WX]2m*qN/{'*f+z}2*f{\~@m&lt;fm&lt;W&lt;}:..+{W&lt;{_'*#'*@'*-,?}/N}/
</code></pre>

<p>Input should not end with a linefeed. Output contains <code>0</code> for cells without nearby mines.</p>

<p>Try it online in the <a href="http://cjam.aditsu.net/#code=0WX%5D2m*qN%2F%7B&#39;*f%2Bz%7D2*f%7B%5C~%40m%3Cfm%3CW%3C%7D%3A..%2B%7BW%3C%7B_&#39;*%23&#39;*%40&#39;*-%2C%3F%7D%2FN%7D%2F&amp;input=**212*32%0A333*33**%0A1*22*333%0A222222*1%0A*33*2232%0A2**22*2*">CJam interpreter</a>.</p>

<h3>Idea</h3>

<p>We start by padding the input matrix with one row and one column of asterisks.</p>

<p>For input</p>

<pre><code>*4*
**2
</code></pre>

<p>this results in</p>

<pre><code>*4**
**2*
****
</code></pre>

<p>Now we generate all possible modifications that result of rotating the rows and columns 0, -1 or 1 units up/left:</p>

<pre><code>*4** **** **2* **4* **** ***2 4*** **** *2**
**2* *4** **** ***2 **4* **** *2** 4*** ****
**** **2* *4** **** ***2 **4* **** *2** 4***
</code></pre>

<p>We discard the "padding locations" from each rotation, i.e.,</p>

<pre><code>*4* *** **2 **4 *** *** 4** *** *2*
**2 *4* *** *** **4 *** *2* 4** ***
</code></pre>

<p>and form a single matrix by concatenating the corresponding characters of each rotation:</p>

<pre><code>******4** 4*******2 **24*****
*******4* *4****2** 2***4****
</code></pre>

<p>The first character of each position is its original character.</p>

<ul>
<li><p>If it is a non-asterisk, it has to be replaced with an asterisk.</p></li>
<li><p>If it is an asterisk, the number of non-asterisks in that string is the number of neighboring mines.</p></li>
</ul>

<h3>How it works</h3>

<pre><code>0WX]2m*   e# Push the array of all vectors of {0,-1,1}^2.
qN/       e# Read all input from STDIN and split at linefeeds.
{'*f+z}2* e# Append a '*' to each row and transpose rows with columns. Repeat.
f{        e# For each vector [A B], push the modified input Q; then:
  \~      e#   Swap Q with [A B] and dump A and B on the stack.
  @m&lt;     e#   Rotate the rows of Q B units up.
  fm&lt;     e#   Rotate each row of the result A units left.
  W&lt;      e#   Discard the last row.
}         e# This pushes all nine rotations with Manhattan distance 1.
:..+      e# Concatenate the corresponding characters for each position.
{         e# For each row:
  W&lt;      e#   Discard the character corresponding to the last column.
  {       e#   For each remaining string:
    _'*#  e#     Find the first index of '*' in a copy.
    '*    e#     Push '*'.
    @'*-, e#     Count the non-asterisks in the string.
    ?     e#     Select '*' if the index is non-zero, the count otherwise.
  }/      e#
  N       e#   Push a linefeed.
}/        e#
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/58985/">58985</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




