<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::264190</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>149</td><td>JavaScript V8</td><td>230815T132951Z</td><td><a href="https://codegolf.stackexchange.com/questions/264190/iterate-over-strings-ii/264206#264206">Arnauld</a></td></tr>
<tr d-ix="1"><td>215</td><td>Haskell</td><td>230815T132630Z</td><td><a href="https://codegolf.stackexchange.com/questions/264190/iterate-over-strings-ii/264204#264204">matteo_c</a></td></tr>
<tr d-ix="2"><td>061</td><td>Charcoal</td><td>230815T101954Z</td><td><a href="https://codegolf.stackexchange.com/questions/264190/iterate-over-strings-ii/264194#264194">Neil</a></td></tr>
<tr d-ix="3"><td>040</td><td>05AB1E</td><td>230815T091556Z</td><td><a href="https://codegolf.stackexchange.com/questions/264190/iterate-over-strings-ii/264192#264192">Kevin Cr</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://v8.dev/" rel="nofollow noreferrer">JavaScript (V8)</a>, 149 bytes</h1>
<p>Prints the strings.</p>
<p>The criterion on 0's is borrowed from <a href="https://codegolf.stackexchange.com/a/264194/58563">Neil's answer</a>.</p>

<pre class="lang-javascript prettyprint-override"><code>n=&gt;(c=[],F=(s,m=1,p,g=i=&gt;~i&amp;&amp;g(i-1,!!i&amp;i==p|(i?2:2*n*/,1/.test(c))&lt;(c[i]=-~c[i])||F(s+&quot;0abcde&quot;[i],m+(i==m&amp;m&lt;n),i),c[i]--))=&gt;s[4*n-1]?print(s):g(m))``
</code></pre>
<p><a href="https://tio.run/##TYtBboMwEEX3PYUTVWgG7KROs4gShuxyCYQEdQFNBQZhK5uQXJ2arrp60vvv/1T3ypmJR6/up6WhxVIGhvJC3gic7EnLUbbElL04ilpgpeVmwxETjTPw9XA@xDbeS73f@dp5MIgpmJwLUq8VOM83cMn2o/oy3/U2GNknEN591KcWJaNcM6UQKXP5MbZKF9dxYuvB4bmFHrEsl2aYoKu9sIKEvgSkJD4DkwTF400IM1g3dPWuG1oo1@j9YZ8lXsLUgP3j/ySI5/IL" rel="nofollow noreferrer" title="JavaScript (V8) – Try It Online">Try it online!</a></p>
<h3>Commented</h3>
<pre class="lang-javascript prettyprint-override"><code>n =&gt; (                    // n = input
  c = [],                 // c[] is an array to keep track of char. counts
  F = (                   // F is a recursive function taking:
    s,                    //   s = current output string
    m = 1,                //   m = upper character bound
    p,                    //   p = previous character index
    g = i =&gt;              //   g is a recursive function taking a counter i
    ~i &amp;&amp; g(              //   unless i = -1, do a recursive call:
      i - 1,              //     decrement i
      !!i &amp; i == p |      //     abort if i &gt; 0 and i = p (repeated letter)
      (                   //     compute the max. count for this character:
        i ?               //       if this is a letter:
          2               //         the max. count is 2
        :                 //       else (this is a '0'):
          2 * n *         //         the max. count is 2n if it's preceded
          /,1/.test(c)    //         by a letter appearing exactly once
      ) &lt; (c[i] = -~c[i]) //     increment c[i] and abort if it's too high
      || F(               //     otherwise, do a recursive call to F:
        s + &quot;0abcde&quot;[i],  //       append the new character to s
        m +               //       increment m if ...
        (i == m &amp; m &lt; n), //       ... i = m and m &lt; n
        i                 //       set the previous character index to i
      ),                  //     end of recursive call
      c[i]--              //     restore c[i] afterwards
    )                     //   end of recursive call
  ) =&gt;                    //
  s[4 * n - 1] ?          //   if the target length is reached:
    print(s)              //     print s
  :                       //   else:
    g(m)                  //     call g with i = m
)``                       // initial call to F
</code></pre>
</div>
<div id="pu1" class="pu"><h1><a href="https://www.haskell.org" rel="nofollow noreferrer">Haskell</a>, 215 bytes</h1>
<pre class="lang-haskell prettyprint-override"><code>import Data.List
f n|c&lt;-&quot;__&quot;&gt;&gt;take n['a'..]=[x|x&lt;-permutations$c++(c&gt;&gt;&quot;0&quot;),x!!0=='a',all(\i-&gt;not$isInfixOf[i,i]x)c,all((\(f,z:s)-&gt;last$(any(&gt;z)$intersect f s):[all(`elem`z:f)['a'..z]|z&gt;'0']).(`splitAt`x))[0..4*n-1]]
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=NZJNaoQwFMfp1lNkRDDpqKRDF-0wCoVuCoUewJHxxSoNo1FMhlqZm3Qzm9IjlfY0NYm6-vn_eCRPP7_fQB7Lur5cvk6qCu9-f3jTtb1Cj6AgeuZSORUS52IXuoeDmyQKjiUSqQ9-FGVxOpyHXdiVfXNSoHgrpFes17hIEpe6JBhWKxrHUzaAusZ7HiaiVR6XT6Liw0uV8oBnAymMi_e4CsatJGFSg1QeBvGBk5F4XKiyl2WhUIUk2aY6nJd12eTjtiL2JGN2HhOf-hmJcC67mqsHlQ-EpDSKbq9FeJNl9np_V_eyrTcoRu9t_yqRC3R6GDCkARi1wCgswMACWGuKWGB0zmgBLMBiTWgAbFiXDDA6t4wAFmCxbEuPmRVtagBb1yVTZ3Sum3mLZepm3qzYuplnFROfwF7adZwGuJh20fXTkpGHxIkhLPXXxxXaEILiGJlXvTPHbnD5Uf4B" rel="nofollow noreferrer">Attempt This Online!</a></p>
</div>
<div id="pu2" class="pu"><h1><a href="https://github.com/somebody1234/Charcoal" rel="nofollow noreferrer">Charcoal</a>, 61 bytes</h1>
<pre><code>Ｎθ⊞υωＦ×⁴θ≔ΣＥυ⁺κ⁺Ｅ∧‹№κ0⊗θ⊙β⁼¹№κμ0Φ⪪…βθ¹∧⁻μΦ⮌κ¬π∧‹№κμ²⬤…βν№κξυυ
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=VZDNSgMxEMfx6lOEPU0gBVs8iJ6WVUGwpVhv4mE_Ujc0X7uTqfZZvFRQ9Jl8GhO7FptLZub3n5k_8_pVt2Vfu1Jvtx8UlqOz76PzG-spzMhUsoeOXxzPCVsgwZ5jvHQ9g3tlJMKpYB3nLEdUTxYWZGBa-qSba0JYDX-q5baBW4kIhSMbEspOMi7YpaNKyyYuiUluN1AJdtVRqRHGgu3FhvMk2PVcKx2ir4XXKkCxqbUsWudTZxfp-HdQA1Nl426zl9_JtexRwirymQvgOR-Uh75MrE4S0fpwuOX_DL3wvycYpQP1KoIYvWNV43DIz4dstNbZ49tkl_8A" rel="nofollow noreferrer">Attempt This Online!</a> Link is to verbose version of code. Explanation: Based on my answer to <a href="https://codegolf.stackexchange.com/q/264102/">Iterate over all non-equivalent strings</a>.</p>
<pre><code>Ｎθ
</code></pre>
<p>Input <code>n</code>.</p>
<pre><code>⊞υω
</code></pre>
<p>Start with an empty string.</p>
<pre><code>Ｆ×⁴θ
</code></pre>
<p>Loop <code>4n</code> times.</p>
<pre><code>≔ΣＥυ⁺κ⁺Ｅ∧‹№κ0⊗θ⊙β⁼¹№κμ0Φ⪪…βθ¹∧⁻μΦ⮌κ¬π∧‹№κμ²⬤…βν№κξυ
</code></pre>
<p>For each string so far, create strings with zero and all of the first n lowercase letters appended to it, but exclude those that fail to satisfy the criteria.</p>
<pre><code>υ
</code></pre>
<p>Output the final strings.</p>
<p>There are two criteria that are checked before a zero can be appended:</p>
<ul>
<li>There must be fewer than <code>2n</code> zeros already in the string.</li>
<li>There must be a letter that appears exactly once in the string.</li>
</ul>
</div>
<div id="pu3" class="pu"><h1><a href="https://github.com/Adriandmen/05AB1E/wiki/Commands" rel="nofollow noreferrer">05AB1E</a>, 40 <a href="https://github.com/Adriandmen/05AB1E/wiki/Codepage" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>A£©Î×ì2×œÙʒáÙ®Q}ʒÔág;Q}ʒS&gt;ƶ©þε®s¡`áÃgĀ}P
</code></pre>
<p>Brute-force, so very slow. Is able to output the result for <span class="math-container">\$n=2\$</span> in about 20 seconds on TIO.</p>
<p><a href="https://tio.run/##yy9OTMpM/f/f8dDiQysP9x2efniN0eHpRycfnnlq0uGFh2ceWhdYC2RNObww3RrECrY7tg2ocN@5rYfWFR9amABU05x@pKE24P9/o/@6unn5ujmJVZUA" rel="nofollow noreferrer">Try it online.</a></p>
<p><strong>Explanation:</strong></p>

<p>Step 1: Create a string with the correct characters, to comply to the first and sixth rules (&quot;<em>Your string should contain exactly two each of the first <span class="math-container">\$n\$</span> letters of the alphabet.</em>&quot; and &quot;<em>It must contain exactly <span class="math-container">\$2n\$</span> zeros.</em>&quot;), and get all its unique permutations:</p>
<pre class="lang-python prettyprint-override"><code>A               # Push the lowercase alphabet
 £              # Pop and leave the (implicit) input amount of leading characters
  ©             # Store it in variable `®` (without popping)
   Î            # Push 0 and the input-integer
    ×           # Pop both, and push a string with the input amount of 0s
     ì          # Prepend it to the string
      2×        # Double the entire string
œ               # Pop and push a list of all its permutations
 Ù              # Uniquify this list
</code></pre>
<p><a href="https://tio.run/##AScA2P9vc2FiaWX//0HCo8Kpw47Dl8OsMsOXxZPDmf//Mv8tLW5vLWxhenk" rel="nofollow noreferrer">Try just step 1 online.</a></p>
<p>Step 2: Verify the fifth rule (&quot;<em>If there is a letter at index <code>i</code> in the string, all the letters earlier in the alphabet must occur somewhere at the indices <code>1..i-1</code>.</em>&quot;):</p>
<pre class="lang-python prettyprint-override"><code>ʒ    }          # Filter this list of strings by:
 á              #  Only keep its letters, removing the 0s
  Ù             #  Uniquify it
   ®Q           #  Check whether it's equal to string `®` of step 1
</code></pre>
<p><a href="https://tio.run/##ATEAzv9vc2FiaWX//0HCo8Kpw47Dl8OsMsOXxZPDmcqSw6HDmcKuUX3//zL/LS1uby1sYXp5" rel="nofollow noreferrer">Try the first two steps online.</a></p>
<p>Step 3: Verify the second rule (&quot;<em>It should not contain the same letter twice in a row</em>&quot;):</p>
<pre class="lang-python prettyprint-override"><code>ʒ     }         # Filter it again by:
 Ô              #  Connected uniquify its characters
  á             #  Then remove all 0s again by keeping letters
   g;           #  Pop and push its length, and halve it
     Q          #  Check if halve this length equals the (implicit) input-integer
</code></pre>
<p><a href="https://tio.run/##ATsAxP9vc2FiaWX//0HCo8Kpw47Dl8OsMsOXxZPDmcqSw6HDmcKuUX3KksOUw6FnO1F9//8y/y0tbm8tbGF6eQ" rel="nofollow noreferrer">Try the first three steps online.</a></p>
<p>Step 4: Verify the seventh rule (&quot;<em>For each zero there must exist a pair of identical letters so that one of the pair is somewhere to its left and one of the pair is somewhere to its right in the string.</em>&quot;), which implicitly also verifies the third and fourth rules at the same time (&quot;<em>It must start with the letter <code>a</code>.</em>&quot; and &quot;<em>It must end with a letter</em>&quot;), and output the result:</p>
<pre class="lang-python prettyprint-override"><code>ʒ               # Filter it once more:
 S              #  Convert the string to a list of characters
  &gt;             #  Increase all 0s to 1s (and keep the letters unchanged)
   ƶ            #  Multiply all values by their 1-based index
    ©           #  Store this list as new variable `®` (without popping)
     þ          #  Pop and keep just its digits, removing the letters
      ε         #  Map over this list of integers:
       ®        #   Push list `®`
        s       #   Swap so the current integer is at the top
         ¡      #   Split list `®` by the current integer, leaving a pair of lists
          `     #   Pop and push both lists to the stack
           á    #   Only keep the letters of the second string
            Ã   #   Only keep the letters from the first string that are also in the second
             gĀ #   Check if what remains is NOT empty
      }P        #  After the map: product to check if all are truthy
                # (after which the result is output implicitly)
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/264190/">264190</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




