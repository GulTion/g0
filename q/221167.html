<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::221167</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>163</td><td>Picat</td><td>240405T040908Z</td><td><a href="https://codegolf.stackexchange.com/questions/221167/can-this-pattern-be-made-with-dominoes/272339#272339">Bubbler</a></td></tr>
<tr d-ix="1"><td>129</td><td>JavaScript V8</td><td>210323T202302Z</td><td><a href="https://codegolf.stackexchange.com/questions/221167/can-this-pattern-be-made-with-dominoes/221177#221177">user8165</a></td></tr>
<tr d-ix="2"><td>120</td><td>Charcoal</td><td>210327T174715Z</td><td><a href="https://codegolf.stackexchange.com/questions/221167/can-this-pattern-be-made-with-dominoes/222460#222460">Neil</a></td></tr>
<tr d-ix="3"><td>082</td><td>Ruby</td><td>210324T002202Z</td><td><a href="https://codegolf.stackexchange.com/questions/221167/can-this-pattern-be-made-with-dominoes/221188#221188">Level Ri</a></td></tr>
<tr d-ix="4"><td>082</td><td>Wolfram Language</td><td>210324T051933Z</td><td><a href="https://codegolf.stackexchange.com/questions/221167/can-this-pattern-be-made-with-dominoes/221198#221198">DanTheMa</a></td></tr>
<tr d-ix="5"><td>103</td><td>JavaScript V8</td><td>210324T025257Z</td><td><a href="https://codegolf.stackexchange.com/questions/221167/can-this-pattern-be-made-with-dominoes/221193#221193">tsh</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="http://picat-lang.org" rel="nofollow noreferrer">Picat</a>, 163 bytes</h1>
<pre><code>import sat.
f(R,C,L)=&gt;Z=[I:I in 1..R*C,L[I]=1],E=[{{I,J},B}:I in Z,J in Z,J-I in[1,C],J mod C!=J-I,B::0..1],foreach(I in Z)1#=sum([B:{T,B}in E,I in T])end,E.solve.
</code></pre>
<p><a href="http://retina.inf.ufsc.br/cgi-bin/picat.py?code=import+sat.%0D%0Af%28R%2CC%2CL%29%3D%3EZ%3D%5BI%3AI+in+1..R*C%2CL%5BI%5D%3D1%5D%2CE%3D%5B%7B%7BI%2CJ%7D%2CB%7D%3AI+in+Z%2CJ+in+Z%2CJ-I+in%5B1%2CC%5D%2CJ+mod+C%21%3DJ-I%2CB%3A%3A0..1%5D%2Cforeach%28I+in+Z%291%23%3Dsum%28%5BB%3A%7BT%2CB%7Din+E%2CI+in+T%5D%29end%2CE.solve.%0D%0A%0D%0Amain+%3D%3E%0D%0A%09Tests+%3D+%5B+%25+6+true%2C+8+false%0D%0A%09%09%7B2%2C+1%2C+%5B1%2C+1%5D%7D%2C%0D%0A%09%09%7B3%2C+4%2C+%5B0%2C+1%2C+0%2C+0%2C+1%2C+1%2C+1%2C+1%2C+1%2C+0%2C+0%2C+0%5D%7D%2C%0D%0A%09%09%7B3%2C+4%2C+%5B1%2C+1%2C+1%2C+1%2C+1%2C+1%2C+1%2C+1%2C+1%2C+1%2C+1%2C+1%5D%7D%2C%0D%0A%09%09%7B3%2C+3%2C+%5B1%2C+1%2C+1%2C+1%2C+0%2C+1%2C+1%2C+1%2C+1%5D%7D%2C%0D%0A%09%09%7B3%2C+4%2C+%5B0%2C+1%2C+1%2C+0%2C+1%2C+0%2C+1%2C+0%2C+1%2C+0%2C+1%2C+0%5D%7D%2C%0D%0A%09%09%7B10%2C+10%2C+%5B%0D%0A%09%09%090%2C+1%2C+0%2C+0%2C+1%2C+1%2C+1%2C+1%2C+1%2C+0%2C%0D%0A%09%09%091%2C+1%2C+1%2C+0%2C+0%2C+1%2C+0%2C+0%2C+1%2C+0%2C%0D%0A%09%09%091%2C+0%2C+1%2C+0%2C+0%2C+1%2C+0%2C+1%2C+1%2C+1%2C%0D%0A%09%09%091%2C+1%2C+1%2C+1%2C+1%2C+1%2C+0%2C+1%2C+0%2C+1%2C%0D%0A%09%09%091%2C+0%2C+0%2C+1%2C+1%2C+1%2C+0%2C+1%2C+0%2C+0%2C%0D%0A%09%09%090%2C+0%2C+1%2C+1%2C+1%2C+0%2C+1%2C+1%2C+1%2C+0%2C%0D%0A%09%09%091%2C+1%2C+1%2C+0%2C+0%2C+1%2C+0%2C+0%2C+1%2C+0%2C%0D%0A%09%09%090%2C+0%2C+1%2C+1%2C+1%2C+1%2C+0%2C+1%2C+1%2C+1%2C%0D%0A%09%09%090%2C+0%2C+1%2C+0%2C+0%2C+1%2C+1%2C+1%2C+0%2C+1%2C%0D%0A%09%09%091%2C+1%2C+0%2C+1%2C+1%2C+1%2C+0%2C+0%2C+1%2C+1%0D%0A%09%09%5D%7D%2C%0D%0A%09%09%7B1%2C+1%2C+%5B1%5D%7D%2C%0D%0A%09%09%7B2%2C+2%2C+%5B1%2C+0%2C+0%2C+1%5D%7D%2C%0D%0A%09%09%7B3%2C+1%2C+%5B1%2C+1%2C+1%5D%7D%2C%0D%0A%09%09%7B3%2C+4%2C+%5B1%2C+1%2C+0%2C+1%2C+0%2C+1%2C+1%2C+1%2C+0%2C+1%2C+0%2C+1%5D%7D%2C%0D%0A%09%09%7B4%2C+4%2C+%5B1%2C+1%2C+1%2C+0%2C+1%2C+0%2C+1%2C+1%2C+1%2C+1%2C+1%2C+0%2C+0%2C+1%2C+1%2C+1%5D%7D%2C%0D%0A%09%09%7B3%2C+6%2C+%5B0%2C+1%2C+0%2C+0%2C+0%2C+0%2C+1%2C+1%2C+1%2C+1%2C+1%2C+1%2C+0%2C+0%2C+0%2C+0%2C+1%2C+0%5D%7D%2C%0D%0A%09%09%7B10%2C+10%2C+%5B%0D%0A%09%09%090%2C+1%2C+1%2C+1%2C+1%2C+1%2C+0%2C+1%2C+1%2C+1%2C%0D%0A%09%09%091%2C+1%2C+1%2C+0%2C+0%2C+1%2C+0%2C+0%2C+0%2C+1%2C%0D%0A%09%09%090%2C+0%2C+1%2C+0%2C+1%2C+0%2C+1%2C+1%2C+1%2C+0%2C%0D%0A%09%09%090%2C+1%2C+0%2C+0%2C+1%2C+0%2C+0%2C+0%2C+1%2C+1%2C%0D%0A%09%09%090%2C+1%2C+1%2C+1%2C+1%2C+1%2C+1%2C+1%2C+0%2C+1%2C%0D%0A%09%09%090%2C+0%2C+0%2C+0%2C+1%2C+0%2C+0%2C+1%2C+1%2C+1%2C%0D%0A%09%09%091%2C+1%2C+1%2C+1%2C+1%2C+0%2C+1%2C+0%2C+0%2C+0%2C%0D%0A%09%09%091%2C+0%2C+1%2C+0%2C+0%2C+0%2C+1%2C+0%2C+0%2C+1%2C%0D%0A%09%09%090%2C+1%2C+1%2C+1%2C+0%2C+1%2C+1%2C+0%2C+1%2C+1%2C%0D%0A%09%09%090%2C+0%2C+0%2C+1%2C+1%2C+0%2C+1%2C+1%2C+1%2C+0%0D%0A%09%09%5D%7D%2C%0D%0A%09%09%7B10%2C+10%2C+%5B%0D%0A%09%09%090%2C+1%2C+1%2C+1%2C+1%2C+1%2C+1%2C+1%2C+1%2C+1%2C%0D%0A%09%09%091%2C+1%2C+1%2C+1%2C+1%2C+1%2C+1%2C+1%2C+1%2C+0%2C%0D%0A%09%09%091%2C+1%2C+1%2C+1%2C+1%2C+1%2C+1%2C+1%2C+1%2C+1%2C%0D%0A%09%09%091%2C+1%2C+1%2C+1%2C+1%2C+1%2C+1%2C+1%2C+1%2C+1%2C%0D%0A%09%09%091%2C+1%2C+1%2C+1%2C+1%2C+1%2C+1%2C+1%2C+1%2C+1%2C%0D%0A%09%09%091%2C+1%2C+1%2C+1%2C+1%2C+1%2C+1%2C+1%2C+1%2C+1%2C%0D%0A%09%09%091%2C+1%2C+1%2C+1%2C+1%2C+1%2C+1%2C+1%2C+1%2C+1%2C%0D%0A%09%09%091%2C+1%2C+1%2C+1%2C+1%2C+1%2C+1%2C+1%2C+1%2C+1%2C%0D%0A%09%09%091%2C+1%2C+1%2C+1%2C+1%2C+1%2C+1%2C+1%2C+1%2C+1%2C%0D%0A%09%09%091%2C+1%2C+1%2C+1%2C+1%2C+1%2C+1%2C+1%2C+1%2C+1%0D%0A%09%09%5D%7D%0D%0A%09%5D%2C%0D%0A%09foreach%28%7BR%2C+C%2C+L%7D+in+Tests%29%0D%0A%09%09if+f%28R%2CC%2CL%29+then+println%28%22True%22%29+else+println%28%22False%22%29+end%0D%0A%09end.%0D%0A%09" rel="nofollow noreferrer">Try it on Picat Web IDE!</a></p>
<p>Takes three arguments, where <code>R</code> and <code>C</code> are the number of rows and columns respectively, and <code>L</code> is a flat list of zeros and ones where 1 indicates an occupied cell. The predicate succeeds if there is a solution, and fails otherwise.</p>
<p>With <code>import cp</code> instead, the last test case takes forever to solve. <code>sat</code> solves them instantly when tested on my local machine.</p>
<p>The list <code>Z</code> contains the 1-based indices of 1s in <code>L</code>. For example, given an input of</p>
<pre><code>R = 3, C = 4, L = [
    0, 1, 0, 0,
    1, 1, 1, 1,
    1, 0, 0, 0
]
</code></pre>
<p>then <code>Z</code> is <code>[2, 5, 6, 7, 8, 9]</code>. If using <code>Z</code> instead of <code>L</code> is an acceptable input format, the code size goes down to <strong>138 bytes</strong>:</p>
<pre><code>import sat.
f(R,C,Z)=&gt;E=[{{I,J},B}:I in Z,J in Z,J-I in[1,C],J mod C!=J-I,B::0..1],foreach(I in Z)1#=sum([B:{T,B}in E,I in T])end,E.solve.
</code></pre>
<p>Ungolfed with comments:</p>
<pre><code>import sat. % use SAT solver

f(R,C,L) =&gt;
    Z = [I:I in 1..R*C,L[I]=1], % list of vertex IDs
    E = [{{I,J},B}: % list of edges and associated boolean variables,
                    % where B=1 means {I,J} is the part of a matching
        I in Z,J in Z, % for all possible vertex IDs
        J-I in[1,C], % J comes on the right of I (+1) or directly below (+C)
        J mod C!=J-I, % a clever way to remove the case where
                      % &quot;right&quot; wraps around the border:
                      % for this to be false, J-I should be 1 (not C),
                      % and then J mod C = 1.
        B::0..1 % for each valid edge, create a boolean variable
    ],
    foreach(I in Z) % for each vertex,
        1#=sum([B:{T,B}in E,I in T]) % exactly one incident edge must be used
        % this is one way to specify perfect matching
    end,
    solve(E). % solve the problem; success &lt;=&gt; a solution exists
</code></pre>
</div>
<div id="pu1" class="pu"><h1><a href="https://v8.dev/" rel="nofollow noreferrer">JavaScript (V8)</a>, 129 bytes</h1>

<pre class="lang-javascript prettyprint-override"><code>f=(g,p=d=&gt;(n=2,v=g.map((r,i)=&gt;r.map((c,j)=&gt;c*n&amp;&amp;(n&gt;1?~(y=i+d,x=j+!d):i==y&amp;j==x)?!n--:c)),n?n&gt;1:f(v)))=&gt;g in f?f[g]:f[g]=p(0)|p(1)
</code></pre>
<p><a href="https://tio.run/##rVZbU9w2FH7XrzjMZMAuxgFC2pSMYWgobXrJtg156AAzaG3ZK2JLrqTdZQv0r9MjyVc2PLVzdrWy9twvn3VDF1SnitdmZ/Hm8TFPgiKqkyw5CkSyHy2SIq5oHQQq4mFypPxDGt3gQ/qV2NwMxNHe8T/BKuHbWXSb3GxvZOEhT5LV5k2S3IbHG2Jn5zANw0gcI@dhHizCEGUL4ALy4/yiuDq0S1IHu@F9HeyFj6kU2kBKNdPnas4ggWsyAbgH2HPr@YxrwI@ZMTCKLzgtHfchjNgoaC6KkkEmKy4klJRnsGDK8JSW5YqQGCYQI1nmGPa7vdOfUgFTBqli1LAMltzM0KBiDG148pb24RWS3XszTNvArO2qRts1NYYpQbyluBFq9@SJMqtu3@1PWgWKpYaKYl5SBYXi3pORmLV/gGT3bMEEcmToLMbAqOblCgwv2RfkXiN9jWT3M6n431IYm5gdl6g2mtbF3kG7O5Nz1QfsBBTNuMurDbX1LHb8ZOisd9Vnf9Jlf89lxe5PW62ZBCENCIbOG4mfeTprlHtOW7FXzZ6KzPWDS1FFV5DaaLASrKrN6lmxlJWlBlpKUaAKYFnB@r6YdNR6@bM7/wPpI9KH5vwE9nZv93bBsKZtrTeklYwHq@X@hFp@ciev3dpqkYKBzIEbDVqWc8NxCjq//dqn8RM@9UreIf3e57m13BfiHL5DOmiy/A1@G/Y@zOEwnLvdgesOz@6adcw8zEvcjEEMb5BOPftzCXiP5IftW7eePtU@DtWe/@CeLPv3SL/07GOXena7nsAZUuzZx17HnfZfkWL4EenEnf@GhOzXbwkZwNAZLfUQh/6Uc9@X1ECJU2bALCXINJ3XHE99V2HP5twgFPg5IWTytMOpYqD/muOPhhvJBYpOV64JdeR6P5VKMKWJD4401t8bO9y0XNIVgk1VS635FKECDXq4QpsN7njcws6WWdZIi3k1Zcq2Wmva8XTzPulwqU3pB4kTZdUhTCxhhbGXOGB22nKuMPacLTvxiAxrN0pPa85G3TivWU2VxVfSdyshw95qsR4BteTFzCCcVRIVpBLREYHcYjNiusZpsSFZp@hULhiZdEUe6Bs4R0j8ZFhap9txZrfUIXA31msd3SaI9AM6ngznfVsKV7NKorK2YiReU@cVstuU1Zi1GTUupKk0RlY7Jcvbnhh5PyxWg3vaFp0qha8OVjFhYDnjqX0pkLizFY/CHjdSRT@ztcaYPMEKFySZjALoskLGYNFVo490mCuyFlBfDkzgTJaysO9tj6@5VNgR6YxpPZVUZWRd1BegxlQYbsG9LPAVZ2ZV/AXeyVPsHNrvOrDU0g/WujPPClOY0vSzUbj8Fy/@n2MLajZzgUe2CwdtETZbjXcMll3ZAbq46O5dEV6u5uwqahgdBkaQ25@rqxDuCMBAm@X5aByuOPZY43yaYOtSXIqt0LO77kRe95JOWpEY73BVEPYCW6G7ZJYIiJAcwUUcx3YfK1aXNGXBS7i/vI@3XxYRbG2FV47ZQq5l9r9JAlsTtPp2YBShZ14aNJsH1n7zH88haP7ZSLpUhFArbJzg@sWd//MBgqXCS0LoQnaXzUvx4m4cwcOluG7UMvu@WNeBs2vvc6FneyAPj/8C" rel="nofollow noreferrer" title="JavaScript (V8) – Try It Online">Try it online!</a></p>
<p>Receives the input as a 2-dimensional array of booleans and returns 0 for false or 1 for true.</p>
<h2>Explanation</h2>
<p>Solves the problem recursively calling itself with a single domino removed from the grid. If it is called with an empty grid (which will happen if the initial grid only contained valid domino positions) then it returns true. At each call it tries removing the top-left position containing a domino, calling itself with either the horizontal or vertical orientation removed.</p>
<pre class="lang-js prettyprint-override"><code>f=(g,
// p = function to remove the top-left domino and recurse if the remove succeeded
p=d=&gt;(
// n = squares remaining for removal
n=2,
// v = grid after removal
v=g.map((r,i)=&gt;r.map((c,j)=&gt;c*n&amp;&amp;(n&gt;1?~(y=i+d,x=j+!d):i==y&amp;j==x)?!n--:c)),
// if n=2 the grid was empty so we return true, if n=1 we could not remove the domino
// if n=0 the domino was successfully removed and we recurse
n?n&gt;1:f(v))
// try removing the top-left square with a horizontal or vertical domino
// and cache results
)=&gt;g in f?f[g]:f[g]=p(0)|p(1)
</code></pre>
</div>
<div id="pu2" class="pu"><h1><a href="https://github.com/somebody1234/Charcoal" rel="nofollow noreferrer">Charcoal</a>, 120 bytes</h1>
<pre><code>ＷＳ⊞υιυＦＬυＦＬ§υι«Ｊκι¿⁼ＫＫO«≔⟦ω⟧θＷθ«≔Φurdl№⪪α¹⊟ＫＤ²✳μλ¿λ«≔§λ⁰λ✳λλ≔ＫＫηＰ§dlur⌕urdlλ¿⁼ηO≔⟦⟧θ«Ｍ✳η⊞θη⊞θＫＫ»»«≔⊟θλ✳λ↧λ✳ＫＫ↧⊟θ»»ＵＭＫＡ↥λ
</code></pre>
<p><a href="https://tio.run/##hVFNa4QwED0nvyJ4imCl7bWnpe3Cll0Utj2VHkSza9jR@JHsFoq/3SYmWW2hNGJMZt68efPMy6zLRQbjeCk5MEI3daPkXna8PtIwJKnqS6oiwsMHnOqgpEqfDqIjdMvqo9RJjVreV3JTF@zTFuncF0YvqmpeBT1ZGsQPhD63KoOepoydaBiRIAksFK36nh9r@n75iEhr0MgJa23eA9YcJOtooLoCgog8CqW17RvgkmYRudOcqWgm/ifesVxyUdP7iMyXKjQrIjA1mUSBa@F7@FEgIrczElkfZiZY5Fyln6t04Z0CyZupzpMGBahOK1/zuriOAVqSrViYVHp/vDdXaxBi0DMnGu3EmS1klZ4KTT@xndVcA1amiw5mH8iC0Q@jjWz/mX8rLqzLs57p2x8w12yJtcyuwPQ37y5rHkVVZdoWU7ICME6@Nc2PBgMexjFO4jgxK8Zmm676aL86ghOb1Q@2UJPC7vSrzFJNZXHs0dgB9YbHmzN8Aw" rel="nofollow noreferrer" title="Charcoal – Try It Online">Try it online!</a> Link is to verbose version of code. Takes input as a newline-terminated list of strings. Outputs a completed board or throws an exception if it can't find a solution. Note: While I know that the algorithm definitely fails on an illegal board, my golfing may mean that it's not 100% successful on legal boards, so feel free to find a counterexample and I'll adapt the code. Explanation: Based on the maximum flow algorithm, so should run in polynomial time (possibly O(n²) in the number of dominoes, as each of the <code>n</code> dominoes might decide to rotate all of the <code>n-1</code> dominoes already placed).</p>
<pre><code>ＷＳ⊞υιυ
</code></pre>
<p>Read and print the input.</p>
<pre><code>ＦＬυＦＬ§υι«
</code></pre>
<p>Loop over all cells of the input.</p>
<pre><code>Ｊκι¿⁼ＫＫO«
</code></pre>
<p>If the current cell is an <code>O</code>, then:</p>
<pre><code>≔⟦ω⟧θＷθ«
</code></pre>
<p>Start a depth-first search of the board.</p>
<pre><code>≔Φurdl№⪪α¹⊟ＫＤ²✳μλ
</code></pre>
<p>Find <code>O</code>s and already placed dominoes in adjacent cells.</p>
<pre><code>¿λ«
</code></pre>
<p>If there is at least one <code>O</code> or domino, then:</p>
<pre><code>≔§λ⁰λ
</code></pre>
<p>Choose the first direction.</p>
<pre><code>✳λλ
</code></pre>
<p>Overwrite the current cell with that direction, and move in that direction.</p>
<pre><code>≔ＫＫη
</code></pre>
<p>Grab the adjacent cell.</p>
<pre><code>Ｐ§dlur⌕urdlλ
</code></pre>
<p>Overwrite it with the reverse direction, creating a domino.</p>
<pre><code>¿⁼ηO≔⟦⟧θ«
</code></pre>
<p>If this was an <code>O</code>, then we successfully placed a domino, so terminate the search.</p>
<pre><code>Ｍ✳η⊞θη⊞θＫＫ»»
</code></pre>
<p>Otherwise we just rotated a domino, so move to where its other end used to be, and save its direction.</p>
<pre><code>«≔⊟θλ✳λ↧λ✳ＫＫ↧⊟θ
</code></pre>
<p>If there were no valid moves, then rotate the last domino on the stack back and back up to the previous position.</p>
<pre><code>»»ＵＭＫＡ↥λ
</code></pre>
<p>After successfully placing a domino, uppercase all the dominoes. This allows them to participate in rotations for the next pair of <code>O</code>s. (Sadly <code>MapAssign(Uppercase, PeekAll());</code> doesn't work.</p>
<p>Example: Consider the following grid:</p>
<pre><code>OOOO
O..O
</code></pre>
<p>The first <code>O</code> is readily covered with an <code>rl</code> domino, resulting in this:</p>
<pre><code>rlOO
O..O
</code></pre>
<p>Another <code>rl</code> domino is then placed, resulting in this:</p>
<pre><code>RLrl
O..O
</code></pre>
<p>The next <code>O</code> doesn't have an adjacent <code>O</code>, but there is an adjacent domino, so we try rotating it:</p>
<pre><code>dORL
u..O
</code></pre>
<p>We still don't have an adjacent <code>O</code>, but there is now another domino that we can rotate (180° around the <code>R</code>):</p>
<pre><code>drlO
u..O
</code></pre>
<p>Finally we can place a domino to cover the now adjacent <code>O</code>s:</p>
<pre><code>drld
u..u
</code></pre>
</div>
<div id="pu3" class="pu"><h1><a href="https://www.ruby-lang.org/" rel="nofollow noreferrer">Ruby</a>, <s>94</s> 82 bytes</h1>
<p>12 bytes saved thanks to Dingus!</p>

<pre class="lang-ruby prettyprint-override"><code>f=-&gt;s{n=s=~/O/
n&amp;&amp;[0,s=~/,/].all?{|i|t=s+?.*i;t[j=i-~n]&gt;?.?(t[n]=t[j]=?.;f[t]):1}}
</code></pre>
<p><a href="https://tio.run/##XVDLboMwELzzFYhDlLSbob02cvgEfwDyIZGCSkUpis0hyuPX6dprE1rLsnfHs@udOY/HyzQ1aru3115Z9Sh1mfWrVf1GPqHS4NB11fXW3pyyrxVe2p2rv1S7ffRmX6Fau7o3iiGjKuya2pnNx/v9Pg2js3kx/FjbHrsT5c2hs5d87a/TpsiyIW/qQpOmwuSSQAOkeREHYDxyAjIfC5h5AZwxaA0PxuMJA75Wh/YIqVB4p8ba5@FrCUEx@lcmrUIZkNgUidCih5fob7@fDrjz6D7ZAr6XDsyCuPciI/EmieUn@VPjjwdBR1AAISy8SHOm6SEjR01IoHQWNhOSKkqmIHoVcIqmhDIgGRRET78" rel="nofollow noreferrer" title="Ruby – Try It Online">Try it online!</a></p>
<p>A recursive function taking input as a comma separated string (this saves one byte over a newline separated string.) A terminating comma is required, at least for single line input, to enable the function to determine the width of the rectangle.</p>
<p>Works by finding the first available <code>O</code> and checking if another <code>O</code> exists to the right or below. If so, both are deleted and the function calls itself to try to eliminate all remaining <code>O</code>s</p>
<p>Returns <code>false</code> if a solution is possible and <code>true</code> if not.</p>
<p><strong>Commented code</strong></p>
<pre class="lang-ruby prettyprint-override"><code>f=-&gt;s{n=s=~/O/             #n=index of first O. If there are none, return nil (board is blank)
n&amp;&amp;                        #if an O was found, look for another O to the right and below it
 [0,s=~/,/].all?{|i|       #iterate twice, 0+1 is offset for second O to right, (s=~/,/ the index of the first comma)+1 is offset for second O below 
  t=s+?.*i                 #make a copy of argument s, with some additional .'s added to the end of it to ensure check for an O below doesn't go out of bounds.
   t[j=i-~n]&gt;?. ?          #if a second O (any ASCII character after &quot;.&quot;) is found (to the right or below the first)...   [Note: i-~n = i+1+n]
    (t[n]=t[j]=?.;f[t]):1  #...overwrite both of them with .'s and then call the function recursively to eliminate the remaining O's.
 }                         #otherwise return 1 (truthy) to indicate it was not possible to match an entire domino in this direction
}                          #return n&amp;&amp; [0,s=~/,/].all?{...} (n false if already solved, loop false if a solution found by deleting domino in either vertical or horizontal direction. 
</code></pre>
</div>
<div id="pu4" class="pu"><h1><a href="https://www.wolfram.com/language/" rel="nofollow noreferrer">Wolfram Language</a>, 82 bytes</h1>
<pre><code>(v=Join@@Position[#,1])==Sort[List@@Join@@FindEdgeCover@Subgraph[GridGraph@#2,v]]&amp;
</code></pre>
<p><a href="https://tio.run/##XYzNCsIwEITvfQqhIAp7Se01EBAtiIdCjyGEaP/20ETS2Evx2WPaomh3YBmGb6ZTrq065fCufE39bqAXg5qx3PTo0GgeAxF7SgtjHb9i7xhbgDPq8lQ21dEMlWXF89ZY9Wh5ZrHMJsfiBAYhtj63qB2v@UiAvGBMwhci@qYSCMigaPO5wM36TSZChnYKh7/2QsoVu26vmYUg814a9vwb" rel="nofollow noreferrer" title="Wolfram Language (Mathematica) – Try It Online">Try it online!</a></p>
<p>Takes two inputs: an array where 1 represents an occupied cell (unoccupied may be anything else), and a list of the width followed by the height.</p>
<p>This answer takes a graph theory approach using built-in language features. The core of my method is generating a <a href="https://en.wikipedia.org/wiki/Edge_cover" rel="nofollow noreferrer">minimum edge cover</a> over a graph representing the occupied spaces (placing the dominoes) and checking whether any vertices are repeated (seeing whether any dominoes overlap).</p>
<p>Part-by-part rundown:</p>
<pre><code>(v=Join@@Position[#,1])     (*generate list of vertices*)
  ==                        (*check if equal to*)
Sort[List@@Join@@           (*the sorted list of vertices from*)
  FindEdgeCover@            (*a minimal edge cover of*)
  Subgraph[GridGraph@#2,v]  (*the graph, generated as a subgraph of a grid graph*)
]&amp;
</code></pre>
</div>
<div id="pu5" class="pu"><h1><a href="https://v8.dev/" rel="nofollow noreferrer">JavaScript (V8)</a>, 103 bytes</h1>

<pre class="lang-javascript prettyprint-override"><code>a=&gt;a.reduce((p,v)=&gt;p.map(u=&gt;u&amp;~v||(S=(m,i)=&gt;m&lt;i?q[m]=m:S(m,i+i,~m&amp;i||S(m-i,i)))(v-u,3),q=[])&amp;&amp;q,[0])[0]
</code></pre>
<p><a href="https://tio.run/##lVZJc9s2FL7jV7yTRU1leE9dt3LGrZPWaWumtXPoOJ4JREISEpKgAVBLR5O/7j4ABBc5OnSeBEHg25cP/MwWTCdKlGZ/cf48HT@z8SWjiqdVwqOoHC2G48uS5qyMqvFltfd1sdlEd@MoHwl8kP8kXj895I/j/OLOHn0nRl/zPbHZ4L99gSzDYbTYr0Ynw9HT@OFxuLf3NHo4fBzi99lwbRKmuYYxfCIxwAbgyK33c6EBP2bOwSixECwDy3kBPTYGWhSzjEMqc1FIyJhIYcGVEQnLsjUhFGKgSJaZwnGzd/oTVsCEQ6I4MzyFpTBzNKg4RxuevKVjOEGye28G/RWFs52XaLtkxnBVEG@J1kJhT7aUWXXHbn8VFCieGFbMqowpmCnhPemJWfunSHbPF7xAjhSdxRg40yJbgxEZ/4bcGdIrJLufSyX@lYWxidl3iQrRBBdbB@3uraxUG7ATUCwVLq821OAZdfyk66x31Wc/brJ/5LJi99dBayqhkAYKjs4biZ8qmdfKPaet2Em9Z0Xq@sGlKGdrSGw0WAmel2a9UyzhWaaBZbKYoQrg6Yy3fRE3FLz83Z3/jXSHdFufX8HR4eroEGzHuka03pAgSTur5f6AWt65kzO3Bi2y4CCnIIwGLbPKCFnoxm@/tmn8gP9aJb8g/dXmOVhuC3EPPyOd1ln@Hr81extmdxju3e7UdYdnd83aZ@7mhdZjQOEc6dqz70rADZIfth/cer2tvR@qPf/V/bPsb5D@aNn7LrXsdr2Ct0jUs/e9po32P5Eo/IZ05c7fI/m5tE//kZXvP2Ygw2kyYJYSZJJUpcBT3z3Ym1NhcOT9PBASb3cyUxz0U4U/Gj5LUaDoZO2aTY9cjydSFVxp4oMI1m@MHWKWLdkaQSUvpdZigpCABj0soc0aXzw@YQfLNK2liyqfcGVbKph2PM1cxw3@hNTdSpwcqw7hYAlrjD3DQbJTNRUKY5/yZSM@It0a9dITzNmoa@c1L5myOErariSk20MB0xE4MzGbG4StXKKCRCIKImBbDEbs1jgVNiTrFJvIBSdxU8yOvo5zhNCtoQhOh7HlK@aQthnfF50bEkTaQexPgPM@lMLVLJeoLFSM0BfqvEK@SniJWZsz40KaSGNkvp/xaeiJnvfdYtX4pm3RmVJ4RfCcFwaWc5FY8Ce0sUV7YfcbKWdf@IvGiLcwwQVJ4l4ATVZIHxSaarSRdnNFXgQU/HqP0Ri8stB7O1feqUnGki9wYKMynLwUrFFcZlLhNSQwlmTOtZ5IpuwVRrEyXH1LsO5b7LCzw9pKfRfgRXJ67g36o53SAQcs1NTvGEuBntdNn2B7qt2mOyacUdZxg8Kd3ClpBxPfTixuTK05022@3i2/LRlKTHdw/M/jT1TjbJpo8LH4WAyG7iVwBeNLWFF8LcujYfu8fprZp7cOmCgiguY3hYmywLYZ2Bc/ZDTJPDp4oPHjwczLLawcLmMYxAN4jbfYBRwOqcXSaDAYjuAY3yR/JKR5Z6RTqd5gK0XGSpYKWyuaRga5nv8D" rel="nofollow noreferrer" title="JavaScript (V8) – Try It Online">Try it online!</a></p>
<p>Input array of binaries, output <code>0</code> to accept, <code>undefined</code> to reject. It can be convert to truthy / falsy by +2 bytes (append <code>+1</code>), but I believe returning two distinct constant values may be acceptable.</p>
<pre class="lang-javascript prettyprint-override"><code>// We use 1 to denote occupied cells, while 0 for empty cells
// And convert above binary as a single number to represent the row
// So `0b1100010` is as same as `OO...O.`
// And specially, `0` is used for an empty row
a=&gt; // input matrix as described above
a.reduce( // for each row
  (p, // p is an array of rows
      // `1` is used if some cells on last row need to be filled with
      //     vertical dominoes cross last row and this row
      // `0` is used if some cells is empty or already filled with
      //     dominoes used before
      // `p` store value `n` with index `n`
      //     or in other words `p[n]` will always equals `n`
      //     `p[m]` will be a hole of array if some value `m` is not
      //     presented in `p`
   v  // current row
  )=&gt;p.map(
    u=&gt; // one possible pattern while unfilled last row
    u&amp;~v|| // if you can use vertical dominoes to fill unfilled
           //     cells on last row, you need to fill these cells
           //     and check if there are some horizontal dominoes
           //     may be used in following recursive function
           // if you cannot fell these cells
           //     you do not ever need to search
    (S=(
      m, // unfilled cells on current row
      i  // a horizontal dominoes
    )=&gt;
     m&lt;i? // if this horizontal domino already moved out the
          // boundary of current row, we stop search
       q[m]=m: // store current unfilled cells pattern to `q` the
               //     variable will be used for next iteration
       S(m,i+i, // move the horizontal domino a cell left
                //     and have it a try by recursion
         ~m&amp;i|| // if current domino may be placed (if cells under
                //     current domino are occupied)
         S(m-i,i) // fill these cells and search recursively
       ))(
         v-u, // fill last row by vertical dominoes and see what left
         3    // a horizontal domino placed on right most
      ),
    q=[] // possible patterns left after current row
  )&amp;&amp;q,
  [0] // nothing is required to be filled before first row
      // so `0` is a valid pattern here
)[0] // check if everything may be just filled
</code></pre>
<p>For matrix with <span class="math-container">\$p\cdot q\$</span> size, its time complexity seems to be <span class="math-container">\$O\left(\left(\sqrt{5}+1\right)^{p}\cdot q\right)\$</span>.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/221167/">221167</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




