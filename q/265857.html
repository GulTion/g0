<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::265857</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>004</td><td>Rust + rand + bnum</td><td>231012T081814Z</td><td><a href="https://codegolf.stackexchange.com/questions/265857/random-factorized-numbers/265935#265935">mousetai</a></td></tr>
<tr d-ix="1"><td>nan</td><td></td><td>231008T194507Z</td><td><a href="https://codegolf.stackexchange.com/questions/265857/random-factorized-numbers/265865#265865">Command </a></td></tr>
<tr d-ix="2"><td>066</td><td>Charcoal</td><td>231008T190055Z</td><td><a href="https://codegolf.stackexchange.com/questions/265857/random-factorized-numbers/265864#265864">Neil</a></td></tr>
<tr d-ix="3"><td>nan</td><td></td><td>231008T143034Z</td><td><a href="https://codegolf.stackexchange.com/questions/265857/random-factorized-numbers/265862#265862">Command </a></td></tr>
</table>
<div id="pu0" class="pu"><h1>Rust + rand + bnum, score=4 on my PC</h1>
<p>Basic implementation of Kalai's algorithm. Apparently it's not very good. The random rejection at the end rejects 99% of candidates so makes it take a lot longer.</p>
<pre class="lang-rs prettyprint-override"><code>use bnum::BUint;
use rand::{distributions::uniform::UniformSampler, Rng};

#[inline]
fn mod_exponentiate(mut base: BUint&lt;16&gt;, mut exponent: BUint&lt;16&gt;, modulus: BUint&lt;16&gt;) -&gt; BUint&lt;16&gt; {
    if modulus == (1u64).into() {
        return 0u64.into();
    }

    let mut result: BUint&lt;16&gt; = (1u64).into();

    while !exponent.is_zero() {
        if exponent.digits()[0] &amp; 1 == 1 {
            result = result * base % modulus
        }
        exponent &gt;&gt;= 1;
        base = (base * base) % modulus
    }

    return result;
}

#[inline]
fn miller_test(candidate: BUint&lt;16&gt;, mut d: BUint&lt;16&gt;, witness: BUint&lt;16&gt;) -&gt; bool {
    let mut x = mod_exponentiate(witness, d, candidate);

    if x == (1usize).into() || x == candidate - BUint::&lt;16&gt;::from(1u64) {
        return true;
    }

    while d != candidate - BUint::&lt;16&gt;::from(1u64) {
        x = (x * x) % candidate;
        d &lt;&lt;= 1;

        if x == (1u64).into() {
            return false;
        }

        if x == candidate - BUint::&lt;16&gt;::from(1u64) {
            return true;
        }
    }

    return false;
}

#[inline]
fn prime_test(candidate: BUint&lt;16&gt;, iterations: usize, rng: &amp;mut rand::rngs::ThreadRng) -&gt; bool {
    if candidate == BUint::ONE {
        return false;
    }
    if candidate == BUint::TWO {
        return true;
    }
    if candidate == BUint::THREE {
        return true;
    }
    if candidate.digits()[0] &amp; 1 == 0 {
        return false;
    }

    let mut d = candidate - BUint::&lt;16&gt;::from(1u64);
    if !d.is_zero() {
        d &gt;&gt;= d.trailing_zeros();
    }

    let distribution =
        bnum::random::UniformInt::&lt;BUint&lt;16&gt;&gt;::new(BUint::TWO, &amp;(candidate - BUint::TWO));

    for _ in 0..iterations {
        let witness = distribution.sample(rng);
        if !miller_test(candidate, d, witness) {
            return false;
        }
    }

    return true;
}

#[inline]
fn kalai_algorithm(max: BUint&lt;16&gt;, rng: &amp;mut rand::rngs::ThreadRng) -&gt; (Vec&lt;BUint&lt;16&gt;&gt;, BUint&lt;16&gt;) {
    loop {
        let mut candidates: Vec&lt;BUint&lt;16&gt;&gt; = vec![];

        while candidates.last() != Some(&amp;BUint::ONE) {
            candidates.push(rng.gen_range(BUint::ONE..*candidates.last().unwrap_or(&amp;max)))
        }

        candidates.retain(|candidate| prime_test(*candidate, 8, rng));

        if let Some(possible_output) = candidates.iter().cloned().reduce(|a, b| (a * b).min(max)) {
            if possible_output &lt; max &amp;&amp; rng.gen_range(BUint::ONE..max) &lt; possible_output {
                break (candidates, possible_output);
            }
        }
    }
}

fn main() {
    let start_time = std::time::Instant::now();
    let max = BUint::ONE &lt;&lt; 500;

    let threads: Vec&lt;_&gt; = (0..8)
        .map(|thread_id| {
            std::thread::spawn(move || {
                let mut rng = rand::thread_rng();
                loop {
                    let (factors, product) = kalai_algorithm(max, &amp;mut rng);
                    if std::time::Instant::now() - std::time::Duration::from_secs(10) &gt; start_time {
                        break;
                    }
                    println!(&quot;{thread_id}\t{product:?} {factors:?}&quot;)
                }
            })
        })
        .collect();

    threads.into_iter().for_each(|i| i.join().unwrap());
}
</code></pre>
<p>Run with:</p>
<pre><code>opt-level=3
lto=true
panic=&quot;abort&quot;
</code></pre>
</div>
<div id="pu1" class="pu"><h1><a href="https://gcc.gnu.org/" rel="nofollow noreferrer">C++ (gcc)</a></h1>

<pre class="lang-cpp prettyprint-override"><code>#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;random&gt;
#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;gmp.h&gt;
#include &lt;gmpxx.h&gt;

std::mt19937 rng;
gmp_randstate_t gmp_rng;
double prob[1001];

void gen_factor(mpz_t N, int Nexp, double Nbase, mpz_t q, long int* qexp, double* qbase, mpz_t p, int* a, mpz_t Nq) {
    int bitcnt = Nexp;
    double invN = 1 / Nbase;
    int sz = (bitcnt-1) * bitcnt / 2;
    for (int j = 1; j &lt; bitcnt; j++) {
        prob[j-1] = j * (1 + ldexp(invN, j - Nexp));
    }
    std::discrete_distribution&lt;&gt; distribution(std::begin(prob), std::begin(prob)+bitcnt-1);
    while (1) {
        int j = 1 + distribution(rng);
        mpz_urandomb(q, gmp_rng, j);
        if (mpz_even_p(q) &amp;&amp; mpz_sgn(q)) continue; // the only valid even numbers are powers of 2.
        mpz_setbit(q, j);
        if (mpz_cmp(q, N) &gt; 0) continue;
       &#32;
        mpz_fdiv_q(Nq, N, q);
        int is_odd = mpz_odd_p(Nq);
        if (is_odd) mpz_add_ui(Nq, Nq, 1);
        long int Nqexp;
        double Nqbase = mpz_get_d_2exp(&amp;Nqexp, Nq);
        *qbase = mpz_get_d_2exp(qexp, q);

        double prob = (log2(*qbase)+*qexp) * ldexp(Nqbase / (Nbase + ldexp(1, j-Nexp) ), Nqexp + j - Nexp) / j;

        if (!std::bernoulli_distribution(prob)(rng)) continue;

        if (mpz_probab_prime_p(q, 15)) {
            mpz_set(p, q);
            *a = 1;
        } else if (mpz_perfect_power_p(q)) { // test is significant
            mpz_t cur;
            mpz_init_set(cur, q);
            *a = 1;
            do {
                for (int e = 2; e &lt;= j; e++) {
                    // double approx = pow(curbase, 1./e) * pow(2, curexp / double(e));
                    if (/*abs(approx - round(approx)) &lt; 0.1 &amp;&amp; */mpz_root(p, cur, e)) {
                        *a *= e;
                        mpz_set(cur, p);
                        break;
                    }
                }
            } while (mpz_perfect_power_p(cur));
            mpz_clear(cur);
            if (!mpz_probab_prime_p(p, 15)) continue;
        } else {
            continue;
        }

        if (*a &gt; 1 &amp;&amp; !std::bernoulli_distribution(1. / *a)(rng)) continue;

        if (is_odd) mpz_sub_ui(Nq, Nq, 1);
        return;
    }
}

void bach(mpz_t v, mpz_t target, std::vector&lt;mpz_class&gt;&amp; factors) {
    if (mpz_cmp_ui(v, 1e5) &lt; 0) {
        unsigned int vI = mpz_get_ui(v);
        int x = std::uniform_int_distribution&lt;&gt;(vI/2+1, vI)(rng);
        mpz_set_ui(target, x);
        factors.clear();
        for (int d = 2; d*d &lt;= x; d++) {
            while (x % d == 0) {
                factors.emplace_back(d);
                x /= d;
            }
        }
        if (x != 1) {
            factors.emplace_back(x);
        }
        return;
    }
    mpz_t q, p, Nt;
    mpz_inits(q, p, Nt, 0);
    long int Nexp;
    double Nbase = mpz_get_d_2exp(&amp;Nexp, v);
    while (1) {
        int a;
        long int qexp;
        double qbase;
        gen_factor(v, Nexp, Nbase, q, &amp;qexp, &amp;qbase, p, &amp;a, Nt);
        bach(Nt, target, factors);
        long int targetexp;
        double targetbase = mpz_get_d_2exp(&amp;targetexp, target);
        double logv = (log2(Nbase) + Nexp - 1)/(log2(qbase) + qexp + log2(targetbase) + targetexp);
        if (std::bernoulli_distribution(logv)(rng)) {
            for (int i = 0; i &lt; a; i++) factors.emplace_back(p);
            mpz_mul(target, target, q);
            mpz_clears(q, p, Nt, 0);
            return;
        }
    }
}

void gen(int n, mpz_t target, std::vector&lt;mpz_class&gt;&amp; factors) {
    mpz_t v;
    mpz_init2(v, n);
    mpz_setbit(v, n);
    mpz_sub_ui(v, v, 1);
    bach(v, target, factors);
}

int main() {

    rng.seed(time(0));
    gmp_randinit_default(gmp_rng);
    time_t end = time(0) + 10;
    int i;
    int tsz = 0;
    int primecnt = 0;
    for (i = 0; time(0) &lt;= end; i++) {
        mpz_t target;
        mpz_init(target);
        std::vector&lt;mpz_class&gt; factors;
        gen(500, target, factors);
        tsz += factors.size();
        if (factors.size() == 1) primecnt++;
        mpz_clear(target);
    }
    std::cout &lt;&lt; "generated " &lt;&lt; i-1 &lt;&lt; " numbers\n";
    std::cout &lt;&lt; "prime probability " &lt;&lt; primecnt/double(i) &lt;&lt; ", expected apprx. " &lt;&lt; 0.0028879 /* (Li(2^500) - Li(2^499)) / 2^499 */ &lt;&lt; '\n';
    std::cout &lt;&lt; "average number of prime divisors " &lt;&lt; tsz/double(i) &lt;&lt; " expected apprx. " &lt;&lt; log(500 * M_LN2) + 1.0345 /* B_2, see Wikipedia */ &lt;&lt; '\n';
   &#32;
}
</code></pre>
<p><a href="https://tio.run/##nVdLc9s4DL77V6Dd2VTyS5LbTJvayWFvnWm9xz1sux5Koh0melmvuu34r28WICmZkuVkZj2TSAIBAgQ@PBhk2WwXBE9Pv4kkiKqQw6rmQZnmd6MTJWaZ@ZmzJExjkxLErLzvEIoyFKlJEWlR5px1xHZxNr/vEQ4HIo1Q/uPHuPRubt6@hzzZLUe4tiHNRclKvilBftNCmFZ@xCHLU/9vz3W9b8vRqE5FCDuebLaMDmPF2U8UWU9BJPjgh2wKWmzts4JPQTHspxClyY64xrA32PDL5MumioU1hPXehl8jwB8p8EUZ4ONWalpKstYmknqNdA8cpXjZyhQ/kW4pyZlnw7jZxYGF4tqmOVjE@kA7LPGx0jz4Ppk0BtBP@uJh5n1DzgfcyvJgAlGI1lhkwRSJM2mcbau9j/K/dHooiiDn6GJ8KXPhV6VIk9UdmJ@W5PT5TiQW6bKn0KdM2qMoDd/vBZ7f8kwz28OgdZ3tMa5ajH7k4kqBzrcwRDryeAqDSWxBRpnXGPXMwnhcXUnJYpfglw1BmpQiqfgSHAfKew5pEv2AmkWIFBKCpIp9nhfAcgRT@p1e0y0s5h07Cl7iwciKIeVBnNHS2oY7cA2VLWNnr20o6s3eWpPEFPbmfugYUWzSMETvECu@4aHW@55OxWNLFoYslVC74Z9nsDaYxoUWkAYo1xLbWtOOl5twsyCoXK1VCnTUji8wK1bi7G9PcCBsR@luYSlxezImfkK5QqU2wQFLpkWLVg/9PJNABXuqzMe1Fr0o8GAoJJe80kDMk7SKItFBsUKmRJcZnLMwEhvz8SFivpER9a5tE7gGGqysGzrpIyYztKUdgUd4qHZ7nm@xxm4kyCRWcW@JSl5Q3KEQu0RsRcCS8kxlCUGVL8/IIhGlNAdXXzZIRad3oE6NoQgvlvhYYQXBZ7e@mD@0WweaZei4AwriwcgOVTG9ucMp0ERcTMl6CmIjZHG7Z6sZDGfM/MLS@84gT6sk1J/osxW4c4/SfOyQC/I0ldGQHuD2JXu1P8a3wJcXGZrgyr0y@zKjjz3tcXj5OHqecmxq4hAmUHHfMbLARJzlcrG7JpE/AN1MQ/e8EmlMdn00wNbNDnTcHUifP5tn3hwDPGYvpJpZvYrKv1S9sBlVedL0qaNu7j4L7nVbr5suXLIcK5LuRWqMWSmvsaK4uwI1DBRtqz5VbdKN23j8WsLKxE6VUDryUBbQ@pNR@UimV7QJ/VJ7hQmc5jHmZdlrpFb9yVlMsLDVn@yBRleojZujHIxlbf5cgcBcaLI2VFkbjkPK2wO@neetBt0Bfif22@5h@6p4nEUs4Bv09qMVDuTBAZxbCLv04@j8jXx9gFdYhfrqBlWZxz5eQMKpIiJgqE2Vy5FZDguroU/xkGrt1An7k9n6Ug@Ufa1@YYphA812sNfuT1Mf/YwRFeGndOmJFI2/Uk31Ss@e9MroPIZzZBrQCRvANBgfMEixDFmlVi54oBVrlNhn8tja67bFS/ttbNN0HKzanu2ohX2zoNu4JJ5U00qrqzfoPFdsSHlTaXrQavJCoHHuEh8rjBQISopB2GUDJTeuojYbm@f@UmkewtwQek8IPlU0xII0Nvmf5UwXw24SLAhXiX0i6gG2T1XlF6n1qfhKbNVD0EKTydKY4bRP6iU7RmBecB5aJfYey23aV3NvkxNKyLesikpLj/CahQTQdJ5Q/dLSCAbPPV2PxOm1lFclY002O3Xhcs2rkgp6sx8WRFSgo/9r1J2p1BG7lZgMts4QPxyMxjedzLauXfe5xKSDTG5bJBbiJ7d6uO@uUbnG0tOcdzLpGqz6Qsdi414XpFUJqxW8Rst4jnfoEF7Tt5h5ktzcf74mr5cDUlIpqPFCRKL8oaQbWxw9zglbcuMAdsjQSaiExrXDXHG7c9ddfPjw/gYcvJR@FtbiH/SRjUVCvr@7ubFpppdvONWRyJuvyZshe1iNh9hxbTXd1JSFeKcSBbpMKUQX9ywbNgxrCEULx9Qvm8/rhUTf3H377poM/WODcysiG/4SjyLjoWBnto2OT0//BtuI7YqnWYToVv8Ph6fZn2//Aw" rel="nofollow noreferrer" title="C++ (gcc) – Try It Online">Try it online!</a></p>
<p>Can output around 12,500 numbers on my computer. Compile with <code>-lgmp -lgmpxx -O3</code>.</p>
<p>I'll add an explanation later, probably after some more optimizations.</p>
</div>
<div id="pu2" class="pu"><h1><a href="https://github.com/somebody1234/Charcoal" rel="nofollow noreferrer">Charcoal</a>, 66 bytes, score 0 (usually)</h1>
<pre><code>≔Ｘ²ＮθＷ¹«≔⟦⊕‽⊖θ⟧υＷ⊖⌊υ⊞υ⊕‽⌊υ≔Φυ▷”8±cGＮºb6﹪←”κυ¿∧‹Πυθ‹‽θΠυ«⟦Ｉ⊞ＯυΠυ⟧Ｄ⎚
</code></pre>
<p><a href="https://tio.run/##ZU85a8MwFJ7tXyEyPYFa0kKnTiFJIdDDdOgSMqi2Uovoio6EUPLbVT1jiKFa9I7vem3PfWu5ynkRgvwx0Niz8PDIyMa4FN@T/i4tpYwc6XN97qUSBB4o@a2rkbDdmNYLLUwUHXxy01kNK3EbHSmlO0ZSoVcjf7p@k0bqpCEVGGlS6CGh9z/JKQ6lRvcXqWIJWDjrE1df3MMsXLS73MvgvNRixsgB0w/2ck9gYTpE4/cqQoDG2y61sejiiYwMw9ET@9seH95dNV6aCNslDxEw8YcTnkc7pJjCd@hZrZJ2MFRLJUo@LK/1Neen@TzfndQf" rel="nofollow noreferrer" title="Charcoal – Try It Online">Try it online!</a> Link is to verbose version of code with extra check because the version of Charcoal on TIO returns <code>None</code> for the product of an empty list and I can't use the version of Charcoal on ATO for multiple reasons. Note that you need to interrupt (<code>^C</code> if running locally or TIO's button) the code manually after ten seconds otherwise it will never print anything. Explanation: Uses Kalai's inefficient algorithm.</p>
<pre><code>≔Ｘ²Ｎθ
</code></pre>
<p>Get <code>2ⁿ</code>.</p>
<pre><code>Ｗ¹«
</code></pre>
<p>Repeat forever.</p>
<pre><code>≔⟦⊕‽⊖θ⟧υ
</code></pre>
<p>Start with a random integer between <code>0</code> and <code>2ⁿ</code> exclusive.</p>
<pre><code>Ｗ⊖⌊υ
</code></pre>
<p>Until a <code>1</code> is generated...</p>
<pre><code>⊞υ⊕‽⌊υ
</code></pre>
<p>... push a random integer between <code>1</code> and the previous integer to the list.</p>
<pre><code>≔Φυ▷”8±cGＮºb6﹪←”κυ
</code></pre>
<p>Filter out all non-primes from the list.</p>
<pre><code>¿∧‹Πυθ‹‽θΠυ«
</code></pre>
<p>If the product is less than <code>2ⁿ</code> and passes a random chance, then...</p>
<pre><code>⟦Ｉ⊞ＯυΠυ⟧Ｄ⎚
</code></pre>
<p>... output the primes and their product.</p>
<p>83 bytes for a version that times itself:</p>
<pre><code>≔Ｘ²Ｎθ≔▷clock⟦⟧ηＷ‹⁻▷clock⟦⟧ηχ«≔⟦⊕‽⊖θ⟧υＷ⊖⌊υ⊞υ⊕‽⌊υ≔Φυ▷”8±cGＮºb6﹪←”κυ¿∧‹Πυθ‹‽θΠυ⟦Ｉ⊞ＯυΠυ
</code></pre>
<p><a href="https://tio.run/##dZBJa8MwEIXPya8QOY1ALW6hp55CFwh0MT30YnxQZbUW0eJoSQilv10dGdMYSk5iZj6992ZEz71wXOe8DkF9WajdQXq4ZmRjhxRfkvnAklJGdvR2OTEPe67fuYeV0E5sV4w0LQI9AodeaUngSYYAz8qmcJZl5KqilHwvF5Nos7HCSyNtlB28cds5A/fy1NpRSltGErosJpv5GN2USQYSYqROoYdUdvgnOeeK1OT@qHTERfHPX@BwNMPxUoXBKyMx@LZcYbRXnwTWtit0ecZta@@6JCLqllMxMjYnz1Kf5nRM6JWN0NzxEKGkfR2k59GNCeZoi34/Od9UVb7Y618" rel="nofollow noreferrer" title="Charcoal – Try It Online">Try it online!</a> Link is to verbose version of code with extra check because the version of Charcoal on TIO returns <code>None</code> for the product of an empty list and I can't use the version of Charcoal on ATO because it doesn't have access to <code>sympy.isprime</code>. Note that the timing is approximate and might generate an extra result which actually finished outside the desired time.</p>
<p>64 bytes for a version that finds one factorisation and exits:</p>
<pre><code>⊞υＸ²Ｎ≔⊖⌈υθＷ∨›Πυθ›‽θΠυ«≔⟦⊕‽θ⟧υＷ⊖⌊υ⊞υ⊕‽⌊υ≔Φυ▷”8±cGＮºb6﹪←”κυ»Ｉ⊞ＯυΠυ
</code></pre>
<p><a href="https://tio.run/##bY9NSwMxEIbP3V8ReppAWorgqSfRKj1oFw9exEPcHbqh@dhOktYi/vaYyK61YG4ZnneeeZtOUuOkTqmOvoMoWO2OSHAl2Nr2MTxF856/nPNldeO92lq4w4bQoA3YwqP8UCYaiJwLts/MsVMaGWwIHghlyNGaXBubkJFCCDbOn6VtnYEyOiP5sc9qMphe1/as@uX5m2AxqyaD6@IeZcd7OBsb/bPlL1dWDcJ7pctpObM6SP0iCab@ZPrTXPmelMGpYLvStOi/qpqUDXArfYCi2vRIMrif@EWjZUrXi0WaHfQ3" rel="nofollow noreferrer" title="Charcoal – Try It Online">Try it online!</a> Link is to verbose version of code. Still usually crashes out because it can't calculate the product of an empty list, and even when it does find a result, it usually takes more than 10 seconds, but just in case, here's a bash script that restarts the program on error and times out after 10 seconds:
<a href="https://tio.run/##S0oszvj/vyQzNzW/tERBt1jBIzRAwdBAIQksXp6RmZOqYMWVkq@gn19Qop@ckViUnJ@YA2co6CYrqD/qmne@9f2eHYc2vd@z7lHnlEdd0x71dJxvPbfj/Z7tjzpWPGrYdW4BiAtkPGrYe24HiHdoNUjl/GWPuqaCxR7NXw4yZDtYc9f5VrChEEkIv3PKuWVAatr2Rw1zLQ5tTHYHWnZoV5LZ@52rHrVNAAqe2wU0dff7PSuBWt/vWQ@0EGiNuoJupoKpgYGCkZ1@SmqZfl5pTo6CmppCanJGPowGei8vFQA" rel="nofollow noreferrer" title="Bash – Try It Online">Try it online!</a></p>
</div>
<div id="pu3" class="pu"><h1><a href="https://www.python.org" rel="nofollow noreferrer">Python</a></h1>
<p>Thanks to @AndersKaseorg for many improvements and bug fixes.</p>
<pre class="lang-python prettyprint-override"><code>import math
import random
import time

import sympy


def gen_factor(N):
    while True:
        j = random.randint(1, N.bit_length() - 1)
        q = (1 &lt;&lt; j) + random.randrange(1 &lt;&lt; j)
        if q &gt; N:
            continue
        Nt = N // q
        if random.random() &gt;= math.log(q, N) * (((Nt + 1) &gt;&gt; 1) &lt;&lt; j) / N:
            continue
        p, a = sympy.perfect_power(q) or (q, 1)
        if random.random() &gt;= 1 / a:
            continue
        if sympy.isprime(p):
            return p, a, Nt


def bach(N):
    if N &lt;= 10 ** 5:
        x = random.randint(N//2 + 1, N)
        return x, sympy.factorint(x)
    while True:
        p, a, Nt = gen_factor(N)
        newx, factx = bach(Nt)
        newx *= p ** a
        if random.random() &lt; math.log(N / 2, newx):
            factx[p] = factx.get(p, 0) + a
            return newx, factx


def gen(n):
    return bach((1 &lt;&lt; n) - 1)


if __name__ == '__main__':
    t = time.perf_counter()
    a = []
    while time.perf_counter() - t &lt; 10:
        a.append(gen(500))

    print('Generated', len(a), 'numbers in 10 seconds:')
    print(*a, sep='\n')
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=hVRNj5swEL30xK-YGzbLElhppWoVcu2NS3vbriwHhoRVMI4xSvJbetlL-6P6azrmIyHbbWOJD8O8ec8zz_7xS5_stlFvbz87W95__v3pa1Xrxliopd1647uRqmjqaWarGr1p0p5qffI8r8ASNqhEKXPbGJbxJw9oHLbVDuGb6XCYu_EK6Zgxco9KWZaEkEXryoodqo3dMg73kPAzYk8IlsByCa8c7uZgujY4_TrHVyVBVpBdON3IG2Ur1eH5Y2YpbwaLBezn0Fn6piYpq7QvRrRrNmxPQjkEwBgj9B2JhNXK3Qdti5ucOgRJrH3ZIo2mxNwK3RzQsD2HxoCjSPgNPQkxyRtMhBxYqlYbahnT_Bph0HZG9YpoVXZs4lrm23P7KEcGS-KLIQjg8YI__t3DbLF4cBVxFfLecRzDUctgDxd-5P80yKSIOK4sdQ5QeKCM7rvTMSi2178hSEE70fJ_pVxeOks-gIewx76rU8_zrF-Iqn-NNmgZaYydF-VHJZ3pu2wNpsa8Y1Ave7CuGv1Ou6oEIZSsUQhIU_CFqGWlhPAHqCuJ2369c0TedMqScYaVO1s9v8yK-kEg0VhadBJfVigjqTWqgjmJj3HMSUbfhL5L_hdUaKTFwg-BNieTPARfdfUaTQuVcs5okbxXtE8-nwED6mCLOvW_K58PZ8t4xExHzR8" rel="nofollow noreferrer">Attempt This Online!</a></p>
<p>This is a simple implementation of <a href="https://en.wikipedia.org/wiki/Bach%27s_algorithm" rel="nofollow noreferrer">Bach's algorithm</a>, just to get the challenge going. Make sure you have <code>gmpy2</code> installed when running. Can generate around <span class="math-container">\$130\$</span> numbers on my computer.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/265857/">265857</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




