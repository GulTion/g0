<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::QNNN</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
  <!-- TXXX -->
<tr d-ix="0"><td>016</td><td>Thunno 2</td><td>230810T124947Z</td><td><a href="https://codegolf.stackexchange.com/questions/78896/compute-the-adler-32-checksum/263986#263986">The Thon</a></td></tr>
<tr d-ix="1"><td>156</td><td>Rockstar</td><td>201005T155347Z</td><td><a href="https://codegolf.stackexchange.com/questions/78896/compute-the-adler-32-checksum/212077#212077">Shaggy</a></td></tr>
<tr d-ix="2"><td>023</td><td>Japt</td><td>201005T145807Z</td><td><a href="https://codegolf.stackexchange.com/questions/78896/compute-the-adler-32-checksum/212074#212074">Shaggy</a></td></tr>
<tr d-ix="3"><td>022</td><td>Husk</td><td>201005T122246Z</td><td><a href="https://codegolf.stackexchange.com/questions/78896/compute-the-adler-32-checksum/212065#212065">Razetime</a></td></tr>
<tr d-ix="4"><td>117</td><td>Forth gforth</td><td>191104T132849Z</td><td><a href="https://codegolf.stackexchange.com/questions/78896/compute-the-adler-32-checksum/195277#195277">reffu</a></td></tr>
<tr d-ix="5"><td>032</td><td>K ngn/k</td><td>191101T103722Z</td><td><a href="https://codegolf.stackexchange.com/questions/78896/compute-the-adler-32-checksum/195146#195146">scrawl</a></td></tr>
<tr d-ix="6"><td>032</td><td>x86 16bit machine code function</td><td>160507T055505Z</td><td><a href="https://codegolf.stackexchange.com/questions/78896/compute-the-adler-32-checksum/79550#79550">Peter Co</a></td></tr>
<tr d-ix="7"><td>030</td><td>x8664 machine code function</td><td>160501T050637Z</td><td><a href="https://codegolf.stackexchange.com/questions/78896/compute-the-adler-32-checksum/78972#78972">Peter Co</a></td></tr>
<tr d-ix="8"><td>164</td><td>Postgresql</td><td>160506T170957Z</td><td><a href="https://codegolf.stackexchange.com/questions/78896/compute-the-adler-32-checksum/79526#79526">lad2025</a></td></tr>
<tr d-ix="9"><td>043</td><td>Perl 5</td><td>160503T174321Z</td><td><a href="https://codegolf.stackexchange.com/questions/78896/compute-the-adler-32-checksum/79271#79271">msh210</a></td></tr>
<tr d-ix="10"><td>118</td><td>ABAP</td><td>160504T144053Z</td><td><a href="https://codegolf.stackexchange.com/questions/78896/compute-the-adler-32-checksum/79380#79380">Rawberry</a></td></tr>
<tr d-ix="11"><td>324</td><td>Fission</td><td>160504T055218Z</td><td><a href="https://codegolf.stackexchange.com/questions/78896/compute-the-adler-32-checksum/79346#79346">Andrew C</a></td></tr>
<tr d-ix="12"><td>120</td><td>Piet</td><td>160503T164936Z</td><td><a href="https://codegolf.stackexchange.com/questions/78896/compute-the-adler-32-checksum/79265#79265">Marv</a></td></tr>
<tr d-ix="13"><td>040</td><td>ARM Thumb2 function accepting uint8_t[]</td><td>160503T034241Z</td><td><a href="https://codegolf.stackexchange.com/questions/78896/compute-the-adler-32-checksum/79212#79212">Peter Co</a></td></tr>
<tr d-ix="14"><td>058</td><td>Python 2</td><td>160501T134308Z</td><td><a href="https://codegolf.stackexchange.com/questions/78896/compute-the-adler-32-checksum/79025#79025">Sp3000</a></td></tr>
<tr d-ix="15"><td>094</td><td>Scala</td><td>160501T123722Z</td><td><a href="https://codegolf.stackexchange.com/questions/78896/compute-the-adler-32-checksum/79009#79009">Keith Pi</a></td></tr>
<tr d-ix="16"><td>082</td><td>Python 3.5</td><td>160430T085431Z</td><td><a href="https://codegolf.stackexchange.com/questions/78896/compute-the-adler-32-checksum/78905#78905">R. Kap</a></td></tr>
<tr d-ix="17"><td>050</td><td>JavaScript ES7</td><td>160430T093305Z</td><td><a href="https://codegolf.stackexchange.com/questions/78896/compute-the-adler-32-checksum/78907#78907">Neil</a></td></tr>
<tr d-ix="18"><td>050</td><td>Haskell</td><td>160430T103807Z</td><td><a href="https://codegolf.stackexchange.com/questions/78896/compute-the-adler-32-checksum/78910#78910">nimi</a></td></tr>
<tr d-ix="19"><td>055</td><td>TMP</td><td>160501T032455Z</td><td><a href="https://codegolf.stackexchange.com/questions/78896/compute-the-adler-32-checksum/78966#78966">brianush</a></td></tr>
<tr d-ix="20"><td>050</td><td>Octave</td><td>160501T010514Z</td><td><a href="https://codegolf.stackexchange.com/questions/78896/compute-the-adler-32-checksum/78953#78953">beaker</a></td></tr>
<tr d-ix="21"><td>195</td><td>Scheme</td><td>160501T012130Z</td><td><a href="https://codegolf.stackexchange.com/questions/78896/compute-the-adler-32-checksum/78956#78956">Numeri</a></td></tr>
<tr d-ix="22"><td>130</td><td>Javascript 130 Characters Golfed</td><td>160501T011826Z</td><td><a href="https://codegolf.stackexchange.com/questions/78896/compute-the-adler-32-checksum/78955#78955">Shubshub</a></td></tr>
<tr d-ix="23"><td>079</td><td>Python 3</td><td>160501T005411Z</td><td><a href="https://codegolf.stackexchange.com/questions/78896/compute-the-adler-32-checksum/78952#78952">R2D2</a></td></tr>
<tr d-ix="24"><td>031</td><td>Labyrinth</td><td>160430T153113Z</td><td><a href="https://codegolf.stackexchange.com/questions/78896/compute-the-adler-32-checksum/78933#78933">Martin E</a></td></tr>
<tr d-ix="25"><td>023</td><td>Pyth</td><td>160430T145230Z</td><td><a href="https://codegolf.stackexchange.com/questions/78896/compute-the-adler-32-checksum/78928#78928">Leaky Nu</a></td></tr>
<tr d-ix="26"><td>030</td><td>J</td><td>160430T131759Z</td><td><a href="https://codegolf.stackexchange.com/questions/78896/compute-the-adler-32-checksum/78920#78920">miles</a></td></tr>
<tr d-ix="27"><td>109</td><td>Clojure</td><td>160430T214307Z</td><td><a href="https://codegolf.stackexchange.com/questions/78896/compute-the-adler-32-checksum/78947#78947">miles</a></td></tr>
<tr d-ix="28"><td>091</td><td>Ruby</td><td>160430T195152Z</td><td><a href="https://codegolf.stackexchange.com/questions/78896/compute-the-adler-32-checksum/78944#78944">Value In</a></td></tr>
<tr d-ix="29"><td>060</td><td>Perl 6</td><td>160430T171142Z</td><td><a href="https://codegolf.stackexchange.com/questions/78896/compute-the-adler-32-checksum/78937#78937">Brad Gil</a></td></tr>
<tr d-ix="30"><td>103</td><td>Factor</td><td>160430T140405Z</td><td><a href="https://codegolf.stackexchange.com/questions/78896/compute-the-adler-32-checksum/78924#78924">cat</a></td></tr>
<tr d-ix="31"><td>029</td><td>CJam</td><td>160430T132737Z</td><td><a href="https://codegolf.stackexchange.com/questions/78896/compute-the-adler-32-checksum/78921#78921">Martin E</a></td></tr>
<tr d-ix="32"><td>022</td><td>MATL</td><td>160430T114340Z</td><td><a href="https://codegolf.stackexchange.com/questions/78896/compute-the-adler-32-checksum/78912#78912">Luis Men</a></td></tr>
<tr d-ix="33"><td>084</td><td>Java</td><td>160430T142620Z</td><td><a href="https://codegolf.stackexchange.com/questions/78896/compute-the-adler-32-checksum/78926#78926">Marv</a></td></tr>
<tr d-ix="34"><td>017</td><td>Jelly</td><td>160430T060328Z</td><td><a href="https://codegolf.stackexchange.com/questions/78896/compute-the-adler-32-checksum/78898#78898">Leaky Nu</a></td></tr>
<tr d-ix="35"><td>046</td><td>Mathematica</td><td>160430T074105Z</td><td><a href="https://codegolf.stackexchange.com/questions/78896/compute-the-adler-32-checksum/78901#78901">Mark Adl</a></td></tr>
<tr d-ix="36"><td>070</td><td>C89</td><td>160430T081648Z</td><td><a href="https://codegolf.stackexchange.com/questions/78896/compute-the-adler-32-checksum/78902#78902">orlp</a></td></tr>
<tr d-ix="37"><td>036</td><td>Actually</td><td>160430T064536Z</td><td><a href="https://codegolf.stackexchange.com/questions/78896/compute-the-adler-32-checksum/78900#78900">user4594</a></td></tr>
<tr d-ix="38"><td>046</td><td>Julia</td><td>160430T054436Z</td><td><a href="https://codegolf.stackexchange.com/questions/78896/compute-the-adler-32-checksum/78897#78897">Alex A.</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://github.com/Thunno/Thunno2" rel="nofollow noreferrer">Thunno 2</a>, 16 <a href="https://github.com/Thunno/Thunno2/blob/main/docs/codepage.md" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>ṡ⁺S$S⁺,»¢¢ȯ»%ɠ²ḋ
</code></pre>
<p><a href="https://Not-Thonnu.github.io/run#aGVhZGVyPSZjb2RlPSVFMSVCOSVBMSVFMiU4MSVCQVMlMjRTJUUyJTgxJUJBJTJDJUMyJUJCJUMyJUEyJUMyJUEyJUM4JUFGJUMyJUJCJTI1JUM5JUEwJUMyJUIyJUUxJUI4JThCJmZvb3Rlcj0maW5wdXQ9JTVCODAlMkMlMjAxMTQlMkMlMjAxMTElMkMlMjAxMDMlMkMlMjAxMTQlMkMlMjA5NyUyQyUyMDEwOSUyQyUyMDEwOSUyQyUyMDEwNSUyQyUyMDExMCUyQyUyMDEwMyUyQyUyMDMyJTJDJTIwODAlMkMlMjAxMTclMkMlMjAxMjIlMkMlMjAxMjIlMkMlMjAxMDglMkMlMjAxMDElMkMlMjAxMTUlMkMlMjAzMiUyQyUyMDM4JTJDJTIwMzIlMkMlMjA2NyUyQyUyMDExMSUyQyUyMDEwMCUyQyUyMDEwMSUyQyUyMDMyJTJDJTIwNzElMkMlMjAxMTElMkMlMjAxMDglMkMlMjAxMDIlNUQmZmxhZ3M9ZQ==" rel="nofollow noreferrer">Try it online!</a></p>
<p>Port of Leaky Nun's Jelly answer.</p>
<h4>Explanation</h4>
<pre class="lang-python prettyprint-override"><code>ṡ⁺S$S⁺,»¢¢ȯ»%ɠ²ḋ  # Implicit input
ṡ⁺                # Cumulative sums, increment
  S               # Sum the resulting list
   $S⁺,           # Pair with sum(input) + 1
       »¢¢ȯ»%     # Mod by 65521
             ɠ²ḋ  # Convert from base 65536
                  # Implicit output
</code></pre>
</div>
<div id="pu1" class="pu"><h1><a href="https://codewithrockstar.com/" rel="nofollow noreferrer">Rockstar</a>, 156 bytes</h1>
<pre><code>listen to N
T's1
C's0
while N
let T be+N-0
let C be+T
listen to N

X's65521
let M be C/X
turn down M
let C be-M*X
let M be T/X
turn down M
say T-M*X+C*65536
</code></pre>
<p><a href="https://codewithrockstar.com/online" rel="nofollow noreferrer">Try it here</a> (Code will need to be pasted in, with input as newline separated codepoints)</p>
</div>
<div id="pu2" class="pu"><h1><a href="https://github.com/ETHproductions/japt" rel="nofollow noreferrer">Japt</a>, 23 <a href="https://en.wikipedia.org/wiki/ISO/IEC_8859-1" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>[UåÄ Up1]®x uFnG²²ÃìG²²
</code></pre>
<p><a href="https://petershaggynoble.github.io/Japt-Interpreter/?v=1.4.6&amp;header=MTA0MG9ANjM&amp;code=W1XlxCBVcDFdrnggdUZuR7Kyw%2bxHsrI&amp;input=WzgwLCAxMTQsIDExMSwgMTAzLCAxMTQsIDk3LCAxMDksIDEwOSwgMTA1LCAxMTAsIDEwMywgMzIsIDgwLCAxMTcsIDEyMiwgMTIyLCAxMDgsIDEwMSwgMTE1LCAzMiwgMzgsIDMyLCA2NywgMTExLCAxMDAsIDEwMSwgMzIsIDcxLCAxMTEsIDEwOCwgMTAyXQ" rel="nofollow noreferrer">Try it</a></p>
</div>
<div id="pu3" class="pu"><h1><a href="https://github.com/barbuz/Husk" rel="nofollow noreferrer">Husk</a>, 22 bytes</h1>
<pre><code>+*□256₁m→∫¹₁:1
%65521Σ
</code></pre>
<p><a href="https://tio.run/##yygtzv7/X1vr0bSFRqZmj5oacx@1TXrUsfrQTiDbypBL1czU1Mjw3OL///9Hm1nqWJrrGBoYA7EFEBvqGBqa6hgbgUUNTcAiQB5YAZQLljHTMTaOBQA" rel="nofollow noreferrer" title="Husk – Try It Online">Try it online!</a></p>
<p>May be shorter with a lambda.</p>
<h2>Explanation</h2>
<pre><code>%65521Σ Function ₁:
      Σ sum of elements of the argument
%65521Σ modulo 65521

+*□256₁m→∫¹₁:1 main program:
           ₁:1 prepend 1(to the input), apply Function ₁
+              plus
         ∫¹    cumulative sums of the input
       m→      increment each sum
      ₁        apply function 1
 *□256         multiply with 256² (65536)
</code></pre>
</div>
<div id="pu4" class="pu"><h1><a href="http://www.complang.tuwien.ac.at/forth/gforth/Docs-html/" rel="nofollow noreferrer">Forth (gforth)</a>, 117 bytes</h1>

<pre class="lang-forth prettyprint-override"><code>: f 2dup bounds 1 -rot do i c@ + loop 65521 mod -rot dup 0 do i for over i + c@ + next loop 65521 mod nip 65536 * + ;
</code></pre>
<p><a href="https://tio.run/##7ZSxDoIwEIZ3n@KXwUECEQwMMGhCjCuvgLQUInBNKUYZfHUswuTiC/Dlkvau3/U6tSClS0cU0zKOEQr4rJe4Ud@yDh4cRRqMUCE/w0ZNJBEGge@hIbacGv8wO@Ya0IMrs7XnhpY/9W9XW32zY4i9MWIzVc5T9Uty5AquhaTk@b3rmwiWeZM7VU3Em87CJRM175ApDqF4prcW5FRPFQmVNU3VCqT9MEzSDgkxjivVxWK9/7Bop5WVlZUF8y2MHw" rel="nofollow noreferrer" title="Forth (gforth) – Try It Online">Try it online!</a></p>
<h3>Code explanation</h3>
<pre class="lang-forth prettyprint-override"><code>: f                 \ start a new word definition
\ Calculate Low:
  2dup bounds       \ copy the string start address and length and get string end address
  1 -rot            \ start an accumulator to hold low (initialize to 1)
  do                \ loop from start address to end-address
    i c@ +          \ get ascii value for each char and add to accumulator
  loop              \ end loop
  65521 mod -rot    \ get value % 65521 to get Low and move off top of stack

\ Calculate High:
  dup 0 do          \ loop from 0 to string-length - 1
    i for           \ loop from outer-loop index to 0
      over i +      \ get address of current ascii char
      c@ +          \ get value of current char and add to total
    next            \ end inner loop
  loop              \ end outer loop
  65521 mod         \ get value % 65521 to get High
  nip               \ remove extraneous value from stack

\ Calculate Checksum
  65536 * +         \ multiply High by 65536 and add to Low
;                   \ end word definition
</code></pre>
</div>
<div id="pu5" class="pu"><h1><a href="https://gitlab.com/n9n/k" rel="nofollow noreferrer">K (ngn/k)</a>, 32 bytes</h1>

<pre><code>{+/1 65536*65521!(*|x),+/x:1+\x}
</code></pre>

<p><a href="https://tio.run/##y9bNS8/7n2RlaGSmMID4f5pVtba@oYKZqamxmRaQNDJU1NCqqdDU0davsDLUjqmo/Z@mkPQfAA" rel="nofollow noreferrer" title="K (ngn/k) – Try It Online">Try it online!</a></p>
</div>
<div id="pu6" class="pu"><h1>x86 16bit machine code function: 32 bytes using a custom calling convention</h1>

<p>Args in registers, and not preserving regs other than bp (and sp).</p>

<p>In 16bit code, we return a 32bit value in the <code>dx:ax</code> register pair.  This means we don't have to spend any instructions merging <code>high</code> and <code>low</code> into <code>eax</code>.  (This would save bytes in 32 and 64 bit code, too, but we can only justify offloading this work to the caller in 16bit code.)</p>

<h3><a href="https://github.com/pcordes/adler32-golf" rel="nofollow">Commented source and test driver on github</a> (for x86 16, 32, and 64bit, and ARM).</h3>

<pre><code>### const char *buf in SI,  uint16_t len in CX
## returns in dx:ax
## also clobbers bx and di.
00000100 &lt;adler32_x16_v6&gt;:
 100:   31 c0                   xor    ax,ax         # set up for lods
 102:   99                      cwd                  # dx= high=0
 103:   bf 01 00                mov    di,0x1        # di= low=0
 106:   bb f1 ff                mov    bx,0xfff1     # bx= m
00000109 &lt;adler32_x16_v6.byteloop&gt;:
 109:   ac                      lods
 10a:   01 c7                   add    di,ax         # low+=buf[i]. modulo-reduce on carry, or on low&gt;=m
 10c:   72 04                   jc     112 &lt;adler32_x16_v6.carry_low&gt;
 10e:   39 df                   cmp    di,bx
 110:   72 02                   jb     114 &lt;adler32_x16_v6.low_mod_m_done&gt;
00000112 &lt;adler32_x16_v6.carry_low&gt;:
 112:   29 df                   sub    di,bx
00000114 &lt;adler32_x16_v6.low_mod_m_done&gt;:
 114:   01 fa                   add    dx,di         # high+=low
 116:   0f 92 d0                setb   al            # store the carry to set up a 32bit dividend.
 119:   92                      xchg   dx,ax
 11a:   f7 f3                   div    bx            # high (including carry) %= m, in dx.  ax=0 or 1 (so we're set for lods next iteration)                                                         
 11c:   e2 eb                   loop   109 &lt;adler32_x16_v6.byteloop&gt;
 11e:   97                      xchg   di,ax         # 
 11f:   c3                      ret    
00000120 &lt;adler32_x16_v6_end&gt;:
</code></pre>

<p>0x120 - 0x100 = 32 bytes</p>

<p>Tested by assembling the same code for 32bit mode, so I can call it (with a wrapper function) from C compiled with <code>-m32</code>.  For me, 16bit mode is somewhat interesting, DOS system calls are not.  All the instructions have explicit operands, except <code>loop</code> and <code>lodsb</code>, so assembling for 32bit mode uses operand-size prefixes.  Same instruction, different encoding.  But <code>lodsb</code> in 32bit mode will use <code>[esi]</code>, so this for-testing version works with 32bit pointers (because we don't do any address-math or pointer increment/compare).</p>

<p>No mismatches.  My test harness prints a message if there is a mismatch.</p>

<pre><code>$ yasm -felf32 -Worphan-labels -gdwarf2 adler32-x86-16.asm -o adler32-x86-16+32.o &amp;&amp;
   g++ -DTEST_16BIT -m32 -std=gnu++11 -O1 -g -Wall -Wextra -o test-adler32-x16  adler32-x86-16+32.o  test-adler32.cpp -lz &amp;&amp;
   ./test-adler32-x16
Eagles are great! (len=17): zlib:0x36c405fe  c:0x36c405fe golfed:0x36c405fe
Programming Puzzles &amp; Code Golf (len=31): zlib:0xbac00b2a  c:0xbac00b2a golfed:0xbac00b2a
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ (len=32): zlib:0x040f0fc1  c:0x040f0fc1 golfed:0x040f0fc1
?????????????????????????????????????????????????? (len=1040): zlib:0x82000000  c:0x82000000 golfed:0x82000000
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ (len=4096): zlib:0xb169e06a  c:0xb169e06a golfed:0xb169e06a
(0xFF repeating) (len=4096): zlib:0x8161f0e2  c:0x8161f0e2 golfed:0x8161f0e2
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ (len=5837): zlib:0x5d2a398c  c:0x5d2a398c golfed:0x5d2a398c
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ (len=5838): zlib:0x97343a0a  c:0x97343a0a golfed:0x97343a0a
(0xFF repeating) (len=9999): zlib:0xcae9ea2c  c:0xcae9ea2c golfed:0xcae9ea2c
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ (len=65535): zlib:0x33bc06e5  c:0x33bc06e5 golfed:0x33bc06e5
</code></pre>

<hr>

<p>With 16bit registers, we can't defer modulo reduction until after the loop.  There's an interesting difference between 16bit and other operand-sizes:  <code>m = 65521</code> (<code>0xFFF1</code>) is more than half 65536.  Subtracting <code>m</code> on carry keeps the value below 2*m, even if <code>high=0xFFF0 + 0xFFF0</code>.  After the loop, a compare-and-subtract will do the trick, instead of a <code>div</code>.</p>

<p>I came up with a <strong>novel technique for modulo-reducing a register after an add that can produce a carry</strong>.  Instead of zeroing the upper half of the input for <code>div</code>, use <code>setc dl</code> to create a 32bit dividend holding the non-truncated add result (<code>dh</code> is already zeroed).  (<a href="http://www.felixcloutier.com/x86/DIV.html" rel="nofollow"><code>div</code></a> does 32b / 16b => 16bit division.)</p>

<p><code>setcc</code> (3 bytes) was introduced with 386.  To run this on 286 or earlier, the best I've come up with uses the <a href="http://www.rcollins.org/secrets/opcodes/SALC.html" rel="nofollow">undocumented <code>salc</code> instruction (set AL from carry)</a>.  It's a one-byte opcode for <code>sbb al,al</code>, so we could use <code>salc</code> / <code>neg al</code> before doing the <code>xchg ax, dx</code> (which we need anyway).  Without <code>salc</code>, there's a 4B sequence: <code>sbb dx,dx</code> / <code>neg dx</code>.  We can't use 3B <code>sbb dx,dx</code> / <code>inc dx</code>, because that would emulate <code>setnc</code> rather than <code>setc</code>.</p>

<hr>

<p>I tried <strong>using 32bit operand-size</strong> instead of handling carry, but it's not just the <code>add</code> instructions that need an operand-size prefix.  Instructions setting up the constants and so on also need operand-size prefixes, so it ended up not being the smallest.</p>
</div>
<div id="pu7" class="pu"><h1>x86-64 machine code function: <s>33</s> 32 bytes  (or <s>31</s> 30 bytes with an <code>int[]</code> input instead of <code>char[]</code>)</h1>

<h1>x86-32 machine code function: 31 bytes</h1>

<p><strong>As a GNU C inline-asm code fragment: saves <s>2B</s> 1B (just the <code>ret</code> insn).</strong></p>

<h2>Commented source and test driver <a href="https://github.com/pcordes/adler32-golf" rel="nofollow noreferrer">on github</a></h2>

<p>The 64bit version is callable directly from C with the standard System V x86-64 ABI (using 2 dummy args to get args in the regs I want).  Custom calling conventions are not uncommon for asm code, so this is a bonus feature.</p>

<p>32bit machine code saves 1B, because merging the high and low halves with <code>push16/push16 =&gt; pop32</code> only works in 32bit mode.  A 32bit function would need a custom calling convention.  We shouldn't hold that against it, but calling from C needs a wrapper function.</p>

<p>After processing 4096 <code>~</code> (ASCII 126) bytes, <code>high = 0x3f040000, low = 0x7e001</code>.  So <code>high</code>'s most-significant bit isn't set yet.  My code takes advantage of this, sign-extending <code>eax</code> into <code>edx:eax</code> with <code>cdq</code> as a way of zeroing <code>edx</code>.</p>

<pre><code># See the NASM source below
0000000000401120 &lt;golfed_adler32_amd64&gt;:
  401120:       31 c0                   xor    eax,eax
  401122:       99                      cdq    
  401123:       8d 7a 01                lea    edi,[rdx+0x1]
0000000000401126 &lt;golfed_adler32_amd64.byteloop&gt;:
  401126:       ac                      lods   al,BYTE PTR ds:[rsi]
  401127:       01 c7                   add    edi,eax
  401129:       01 fa                   add    edx,edi
  40112b:       e2 f9                   loop   401126 &lt;golfed_adler32_amd64.byteloop&gt;
000000000040112d &lt;golfed_adler32_amd64.end&gt;:
  40112d:       66 b9 f1 ff             mov    cx,0xfff1
  401131:       92                      xchg   edx,eax
  401132:       99                      cdq    
  401133:       f7 f1                   div    ecx
  401135:       52                      push   rdx
  401136:       97                      xchg   edi,eax
  401137:       99                      cdq    
  401138:       f7 f1                   div    ecx
  40113a:       66 52                   push   dx      # this is the diff from last version: evil push/pop instead of shift/add
  40113c:       58                      pop    rax
  40113d:       66 5a                   pop    dx
  40113f:       c3                      ret    
0000000000401140 &lt;golfed_adler32_amd64_end&gt;:
</code></pre>

<p><code>0x40 - 0x20</code> = 32 bytes.</p>

<hr>

<h2>Commented NASM source:</h2>

<p>tricks:</p>

<ul>
<li><p><code>xchg eax, r32</code> is one byte; cheaper than mov.  8086 needed data in ax for a lot more stuff than >= 386, so they decided to spend a lot of opcode-space on the now-rarely-used <code>xchg ax, r16</code>.</p></li>
<li><p>Mixing push64 and push16 for merging high and low into a single register saves reg-reg data movement instructions around two <code>div</code>s.  The 32bit version of this trick works even better: <code>push16 / push16 / pop32</code> is only 5B total, not 6.</p></li>
</ul>

<p>Since we push/pop, this <a href="https://stackoverflow.com/questions/34520013/using-base-pointer-register-in-c-inline-asm/34522750#34522750">isn't safe for inline asm in the SysV amd64 ABI (with a red zone)</a>.</p>

<pre><code>golfed_adler32_amd64_v3:   ; (int dummy, const char *buf, int dummy, uint64_t len)

    ;; args: len in rcx,  const char *buf in rsi
    ;; Without dummy args, (unsigned len, const char *buf),  mov ecx, edi is the obvious solution, costing 2 bytes

    xor     eax,eax         ; scratch reg for loading bytes
    cdq                     ; edx: high=0
    lea     edi, [rdx+1]    ; edi: low=1
    ;jrcxz  .end            ; We don't handle len=0.  unlike rep, loop only checks rcx after decrementing
.byteloop:
    lodsb                   ; upper 24b of eax stays zeroed (no partial-register stall on Intel P6/SnB-family CPUs, thanks to the xor-zeroing)
    add     edi, eax        ; low += zero_extend(buf[i])
    add     edx, edi        ; high += low
    loop   .byteloop
.end:
    ;; exit when ecx = 0, eax = last byte of buf
    ;; lodsb at this point would load the terminating 0 byte, conveniently leaving eax=0

    mov     cx, 65521       ; ecx = m = adler32 magic constant.  (upper 16b of ecx is zero from the loop exit condition.  This saves 1B over mov r32,imm32)
    ;sub    cx, (65536 - 65521) ; the immediate is small enough to use the imm8 encoding.  No saving over mov, though, since this needs a mod/rm byte

    xchg    eax, edx        ; eax = high,  edx = buf[last_byte]
    cdq                     ; could be removed if we could arrange things so the loop ended with a load of the 0 byte

    div     ecx             ; div instead of idiv to fault instead of returning wrong answers if high has overflowed to negative.  (-1234 % m is negative)
    push    rdx             ; push high%m and 6B of zero padding

    xchg    eax, edi        ; eax=low
    cdq
    div     ecx             ; edx = low%m

    ;; concatenate the two 16bit halves of the result by putting them in contiguous memory
    push    dx              ; push low%m with no padding
    pop     rax             ; pop  high%m &lt;&lt; 16 | low%m   (x86 is little-endian)

    pop     dx              ; add rsp, 2 to restore the stack pointer

    ;; outside of 16bit code, we can't justify returning the result in the dx:ax register pair
    ret
golfed_adler32_amd64_end_v3:
</code></pre>

<p>I also considered using <code>rcx</code> as an array index, instead of having two loop counters, but adler32(s) != adler32(reverse(s)).  So we couldn't use <code>loop</code>.  Counting from -len up towards zero and using <code>movzx r32, [rsi+rcx]</code> just uses way too many bytes.</p>

<p>If we want to consider incrementing the pointer ourself, 32bit code is probably the way to go.  Even the x32 ABI (32bit pointers) isn't sufficient, because <code>inc esi</code> is 2B on amd64, but 1B on i386.  It appears hard to beat <code>xor eax,eax</code> / <code>lodsb</code> / <code>loop</code>: 4B total to get each element in turn zero-extended into eax.  <code>inc esi</code> / <code>movzx r32, byte [esi]</code> / <code>loop</code> is 5B.</p>

<p><code>scas</code> is another option for incrementing a pointer with a 1B instruction in 64bit mode.  (<code>rdi</code>/<code>edi</code> instead of <code>rsi</code>, so we'd take the pointer arg in <code>rdi</code>).  We can't use the flag result from <code>scas</code> as a loop condition, though, because we don't want to keep eax zeroed.  Different register allocation could maybe save a byte after the loop.</p>

<hr>

<h3><code>int[]</code> input</h3>

<p>The full function taking <code>uint8_t[]</code> is the "main" answer, because it's a more interesting challenge.  Unpacking to <code>int[]</code> is an unreasonable thing to ask our caller to do in this language, but it does save 2B.</p>

<p>If we take our input as an unpacked array of 32bit integers, we can save one byte easily (use <code>lodsd</code> and replace <code>xor eax,eax / cdq</code> with just <code>xor edx,edx</code>).</p>

<p>We can save another byte by zeroing edx with <code>lodsd</code>/<code>cdq</code>, and re-arranging the loop so it loads the terminating 0 element before exiting.  (We're still assuming it exists, even though this is an array of <code>int</code>, not a string).</p>

<pre><code>; untested: I didn't modify the test driver to unpack strings for this
golfed_adler32_int_array:
    ; xor   edx,edx
    lodsd                   ; first element. only the low byte non-zero
    cdq                     ; edx: high=0
    lea     edi, [rdx+1]    ; edi: low=1
    ;jrcxz  .end            ; handle len=0?  unlike rep, loop only checks rcx after decrementing
.intloop:
    add     edi, eax        ; low += buf[i]
    add     edx, edi        ; high += low
    lodsd                   ; load buf[i+1] for next iteration
    loop   .intloop
.end:
    ;; exit when ecx = 0, eax = terminating 0

    xchg    eax, edx
    ;cdq               ; edx=0 already, ready for div
    ; same as the char version
</code></pre>

<p>I also made an untested version that uses <code>scasd</code> (1B version of <code>add edi,4</code>) and <code>add eax, [rdi]</code> instead of <code>lodsd</code>, but it's also 30 bytes.  The savings from having <code>high</code> in eax at the end of the loop are balanced out by larger code elsewhere.  It has the advantage of not depending on a terminating <code>0</code> element in the input, though, which is maybe unreasonable for an unpacked array where we're also given the length explicitly.</p>

<hr>

<h2>C++11 test driver</h2>

<p>See the github link.  This answer was getting too big, and the test driver got more features with bigger code.</p>
</div>
<div id="pu8" class="pu"><h1>Postgresql, 164 bytes</h1>
<pre><code>SELECT t,((SUM(b)+1)%65521)+65536*(SUM(1+b*(LENGTH(t)-r+1))%65521)
FROM v,LATERAL generate_series(1,LENGTH(t))r
,LATERAL(SELECT ASCII(SUBSTRING(t,r,1))b)z GROUP BY t;
</code></pre>
<p><kbd><strong><a href="http://sqlfiddle.com/#!15/51d09/1/0" rel="nofollow noreferrer"><code>SqlFiddleDemo</code></a></strong></kbd></p>
<p>Output:</p>
<pre><code>╔═══════════════════════════════════╦════════════╗
║                t                  ║  ?column?  ║
╠═══════════════════════════════════╬════════════╣
║ PostgreSQL can handle it          ║ 1850149040 ║
║ ?(x1040)                          ║ 2181038080 ║
║ Programming Puzzles &amp; Code Golf   ║ 3133147946 ║
║ Eagles are great!                 ║  918816254 ║
║ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  ║   68095937 ║
╚═══════════════════════════════════╩════════════╝
</code></pre>
<hr>
<p>Version with parameter as subquery:</p>
<pre><code>SELECT((SUM(b)+1)%65521)+65536*(SUM(1+b*(LENGTH(t)-r+1))%65521)
FROM(SELECT text'Eagles are great!'t)s,LATERAL generate_series(1,LENGTH(t))r
,LATERAL(SELECT ASCII(SUBSTRING(t,r,1))b)z;
</code></pre>
<p><kbd><strong><a href="http://sqlfiddle.com/#!15/5b8e8/7/0" rel="nofollow noreferrer"><code>SqlFiddleDemo2</code></a></strong></kbd></p>
</div>
<div id="pu9" class="pu"><h1>Perl 5, 43 bytes</h1>
<p>42 bytes, plus 1 for <code>-aE</code> instead of <code>-e</code></p>
<p>Input is as decimal integers, space-separated.</p>
<pre><code>map$h+=$.+=$_,@F;say$.%65521+$h%65521*4**8
</code></pre>
<p>A tip of my hat to <a href="/a/79025">Sp3000</a>, from whom I took ideas for this answer.</p>
<p>How it works:</p>
<ol>
<li>Because of <a href="http://perldoc.perl.org/perlrun.html#Command-Switches" rel="nofollow noreferrer"><code>-a</code></a>, <a href="http://perldoc.perl.org/perlvar.html#Variables-related-to-filehandles" rel="nofollow noreferrer"><code>$.</code></a>  starts at 1 and <code>@F</code> is the input array. <code>$h</code> starts at 0. <code>$_</code> is used by <code>map</code> as a placeholder for each element of an array.</li>
<li><code>map$h+=$.+=$_,@F</code> means that for each element in <code>@F</code> we add that element to <code>$.</code> and then add <code>$.</code> to <code>$h</code>.</li>
<li>Then we do the modular arithmetic <code>$.%65521+$h%65521*4**8</code> (that is, <code>($. % 65521) + ( ($h % 65521) * (4**8) )</code> and <code>say</code> (print) the result.</li>
</ol>
</div>
<div id="pu10" class="pu"><h1>ABAP, 118 bytes</h1>

<pre><code>FORM a TABLES t USING l h.l = 1.LOOP AT t.ADD:t TO l,l TO h.ENDLOOP.l = l MOD 65521 + 65536 * ( h MOD 65521 ).ENDFORM.
</code></pre>

<p>Ungolfed</p>

<pre><code>FORM a TABLES t USING l h.
  l = 1.
  LOOP AT t.
    ADD: t TO l,
         l TO h.
  ENDLOOP.
  l = l MOD 65521 + 65536 * ( h MOD 65521 ).
ENDFORM.
</code></pre>

<p>This is my first try at code golfing, if I did anything wrong please let me know! I used ABAP because that's my main programming language. Now for the explanation:</p>

<pre><code>FORM a TABLES t USING l h.
  ...
ENDFORM.
</code></pre>

<p>This declares the function "a" with the inputs t, l and h. I defined t as a table of integers and filled it with the different numbers from the original post (for test purposes). l and h are defined as DEC variables with length 31 (highest it can go in ABAP). l is also used as the returning variable for the function so I don't have to use an additional variable.</p>

<pre><code>  LOOP AT t.
    ...
  ENDLOOP.
</code></pre>

<p>This is a loop over the table t, which is defined as a table with <a href="http://help.sap.com/abapdocu_702/en/abenitab_header_line.htm" rel="nofollow">header-line</a>. This means that the table has a header-line which acts as a variable ("t") and it also has a table body ("t[ ]") at the same time. So "LOOP AT t" reads the rows in the table t[ ] (in order) into the header-line t. Header-lines are obsolete but they save quite a bit of bytes over the now used "LOOP AT table INTO variable.".</p>

<pre><code>    ADD: t TO l,
         l TO h.
</code></pre>

<p>Within the loop I'm starting a slightly modified version (pretty much just rearranged) of the calculation that Dennis has in his original post. l = low, h = high. I'm adding the current value in the table to the variable l (which i define to start at 1 in the line "l = 1."). Each step in the loop I'm also adding l to h.
I use "ADD" because ABAP doesn't have "l += t" and using the code above is shorter than:</p>

<pre><code>l = l + t.
h = h + l.
</code></pre>

<p>After the loop we have the following:</p>

<ul>
<li>l = (1 + b<sub>1</sub> + ⋯ + b<sub>n</sub>)</li>
<li>h = ((1 + b<sub>1</sub>) + (1 + b<sub>1</sub> + b<sub>2</sub>) + ⋯ (1 + b<sub>1</sub> + ⋯ + b<sub>n</sub>))</li>
</ul>

<p>At the end I'm doing the final calculation:</p>

<pre><code>  l = l MOD 65521 + 65536 * ( h MOD 65521 ).
</code></pre>

<p>Sadly you need spaces between the operators and numbers/variables because ABAP uses the operators without spaces for different things. For example:</p>

<pre><code>char+4 = 'A'.
</code></pre>

<p>This sets the 5th character (because the offset is set as "4") of the character variable "char" as 'A'. So if "char" was "BBBBB" before that line, it would be "BBBBA" after.</p>

<p>I hope this explanation isn't too long (which I think it is, since the code is really straight forward). ABAP doesn't have bitwise operations AFAIK so I couldn't use a shorter algorithm but I think 118 bytes is still pretty good.</p>

<p>Here's the full program in case anyone can and wants to test it:</p>

<pre><code>REPORT z_adler_checksum.

DATA:
  lt_i TYPE TABLE OF i WITH HEADER LINE, "Input table
  l_l  TYPE zz, "Calculation and return variable
  l_h  TYPE zz. "Calculation variable

DO 1040 TIMES. "Filling the table for the last test case in the original post
  APPEND 63 TO lt_i.
ENDDO.

PERFORM a TABLES lt_i USING l_l l_h. "Calling the function

WRITE l_l. "Output of the result

FORM a TABLES t USING l h.
  l = 1.
  LOOP AT t.
    ADD: t TO l,
         l TO h.
  ENDLOOP.
  l = l MOD 65521 + 65536 * ( h MOD 65521 ).
ENDFORM.
</code></pre>
</div>
<div id="pu11" class="pu"><h1><a href="https://esolangs.org/wiki/Fission" rel="nofollow noreferrer">Fission</a>, 324 bytes</h1>
<pre><code>          /   M
       R_MZ  |S
      D ]    |S
 /?V?\} {}/  |S /    \
R{/A  Z$[/   |S/     {\
  } J{\      |S      ;_
 \^  /       |S   R'~++Y++~'L
 /    /      |S       }Y;
 \  \        ;^/
 /  /         +\+ R'~++A++~'L
 \  &lt;Z________________/
    ;\X       //
              \Y/
               *
</code></pre>
<p><em>Fair warning, the only implementation I've tested this on is my own port of the language to F#. It's not golfed, mainly because I found it easier to have a couple of long runs while my prime constant cooled along the bottom, so I may come back and tweak it.</em></p>
<p>How does it work?</p>
<ul>
<li>The <code>R'~++Y++~'L</code> block fuses a 256 constant and launches it downwards, setting the mass multiplier of the reactor directly below it.</li>
<li>The <code>R'~++A++~'A</code> block fuses another 256 and launches it up towards the reactor above, which fissions the particle into two mass multiples of <code>65536</code> mass each, launching them left and right (where the right particle is immediately destroyed by the terminator).</li>
<li>The left particle hits another reactor and undergoes fission, splitting into two particles of equal mass heading up and down.</li>
<li>The upward travelling power-of-two particle passes through a net-zero mass manipulation, reflects to the left, then sets the mass multiplier of the fusion reactor. This reactor will be how we multiply the H block.</li>
<li>The downward travelling particle reflects to the left and sheds mass over the long run, ultimately reaching a mass of <code>65521</code> (our large prime).</li>
<li>The rotational mirror (<code>Z</code>) at the end of the run causes the particle to duplicate the prime, sending one back to the right where it ultimately sets the stored mass of the fission reactor (<code>^</code>). This is how we'll be applying the modulus operator to the H block.</li>
<li>The second copy is reflected back, where it performs an analogous function for the fission reactor (<code>&lt;</code>) we'll be using for the L block.</li>
<li>Now that our constants are in place, we engage in shenanigans in the upper left to read our input and generate our two lists. To be honest, I forget how those work, but for the empty string I had to slow down the H block summing particle, which explains the <code>|S</code> &quot;cooling tower&quot;.</li>
<li><code>\Y/</code> fuses the L block (which comes in through the left channel) and the H block (which comes in through the right channel), then slams them into a terminator which sets the exit code to the fused mass.</li>
</ul>
</div>
<div id="pu12" class="pu"><h1>Piet, 120 Codels <a href="https://i.stack.imgur.com/6L6Ur.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/6L6Ur.png" alt="codelsize 1"></a></h1>

<p>With codelsize 20:</p>

<p><a href="https://i.stack.imgur.com/NUxUp.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/NUxUp.png" alt="codelsize 20"></a></p>

<h3>Notes / How does it work?</h3>

<ul>
<li><p>Since it is not possible to use an array or string as input, this program works by taking a series of integers (representing ascii characters) as inputs. I thought about using character inputs at first but struggled to find a nice solution for termination, so now it terminates when any numer smaller than 1 is entered. It was originally only negative values for termination, but I had to change the initialization after writing the program, so now I can't fit the required <code>2</code>, only a <code>1</code> (26/45 on the trace image). This doesn't matter though because as per the challenge rules, only printable ascii characters are allowed.</p></li>
<li><p>Struggled for a long time with reentering the loop, though I found quite the elegant solution in the end. No <code>pointer</code> or <code>switch</code> operations, only the interpreter running into walls until it transitions back into the green codel to read the input (43->44 on the trace images).</p></li>
<li><p>Loop termination is achived by first duplicating the input, adding 1 and then checking if it is bigger than 1. If it is, the codel chooser is triggered and execution continues on the lower path. If it is not, the program contines left (Bright yellow codels, 31/50 on the trace images).</p></li>
<li><p>The supported input size is interpreter implementation dependent, though it would be possible to support an arbitrarily large input with the right interpreter (Say, for example, a Java interpreter that uses <code>BigInteger</code> as internal values)</p></li>
<li><p>Just saw that the setup includes one unnecessary <code>DUP</code> and <code>CC</code> (7->8->9 in the trace images). No idea how that happened. This is effectively a noop though, it toggles the codel chooser 16 times which results in no change.</p></li>
</ul>

<h3>Npiet trace images</h3>

<p>Setup and first loop:</p>

<p><a href="https://i.stack.imgur.com/OMdNz.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/OMdNz.png" alt="starttrace"></a></p>

<p>Loop termination, output and exit:</p>

<p><a href="https://i.stack.imgur.com/funAu.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/funAu.png" alt="endtrace"></a></p>

<h3>Outputs</h3>

<p>Forgive me if I only include one output, it just takes a long time to input :^)</p>

<pre><code>String: "Eagles are great!"

PS B:\Marvin\Desktop\Piet&gt; .\npiet.exe adler32.png
? 69
? 97
? 103
? 108
? 101
? 115
? 32
? 97
? 114
? 101
? 32
? 103
? 114
? 101
? 97
? 116
? 33
? -1
918816254
</code></pre>

<h3>Npiet trace for [65, -1]</h3>

<pre><code>trace: step 0  (0,0/r,l nR -&gt; 1,0/r,l dR):
action: push, value 4
trace: stack (1 values): 4

trace: step 1  (1,0/r,l dR -&gt; 2,0/r,l dB):
action: duplicate
trace: stack (2 values): 4 4

trace: step 2  (2,0/r,l dB -&gt; 3,0/r,l nM):
action: multiply
trace: stack (1 values): 16

trace: step 3  (3,0/r,l nM -&gt; 4,0/r,l nC):
action: duplicate
trace: stack (2 values): 16 16

trace: step 4  (4,0/r,l nC -&gt; 5,0/r,l nY):
action: duplicate
trace: stack (3 values): 16 16 16

trace: step 5  (5,0/r,l nY -&gt; 6,0/r,l nM):
action: duplicate
trace: stack (4 values): 16 16 16 16

trace: step 6  (6,0/r,l nM -&gt; 7,0/r,l nC):
action: duplicate
trace: stack (5 values): 16 16 16 16 16

trace: step 7  (7,0/r,l nC -&gt; 8,0/r,l nY):
action: duplicate
trace: stack (6 values): 16 16 16 16 16 16

trace: step 8  (8,0/r,l nY -&gt; 9,0/r,l lB):
action: switch
trace: stack (5 values): 16 16 16 16 16
trace: stack (5 values): 16 16 16 16 16

trace: step 9  (9,0/r,l lB -&gt; 10,0/r,l dM):
action: multiply
trace: stack (4 values): 256 16 16 16

trace: step 10  (10,0/r,l dM -&gt; 11,0/r,l nR):
action: multiply
trace: stack (3 values): 4096 16 16

trace: step 11  (11,0/r,l nR -&gt; 12,0/r,l lY):
action: multiply
trace: stack (2 values): 65536 16

trace: step 12  (12,0/r,l lY -&gt; 13,0/r,l lM):
action: duplicate
trace: stack (3 values): 65536 65536 16

trace: step 13  (13,0/r,l lM -&gt; 14,0/r,l nM):
action: push, value 3
trace: stack (4 values): 3 65536 65536 16

trace: step 14  (14,0/r,l nM -&gt; 15,0/r,l dM):
action: push, value 2
trace: stack (5 values): 2 3 65536 65536 16

trace: step 15  (15,0/r,l dM -&gt; 16,0/r,l lC):
action: roll
trace: stack (3 values): 16 65536 65536

trace: step 16  (16,0/r,l lC -&gt; 17,0/r,l nB):
action: sub
trace: stack (2 values): 65520 65536

trace: step 17  (17,0/r,l nB -&gt; 18,0/r,l dB):
action: push, value 1
trace: stack (3 values): 1 65520 65536

trace: step 18  (18,0/r,l dB -&gt; 19,0/r,l dM):
action: add
trace: stack (2 values): 65521 65536

trace: step 19  (19,0/r,l dM -&gt; 19,1/d,r dC):
action: duplicate
trace: stack (3 values): 65521 65521 65536

trace: step 20  (19,1/d,r dC -&gt; 18,1/l,l lC):
action: push, value 1
trace: stack (4 values): 1 65521 65521 65536

trace: step 21  (18,1/l,l lC -&gt; 17,1/l,l nC):
action: push, value 1
trace: stack (5 values): 1 1 65521 65521 65536

trace: step 22  (17,1/l,l nC -&gt; 16,1/l,l dB):
action: sub
trace: stack (4 values): 0 65521 65521 65536

trace: step 23  (16,1/l,l dB -&gt; 15,1/l,l lB):
action: push, value 1
trace: stack (5 values): 1 0 65521 65521 65536

trace: step 24  (15,1/l,l lB -&gt; 13,2/l,l dG):
action: in(number)
? 65
trace: stack (6 values): 65 1 0 65521 65521 65536

trace: step 25  (13,2/l,l dG -&gt; 12,2/l,l dR):
action: duplicate
trace: stack (7 values): 65 65 1 0 65521 65521 65536

trace: step 26  (12,2/l,l dR -&gt; 11,2/l,l lR):
action: push, value 1
trace: stack (8 values): 1 65 65 1 0 65521 65521 65536

trace: step 27  (11,2/l,l lR -&gt; 10,2/l,l lY):
action: add
trace: stack (7 values): 66 65 1 0 65521 65521 65536

trace: step 28  (10,2/l,l lY -&gt; 9,2/l,l nY):
action: push, value 1
trace: stack (8 values): 1 66 65 1 0 65521 65521 65536

trace: step 29  (9,2/l,l nY -&gt; 8,1/l,r nB):
action: greater
trace: stack (7 values): 1 65 1 0 65521 65521 65536

trace: step 30  (8,1/l,r nB -&gt; 7,1/l,r lY):
action: switch
trace: stack (6 values): 65 1 0 65521 65521 65536
trace: stack (6 values): 65 1 0 65521 65521 65536

trace: step 31  (7,1/l,l lY -&gt; 6,2/l,l nY):
action: push, value 2
trace: stack (7 values): 2 65 1 0 65521 65521 65536

trace: step 32  (6,2/l,l nY -&gt; 5,3/l,l dB):
action: pointer
trace: stack (6 values): 65 1 0 65521 65521 65536

trace: step 33  (5,3/r,l dB -&gt; 7,4/r,l dM):
action: add
trace: stack (5 values): 66 0 65521 65521 65536

trace: step 34  (7,4/r,l dM -&gt; 8,4/r,l dC):
action: duplicate
trace: stack (6 values): 66 66 0 65521 65521 65536

trace: step 35  (8,4/r,l dC -&gt; 9,3/r,l lC):
action: push, value 3
trace: stack (7 values): 3 66 66 0 65521 65521 65536

trace: step 36  (9,3/r,l lC -&gt; 10,3/r,l nC):
action: push, value 2
trace: stack (8 values): 2 3 66 66 0 65521 65521 65536

trace: step 37  (10,3/r,l nC -&gt; 11,3/r,l dY):
action: roll
trace: stack (6 values): 0 66 66 65521 65521 65536

trace: step 38  (11,3/r,l dY -&gt; 12,3/r,l dG):
action: add
trace: stack (5 values): 66 66 65521 65521 65536

trace: step 39  (12,3/r,l dG -&gt; 13,3/r,l lG):
action: push, value 2
trace: stack (6 values): 2 66 66 65521 65521 65536

trace: step 40  (13,3/r,l lG -&gt; 14,3/r,l nG):
action: push, value 1
trace: stack (7 values): 1 2 66 66 65521 65521 65536

trace: step 41  (14,3/r,l nG -&gt; 15,3/r,l dR):
action: roll
trace: stack (5 values): 66 66 65521 65521 65536
trace: white cell(s) crossed - continuing with no command at 17,3...

trace: step 42  (15,3/r,l dR -&gt; 17,3/r,l lB):

trace: step 43  (17,3/r,l lB -&gt; 13,2/l,l dG):
action: in(number)
? -1
trace: stack (6 values): -1 66 66 65521 65521 65536

trace: step 44  (13,2/l,l dG -&gt; 12,2/l,l dR):
action: duplicate
trace: stack (7 values): -1 -1 66 66 65521 65521 65536

trace: step 45  (12,2/l,l dR -&gt; 11,2/l,l lR):
action: push, value 1
trace: stack (8 values): 1 -1 -1 66 66 65521 65521 65536

trace: step 46  (11,2/l,l lR -&gt; 10,2/l,l lY):
action: add
trace: stack (7 values): 0 -1 66 66 65521 65521 65536

trace: step 47  (10,2/l,l lY -&gt; 9,2/l,l nY):
action: push, value 1
trace: stack (8 values): 1 0 -1 66 66 65521 65521 65536

trace: step 48  (9,2/l,l nY -&gt; 8,1/l,r nB):
action: greater
trace: stack (7 values): 0 -1 66 66 65521 65521 65536

trace: step 49  (8,1/l,r nB -&gt; 7,1/l,r lY):
action: switch
trace: stack (6 values): -1 66 66 65521 65521 65536
trace: stack (6 values): -1 66 66 65521 65521 65536

trace: step 50  (7,1/l,r lY -&gt; 6,1/l,r dY):
action: pop
trace: stack (5 values): 66 66 65521 65521 65536

trace: step 51  (6,1/l,r dY -&gt; 4,1/l,r lY):
action: push, value 3
trace: stack (6 values): 3 66 66 65521 65521 65536

trace: step 52  (4,1/l,r lY -&gt; 3,1/l,r nY):
action: push, value 2
trace: stack (7 values): 2 3 66 66 65521 65521 65536

trace: step 53  (3,1/l,r nY -&gt; 2,1/l,r nM):
action: duplicate
trace: stack (8 values): 2 2 3 66 66 65521 65521 65536

trace: step 54  (2,1/l,r nM -&gt; 1,1/l,r dG):
action: pointer
trace: stack (7 values): 2 3 66 66 65521 65521 65536

trace: step 55  (1,1/r,r dG -&gt; 2,2/r,r lR):
action: roll
trace: stack (5 values): 65521 66 66 65521 65536

trace: step 56  (2,2/r,r lR -&gt; 2,3/d,l nR):
action: push, value 1
trace: stack (6 values): 1 65521 66 66 65521 65536

trace: step 57  (2,3/d,l nR -&gt; 2,4/d,l lC):
action: switch
trace: stack (5 values): 65521 66 66 65521 65536
trace: stack (5 values): 65521 66 66 65521 65536

trace: step 58  (2,4/d,r lC -&gt; 2,5/d,r nM):
action: mod
trace: stack (4 values): 66 66 65521 65536

trace: step 59  (2,5/d,r nM -&gt; 4,5/r,r dM):
action: push, value 3
trace: stack (5 values): 3 66 66 65521 65536

trace: step 60  (4,5/r,r dM -&gt; 6,5/r,r lM):
action: push, value 2
trace: stack (6 values): 2 3 66 66 65521 65536

trace: step 61  (6,5/r,r lM -&gt; 7,5/r,r nC):
action: roll
trace: stack (4 values): 65521 66 66 65536

trace: step 62  (7,5/r,r nC -&gt; 8,5/r,r dM):
action: mod
trace: stack (3 values): 66 66 65536

trace: step 63  (8,5/r,r dM -&gt; 11,5/r,r lM):
action: push, value 3
trace: stack (4 values): 3 66 66 65536

trace: step 64  (11,5/r,r lM -&gt; 12,5/r,r nM):
action: push, value 1
trace: stack (5 values): 1 3 66 66 65536

trace: step 65  (12,5/r,r nM -&gt; 13,5/r,r dC):
action: roll
trace: stack (3 values): 66 65536 66

trace: step 66  (13,5/r,r dC -&gt; 14,5/r,r nB):
action: multiply
trace: stack (2 values): 4325376 66

trace: step 67  (14,5/r,r nB -&gt; 15,5/r,r nM):
action: add
trace: stack (1 values): 4325442

trace: step 68  (15,5/r,r nM -&gt; 16,5/r,r dB):
action: out(number)
4325442
trace: stack is empty
trace: white cell(s) crossed - continuing with no command at 19,5...

trace: step 69  (16,5/r,r dB -&gt; 19,5/r,r nM):
</code></pre>
</div>
<div id="pu13" class="pu"><h1>ARM Thumb-2 function accepting <code>uint8_t[]</code>: 40 bytes (36B for non-standard ABI and <code>int[]</code>)</h1>

<p>Features: non-deferred modulo, so arbitrary-size inputs are fine.  Doesn't actually use the division instruction, so it's not slow.  (err, at least not for that reason :P)</p>

<p>Savings from following less strict rules:</p>

<ul>
<li>-2B if we don't have to save registers before using them.</li>
<li>-2B for requiring the caller to unpack bytes into a <code>uint32_t[]</code> array.</li>
</ul>

<p>So, best-case is 36B.</p>

<p></p>

<pre><code>// uint8_t *buf in r0,  uint32_t len in r1
00000000 &lt;adler32arm_golf2&gt;:
   0:   b570            push    {r4, r5, r6, lr} //
   2:   2201            movs    r2, #1          // low
   4:   2300            movs    r3, #0          // high
   6:   f64f 75f1       movw    r5, #65521      ; 0xfff1 = m
0000000a &lt;adler32arm_golf2.byteloop&gt;:
   a:   f810 4b01       ldrb.w  r4, [r0], #1    // post-increment byte-load
   e:   4422            add     r2, r4          // low += *B
  10:   4413            add     r3, r2          // high += low
  12:   42aa            cmp     r2, r5          // subtract if needed instead of deferred modulo
  14:   bf28            it      cs
  16:   1b52            subcs   r2, r2, r5
  18:   42ab            cmp     r3, r5
  1a:   bf28            it      cs              // Predication in thumb mode is still possible, but takes a separate instruction
  1c:   1b5b            subcs   r3, r3, r5
  1e:   3901            subs    r1, #1          // while(--len)
  20:   d1f3            bne.n   a &lt;.byteloop2&gt;
  22:   eac2 4003       pkhbt   r0, r2, r3, lsl #16   // other options are the same size: ORR or ADD.
  26:   bd70            pop     {r4, r5, r6, pc}  // ARM can return by popping the return address (from lr) into the pc; nifty
00000028 &lt;adler32arm_end_golf2&gt;:
</code></pre>

<p><strong>0x28 = 40 bytes</strong></p>

<hr>

<h2>Notes:</h2>

<p>Instead of <code>log%m</code> at the end, we do <code>if(low&gt;=m) low-=m</code> inside the loop.  If we do low before high, we know that neither can possibly exceed <code>2*m</code>, so modulo is just a matter of subtracting or not.  A <code>cmp</code> and predicated <code>sub</code> is only 6B in Thumb2 mode.  <a href="https://stackoverflow.com/a/23857807/224132">The standard idiom for <code>%</code></a> is 8B in Thumb2 mode:</p>

<pre><code>UDIV R2, R0, R1         // R2 &lt;- R0 / R1
MLS  R0, R1, R2, R0     // R0 &lt;- R0 - (R1 * R2 )
</code></pre>

<hr>

<p>The implicit-length <code>adler(char *)</code> version is the same code-size as the explicit length <code>adler(uint8_t[], uint32_t len)</code>.  We can set flags for the loop-exit condition with a single 2B instruction either way.</p>

<p>The implicit-length version has the advantage of working correctly with the empty string, instead of trying to loop 2^32 times.</p>

<hr>

<h2>assemble / compile with:</h2>

<pre><code>arm-linux-gnueabi-as --gen-debug -mimplicit-it=always -mfloat-abi=soft -mthumb adler32-arm.S
</code></pre>

<p>or</p>

<pre><code>arm-linux-gnueabi-g++ -Wa,-mimplicit-it=always -g -static -std=gnu++14 -Wall -Wextra -Os -march=armv6t2 -mthumb -mfloat-abi=soft test-adler32.cpp -fverbose-asm adler32-arm.S -o test-adler32
qemu-arm ./test-adler32
</code></pre>

<p>Without <code>-static</code>, the process running under <code>qemu-arm</code> didn't find it's dynamic linker.  (And yes, I install an ARM cross-devel setup just for this answer, because I thought my predicated-subtract idea was neat.)  On amd64 Ubuntu, install <code>gcc-arm-linux-gnueabi</code>, <code>g++-arm-linux-gnueabi</code>.  I found <code>gdb-arm-none-eabi</code> sort of barely worked connecting to <code>qemu-arm -g port</code>.</p>

<h2>Commented source:</h2>

<pre><code>// There's no directive to enable implicit-it=always

// gcc uses compiler uses these in its output
.syntax unified
.arch armv8-a
.fpu softvfp

.thumb      @ aka .code 16

.p2align 4
.globl adler32arm_golf    @ put this label on the one we want to test

.thumb_func
adler32arm_golf:
adler32arm_golf2:   @ (uint8_t buf[], uint32_t len)
        @ r0 = buf
        @ r1 = len
        push    {r4, r5, r6, lr}   @ even number of regs keeps the stack aligned.  Good style? since there's no code-size saving

        movs    r2, #1          @ r2: low
        movs    r3, #0          @ r3: high
                                @ r4 = tmp for loading bytes
        movw    r5, #65521      @ r5: modulo constant

adler32arm_golf2.byteloop2:
        ldrb    r4, [r0], #1    @ *(buf++) post-increment addressing.  4B encoding
        @ldrb    r4, [r0, r1]   @ 2B encoding, but unless we make the caller pass us buf+len and -len, it needs extra code somewhere else
        @ldmia   r0!, {r4}      @ int[] version:  r4 = [r0]; r0+=4;  post-increment addressing.  2B encoding.

        add     r2, r2, r4      @ low += tmp
        add     r3, r3, r2      @ high += low;   // I think it's safe to do this before the modulo range-reduction for low, but it would certainly work to put it after.

        cmp     r2, r5
        subhs   r2, r5          @ if(low&gt;=m) low-=m;   @ 6B total for %.  predicated insns require an IT instruction in thumb2

        cmp     r3, r5
        subhs   r3, r5          @ if(high&gt;=m) high-=m;  // equivalent to high %= m.

        @sub    r1, #1          @ 4B encoding: sub.w to not set flags with immediate
        subs    r1, #1          @ len-- and set flags.  2B encoding
        @cmp    r4, #0          @ null-termination check. 2B encoding
        bne     adler32arm_golf2.byteloop2

@        udiv    r0, r2, r5            @ normal way to do one of the modulos
@        mls     r2, r5, r0, r2         @ r2 = low % m.  8B total for %

        PKHBT   r0, r2, r3, lsl #16     @ 4B   r0 = [ high%m &lt;&lt;16  |   low%m  ]
        @orr     r0, r0, r4, lsl #16    @ 4B
        @orr     r0, r0, r4             @ 4B
        @add     r0, r2, r3, lsl #16    @ 4B
        @add     r0, r0, r4             @ 2B
        pop     {r4, r5, r6, pc}        @ ARM can return by popping the return address (saved from lr) into pc.  Nifty
adler32arm_end_golf2:
</code></pre>

<p><code>test-adler32.cpp</code> has the same test-cases and <code>main()</code> as for my x86-64 answer, but starts this way:</p>

<pre class="lang-c prettyprint-override"><code>#include &lt;stdint.h&gt;
uint32_t adler32_simple(const uint8_t *B) {
  const uint32_t m=65521;

  uint32_t h=0, l=1;
  do {
    l += *B++;        // Borrowed from orlp's answer, as a simple reference implementation
    h += l;
    l %= m; h %= m;   // with non-deferred modulo if this is uncommented
  } while(*B);

  return h%m&lt;&lt;16|l%m;
}


#include &lt;stdio.h&gt;
//#include &lt;zlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;string&gt;   // useful for the memset-style constructors that repeat a character n times


extern "C" {
    unsigned golfed_adler32_amd64(int /*dummy1*/, const char *buf, int /*dummy2*/, unsigned len);
    unsigned adler32arm_golf(const char *buf, unsigned len);
}
#ifdef __amd64__
#define golfed_adler32(buf, len)   golfed_adler32_amd64(1234, buf, 1234, len)
#elif  __arm__
#define golfed_adler32(buf, len)   adler32arm_golf(buf, len)
#else
#error "no architecture"
#endif

static void test_adler(const char *str)
{
    unsigned len = strlen(str);
//    unsigned zlib = zlib_adler(len, str);
    unsigned reference = adler32_simple((const uint8_t*)str);
    unsigned golfed = golfed_adler32(str, len);

    printf("%s: c:%u asm:%u\n", str, reference, golfed);
    assert(reference == golfed);
}

// main() to call test_adler() unchanged from my amd64 answer, except that the comments about length limits don't apply
</code></pre>
</div>
<div id="pu14" class="pu"><h2>Python 2, <s>60</s> 58 bytes</h2>

<pre class="lang-py prettyprint-override"><code>H=h=65521
l=1
for n in input():l+=n;h+=l
print h%H&lt;&lt;16|l%H
</code></pre>

<p>A pretty straightforward approach. This is a full program which takes a list of integers via STDIN, e.g. <code>[72, 105, 33]</code>.</p>

<p><em>(Thanks to @xnor for the amazing aliasing/initialisation tip)</em></p>
</div>
<div id="pu15" class="pu"><h2>Scala, 94 Bytes</h2>

<pre><code>(s:String)=&gt;{
val t=((1L,0L)/:s){(r,c)=&gt;val a=(c+r._1)%65521
(a,(a+r._2)%65521)};t._1+(t._2&lt;&lt;16)
}
</code></pre>

<p>Performs Adler-32 Checksum on Strings, using the alternate for foldLeft, /:</p>
</div>
<div id="pu16" class="pu"><h1>Python 3.5, 82 bytes:</h1>
<p>(<em>-1 byte thanks to <a href="https://codegolf.stackexchange.com/users/17602/neil">Neil</a>!</em>)</p>
<p>(<em>-1 byte thanks to <a href="https://codegolf.stackexchange.com/users/36885/mathmandan">mathmandan</a>!</em>)</p>
<p>(<em>-4 bytes thanks to <a href="https://codegolf.stackexchange.com/users/12012/dennis">Dennis</a>!</em>)</p>
<pre><code>lambda w:((1+sum(w))%65521)+4**8*(sum(1+sum(w[:i+1])for i in range(len(w)))%65521)
</code></pre>
<p>An anonymous <code>lambda</code> function. Accepts a byte array, applies the entire algorithm to the array, and outputs the result. Has successfully worked for all the test cases. You call this by assigning a variable to it, and then calling that variable just like you would call a normal function. If you are using the shell, then this should output without a print function. However, if you are not, then you must wrap the function call in the <code>print()</code> function to actually see the output.</p>
<p><a href="http://ideone.com/sQ0UFd" rel="nofollow noreferrer">Try it online! (Ideone)</a></p>
</div>
<div id="pu17" class="pu"><h2>JavaScript (ES7), <s>52</s> 50 bytes</h2>

<pre><code>a=&gt;a.map(b=&gt;h+=l+=b,h=0,l=1)&amp;&amp;l%65521+h%65521*4**8
</code></pre>

<p>ES6 takes 51 bytes (replace 4**8 with 65536). If you want a string version, then for 69 bytes:</p>

<pre><code>s=&gt;[...s].map(c=&gt;h+=l+=c.charCodeAt(),h=0,l=1)&amp;&amp;l%65521+h%65521*65536
</code></pre>

<p>Edit: Saved 2 bytes thanks to @user81655.</p>
</div>
<div id="pu18" class="pu"><h2>Haskell, <s>54</s> 50 bytes</h2>

<pre><code>m=(`mod`65521).sum
g x=m(-1:scanl(+)1x)*4^8+m(1:x)
</code></pre>

<p>Usage example: <code>g [69,97,103,108,101,115,32,97,114,101,32,103,114,101,97,116,33]</code>-> <code>918816254</code>.</p>

<p><code>scanl</code> includes the starting value (-> <code>1</code>) in the list (-> <code>[1,1+b1,1+b1+b2,..]</code>), so the <code>sum</code> is off by <code>1</code>, which is fixed by prepending <code>-1</code> to the list before summing.   </p>

<p>Edit: Thanks @xnor for 4 bytes.</p>
</div>
<div id="pu19" class="pu"><h1>TMP, 55 bytes</h1>

<p><code>3a1.3b0.1;4+a&gt;T8%a&gt;xFFF14+b&gt;a8%b&gt;xFFF11~5&lt;b&gt;164|b&gt;a2$b$</code></p>

<p>Implementation in Lua can be found here: <a href="http://preview.ccode.gq/projects/TMP.lua" rel="nofollow">http://preview.ccode.gq/projects/TMP.lua</a></p>
</div>
<div id="pu20" class="pu"><h1>Octave, <s>52</s> 50 bytes</h1>
<p>Saved 2 bytes thanks to @LuisMendo</p>
<pre><code>@(B)mod([sum(S=cumsum(B)+1),S(end)],65521)*[4^8;1]
</code></pre>
<p>Takes an array of integers as input.</p>
<p><strong>low</strong> is taken from the last element of <strong>high</strong> (before summing) rather than calculating the sum explicitly, saving a grand total of... <strong>1 byte</strong>!</p>
<p>Sample run on <a href="http://ideone.com/CAjSTm" rel="nofollow noreferrer">ideone</a>.</p>
</div>
<div id="pu21" class="pu"><h1>Scheme, 195 bytes</h1>

<pre><code>(define(a b)(+(let L((b b)(s 1))(if(=(length b)0)s(L(cdr b)(modulo(+ s(car b))65521))))(* 65536(let H((b b)(s 1)(t 0))(if(=(length b)0)t(let((S(+ s(car b))))(H(cdr b)S(modulo(+ t S)65521))))))))
</code></pre>

<p>If it weren't for all those parentheses... </p>
</div>
<div id="pu22" class="pu"><h3>Javascript (130 Characters Golfed)</h3>
<h2>Ungolfed</h2>
<pre><code>function a(b)
{
    c=1
    for(i=0;i&lt;b.length;i++)
    {
        c+=b[i]
    }
    d=c%65521
    f=&quot;&quot;
    e=0
    k=&quot;&quot;
    for(j=0;j&lt;b.length;j++)
    {
        k+= &quot;+&quot;+b[j]
        f+= &quot;(1&quot;+k+&quot;)&quot;
        e= ((eval(f)))
        if(j!=b.length-1){f+=&quot;+&quot;}
    }
    g=e%65521
    h=d+65536*g
    console.log(h)
}
</code></pre>
<h2>Golfed</h2>
<pre><code>a=b=&gt;{for(c=1,k=f=&quot;&quot;,y=b.length,i=0;i&lt;y;i++)c+=x=b[i],f+=&quot;(1&quot;+(k+=&quot;+&quot;+x)+&quot;)&quot;,i&lt;y-1&amp;&amp;(f+=&quot;+&quot;);return z=65521,c%z+65536*(eval(f)%z)}
</code></pre>
<p>Paste into Developers Console and then give it an Array of Bytes
EG:</p>
<h2></h2>
<pre><code>[69, 97, 103, 108, 101, 115, 32, 97, 114, 101, 32, 103, 114, 101, 97, 116, 33]
</code></pre>
<p>And it will return the checksum to the console</p>
</div>
<div id="pu23" class="pu"><h1>Python 3 (79 bytes)</h1>

<p>Based on R. Kap's solution.</p>

<pre><code>lambda w,E=65521:(1+sum(w))%E+(sum(1+sum(w[:i+1])for i in range(len(w)))%E&lt;&lt;16)
</code></pre>

<p>I replaced the multiplication by a shift and removed a pair of brackets. </p>

<p>Because I can't post comments I made a new answer. </p>
</div>
<div id="pu24" class="pu"><h2><a href="https://github.com/mbuettner/labyrinth" rel="nofollow">Labyrinth</a>, <s>37</s> <s>36</s> <s>32</s> 31 bytes</h2>

<pre><code>}?"{655:}21:}%=}){%{{36*+!
:++)
</code></pre>

<p><a href="http://labyrinth.tryitonline.net/#code=fT8iezY1NTp9MjE6fSU9fSl7JXt7MzYqKyEKOisrKQ&amp;input=NjkgOTcgMTAzIDEwOCAxMDEgMTE1IDMyIDk3IDExNCAxMDEgMzIgMTAzIDExNCAxMDEgOTcgMTE2IDMz" rel="nofollow">Try it online!</a></p>

<p>Input as a list of integers. The program terminates with an error (whose error message goes to STDERR).</p>

<h3>Explanation</h3>

<p>Labyrinth primer:</p>

<ul>
<li>Labyrinth has two stacks of arbitrary-precision integers, <em>main</em> and <em>aux</em>(iliary), which are initially filled with an (implicit) infinite amount of zeros.</li>
<li>The source code resembles a maze, where the instruction pointer (IP) follows corridors when it can (even around corners). The code starts at the first valid character in reading order, i.e. in the top left corner in this case. When the IP comes to any form of junction (i.e. several adjacent cells in addition to the one it came from), it will pick a direction based on the top of the main stack. The basic rules are: turn left when negative, keep going ahead when zero, turn right when positive. And when one of these is not possible because there's a wall, then the IP will take the opposite direction. The IP also turns around when hitting dead ends.</li>
<li>Digits are processed by multiplying the top of the main stack by 10 and then adding the digit. To start a new number, you can push a zero with <code>_</code>.</li>
</ul>

<p>Although the code starts with a 4x2 "room", that is actually two separate two-by-two loops squeezed together. The IP just happens to stick to one loop at a time due to the stack values. </p>

<p>So the code starts with a 2x2 (clockwise) loop which reads input while computing prefix sums:</p>

<pre><code>}   Move last prefix sum over to aux.
?   Read an integer from STDIN or push 0 on EOF, which exits the loop.
+   Add current value to prefix sum.
:   Duplicate this prefix sum.
</code></pre>

<p>Now we've got all the prefix sums on the <em>aux</em> stack, as well as a copy of the sum over all values and the <code>0</code> from EOF on <em>main</em>. With that, we enter another 2x2 (clockwise) loop which sums all the prefix sums to compute <code>HIGH</code>.</p>

<pre><code>"   No-op. Does nothing.
{   Pull one prefix sum over from aux. When we're done, this fetches a 0,
    which exits the loop.
)   Increment prefix sum.
+   Add it to HIGH.
</code></pre>

<p>The main stack now has <code>LOW - 1</code> and <code>HIGH</code> and zero, except we haven't taken the modulo yet. The remainder of the code is completely linear:</p>

<pre><code>655      Turn the zero into 655.
:}       Make a copy and shift it over to aux.
21       Turn the copy on main into 65521.
:}       Make a copy and shift it over to aux.
%        Take HIGH mod 65521.
=        Swap HIGH with the other copy of 65521 on aux.
}){      Move 65521 back to aux, increment LOW-1 to LOW, 
         move 65521 back to main.
%        Take LOW mod 65521.
{        Move HIGH back to main.
{        Move the other copy of 655 back to main.
36       Turn it into 65536.
*        Multiply HIGH by that.
+        Add it to LOW.
!        Print it.
</code></pre>

<p>The IP now hits a dead end and turns around. The <code>+</code> and <code>*</code> are essentially no-ops, due to the zeros at the stack bottom. The <code>36</code> now turns the top of <em>main</em> into <code>63</code>, but the two <code>{{</code> pull two zeros from <em>aux</em> on top of it. Then <code>%</code> tries to divide by zero which terminates the program.</p>

<p>Note that Labyrinth uses arbitrary-precision integers so deferring the modulo until the end of the sum won't cause problems with integer overflow.</p>
</div>
<div id="pu25" class="pu"><h1>Pyth, <s>25</s> <s>24</s> 23 bytes</h1>
<p><em>1 byte thanks to <a href="https://codegolf.stackexchange.com/users/29577/jakube">@Jakube</a>.</em></p>
<p><em>1 more byte thanks to <a href="https://codegolf.stackexchange.com/users/29577/jakube">@Jakube</a>.</em></p>
<pre><code>i%R65521sMeBhMsM._Q^4 8
</code></pre>
<p><a href="http://pyth.herokuapp.com/?code=i%25R65521sMeBmhsd._Q%5E4+8&amp;input=%5B80%2C+114%2C+111%2C+103%2C+114%2C+97%2C+109%2C+109%2C+105%2C+110%2C+103%2C+32%2C+80%2C+117%2C+122%2C+122%2C+108%2C+101%2C+115%2C+32%2C+38%2C+32%2C+67%2C+111%2C+100%2C+101%2C+32%2C+71%2C+111%2C+108%2C+102%5D&amp;debug=0" rel="nofollow noreferrer">Try it online!</a></p>
<p>Translation of my <a href="https://codegolf.stackexchange.com/a/78898/48934">answer in Jelly</a>.</p>
</div>
<div id="pu26" class="pu"><h1>J, 30 bytes</h1>

<pre><code>+/(+65536&amp;*)&amp;(65521|+/)&amp;:&gt;:+/\
</code></pre>

<p>This could probably be condensed more with a different train.</p>

<h2>Usage</h2>

<p>Here <code>x $ y</code> creates a list with <code>x</code> copies of <code>y</code>.</p>

<pre><code>   f =: +/(+65536&amp;*)&amp;(65521|+/)&amp;:&gt;:+/\
   f 69 97 103 108 101 115 32 97 114 101 32 103 114 101 97 116 33
918816254
   f 80 114 111 103 114 97 109 109 105 110 103 32 80 117 122 122 108 101 115 32 38 32 67 111 100 101 32 71 111 108 102
3133147946
   f (32 $ 126)
68095937
   f (1040 $ 63)
2181038080
   f (4096 $ 255)
2170679522
</code></pre>

<h2>Explanation</h2>

<pre><code>+/(+65536&amp;*)&amp;(65521|+/)&amp;:&gt;:+/\
f (           g           ) h     Monad train (f g h) y = (f y) g (h y)
+/                                Sum the input list
                           +/\    Sum each prefix of the input, forms a list
x     f   &amp;   g   &amp;:   h    y     Composed verbs, makes (g (h x)) f (g (h y))
                         &gt;:       Increment the sum and increment each prefix sum
               (m f g) y          Hook, makes m f (g y)
                    +/            Sum the prefix sums
              65521|              Take the sum and prefix total mod 65521
    (f g) y                       Hook again
    65536&amp;*                       Multiply the prefix total by 65536
                                  This is a bonded verb, it will only multiply
                                  using a fixed value now
   +                              Add the sum and scaled prefix total
</code></pre>
</div>
<div id="pu27" class="pu"><h1>Clojure, 109 bytes</h1>

<p>Based on @Mark Adler's <a href="https://codegolf.stackexchange.com/questions/78896/compute-the-adler-32-checksum/78901#78901">solution</a>.</p>

<pre><code>(fn f[s](-&gt;&gt; s(reduce #(mapv + %(repeat %2)[0(first %)])[1 0])(map #(rem % 65521))(map *[1 65536])(apply +)))
</code></pre>

<h3>Ungolfed</h3>

<pre><code>(fn f [s]
  (-&gt;&gt; s
       (reduce #(mapv + % (repeat %2) [0 (first %)]) [1 0])
       (map #(rem % 65521))
       (map * [1 65536])
       (apply +)))
</code></pre>

<h2>Usage</h2>

<pre><code>=&gt; (def f (fn f[s](-&gt;&gt; s(reduce #(mapv + %(repeat %2)[0(first %)])[1 0])(map #(rem % 65521))(map *[1 65536])(apply +))))
=&gt; (f [69 97 103 108 101 115 32 97 114 101 32 103 114 101 97 116 33])
918816254
=&gt; (f [80 114 111 103 114 97 109 109 105 110 103 32 80 117 122 122 108 101 115 32 38 32 67 111 100 101 32 71 111 108 102])
3133147946
=&gt; (f (repeat 32 126))
68095937
=&gt; (f (repeat 1040 63))
2181038080
=&gt; (f (repeat 4096 255))
2170679522
</code></pre>
</div>
<div id="pu28" class="pu"><h1>Ruby, 91 bytes</h1>
<pre><code>-&gt;s{b=s.bytes;z=i=b.size
b.inject(1,:+)%65521+b.map{|e|e*(1+i-=1)}.inject(z,:+)%65521*4**8}
</code></pre>
</div>
<div id="pu29" class="pu"><h1><a href="http://perl6.org" rel="nofollow">Perl 6</a>, 60 bytes</h1>



<pre class="lang-perl6 prettyprint-override"><code>{(.sum+1)%65521+65536*((sum(1,*+.shift...-&gt;{!$_})-1)%65521)}
</code></pre>

<h3>Explanation:</h3>

<pre class="lang-perl6 prettyprint-override"><code>{
  # $_ is the implicit parameter for this lambda because this block doesn't have
  # an explicit parameter, and @_ isn't seen inside of it.
  # ( @_ takes precedence over $_ when it is seen by the compiler )

  # .sum is short for $_.sum
  ( .sum + 1 ) % 65521 + 65536
  *
  (
    (
      sum(

        # generate a sequence:

        1,         # starting with 1
        * + .shift # lambda that adds previous result (*) with $_.shift
        ...        # generate until:
        -&gt; { !$_ } # $_ is empty

        # ^ I used a pointy block with zero parameters
        # so that the block doesn't have an implicit parameter
        # like the surrounding block

        # this is so that $_ refers to the outer $_

      ) - 1        # remove starting value
    ) % 65521
  )
}
</code></pre>

<h3>Test:</h3>

<pre class="lang-perl6 prettyprint-override"><code>#! /usr/bin/env perl6
use v6.c;
use Test;

# give the lambda a name
my &amp;Adler32 = {(.sum+1)%65521+65536*((sum(1,*+.shift...-&gt;{!$_})-1)%65521)}

my @tests = (
  (  918816254,  'Eagles are great!'),
  ( 3133147946,  'Programming Puzzles &amp; Code Golf'),
  (   68095937,  '~' x 32,     "'~' x 32"),
  ( 2181038080,  63 xx 1040,   "'?' x 1040"),
);

plan +@tests;

for @tests -&gt; ($checksum, $input, $gist? ) {
  my @array := do given $input {
    when Str { .encode.Array }
    default { .Array }
  }

  is Adler32(@array), $checksum, $gist // $input.perl
}
</code></pre>

<pre class="lang-none prettyprint-override"><code>1..4
ok 1 - "Eagles are great!"
ok 2 - "Programming Puzzles \&amp; Code Golf"
ok 3 - '~' x 32
ok 4 - '?' x 1040
</code></pre>
</div>
<div id="pu30" class="pu"><h1>Factor, <s>112</s> <s>109</s> 103 bytes</h1>

<p><strong>Now</strong>, this is a literal translation of the algorithm in the question... now that I actually made it, y'know, correct.</p>

<pre><code>[ [ sum 1 + ] [ [ dup length [1,b] reverse v. ] [ length ] bi + ] bi [ 65521 mod ] bi@ 16 shift bitor ]
</code></pre>

<p>Ungolfed:</p>

<pre><code>: adler-32 ( seq -- n )
  [ sum 1 + ] 
  [ 
    [ dup length [1,b] reverse v. ] 
    [ length ] bi + 
  ] bi 
  [ 65521 mod ] bi@ 
  16 shift bitor 
  ;
</code></pre>

<p>Expects any sequence of numbers or a string (not much difference, though they aren't technically the same).</p>

<p>I don't know how this will perform for the given limit on a version of Factor compiled with 32-bit word-size, but on my 6GB 64-bit 2.2GHz machine:</p>

<pre><code>IN: scratchpad 1040 63 &lt;array&gt;

--- Data stack:
{ 63 63 63 63 63 63 63 63 63 63 63 63 63 63 ~1026 more~ }
IN: scratchpad [ adler-32 ] time
Running time: 7.326900000000001e-05 seconds

--- Data stack:
2181038080
IN: scratchpad 10,000 63 &lt;array&gt; 

--- Data stack:
2181038080
{ 63 63 63 63 63 63 63 63 63 63 63 63 63 63 ~9986 more~ }
IN: scratchpad [ adler-32 ] time
Running time: 0.000531669 seconds
</code></pre>
</div>
<div id="pu31" class="pu"><h2>CJam, <s>30</s> 29 bytes</h2>

<pre><code>q~{1$+}*]:)_W&gt;]1fb65521f%2G#b
</code></pre>

<p>Input as a list of integers.</p>

<p><a href="http://cjam.aditsu.net/#code=q~%7B1%24%2B%7D*%5D%3A)_W%3E%5D1fb65521f%252G%23b&amp;input=%5B69%2097%20103%20108%20101%20115%2032%2097%20114%20101%2032%20103%20114%20101%2097%20116%2033%5D" rel="nofollow">Test it here.</a></p>

<h3>Explanation</h3>

<pre><code>q~       e# Read and evaluate input.
{        e# Fold this block over the list, computing prefix sums.
  1$+    e#   Copy the last prefix and add the current element.
}*
]        e# Wrap the prefix sums in an array.
:)       e# Increment each. This will sum to HIGH.
_W&gt;      e# Copy the list and truncate to only the last element, i.e.
         e# the sum of the entire input plus 1. This is LOW.
]        e# Wrap both of those lists in an array.
1fb      e# Sum each, by treating it as base 1 digits.
65521f%  e# Take each modulo 65521.
2G#b     e# Treat the list as base 65536 digits, computing 65536*HIGH + LOW.
</code></pre>
</div>
<div id="pu32" class="pu"><h1><a href="https://github.com/lmendo/MATL" rel="noreferrer">MATL</a>, 22 bytes</h1>
<pre><code>tsQwYsQsh16W15-\l8Mh*s
</code></pre>
<p>Input can be an array of numbers or the corresponding ASCII string.</p>
<p><a href="http://matl.tryitonline.net/#code=dHNRd1lzUXNoMTZXMTUtXGw4TWgqcw&amp;input=J35-fn5-fn5-fn5-fn5-fn5-fn5-fn5-fn5-fn5-fn5-Jw" rel="noreferrer"><strong>Try it online!</strong></a></p>
<h3>Explanation</h3>
<pre><code>t       % Take array or string as input. Duplicate
sQ      % Sum all its values, and add 1
wYsQs   % Swap. Cumulative sum, add 1, sum
h       % Concatenate horizontally
16W     % 2^16: gives 65536
15-     % Subtract 15: gives 65521
\       % Element-wise modulo operation
l       % Push 1
8M      % Push 65536 again
h       % Concatenate horizontally: gives array [1, 65535]
*s      % Element-wise multiplication and sum. Display
</code></pre>
</div>
<div id="pu33" class="pu"><h1>Java, 84 bytes</h1>

<pre><code>long a(int[]i){long a=1,b=0;for(int p:i)b=(b+(a=(a+p)%(p=65521)))%p;return b&lt;&lt;16|a;}
</code></pre>

<p>If Java solutions are always supposed to be complete compilable code please let me know.</p>

<h3>Ungolfed</h3>

<pre><code>long a(int[] i) {
    long a = 1, b = 0;
    for (int p : i) b = (b + (a = (a + p) % (p = 65521))) % p;
    return b &lt;&lt; 16 | a;
}
</code></pre>

<h3>Note</h3>

<p>You will have to convert the input <code>String</code> to <code>int[]</code> (<code>int[]</code> is one byte shorter than <code>byte[]</code> or <code>char[]</code>).</p>

<h3>Output</h3>

<pre><code>String:     "Eagles are great!"
Byte Array: [69, 97, 103, 108, 101, 115, 32, 97, 114, 101, 32, 103, 114, 101, 97, 116, 33]
Checksum:   918816254
Expected:   918816254

String:     "Programming Puzzles &amp; Code Golf"
Byte Array: [80, 114, 111, 103, 114, 97, 109, 109, 105, 110, 103, 32, 80, 117, 122, 122, 108, 101, 115, 32, 38, 32, 67, 111, 100, 101, 32, 71, 111, 108, 102]
Checksum:   3133147946
Expected:   3133147946

String:     "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
Byte Array: [126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126]
Checksum:   68095937
Expected:   68095937

String:     "?????????...?"
Byte Array: [63, 63, 63, 63, 63, 63, 63, 63, 63, ...,63]
Checksum:   2181038080
Expected:   2181038080
</code></pre>
</div>
<div id="pu34" class="pu"><h1>Jelly, <s>19</s> 17 bytes</h1>
<pre><code>+\,S‘S€%65521ḅ⁹²¤
</code></pre>
<p><a href="http://jelly.tryitonline.net/#code=K1wsU-KAmFPigqwlNjU1MjHhuIU2NTUzNg&amp;input=&amp;args=WzgwLCAxMTQsIDExMSwgMTAzLCAxMTQsIDk3LCAxMDksIDEwOSwgMTA1LCAxMTAsIDEwMywgMzIsIDgwLCAxMTcsIDEyMiwgMTIyLCAxMDgsIDEwMSwgMTE1LCAzMiwgMzgsIDMyLCA2NywgMTExLCAxMDAsIDEwMSwgMzIsIDcxLCAxMTEsIDEwOCwgMTAyXQ" rel="nofollow noreferrer">Try it online!</a></p>
<pre><code>+\,S‘S€%65521ḅ⁹²¤    Main monadic chain. Takes array as only argument.

                     The array is shown here as [b1 b2 ... bn].
+\                   Reduce by addition (+) while returning immediate results.
                         yields [b1 b1+b2 ... b1+b2+...+bn].

  ,                  Concatenate with...
   S                 the sum of the argument.
                         yields [[b1 b1+b2 ... b1+b2+...+bn] b1+b2+...+bn].

    ‘                Increment [each].
                         yields [[1+b1 1+b1+b2 ... 1+b1+b2+...+bn] 1+b1+b2+...+bn].

     S€              Sum each list.
                         yields [[1+b1+1+b1+b2+...+1+b1+b2+...+bn] 1+b1+b2+...+bn].

       %65521        Modulo [each] by 65521.

             ḅ⁹²¤    Convert from base    65536    to integer.
              ⁹                        256
               ²                           squared
</code></pre>
</div>
<div id="pu35" class="pu"><h1>Mathematica, 46 bytes</h1>

<pre><code>{1,4^8}.Fold[##+{0,#&amp;@@#}&amp;,{1,0},#]~Mod~65521&amp;
</code></pre>

<p>An anonymous function that takes an integer array and returns the Adler-32, with some improvements from miles and Martin (see comments).</p>

<p>miles' is also <strong>46 bytes</strong>, but faster:</p>

<pre><code>{1,4^8}.{Tr@#+1,Tr[Accumulate@#+1]}~Mod~65521&amp;
</code></pre>
</div>
<div id="pu36" class="pu"><h1>C89, 70 bytes</h1>
<pre><code>h,l,m=65521;A(char*B){h=0;l=1;while(*B)h+=l+=*B++;return h%m&lt;&lt;16|l%m;}
</code></pre>
<p>To test (compile with <code>gcc -std=c89 -lm golf.c</code>):</p>
<pre><code>#include &lt;stdio.h&gt;
int main(int argc, char** argv) {
    printf(&quot;%u\n&quot;, A(&quot;Eagles are great!&quot;));
    printf(&quot;%u\n&quot;, A(&quot;Programming Puzzles &amp; Code Golf&quot;));
    printf(&quot;%u\n&quot;, A(&quot;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&quot;));
    return 0;
}
</code></pre>
</div>
<div id="pu37" class="pu"><h2>Actually, 36 bytes</h2>
<pre><code>;Σu@;╗lR`╜HΣu`MΣk`:65521@%`M1#84ⁿ@q*
</code></pre>
<p><a href="http://actually.tryitonline.net/#code=O86jdUA74pWXbFJg4pWcSM6jdWBNzqNrYDo2NTUyMUAlYE0xIzg04oG_QHEq&amp;input=WzY5LCA5NywgMTAzLCAxMDgsIDEwMSwgMTE1LCAzMiwgOTcsIDExNCwgMTAxLCAzMiwgMTAzLCAxMTQsIDEwMSwgOTcsIDExNiwgMzNd" rel="noreferrer">Try it online!</a></p>
<p>Explanation:</p>
<pre><code>;Σu@;╗lR`╜HΣu`MΣk`:65521@%`M1#84ⁿ@q*
;Σu                                   sum(input)+1
   @;╗lR                              push a copy of input to reg0, push range(1, len(input)+1)
        `╜HΣu`M                       map over range: sum(head(reg0,n))+1
               Σk                     sum, combine lower and upper into a list
                 `:65521@%`M          modulo each by 65521
                            1#84ⁿ@q*  dot product with [1,4**8]
</code></pre>
</div>
<div id="pu38" class="pu"><h1>Julia, <s>73</s> 46 bytes</h1>



<pre class="lang-default prettyprint-override"><code>x-&gt;[sum(x)+1;sum(cumsum(x)+1)]%65521⋅[1;4^8]
</code></pre>

<p>This is an anonymous function that accepts an array and returns an integer. To call it, assign it to a variable.</p>

<p>We combine <code>sum(x) + 1</code> and <code>sum(cumsum(x) + 1)</code> into an array, where <code>x</code> is the input array, and take each modulo 65521. We then compute the dot product with 1 and 4<sup>8</sup>, which gives us <code>(sum(x) + 1) + 4^8 * sum(cumsum(x) + 1)</code>, which is exactly the Adler-32 formula.</p>

<p><a href="http://julia.tryitonline.net/#code=Zj14LT5bc3VtKHgpKzE7c3VtKGN1bXN1bSh4KSsxKV0lNjU1MjHii4VbMTs0XjhdCgpmb3IgY2FzZSBpbiBbKCJFYWdsZXMgYXJlIGdyZWF0ISIsIDkxODgxNjI1NCksCiAgICAgICAgICAgICAoIlByb2dyYW1taW5nIFB1enpsZXMgJiBDb2RlIEdvbGYiLCAzMTMzMTQ3OTQ2KSwKICAgICAgICAgICAgICgifn5-fn5-fn5-fn5-fn5-fn5-fn5-fn5-fn5-fn5-fn4iLCA2ODA5NTkzNyksCiAgICAgICAgICAgICAoIj8iXjEwNDAsIDIxODEwMzgwODApXQogICAgYSA9IG1hcChJbnQsIFtjYXNlWzFdLi4uXSkKICAgIHByaW50bG4oZihhKSA9PSBjYXNlWzJdKQplbmQ&amp;input=">Try it online!</a> (Includes all test cases)</p>

<p>Saved 27 bytes thanks to Sp3000 and Dennis!</p>
</div>
<!-- TYYY -->

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/QNNN/">QNNN</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




