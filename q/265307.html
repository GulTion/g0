<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::265307</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>020</td><td>Retina 0.8.2</td><td>230919T001903Z</td><td><a href="https://codegolf.stackexchange.com/questions/265307/play-a-game-of-memory/265357#265357">Neil</a></td></tr>
<tr d-ix="1"><td>108</td><td>sed</td><td>230919T052857Z</td><td><a href="https://codegolf.stackexchange.com/questions/265307/play-a-game-of-memory/265363#265363">Philippo</a></td></tr>
<tr d-ix="2"><td>010</td><td>Jelly</td><td>230918T235229Z</td><td><a href="https://codegolf.stackexchange.com/questions/265307/play-a-game-of-memory/265354#265354">Unrelate</a></td></tr>
<tr d-ix="3"><td>035</td><td>J</td><td>230918T230834Z</td><td><a href="https://codegolf.stackexchange.com/questions/265307/play-a-game-of-memory/265353#265353">Jonah</a></td></tr>
<tr d-ix="4"><td>141</td><td>R 4.1</td><td>230918T164439Z</td><td><a href="https://codegolf.stackexchange.com/questions/265307/play-a-game-of-memory/265340#265340">Evargalo</a></td></tr>
<tr d-ix="5"><td>126</td><td>Python3</td><td>230918T120945Z</td><td><a href="https://codegolf.stackexchange.com/questions/265307/play-a-game-of-memory/265333#265333">Ajax1234</a></td></tr>
<tr d-ix="6"><td>025</td><td>Charcoal</td><td>230918T092610Z</td><td><a href="https://codegolf.stackexchange.com/questions/265307/play-a-game-of-memory/265324#265324">Neil</a></td></tr>
<tr d-ix="7"><td>057</td><td>JavaScript Node.js</td><td>230918T053636Z</td><td><a href="https://codegolf.stackexchange.com/questions/265307/play-a-game-of-memory/265308#265308">tsh</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://github.com/m-ender/retina/wiki/The-Language/a950ad7d925ec9316e3e2fb2cf5d49fd15d23e3d" rel="nofollow noreferrer">Retina 0.8.2</a>, <s>25</s> 20 bytes</h1>
<pre><code>(.)(?&lt;!\1..+)
1
11|.
</code></pre>
<p><a href="https://tio.run/##Dcy7DsIgFADQ/f6FgwmNCQm7iaM/4eCFAgX6glJe8d@xw1lPkNGs2O/k/e2EDuT1vH0YpY8BGDD2o70jAiLncEHQ2lhnnAXvc5YyhBhB8CJK4ogJWi0t11RShsgNuljTWsQZRJt1XiY7n5vfvdPHng9lRiXH0JapSlyvYLOAqmEpTf0B" rel="nofollow noreferrer" title="Retina 0.8.2 – Try It Online">Try it online!</a> Link includes test cases. Explanation: Port of @UnrelatedString's Jelly answer, as I don't see how it works, let alone ports @Jonah's J answer.</p>
<pre><code>(.)(?&lt;!\1..+)
1
</code></pre>
<p>Replace the first character of each pair with a <code>1</code>, but also the second if it's adjacent.</p>
<pre><code>11|.
</code></pre>
<p>Subtract the number of pairs of <code>1</code>s from the length of the string.</p>
<p>Would be <code>22</code> bytes as a one-liner: <code>((.)(?&lt;!\2..+)){1,2}|.</code></p>
</div>
<div id="pu1" class="pu"><h1><a href="https://www.gnu.org/software/sed/" rel="nofollow noreferrer">sed</a>, 108 bytes</h1>
<p>I insert an underscore <code>_</code> as marker up to where cards are known, then do backreference replacements for all possible cases. For each turn, <code>H</code> appends the pattern to the hold space, so in the end I output the number of turns as <code>+</code>:</p>
<pre><code>s/^/_/
t2
:1
H
:2
s/(.)(.*)\1(.*)_/\2\3_/
t1
s/_(.)\1/_/
t1
s/(.)(.*_)\1/\2/
t1
s/_(..)/\1_/
t1
x
s/.\S*/+/g
</code></pre>
<p>The <code>t2</code> at the beginning looks avoidable, but is needed to reset the <code>t</code> trigger after the first replacement.</p>
<p><a href="https://tio.run/##RYrBCoMwEAXv@yXGYh6b3rwXvHtdGtQW6UWFqOTr3SaIeHnwZiZ8P9U4baoBb3jQ6qhmaqh2FFBYU9jSCOf1ECfPnHBSPjlhXPcsfUbi7sQaCJ9NTMRKW@KBUXXo4xD3vuv2Y17W3zwFrV5/" rel="nofollow noreferrer" title="sed – Try It Online">Try it online!</a></p>
</div>
<div id="pu2" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="nofollow noreferrer">Jelly</a>, 10 bytes</h1>
<pre><code>ṪfṖƊƤŒɠHĊS
</code></pre>
<p><a href="https://tio.run/##DcwpEsIwFABQn5PhUcifNEmzdEmaZpMYZioRaASKQWI6SKAzHKNcJCCefZJqnUpZ5ytb59MyLZf38XPevKZtWR/35@G7v@1KAUAAGKM/QJwLqYSSyJgQKLXWOURwJNFjAI9yijkkH31ADgtQLvk2ktGSrHloaqnHzvRG8aEPAxMVo5XNTZ0otP@gkwhYhhgz@wE" rel="nofollow noreferrer" title="Jelly – Try It Online">Try it online!</a></p>
<p>This alternate solution kinda grew alongside the one preserved below, for what it's worth. Ultimately derived from <a href="https://codegolf.stackexchange.com/a/265353/85334">Jonah's description of his J solution</a>, but whatever the actual code does I strongly suspect it isn't this.</p>
<pre><code>   ƊƤ         For every prefix:
Ṫ             Pop the last element
 f            and filter it by membership in
  Ṗ           all but the last remaining (after the pop!) elements.
     Œɠ       Take the lengths of all runs of consecutive equal results,
       H      halve
        Ċ     and ceiling them,
         S    and sum.
</code></pre>
<h1><a href="https://github.com/DennisMitchell/jelly" rel="nofollow noreferrer">Jelly</a>, <s>16</s> <s>13</s> <s>12</s> 11 bytes</h1>
<pre><code>ṪeṖƊƤœṣØ0KL
</code></pre>
<p><a href="https://tio.run/##Dcw7DsIgGADgndN4D72A4w8FyqMPaMtrdDFxNTHuOhlHl8axsffAi6DDt36Sah1LyfOD5vmyntb755zn23LdbHclv1/L8Xt47ksBQAAYoz9AnAuphJLIGO8ptXYcEcGBBIcBHEoxJB9dcB6NWIAao2sDmSxJmvumlnrqTG8UH3o/MFExWtnU1JFC@w86iYAlCCGxHw" rel="nofollow noreferrer" title="Jelly – Try It Online">Try it online!</a></p>
<p><em>-1 kinda back-porting <a href="https://codegolf.stackexchange.com/a/265357/85334">Neil's Retina solution</a> since I don't actually have a clue why Jonah's pointer starts at 2 to begin with</em></p>
<p><em>-1 doing it again</em></p>
<p>Vague port of Jonah's J algorithm.</p>
<pre><code>   ƊƤ          For each prefix:
Ṫ              Is the last element
 e             also found
Ṫ Ṗ            two or more indices earlier?
     œṣØ0      Split on all non-overlapping occurrences of the substring 0,0,
         K     join on spaces,
          L    and take the length of that result.
</code></pre>
</div>
<div id="pu3" class="pu"><h1><a href="https://www.jsoftware.com" rel="nofollow noreferrer">J</a>, 35 bytes</h1>
<pre><code>[:#(#@]&lt;.[+2-{.+./@e.~2{.}.)~^:a:&amp;2
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=Nc9Ba8IwFAfwu58irmyZuGaz28SGCcJgp512FQdJTNqmam1Nk7Qyv8gu3cGvJPhtJiQeHo_34897vN8_2Z1v4z4eLcZ9HEPYu0FQgCkGEDyAJ4AvFSLw_vX5cayVCCfnYI6D-2C2eEPzYRTu0RA9zjg6RHv0gwaHb0zwXeSjp0GPs7QAIzAFAkBCoJuj60ypl2cvlF4zYydJksk8y6XXV6dlaQznVaWU94lzRi2zmhKivcfO28a2ptFWG-8v_qCiGclVozeW1RVrV4lZp3JVF-W2zJPd1uxEthR8WbXrtOFkc9ldSOi-6zrX_wE" rel="nofollow noreferrer">Attempt This Online!</a></p>
<p>A bit chonky as far as J code goes, but imo a nice simplification of the algorithm:</p>
<ul>
<li><p>We imagine a pointer, starting at index 2, pointing into our string:</p>
<pre><code>ggijkikj
  ^
01234567
</code></pre>
</li>
<li><p>On each iteration, we increment the pointer by 2 as a default</p>
<ul>
<li>But: If the character at the pointer, or the character to the right of the pointer, exists within any of the previous characters (left of the pointer), we only increment by 1.</li>
</ul>
</li>
<li><p>We keep incrementing until the pointer exceeds the length of the string</p>
</li>
<li><p>Our answer is the number of iterations that process took</p>
</li>
</ul>
<p>This approach has the advantage of reducing the number of rules/cases down to just a single rule: increment by 2 or 1, depending on whether the next two characters have been seen.  This avoids special-casing the <code>aa</code> case, or distinguishing between &quot;1st character was already seen&quot; and &quot;2nd character was already seen&quot;.</p>
</div>
<div id="pu4" class="pu"><h1><a href="https://www.r-project.org/" rel="nofollow noreferrer">R</a> 4.1, 141 bytes</h1>

<pre class="lang-r prettyprint-override"><code>b=\(v,x){j=duplicated(v)
ifelse(is.na(v[3]),1,ifelse(j[x],1+b(v[v!=v[x]],x-1),ifelse(j[x+1],2+b(v[v!=v[x+1]],x)-(v[x]==v[x+1]),1+b(v,x+2))))}
</code></pre>
<p><a href="https://tio.run/##TVDbboQgFHz3L@oTRGzi9rV@ycYHRW1ZrVdE3abfbg8wbiSZzJnDcAaYjqNI66WTWvUdM2Ljv4@0XIZWyVxXJTM8UHXVzhVT83uXM3P/yLhIBJqP@5aJJCqob95SQyoTW5zwy36UZOJ2cZAmD4@ZdafocD9EbNGN0/o7hs9YsjAPBYEH40WJsHDgwfTqFoD1zq77RcpCER6EBnXjNA@0c42kLFagAiZAO/BgcW6JlI0gweaV7GHIbZz7SWqH64n5O06cJ1dyr86tMUdhToP080R3yV1wO4nJLd5qE34I33hzC2@PVw7gBv4ZvRV1jfwSdYV6Qs45e8defrnX@Q89/rdgg0gsjZ4mT7Mn7WnxZDytRMfxDw" rel="nofollow noreferrer" title="R – Try It Online">Try it online!</a></p>
<h4>Test:</h4>
<pre class="lang-r prettyprint-override"><code>w&lt;-c(&quot;t&quot;,&quot;b&quot;,&quot;i&quot;,&quot;a&quot;,&quot;k&quot;,&quot;t&quot;,&quot;y&quot;,&quot;v&quot;,&quot;n&quot;,&quot;x&quot;,&quot;c&quot;,&quot;u&quot;,&quot;r&quot;,&quot;c&quot;,&quot;z&quot;,&quot;l&quot;,&quot;g&quot;,&quot;w&quot;,&quot;m&quot;,&quot;h&quot;,&quot;j&quot;,&quot;l&quot;,&quot;u&quot;,&quot;o&quot;,&quot;q&quot;,&quot;p&quot;,&quot;q&quot;,&quot;k&quot;,&quot;g&quot;,&quot;s&quot;,&quot;p&quot;,&quot;w&quot;,&quot;s&quot;,&quot;f&quot;,&quot;i&quot;,&quot;d&quot;,&quot;f&quot;,&quot;e&quot;,&quot;d&quot;,&quot;r&quot;,&quot;z&quot;,&quot;m&quot;,&quot;h&quot;,&quot;y&quot;,&quot;e&quot;,&quot;a&quot;,&quot;n&quot;,&quot;x&quot;,&quot;v&quot;,&quot;b&quot;,&quot;o&quot;,&quot;j&quot;)

b(w,1)
</code></pre>
<blockquote>
<p>43</p>
</blockquote>
<h4>Brief explanation:</h4>
<p>b is a recursive function with input:</p>
<ul>
<li>v a vector of characters</li>
<li>x the position of the first unknown element of v</li>
</ul>
<p>It proceeds :</p>
<ul>
<li>If v[x] is duplicated we use one move to remove that pair, and we continue with a shorter vector and one less known element.</li>
<li>If v[x+1] is duplicated we use a second move to remove its pair (but if its twin is v[x]), and we continue with a shorter vector and as many known elements.</li>
<li>Otherwise we use one move to see two more elements.</li>
</ul>
</div>
<div id="pu5" class="pu"><h1>Python3, 126 bytes:</h1>
<pre class="lang-py prettyprint-override"><code>def f(a):
 s,c=[],0
 while a:
  if(v:=a.pop(0))in s:s={*s}-{v}
  else:s={*s,*[v,(K:=a.pop(0))]*(v!=K)}
  c+=1
 return c+len(s)
</code></pre>
<p><a href="https://tio.run/##ZY7BboQgFEX3fgVNFwPWNtN0MzHxC@YTjAtAUEYHERCQyXy71XQz1eU997y8q2bbDvLnovSy1IwDDjHKE2AyWpRVdk6Ab0XPAF4ZEBy6vMBfalDwjJCQwOSmeKTm@flwz1VgvWF/JEtLl8Hri12l0L0VV7R59KP4ToBmdtJyDT2T0KBFaSEt5LBMTxifKoSSf4SQAyPk4DWNuHWiu@35OHrPmNbW7htKAg2OYOy2Bryv0qBfhTiH6GcXnN@fWiJwZ2cnA500jX3j7@2tn4ZRjV1jlDdc1JzVOt7bmWG5fhkOwzCPOITIN778Ag" rel="nofollow noreferrer">Try it online!</a></p>
</div>
<div id="pu6" class="pu"><h1><a href="https://github.com/somebody1234/Charcoal" rel="nofollow noreferrer">Charcoal</a>, 25 bytes</h1>
<pre><code>ＦＬθＭ⊕×⊕﹪ⅈ²№…θ⁻ι﹪ⅈ²§θι→Ｉ⊘ⅈ
</code></pre>
<p><a href="https://tio.run/##VU27DsIwENv5io4XCRZGOqEuIFEJIQbWkFybQJpr86Ll50Ngw4NlWX4IxZ0gbnLuyFVwQtsHBRNjVUsJ4WiFwwFtQAlXPaD/c1qS0RDcgK2rLSvUULQBmkUYbBSNMK2rVtvoQRfxHy68D0crcf6mNPs5u4vuVWD16uz0d4j7AAduUvkqvYI653DX/BmWZGcRnXib/jWoh4k0jdOz9@PLd1p2KN17UAtyO6c7PfImmQ8" rel="nofollow noreferrer" title="Charcoal – Try It Online">Try it online!</a> Link is to verbose version of code. Explanation:</p>
<pre><code>ＦＬθ
</code></pre>
<p>Loop over the indices of the input.</p>
<pre><code>Ｍ⊕×⊕﹪ⅈ²№…θ⁻ι﹪ⅈ²§θι→
</code></pre>
<p>Calculate how many cards get turned as a result of this card. This is <code>1</code> for the card itself and then a possible further <code>1</code> or <code>2</code> if this card has been seen before depending on whether an even or odd number of cards have been turned so far, except in the odd case where the previous card is the one seen before.</p>
<pre><code>Ｉ⊘ⅈ
</code></pre>
<p>Output the number of turns (which is half of the number of cards turned).</p>
</div>
<div id="pu7" class="pu"><h1><a href="https://nodejs.org" rel="nofollow noreferrer">JavaScript (Node.js)</a>, 57 bytes</h1>

<pre class="lang-javascript prettyprint-override"><code>a=&gt;a.map(c=&gt;a[n+=!i|a[c]&amp;i!=c,i=i||a[c]?0:c,c]=1,i=n=0)|n
</code></pre>
<p><a href="https://tio.run/##TdDNcsIgEAfwO0@BlwrTyGhtO/0Y7KlPkWZGgiSSD0gIEpLaZ0@j0dY9/fc3u3vYjDnWcCMru1B6J4aEDoxuGClZhfgYQnVPZ/LIQh7dyRnlgaTyeG4/lm884BFdjaToEh/VYCGFW8AY/KvFYgNXo8TxrTyAEditrEGayiyXeXaVZ1DXbSuEMdZO8gR47Ll3MWNukhfQd75vO@ddO8krsLFkue2c8vxgeF@kbbnPioOuqzpPm6ptErlLxM705b4TTI3ndHZefVyDLbFGlgiTpiqkRfMvNcfnT3hIN9BfeZy@uDu5u2xh/A4sSbT5ZHyPUCgDKCJ8mvgGEHKtGl0IUugUCUgpTFBICJERDv4jBj94@AU" rel="nofollow noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a></p>
<p>We uncover cards from left to right and, for every next card <code>c</code>, with previous uncovered card in this turn <code>i</code>:</p>
<ul>
<li>Count an extra turn (<code>++n</code>) whenever:
<ul>
<li>This is the first card to uncover in this turn (<code>!i</code>): as a new turn;</li>
<li>This is the second card to uncover in this turn (<code>i</code>), AND the card just uncovered in the same turn does not equals to the current one (<code>i!=c</code>), AND the card just uncovered had already seen some time before (<code>a[c]</code>): as we need an extra turn to match these two cards;</li>
</ul>
</li>
<li>Leave this card uncovered for this turn (<code>i=c</code>) whenever:
<ul>
<li>This is the first card to uncover this turn (<code>!i</code>), AND this card is not ever seen before (<code>!a[c]</code>);</li>
</ul>
</li>
<li>Remember the card as a seen card (<code>a[c]=1</code>)</li>
</ul>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/265307/">265307</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




