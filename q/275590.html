<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::275590</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>406</td><td>JavaScript</td><td>240919T161621Z</td><td><a href="https://codegolf.stackexchange.com/questions/275590/play-the-final-fantasy-prelude/275646#275646">Jordan</a></td></tr>
<tr d-ix="1"><td>203</td><td>ZX Spectrum 48K Basic</td><td>240918T121524Z</td><td><a href="https://codegolf.stackexchange.com/questions/275590/play-the-final-fantasy-prelude/275609#275609">Neil</a></td></tr>
<tr d-ix="2"><td>nan</td><td>CP1610 machine code</td><td>240919T013051Z</td><td><a href="https://codegolf.stackexchange.com/questions/275590/play-the-final-fantasy-prelude/275627#275627">Arnauld</a></td></tr>
<tr d-ix="3"><td>304</td><td>PowerShell</td><td>240918T153022Z</td><td><a href="https://codegolf.stackexchange.com/questions/275590/play-the-final-fantasy-prelude/275613#275613">bigyihsu</a></td></tr>
<tr d-ix="4"><td>077</td><td>MATL 1 language</td><td>240917T230511Z</td><td><a href="https://codegolf.stackexchange.com/questions/275590/play-the-final-fantasy-prelude/275600#275600">Luis Men</a></td></tr>
<tr d-ix="5"><td>303</td><td>Chipmunk Basic</td><td>240918T153621Z</td><td><a href="https://codegolf.stackexchange.com/questions/275590/play-the-final-fantasy-prelude/275614#275614">roblogic</a></td></tr>
<tr d-ix="6"><td>190</td><td>alsautils</td><td>240918T121158Z</td><td><a href="https://codegolf.stackexchange.com/questions/275590/play-the-final-fantasy-prelude/275608#275608">Themooni</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>JavaScript, 406 bytes</h1>
<p>I don't golf with JavaScript much so I'm sure there's a lot of opportunities for golfing here. Should work on most browsers.</p>
<pre class="lang-js prettyprint-override"><code>x=&gt;{a=new AudioContext
o=a.createOscillator()
d=.19;[y=[0,2,4,7],z=[-3,-1,0,4],y,z,[-7,-5,-3,0],[-5,-3,-1,2],[-4,0,3,7],[-2,2,5,9]].map((c,t)=&gt;{p=s=&gt;o.frequency.setValueAtTime(440*2**((s-21)/12),(t*32+j)*d)
for(i=0,j=0;i&lt;17;i++,j++)p(c[j%4]+12*((i/4)|0))
for(i=0;i&lt;15;i++,j++)p(c[3-((j-1)%4)]+12*(((15-i)/4)|0))})
o.connect(g=a.createGain()).connect(a.destination)
g.gain.value=0.1
o.start()
o.stop(256*d)}
</code></pre>
<h2>Try it</h2>
<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>f =

x=&gt;{a=new AudioContext
o=a.createOscillator()
d=.19;[y=[0,2,4,7],z=[-3,-1,0,4],y,z,[-7,-5,-3,0],[-5,-3,-1,2],[-4,0,3,7],[-2,2,5,9]].map((c,t)=&gt;{p=s=&gt;o.frequency.setValueAtTime(440*2**((s-21)/12),(t*32+j)*d)
for(i=0,j=0;i&lt;17;i++,j++)p(c[j%4]+12*((i/4)|0))
for(i=0;i&lt;15;i++,j++)p(c[3-((j-1)%4)]+12*(((15-i)/4)|0))})
o.connect(g=a.createGain()).connect(a.destination)
g.gain.value=0.1
o.start()
o.stop(256*d)}</code></pre>
<pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;button type="button" id="play" onclick="f()"&gt;Play&lt;/button&gt;</code></pre>
</div>
</div>
</p>
</div>
<div id="pu1" class="pu"><h1>ZX Spectrum 48K Basic, <s>246</s> 203 bytes</h1>
<pre><code>  10 LET t=VAL &quot;.14&quot;: LET a$=&quot;&lt;0
247&lt;?0237&lt;&lt;0247&lt;?0237&lt;C0247&lt;A024
7&lt;@047;&lt;&gt;047;&lt;&quot;: FOR i=SGN PI TO
 LEN a$ STEP VAL &quot;6&quot;: FOR j=NOT
PI TO INT PI: FOR k=SGN PI TO VA
L &quot;4&quot;: BEEP t,VAL &quot;12&quot;*j+CODE a$
(i+k)-CODE a$(i): NEXT k: NEXT j
: FOR j=INT PI TO NOT PI STEP -S
GN PI: FOR k=VAL &quot;5&quot; TO VAL &quot;2&quot;
STEP -SGN PI: BEEP t,VAL &quot;12&quot;*j+
CODE a$(i+k)-CODE a$(i): NEXT k:
 NEXT j: NEXT i
</code></pre>
<p>The above is how the program lists on screen as the ZX Spectrum's screen is 32 characters wide. The byte count was calculated by subtracting the system variables for the end and start of the program; this will be one less than the save file length as an empty program has a save file length of 1. Unfortunately I was using an online emulator which only has a save snapshot option, so you'll have to retype this yourself to test it. Note that if you try to enter this program literally in 128K mode it will try to tokenise the <code>&lt;&gt;</code> inside the string, breaking the program, so either replace it with <code>&lt;&quot;+&quot;&gt;</code>, do some magic with POKE, or use 48K mode and type <code>&lt;&gt;</code> as two characters rather than the token. In both modes you may also need to use the keyboard layout to enter some special characters such as <code>-</code> or <code>*</code>. Explanation:</p>
<pre><code>  10
</code></pre>
<p>Arbitrary line number (always costs 2 bytes).</p>
<pre><code>LET t=VAL &quot;.14&quot;
</code></pre>
<p>Timing variable, adjusted to make the overall run time about 48s of real time. (Processing overhead makes the program take about 50% longer than the actual notes).</p>
<pre><code>LET a$=&quot;&lt;0247&lt;?0237&lt;&lt;0247&lt;?0237&lt;C0247&lt;A0247&lt;@047;&lt;&gt;047;&lt;&quot;
</code></pre>
<p>String of tonic and arpeggio data.</p>
<pre><code>FOR i=SGN PI TO LEN a$ STEP VAL &quot;6&quot;
</code></pre>
<p>This steps through each tonic in the data string, thus repeating <code>8</code> times. <code>SGN PI</code> is used as it's even shorter than <code>VAL &quot;1&quot;</code>, which saves a few bytes because numeric literals take up six bytes for their internal representation.</p>
<pre><code>FOR j=NOT PI TO INT PI
</code></pre>
<p>Repeat for four octaves; <code>NOT PI</code> is <code>0</code> and <code>INT PI</code> is of course <code>3</code>.</p>
<pre><code>FOR k=SGN PI TO VAL &quot;4&quot;
</code></pre>
<p>Repeat for four notes.</p>
<pre><code>BEEP t,VAL &quot;12&quot;*j+CODE a$(i+k)-CODE a$(i)
</code></pre>
<p>Compute the note index (<code>C‚ÇÑ=0</code>) and play it.</p>
<pre><code>NEXT k: NEXT j
</code></pre>
<p>Repeat for the rest of the ascending arpeggio.</p>
<pre><code>FOR j=INT PI TO NOT PI STEP -SGN PI
</code></pre>
<p>Loop back down through the octaves.</p>
<pre><code>FOR k=VAL &quot;5&quot; TO VAL &quot;2&quot; STEP -SGN PI
</code></pre>
<p>Loop down through the notes.</p>
<pre><code>BEEP t,VAL &quot;12&quot;*j+CODE a$(i+k)-CODE a$(i)
</code></pre>
<p>Compute and play the note.</p>
<pre><code>NEXT k: NEXT j: NEXT i
</code></pre>
<p>Repeat for the remainder of the prelude.</p>
<p>Edit: Saved 43 bytes thanks to @Arnauld's suggesting of indexing into a single data string.</p>
<h1>ZX Spectrum 128K Basic, 195 bytes</h1>
<pre><code>  10 LET a$=&quot;CDEG  #BGED abCE  A
     ECb  fgaC  FCag  gabD  GDBa
       $aC$E$G$AG$EC$bDFA $BAFd &quot;
     : FOR i= NOT PI TO VAL &quot;84&quot;
      STEP VAL &quot;12&quot;: FOR j = INT
     PI TO VAL &quot;6&quot; STEP INT PI :
      FOR k=j TO VAL &quot;9&quot;-j STEP
     SGN ( VAL &quot;9&quot;-j-j): PLAY &quot;O
     &quot;+ STR$ k+&quot; 2&quot;+(a$( TO VAL
     &quot;24&quot;)+a$)(i+j+j- VAL &quot;5&quot; TO
      i+j+j): NEXT k: NEXT j: NE
     XT i
</code></pre>
<p>The above is how the program displays during edit mode as the ZX Spectrum's screen is 32 characters wide and it wraps lines to column 5. The byte count was calculated by subtracting the system variables for the end and start of the program as the code is automatically tokenised (in edit mode tokens are always preceded with spaces but if you list the program then some of those will disappear) although when typing in the program you won't need to enter spaces except inside the string literal or between consecutive tokens. Explanation:</p>
<pre><code>  10
</code></pre>
<p>Arbitrary line number (always costs 2 bytes).</p>
<pre><code>LET a$=&quot;CDEG  #BGED abCE  AECb  fgaC  FCag  gabD  GDBa  $aC$E$G$AG$EC$bDFA $BAFd &quot;
</code></pre>
<p>Arpeggio data. Lower case letters play an octave below, so each octave command actually selects two octaves from which notes can be played, but to be able to play all of the arpeggios using the given four octaves I have had to cheat and play the C‚Çá as a BùÑ∞‚ÇÜ. Note that the first two arpeggios are only shown once here and doubled up below.</p>
<pre><code>FOR i= NOT PI TO VAL &quot;84&quot; STEP VAL &quot;12&quot;
</code></pre>
<p>Loop eight times, stepping though the arpeggio data string.</p>
<pre><code>FOR j = INT PI TO VAL &quot;6&quot; STEP INT PI
</code></pre>
<p>Switch between starting at octave <code>3</code> and octave <code>6</code>.</p>
<pre><code>FOR k=j TO VAL &quot;9&quot;-j STEP SGN ( VAL &quot;9&quot;-j-j)
</code></pre>
<p>Loop through the four octaves.</p>
<pre><code>PLAY &quot;O&quot;+ STR$ k+&quot; 2&quot;+(a$( TO VAL &quot;24&quot;)+a$)(i+j+j- VAL &quot;5&quot; TO i+j+j)
</code></pre>
<p>Select the octave and the note duration (the default tempo is 120 bpm but a note length code of <code>2</code> gives us the desired duration at this tempo) and play the current arpeggio at this octave.</p>
<pre><code>NEXT k: NEXT j: NEXT i
</code></pre>
<p>Repeat for the remainder of the prelude.</p>
<p>The figure of 195 bytes compares well to the 272 byte string needed to play the prelude in a single PLAY command: (line wrapping not part of the string)</p>
<pre><code>T80O3(1CDEGO5cdegCDEGO7cdegCgedcO5GEDCgedcO3GED
abCEABO5ceabCEABO7ceaeaO5BAECbaecO3BAECb)
fgaCFGAO5cfgaCFGAO7cfcO5AGFCagfcO3AGFCag
gabDGABO5dgabDGABO7dgdO5BAGDbagdO3BAGDba
$aC$EG$AO5c$eg$aC$EG$AO7c$eg$ag$ecO5$AG$EC$ag$ecO3$AG$EC
$bDFA$BO5dfa$bDFA$BO7dfa$bafdO5$BAFD$bafdO3$BAFD
</code></pre>
</div>
<div id="pu2" class="pu"><h1><a href="https://en.wikipedia.org/wiki/General_Instrument_CP1600" rel="nofollow noreferrer">CP-1610</a> machine code, 136 DECLEs<sup>1</sup>=170 bytes</h1>
<p><em><sup>1. CP-1610 instructions are encoded with 10-bit values (0x000 to 0x3FF), known as DECLEs. Although the Intellivision is also able to work on 16-bit data, programs were really stored in 10-bit ROM back then.</sup></em></p>
<p>A fantasy console?!? Let's do it on a real one!</p>
<p>This code is meant to be run on a PAL Intellivision (50Hz). It would also work on an NTSC system (60Hz), but at a different pitch and speed.</p>
<h2>Demo</h2>
<p><a href="https://youtu.be/2DOweHnZf0g" rel="nofollow noreferrer">Here is what we get</a> on the real hardware (YouTube video), using the <a href="http://ltoflash.leftturnonly.info/" rel="nofollow noreferrer">LTO Flash!</a>.</p>
<h2>Source code</h2>
<pre><code>                            ROMW  10          ; use 10-bit ROM width
0x4800                      ORG   $4800       ; map our code at $4800
                   
                    ;; -------------------------------------------------------- ;;
                    ;;  build the note period table in RAM:                     ;;
                    ;;    p(0) = 1432                                           ;;
                    ;;    p(n) = p(n-1) * 483 + 350 &gt;&gt; 9                        ;;
                    ;; -------------------------------------------------------- ;;
4800   001                  SDBD              ; R0 = note period, starting at ...
4801   2B8 098 005          MVII  #1432, R0   ; ... the highest value 1432 for F-2
4804   2BC 2F0              MVII  #$2F0, R4   ; R4 = write pointer in RAM
                   
4806   260          init    MVO@  R0, R4      ; write the period
                   
4807   1C9                  CLRR  R1          ; R1 and R3 are the most significant
4808   1DB                  CLRR  R3          ; words in R1:R0 and R3:R2 (32-bit)
                   
                            ; multiplication by 483, split into 2 + 1 - 32 + 512
4809   082                  MOVR  R0, R2      ; R2 = R0  \
480A   048                  SLL   R0          ; R0 *= 2   |__ 16-bit operations
480B   0C2                  ADDR  R0, R2      ; R2 += R0  |
480C   04C                  SLL   R0, 2       ; R0 *= 4  /
480D   05C                  SLLC  R0, 2       ; 32-bit values required from here
480E   055                  RLC   R1, 2       ; R1:R0 *= 4
480F   102                  SUBR  R0, R2      ; R3:R2 -= R1:R0
                                              ; (carry never set -&gt; no ADCR R3)
4810   013                  DECR  R3
4811   10B                  SUBR  R1, R3
4812   05C                  SLLC  R0, 2       ; R1:R0 *= 16
4813   055                  RLC   R1, 2
4814   05C                  SLLC  R0, 2
4815   055                  RLC   R1, 2
4816   0C2                  ADDR  R0, R2      ; R3:R2 += R1:R0
4817   02B                  ADCR  R3
4818   0CB                  ADDR  R1, R3
                   
4819   2FA 15E              ADDI  #350, R2    ; R3:R2 += 350
                                              ; (carry never set -&gt; no ADCR R3)
                   
481B   042                  SWAP  R2          ; R2 = R3:R2 &gt;&gt; 9
481C   043                  SWAP  R3
481D   3BA 0FF              ANDI  #$FF, R2
481F   1DA                  XORR  R3, R2
4820   07A                  SARC  R2
                   
4821   090                  MOVR  R2, R0      ; copy R2 to R0
                   
4822   378 00F              CMPI  #$F, R0     ; loop until R0 = $F
4824   22E 01F              BGT   init
                   
                    ;; -------------------------------------------------------- ;;
                    ;;  play the song                                           ;;
                    ;; -------------------------------------------------------- ;;
4826   240 1FB              MVO   R0, $1FB    ; set the volume on channel A to $F
                   
4828   001          loop    SDBD              ; R4 = pointer into chords table
4829   2BC 063 048          MVII  #chords, R4
                   
482C   2A2          chord   MVI@  R4, R2      ; R2 = initial note address
482D   274                  PSHR  R4          ; save R4 on the stack
482E   2E4                  ADD@  R4, R4      ; R4 = pointer into delta values
482F   2BD 008              MVII  #8, R5      ; R5 = octave counter
                   
4831   093          octave  MOVR  R2, R3      ; copy R2 to R3
4832   2B9 004              MVII  #4, R1      ; R1 = note counter
                   
4834   298          note    MVI@  R3, R0      ; R0 = note period
4835   240 1F0              MVO   R0, $1F0    ; save the low bits
4837   040                  SWAP  R0
4838   240 1F4              MVO   R0, $1F4    ; save the high bits
                   
483A   001                  SDBD              ; wait for ~184500 cycles
483B   2B8 00C 030          MVII  #12300, R0  ; (approximately 185ms)
                   
483E   010          spin    DECR  R0          ; (6 cycles)
483F   22C 002              BNEQ  spin        ; (9 cycles)
                   
4841   2E3                  ADD@  R4, R3      ; update R3
4842   33B 005              SUBI  #5, R3
4844   011                  DECR  R1          ; decrement the note counter
4845   22C 012              BNEQ  note        ; loop if not zero
                   
4847   37D 005              CMPI  #5, R5      ; compare octave counter with 5
4849   20C 003              BNEQ  phase       ; time to switch the phase? ...
                   
484B   09A                  MOVR  R3, R2      ; ... yes: copy R3 to R2
484C   200 008              B     next
                   
484E   20E 002      phase   BGT   asc         ; ascending phase?
                   
4850   33A 018              SUBI  #24, R2     ; descending phase: -12 semitones
4852   2FA 00C      asc     ADDI  #12, R2     ; ascending phase: +12 semitones
                   
4854   33C 004              SUBI  #4, R4      ; rewind R4
                   
4856   015          next    DECR  R5          ; decrement the octave counter
4857   22C 027              BNEQ  octave      ; loop if not zero
                   
4859   2B4                  PULR  R4          ; advance to the next chord
485A   00C                  INCR  R4
                   
485B   001                  SDBD              ; was it the last chord?
485C   37C 073 048          CMPI  #ch_end, R4
485F   225 034              BLT   chord
4861   220 03A              B     loop        ; if yes, repeat from the beginning
                   
                    ;; -------------------------------------------------------- ;;
                    ;;  chords tables                                           ;;
                    ;; -------------------------------------------------------- ;;
4863   2F7 00E      chords  DECLE $2F7, add2   - $ - 1  ; C/add2
4865   2F4 013              DECLE $2F4, add2_m - $ - 1  ; Am/add2
4867   2F7 00A              DECLE $2F7, add2   - $ - 1  ; C/add2
4869   2F4 00F              DECLE $2F4, add2_m - $ - 1  ; Am/add2
486B   2F0 006              DECLE $2F0, add2   - $ - 1  ; F/add2
486D   2F2 004              DECLE $2F2, add2   - $ - 1  ; G/add2
486F   2F3 010              DECLE $2F3, maj7   - $ - 1  ; G#/maj7
4871   2F5 00E              DECLE $2F5, maj7   - $ - 1  ; A#/maj7
0x4873              ch_end
                   
                            ; delta values, with +5 offset
4873   007 007 ...  add2    DECLE 7, 7, 8, 10, 0, 2, 3
487A   007 006 ...  add2_m  DECLE 7, 6, 9, 10, 0, 1, 4
4881   009 008 ...  maj7    DECLE 9, 8, 9,  6, 4, 1, 2

0x4888              end
</code></pre>
<h2>How it works</h2>
<h3>About the Programmable Sound Generator (PSG)</h3>
<p>The PAL-based Intellivision uses a 4.00MHz clock. The PSG is driven from a clock signal at half this rate. Internally, the PSG divides down its clock by 16 to determine the final square-wave frequency. The frequency of a tone produced by a PAL Intellivision is therefore given by:</p>
<p><span class="math-container">$$F\_tone=\frac{4000000}{32\times P\_channel}$$</span></p>
<p>where <span class="math-container">\$P\_channel\$</span> is the period register setting for the given channel.</p>
<p><em>(adapted from the <code>psg.txt</code> file included in <a href="http://spatula-city.org/%7Eim14u2c/intv/" rel="nofollow noreferrer">jzIntv</a>)</em></p>
<h3>Building the note period table</h3>
<p>The frequency ratio between two consecutive semitones is given by:</p>
<p><span class="math-container">$$\sqrt[12]{2}\approx 1,0594631$$</span></p>
<p>And what we really need is the period ratio between two consecutive semitones:</p>
<p><span class="math-container">$$1/\sqrt[12]{2}\approx 0,9438743$$</span></p>
<p>To apply this ratio to a period <span class="math-container">\$P_n\$</span>, we use the following approximation:</p>
<p><span class="math-container">$$P_{n+1}=\left\lfloor\frac{P_n \times 483 + 350}{512}\right\rfloor$$</span></p>
<p>We start with <span class="math-container">\$P_0=1432\$</span>, which is the period for F<sub>2</sub> (87.31Hz) on a PAL Intellivision, computed with the formula described in the previous section. We stop when a period of 15 is reached -- an arbitrary choice to have a register ready to initialize the volume on the PSG.</p>
<p>The CP-1610 doesn't have any multiplication instruction, so we have to compute it with additions and shifts. Besides, we need 32-bit values to have enough precision. So two pairs of 16-bit registers are used (R0/R1 and R2/R3).</p>
<p>The integer division by 512 is of course much simpler since it boils down to a right-shift by 9.</p>
<h3>Chords encoding</h3>
<p>Each chord is described by the address of the first note in our period table, followed by a pointer to 7 delta values:</p>
<pre><code>a0, a1, a2, s, d0, d1, d2
</code></pre>
<p>where:</p>
<ul>
<li><code>a0</code>, <code>a1</code>, <code>a2</code> are the delta values for the ascending phase, repeated 4 times and starting at the next octave each time</li>
<li><code>s</code> is the delta value applied when switching from the ascending to the descending phase</li>
<li><code>d0</code>, <code>d1</code>, <code>d2</code> are the delta values for the descending phase, repeated 4 times and starting at the previous octave each time</li>
</ul>
<p>The actual delta values are obtained by subtracting 5 to the stored values.</p>
</div>
<div id="pu3" class="pu"><h1><a href="https://github.com/PowerShell/PowerShell" rel="nofollow noreferrer">PowerShell</a>, <s>401</s> <s>379</s> <s>340</s> 304 bytes</h1>
<pre class="lang-powershell prettyprint-override"><code>$C=130,146,164,196,261
$A=110,123,130,174,220
$G=103,130,155,196,207
function P($c,$h){0..7|%{$i=$_;if($i-lt4){0..3|%{[console]::Beep(($c[$_])*[math]::Pow(2,$i+$h/12),187)}}else{4..1|%{[console]::Beep(($c[$_])*[math]::Pow(2,8-$i-1+$h/12),187)}}}}
P $C 0
P $A 0
P $C 0
P $A 0
P $C -7
P $C -5
P $G 0
P $G 2
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=jZC9boMwFEbVladguJGgNdTXGExSMaQZWNlRFFXICEsujgpRBsqTdMnSpY_Up6kTyJBMnY7uuX_S9_WzN0f50TVS69Pp-9DXQfr7QGGTYUQJ8oRgwgkuE8ISdGCdIVrNInJpC04Yow7kGdJZxfE0TYVTH9qqV6Z1Cw8qAo0_0DAUn4sBVAa7F1V7oALd84uPrC8r03ZGy-1q9Srl3rNrJey2_mP5_tY31hbm6DEC6gmaZ2Q-wVT44yh1Jwcehvj_E2lgX-PtmXF0Chc2Lj1jPeG-CsTM-Mx80rnLpuDm_K45_gE" rel="nofollow noreferrer">Attempt This Online!</a></p>
<p>An extremely brute-force solution, since I'm a novice at PowerShell golf. Defines a function <code>P</code> that plays a chord (array of numbers, truncated to the nearest integer) at a given half-step offset, first up 4 times then down 4 times. Each note is played using the builtin <code>[System.Console]::Beep</code> method.</p>
<p>To run, paste this into a <code>.ps1</code> file, then run it in PowerShell; or paste it directly into a PowerShell terminal.</p>
<ul>
<li>-22 from general golfs</li>
<li>-39 from replacing <code>for</code>-loops with ranges piped into <code>ForEach-Object</code>s.</li>
<li>-36 from reusing the back 4 notes of the chords, in reverse, for the descending arpeggios.</li>
</ul>
<p><em>P.S. I keep getting this weird issue where some notes are missed; I modified the code to write out the current note and index that it's on and it is indeed running correctly, but the beeps are being clobbered by something else.</em></p>
</div>
<div id="pu4" class="pu"><h1><a href="https://github.com/lmendo/MATL" rel="nofollow noreferrer">MATL</a> (1 language), <s>78</s> 77 bytes</h1>
<pre><code>0'!4XC@nRAxt~&amp;'F5:ZaKeK1X&quot;tP[AaABOlHN]0Y(_&amp;vhYs&quot;1875:YPE*76/@12/W*Y,E]&amp;h1e4Y#
</code></pre>
<p>This uses equal temperament, with a C<sub>3</sub> frequency of 131.6 Hz (more accurate values could be achieved at the cost of 2 or 3 bytes, namely replacing <code>76</code> in the code by <code>76.4</code> or <code>76.45</code>).</p>
<p>The timbre corresponds to a sine wave hard-clipped at half its amplitude (this clipping costs 1 byte but produces nicer sound than a pure sine wave; the latter can be obtained by removing the <code>E</code> near the end of the code).</p>
<p>Try it at <a href="https://matl.io/?code=0%27%214XC%40nRAxt%7E%26%27F5%3AZaKeK1X%22tP%5BAaABOlHN%5D0Y%28_%26vhYs%221875%3AYPE%2a76%2F%4012%2FW%2aY%2CE%5D%26h1e4Y%23&amp;inputs=&amp;version=22.8.0" rel="nofollow noreferrer">MATL online</a>!</p>
<h2>How it works</h2>
<p>Number 0 is first pushed to the stack. This will serve as the initial note. The rest of the notes will be defined by consecutive differences, measured in semitones.</p>
<p>The basic structure of the song is described by the following 4√ó8 matrix:</p>
<pre><code>2 2 2 2 2 2 4 4
2 1 2 1 2 2 3 3
3 4 3 4 3 3 4 4
5 5 5 5 5 5 1 1
</code></pre>
<p>which contains the increments (in semitones) of the ascending arpeggios, each column corresponding to one of the 8 chords in order.</p>
<p>To generate this matrix, the string <code>'!4XC@nRAxt~&amp;'</code> is interpreted as a &quot;number&quot; in the base defined by all ASCII characters except single quote, and is decoded into the base formed by the numbers [1 2 3 4 5], producing a row vector (this operation is done by the code <code>F5:Za</code>). Reshaping this with 4 rows (<code>Ke</code>) gives the above matrix. Then, the matrix is extended by replicating it 4 times vertically (<code>K1X&quot;</code>), because each ascending arpeggio is played 4 times. This yields a 16√ó8 matrix.</p>
<p>A duplicate (<code>t</code>) of this 16√ó8 matrix is produced, and it is then flipped vertically (<code>P</code>). This represents the descending arpeggios, except that the sign should be negated; and the last row is incorrect, because it does not consider the transition to the next chord. Specifically, the values of the last row should be [5 ‚àí1 5 6 0 1 2 NaN] (represented compactly in the code as <code>[AaABOlHN]</code>). The final NaN value indicates that there is no following chord in the last column. Thus, the last row of the second 16√ó8 matrix is overwritten with that vector (<code>0Y(</code>), and the two matrices are concatenated vertically (<code>&amp;v</code>). The resulting 32√ó8 matrix describes the repeated up and down arpeggios for each chord, with the correct transition to the next chord. To produce the notes it should be read in column-major order (down, then across).</p>
<p>To transform the increments between notes into the actual notes, the 0 produced at the beginning of the program is concatenated horizontally (<code>h</code>) with the 32√ó8 matrix. This causes the matrix to be read in column-major order, and gives a 1√ó257 row vector. Its cumulative sum (<code>Ys</code>) produces the notes, starting at 0, where each note is represented by the number <em>S</em> of semitones up or down from C<sub>3</sub>. The last value is NaN, which will be interpreted as no note.</p>
<p>A <em>for each</em> loop (<code>&quot;</code>...<code>]</code>) reads each note, represented by the corresponding number <em>S</em>. To generate the waveform for each note, a time vector [1 2 ... 1875] is first generated (<code>1875:</code>). The length of this vector, when replayed at 10000 samples per second, determines a tempo of 80 bpm, as required. This vector is element-wise multiplied by 2*pi <code>(YPE*)</code>, divided by 76 (<code>76/</code>), and then multiplied by 2 raised to the number that results from dividing <em>S</em> by 12 (<code>@12/W*</code>). Applying the sine function (<code>Y,</code>) produces a 1√ó1875 vector with samples of a sinusoid of the frequency correponding to <em>S</em>. The values of this vector are multiplied by 2 (<code>E</code>). The last sinusoid contains NaN values and will produce no sound.</p>
<p>The 257 resulting waveforms, each with 1875 samples, are concatened horizontally (<code>&amp;h</code>) into a single waveform. This waveform is then replayed, without scaling, at the indicated sample rate (<code>1e4Y#</code>). When replaying, sample values are clipped to the interval [1, ‚àí1].</p>
</div>
<div id="pu5" class="pu"><h1><a href="https://www.nicholson.com/rhn/basic/" rel="nofollow noreferrer">Chipmunk Basic</a>, <sub><s>677</s></sub> 303 bytes</h1>
<pre class="lang-basic prettyprint-override"><code>data 0,2,4,7,-3,-1,0,4,0,2,4,7,-3,-1,0,4,-7,-5,-3,0,-5,-3,-1,2,-4,0,3,7,-2,2,5,9
for k=0to 7:dim a(4):for i=1to 4:read a(i):next
dim m(16):for i=0to 3:for j=1to 4:n=a(j)+12*i:m(j+4*i)=440*2^((n-21)/12):next:next
for i=1to 16:s(m(i)):next:for i=1to 15:s(m(16-i)):next:next
sub s(n):sound n,.18,50:return
</code></pre>
<p>The info about chords and octaves in the &quot;music theory&quot; section helped a lot.</p>
<p><sub><s><a href="https://github.com/roblogic/golf/blob/46d9ed8a30eaa2785bd216b5188800784a5be9eb/basic/275590-play-the-final-fantasy-prelude.bas" rel="nofollow noreferrer">677 bytes</a></s> <em>: I am sure there is a better way of coding this ...</em></sub></p>
</div>
<div id="pu6" class="pu"><h1><a href="https://github.com/bear24rw/alsa-utils" rel="nofollow noreferrer">alsa-utils</a>, 190 bytes</h1>
<p>xxd dump:</p>
<pre><code>00000000: 4d54 6864 0000 0006 0001 0002 00dc 4d54  MThd..........MT
00000010: 726b 0000 0013 00ff 5103 07a1 2000 ff58  rk......Q... ..X
00000020: 0404 0218 0801 ff2f 004d 5472 6b00 0000  ......./.MTrk...
00000030: 8d00 c000 0090 3050 0034 5000 3750 8670  ......0P.4P.7P.p
00000040: 3000 0034 0000 3700 0039 5000 3d50 0040  0..4..7..9P.=P.@
00000050: 5086 7030 5000 3450 0037 5000 3900 003d  P.p0P.4P.7P.9..=
00000060: 0000 4000 8670 3000 0034 0000 3700 0039  ..@..p0..4..7..9
00000070: 5000 3d50 0040 5086 7035 5000 3900 0039  P.=P.@P.p5P.9..9
00000080: 5000 3c50 003d 0000 4000 8670 3500 0038  P.&lt;P.=..@..p5..8
00000090: 5000 3900 003c 0000 3c50 003f 5086 7038  P.9..&lt;..&lt;P.?P.p8
000000a0: 0000 3a50 003c 0000 3e50 003f 0000 4150  ..:P.&lt;..&gt;P.?..AP
000000b0: 8670 3a00 003e 0000 4100 01ff 2f00       .p:..&gt;..A.../.
</code></pre>
<p>Environment: A modern linux computer, with alsa installed (default in many distributions, though becoming superseded by pipewire), and a midi card installed (could be a USB midi card) available at midi port x.</p>
<p>to play:
save code to a file, then</p>
<pre><code>aplaymidi --port=x.0 &lt;filepath&gt;
</code></pre>
<p>as you can probably guess, this is just a straight up midi file I generated with the appropriate notes and tempo.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/275590/">275590</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




