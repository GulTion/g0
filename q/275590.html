<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::275590</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>078</td><td>MATL 1 language</td><td>240917T230511Z</td><td><a href="https://codegolf.stackexchange.com/questions/275590/play-the-final-fantasy-prelude/275600#275600">Luis Men</a></td></tr>
<tr d-ix="1"><td>203</td><td>ZX Spectrum 48K Basic</td><td>240918T121524Z</td><td><a href="https://codegolf.stackexchange.com/questions/275590/play-the-final-fantasy-prelude/275609#275609">Neil</a></td></tr>
<tr d-ix="2"><td>379</td><td>PowerShell</td><td>240918T153022Z</td><td><a href="https://codegolf.stackexchange.com/questions/275590/play-the-final-fantasy-prelude/275613#275613">bigyihsu</a></td></tr>
<tr d-ix="3"><td>677</td><td>Chipmunk Basic</td><td>240918T153621Z</td><td><a href="https://codegolf.stackexchange.com/questions/275590/play-the-final-fantasy-prelude/275614#275614">roblogic</a></td></tr>
<tr d-ix="4"><td>190</td><td>alsautils</td><td>240918T121158Z</td><td><a href="https://codegolf.stackexchange.com/questions/275590/play-the-final-fantasy-prelude/275608#275608">Themooni</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://github.com/lmendo/MATL" rel="nofollow noreferrer">MATL</a> (1 language), 78 bytes</h1>
<pre><code>0'!4XC@nRAxt~&amp;'F5:ZaKe16:Y)tP[AaABOlHN]0Y(_&amp;vhYs&quot;1875:YPE*76/@12/W*Y,E]&amp;h1e4Y#
</code></pre>
<p>This uses equal temperament, with a C<sub>3</sub> frequency of 131.6 Hz (more accurate values could be achieved at the cost of 2 or 3 bytes, namely replacing <code>76</code> in the code by <code>76.4</code> or <code>76.45</code>).</p>
<p>The timbre corresponds to a sine wave hard-clipped at half its amplitude (this clipping costs 1 byte but produces nicer sound than a pure sine wave; the latter can be obtained by removing the <code>E</code> near the end of the code).</p>
<p>Try it at <a href="https://matl.io/?code=0%27%214XC%40nRAxt%7E%26%27F5%3AZaKe16%3AY%29tP%5BAaABOlHN%5D0Y%28_%26vhYs%221875%3AYPE%2a76%2F%4012%2FW%2aY%2CE%5D%26h1e4Y%23&amp;inputs=&amp;version=22.8.0" rel="nofollow noreferrer">MATL online</a>!</p>
<h2>How it works</h2>
<p>A <code>0</code> is first pushed to the stack. This will serve as the initial note. The rest of the notes will be defined by consecutive differences.</p>
<p>The basic structure of the song is described by the following 4×8 matrix:</p>
<pre><code>2 2 2 2 2 2 4 4
2 1 2 1 2 2 3 3
3 4 3 4 3 3 4 4
5 5 5 5 5 5 1 1
</code></pre>
<p>which contains the increments (in semitones) of the ascending arpeggios, each column corresponding to one of the 8 chords in order.</p>
<p>To generate this matrix, the string <code>'!4XC@nRAxt~&amp;'</code> is interpreted as a &quot;number&quot; in the base defined by all ASCII characters except single quote, and is decoded into the base formed by the numbers [1 2 3 4 5], producing a row vector (this operation is done by the code <code>F5:Za</code>). Converting this to a 4-row matrix (<code>Ke</code>) gives the above matrix. Then, the matrix is repeated 4 times vertically, because each ascending arpeggio is played 4 times. This is carried out by applying modular indexing from 1 to 16 into the rows of the above matrix (code <code>16:Y)</code>), which yields a 16×8 matrix.</p>
<p>A duplicate (<code>t</code>) of this 16×8 matrix is produced, and it is then flipped vertically (<code>P</code>). This represents the descending arpeggios, except that the sign should be negated; and the last row is incorrect, because it does not consider the transition to the next chord. Specifically, the values of the last row should be [5 −1 5 6 0 1 2 NaN] (represented compactly in the code as <code>[AaABOlHN]</code>). The final NaN value indicates that there is no following chord in the last column. Thus, the last row of the second 16×8 matrix is overwritten with that vector (<code>0Y(</code>), and the two matrices are concatenated vertically (<code>&amp;v</code>). The resulting 32×8 matrix describes the repeated up and down arpeggios for each chord, with the correct transition to the next chord. To produce the notes it should be read in column-major order (down, then across).</p>
<p>To transform the increments between notes into the actual notes, the 0 produced at the beginning of the program is concatenated horizontally (<code>h</code>) with the 32×8 matrix. This causes the matrix to be read in column-major order, and gives a 1×257 row vector. Its cumulative sum (<code>Ys</code>) produces the notes, starting at <code>0</code>, where each note is represented by the number <em>S</em> of semitones up or down from C<sub>3</sub>. The last value is NaN, which will be interpreted as no note.</p>
<p>A <em>for each</em> loop (<code>&quot;</code>...<code>]</code>) reads each note, represented by the corresponding number <em>S</em>. To generate the waveform for each note, a time vector [1 2 ... 1875] is first generated (<code>1875:</code>). The length of this vector, when replayed at 10000 samples per second, determines a tempo of 80 bpm, as required. This vector is element-wise multiplied by 2*pi <code>(YPE*)</code>, divided by 76 (<code>76/</code>), and then multiplied by 2 raised to the number that results from dividing <em>S</em> by 12 (<code>@12/W*</code>). Applying the sine function (<code>Y,</code>) produces a 1×1875 vector with samples of a sinusoid of the frequency correponding to <em>S</em>. The values of this vector are multiplied by 2 (<code>E</code>). The last sinusoid contains NaN values and will produce no sound.</p>
<p>The 257 resulting waveforms, each with 1875 samples, are concatened horizontally (<code>&amp;h</code>) into a single waveform, and this is replayed, without scaling, at the indicated sample rate (<code>1e4Y#</code>). When replaying, sample values are clipped to the interval [1, −1].</p>
</div>
<div id="pu1" class="pu"><h1>ZX Spectrum 48K Basic, <s>246</s> 203 bytes</h1>
<pre><code>  10 LET t=VAL &quot;.14&quot;: LET a$=&quot;&lt;0
247&lt;?0237&lt;&lt;0247&lt;?0237&lt;C0247&lt;A024
7&lt;@047;&lt;&gt;047;&lt;&quot;: FOR i=SGN PI TO
 LEN a$ STEP VAL &quot;6&quot;: FOR j=NOT
PI TO INT PI: FOR k=SGN PI TO VA
L &quot;4&quot;: BEEP t,VAL &quot;12&quot;*j+CODE a$
(i+k)-CODE a$(i): NEXT k: NEXT j
: FOR j=INT PI TO NOT PI STEP -S
GN PI: FOR k=VAL &quot;5&quot; TO VAL &quot;2&quot;
STEP -SGN PI: BEEP t,VAL &quot;12&quot;*j+
CODE a$(i+k)-CODE a$(i): NEXT k:
 NEXT j: NEXT i
</code></pre>
<p>The above is how the program lists on screen as the ZX Spectrum's screen is 32 characters wide. The byte count was calculated by subtracting the system variables for the end and start of the program; this will be one less than the save file length as an empty program has a save file length of 1. Unfortunately I was using an online emulator which only has a save snapshot option, so you'll have to retype this yourself to test it. Note that if you try to enter this program literally in 128K mode it will try to tokenise the <code>&lt;&gt;</code> inside the string, breaking the program, so either replace it with <code>&lt;&quot;+&quot;&gt;</code>, do some magic with POKE, or use 48K mode and type <code>&lt;&gt;</code> as two characters rather than the token. In both modes you may also need to use the keyboard layout to enter some special characters such as <code>-</code> or <code>*</code>. Explanation:</p>
<pre><code>  10
</code></pre>
<p>Arbitrary line number (always costs 2 bytes).</p>
<pre><code>LET t=VAL &quot;.14&quot;
</code></pre>
<p>Timing variable, adjusted to make the overall run time about 48s of real time. (Processing overhead makes the program take about 50% longer than the actual notes).</p>
<pre><code>LET a$=&quot;&lt;0247&lt;?0237&lt;&lt;0247&lt;?0237&lt;C0247&lt;A0247&lt;@047;&lt;&gt;047;&lt;&quot;
</code></pre>
<p>String of tonic and arpeggio data.</p>
<pre><code>FOR i=SGN PI TO LEN a$ STEP VAL &quot;6&quot;
</code></pre>
<p>This steps through each tonic in the data string, thus repeating <code>8</code> times. <code>SGN PI</code> is used as it's even shorter than <code>VAL &quot;1&quot;</code>, which saves a few bytes because numeric literals take up six bytes for their internal representation.</p>
<pre><code>FOR j=NOT PI TO INT PI
</code></pre>
<p>Repeat for four octaves; <code>NOT PI</code> is <code>0</code> and <code>INT PI</code> is of course <code>3</code>.</p>
<pre><code>FOR k=SGN PI TO VAL &quot;4&quot;
</code></pre>
<p>Repeat for four notes.</p>
<pre><code>BEEP t,VAL &quot;12&quot;*j+CODE a$(i+k)-CODE a$(i)
</code></pre>
<p>Compute the note index (<code>C₄=0</code>) and play it.</p>
<pre><code>NEXT k: NEXT j
</code></pre>
<p>Repeat for the rest of the ascending arpeggio.</p>
<pre><code>FOR j=INT PI TO NOT PI STEP -SGN PI
</code></pre>
<p>Loop back down through the octaves.</p>
<pre><code>FOR k=VAL &quot;5&quot; TO VAL &quot;2&quot; STEP -SGN PI
</code></pre>
<p>Loop down through the notes.</p>
<pre><code>BEEP t,VAL &quot;12&quot;*j+CODE a$(i+k)-CODE a$(i)
</code></pre>
<p>Compute and play the note.</p>
<pre><code>NEXT k: NEXT j: NEXT i
</code></pre>
<p>Repeat for the remainder of the prelude.</p>
<p>Edit: Saved 43 bytes thanks to @Arnauld's suggesting of indexing into a single data string.</p>
</div>
<div id="pu2" class="pu"><h1><a href="https://github.com/PowerShell/PowerShell" rel="nofollow noreferrer">PowerShell</a>, <s>401</s> 379 bytes</h1>
<pre class="lang-powershell prettyprint-override"><code>$C=130,146,164,196,261,196,164,146
$A=110,123,130,174,220,174,130,123
$G=103,130,155,196,207,196,155,130
function P($c,$h){for($i=0;$i-lt8;$i++){if($i-lt4){for($n=0;$n-lt4;$n++){[console]::Beep(($c[$n])*[math]::Pow(2,$i+$h/12),187)}}else{for($n=4;$n-lt8;$n++){[console]::Beep(($c[$n])*[math]::Pow(2,8-$i-1+$h/12),187)}}}}
P $C 0
P $A 0
P $C 0
P $A 0
P $C -7
P $C -5
P $G 0
P $G 2
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=lZGxboMwFEXVla9g8ACNUfyMMW4ihjQDKzvKUCEjkFw7CkQZEF_SJUuXflK_pjYmQ7t1OrrPV0eW7sfX2dzkZeikUvf753VsE_H9NKFjASnBwDgGzjC8cEw5LFwy4wE6FAC2QlO8VHOGKfVcMk0DVBZA1ucs8xaSe4vLKQnaq27G3uiwilCDURdPrblEqC_IHvWJGoXFZhNPfRstma0F7QraHSxcoW6MHoySp93uVcpzZHU10qf4uX5_Gzt7rcwtotjaULcFGmMQeTzPUg3yYWTeKP5nFIn9GPy2znNQhegYEoeDx9-U5Cszx9Kfy5D6DdYpHpP8AA" rel="nofollow noreferrer">Attempt This Online!</a></p>
<p>An extremely brute-force solution, since I'm a novice at PowerShell golf. Defines a function <code>P</code> that plays a chord (array of numbers, truncated to the nearest integer) at a given half-step offset, first up 4 times then down 4 times. Each note is played using the builtin <code>[System.Console]::Beep</code> method.</p>
<p>To run, paste this into a <code>.ps1</code> file, then run it in PowerShell.</p>
</div>
<div id="pu3" class="pu"><h1><a href="https://www.nicholson.com/rhn/basic/" rel="nofollow noreferrer">Chipmunk Basic</a>, 677 bytes</h1>
<pre class="lang-basic prettyprint-override"><code>data 131,147,165,196,262,294,330,392,523,587,659,784,1047,1175,1319,1568,2093
data 110,123,131,165,220,247,262,330,440,494,523,659,880,988,1047,1319,1760
data 131,147,165,196,262,294,330,392,523,587,659,784,1047,1175,1319,1568,2093
data 87,98,110,131,175,196,220,262,349,392,440,523,698,784,880,1047,1397
data 98,110,123,147,196,220,247,294,392,440,494,587,784,880,988,1175,1568
data 104,123,156,185,208,247,311,370,415,494,622,740,831,988,1245,1480,1661
data 116,139,165,208,233,277,330,415,466,554,659,831,932,1109,1319,1661,1865
for j=1 to 7:dim m(16):for i=0 to 16:read m(i):next
for i=0 to 16:s(m(i)):next:for i=0 to 15:s(m(15-i)):next:next
sub s(n):sound n,.18,50:return
</code></pre>
<p>May have golfed the data too much by converting all the frequencies to integers. I am sure there is a better way of coding this using base frequencies and interesting formulae using powers of 2. But this is enough for today.</p>
</div>
<div id="pu4" class="pu"><h1><a href="https://github.com/bear24rw/alsa-utils" rel="nofollow noreferrer">alsa-utils</a>, 190 bytes</h1>
<p>xxd dump:</p>
<pre><code>00000000: 4d54 6864 0000 0006 0001 0002 00dc 4d54  MThd..........MT
00000010: 726b 0000 0013 00ff 5103 07a1 2000 ff58  rk......Q... ..X
00000020: 0404 0218 0801 ff2f 004d 5472 6b00 0000  ......./.MTrk...
00000030: 8d00 c000 0090 3050 0034 5000 3750 8670  ......0P.4P.7P.p
00000040: 3000 0034 0000 3700 0039 5000 3d50 0040  0..4..7..9P.=P.@
00000050: 5086 7030 5000 3450 0037 5000 3900 003d  P.p0P.4P.7P.9..=
00000060: 0000 4000 8670 3000 0034 0000 3700 0039  ..@..p0..4..7..9
00000070: 5000 3d50 0040 5086 7035 5000 3900 0039  P.=P.@P.p5P.9..9
00000080: 5000 3c50 003d 0000 4000 8670 3500 0038  P.&lt;P.=..@..p5..8
00000090: 5000 3900 003c 0000 3c50 003f 5086 7038  P.9..&lt;..&lt;P.?P.p8
000000a0: 0000 3a50 003c 0000 3e50 003f 0000 4150  ..:P.&lt;..&gt;P.?..AP
000000b0: 8670 3a00 003e 0000 4100 01ff 2f00       .p:..&gt;..A.../.
</code></pre>
<p>Environment: A modern linux computer, with alsa installed (default in many distributions, though becoming superseded by pipewire), and a midi card installed (could be a USB midi card) available at midi port x.</p>
<p>to play:
save code to a file, then</p>
<pre><code>aplaymidi --port=x.0 &lt;filepath&gt;
</code></pre>
<p>as you can probably guess, this is just a straight up midi file I generated with the appropriate notes and tempo.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/275590/">275590</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




