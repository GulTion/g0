<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::74864</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>004</td><td>Thunno 2</td><td>230813T091325Z</td><td><a href="https://codegolf.stackexchange.com/questions/74864/making-a-coin-fair/264110#264110">The Thon</a></td></tr>
<tr d-ix="1"><td>011</td><td>str</td><td>210322T170302Z</td><td><a href="https://codegolf.stackexchange.com/questions/74864/making-a-coin-fair/221078#221078">Conor O&</a></td></tr>
<tr d-ix="2"><td>004</td><td>Jelly</td><td>210322T135002Z</td><td><a href="https://codegolf.stackexchange.com/questions/74864/making-a-coin-fair/221070#221070">Unrelate</a></td></tr>
<tr d-ix="3"><td>4535</td><td>beeswax</td><td>160327T031014Z</td><td><a href="https://codegolf.stackexchange.com/questions/74864/making-a-coin-fair/76338#76338">M L</a></td></tr>
<tr d-ix="4"><td>162</td><td>DOS/Windows Batch</td><td>160307T121907Z</td><td><a href="https://codegolf.stackexchange.com/questions/74864/making-a-coin-fair/74974#74974">Dennis v</a></td></tr>
<tr d-ix="5"><td>033</td><td>brainfuck</td><td>160309T083910Z</td><td><a href="https://codegolf.stackexchange.com/questions/74864/making-a-coin-fair/75179#75179">Xwtek</a></td></tr>
<tr d-ix="6"><td>046</td><td>Ruby</td><td>160309T070259Z</td><td><a href="https://codegolf.stackexchange.com/questions/74864/making-a-coin-fair/75177#75177">Sherlock</a></td></tr>
<tr d-ix="7"><td>016</td><td>Befunge 93</td><td>160309T044919Z</td><td><a href="https://codegolf.stackexchange.com/questions/74864/making-a-coin-fair/75174#75174">Sp3000</a></td></tr>
<tr d-ix="8"><td>017</td><td>Perl</td><td>160306T110404Z</td><td><a href="https://codegolf.stackexchange.com/questions/74864/making-a-coin-fair/74931#74931">Ton Hosp</a></td></tr>
<tr d-ix="9"><td>040</td><td>Befunge93</td><td>160309T012402Z</td><td><a href="https://codegolf.stackexchange.com/questions/74864/making-a-coin-fair/75168#75168">Luis Men</a></td></tr>
<tr d-ix="10"><td>072</td><td>Python</td><td>160308T044200Z</td><td><a href="https://codegolf.stackexchange.com/questions/74864/making-a-coin-fair/75070#75070">Aleksi T</a></td></tr>
<tr d-ix="11"><td>066</td><td>Ruby</td><td>160307T231423Z</td><td><a href="https://codegolf.stackexchange.com/questions/74864/making-a-coin-fair/75043#75043">icy</a></td></tr>
<tr d-ix="12"><td>083</td><td>C#</td><td>160307T222406Z</td><td><a href="https://codegolf.stackexchange.com/questions/74864/making-a-coin-fair/75037#75037">Mormegil</a></td></tr>
<tr d-ix="13"><td>019</td><td>GNU sed</td><td>160307T184606Z</td><td><a href="https://codegolf.stackexchange.com/questions/74864/making-a-coin-fair/75014#75014">Toby Spe</a></td></tr>
<tr d-ix="14"><td>057</td><td>C</td><td>160307T181108Z</td><td><a href="https://codegolf.stackexchange.com/questions/74864/making-a-coin-fair/75007#75007">Toby Spe</a></td></tr>
<tr d-ix="15"><td>117</td><td>Java</td><td>160307T135840Z</td><td><a href="https://codegolf.stackexchange.com/questions/74864/making-a-coin-fair/74980#74980">user9023</a></td></tr>
<tr d-ix="16"><td>021</td><td>Perl</td><td>160305T175031Z</td><td><a href="https://codegolf.stackexchange.com/questions/74864/making-a-coin-fair/74880#74880">Doorknob</a></td></tr>
<tr d-ix="17"><td>021</td><td>Hexagony</td><td>160306T164645Z</td><td><a href="https://codegolf.stackexchange.com/questions/74864/making-a-coin-fair/74943#74943">Martin E</a></td></tr>
<tr d-ix="18"><td>008</td><td>MATL</td><td>160305T172122Z</td><td><a href="https://codegolf.stackexchange.com/questions/74864/making-a-coin-fair/74868#74868">Luis Men</a></td></tr>
<tr d-ix="19"><td>036</td><td>Mathematica</td><td>160305T202431Z</td><td><a href="https://codegolf.stackexchange.com/questions/74864/making-a-coin-fair/74898#74898">feersum</a></td></tr>
<tr d-ix="20"><td>012</td><td>Prelude</td><td>160306T161350Z</td><td><a href="https://codegolf.stackexchange.com/questions/74864/making-a-coin-fair/74941#74941">Martin E</a></td></tr>
<tr d-ix="21"><td>011</td><td>><></td><td>160306T152152Z</td><td><a href="https://codegolf.stackexchange.com/questions/74864/making-a-coin-fair/74940#74940">Sp3000</a></td></tr>
<tr d-ix="22"><td>012</td><td>Labyrinth</td><td>160305T194613Z</td><td><a href="https://codegolf.stackexchange.com/questions/74864/making-a-coin-fair/74895#74895">Sp3000</a></td></tr>
<tr d-ix="23"><td>033</td><td>JavaScript ES6</td><td>160305T174012Z</td><td><a href="https://codegolf.stackexchange.com/questions/74864/making-a-coin-fair/74877#74877">ETHprodu</a></td></tr>
<tr d-ix="24"><td>031</td><td>Labyrinth</td><td>160305T195201Z</td><td><a href="https://codegolf.stackexchange.com/questions/74864/making-a-coin-fair/74896#74896">Martin E</a></td></tr>
<tr d-ix="25"><td>029</td><td>Haskell</td><td>160305T173505Z</td><td><a href="https://codegolf.stackexchange.com/questions/74864/making-a-coin-fair/74874#74874">joeytwid</a></td></tr>
<tr d-ix="26"><td>066</td><td>C</td><td>160306T023328Z</td><td><a href="https://codegolf.stackexchange.com/questions/74864/making-a-coin-fair/74920#74920">aragaer</a></td></tr>
<tr d-ix="27"><td>033</td><td>sed</td><td>160305T181056Z</td><td><a href="https://codegolf.stackexchange.com/questions/74864/making-a-coin-fair/74884#74884">Doorknob</a></td></tr>
<tr d-ix="28"><td>033</td><td>JavaScript ES6</td><td>160305T203734Z</td><td><a href="https://codegolf.stackexchange.com/questions/74864/making-a-coin-fair/74899#74899">Neil</a></td></tr>
<tr d-ix="29"><td>039</td><td>Mathematica</td><td>160305T190317Z</td><td><a href="https://codegolf.stackexchange.com/questions/74864/making-a-coin-fair/74889#74889">Calculat</a></td></tr>
<tr d-ix="30"><td>042</td><td>Python</td><td>160305T184704Z</td><td><a href="https://codegolf.stackexchange.com/questions/74864/making-a-coin-fair/74886#74886">Sp3000</a></td></tr>
<tr d-ix="31"><td>048</td><td>Python 2</td><td>160305T172249Z</td><td><a href="https://codegolf.stackexchange.com/questions/74864/making-a-coin-fair/74870#74870">user4594</a></td></tr>
<tr d-ix="32"><td>009</td><td>Pyth</td><td>160305T172122Z</td><td><a href="https://codegolf.stackexchange.com/questions/74864/making-a-coin-fair/74869#74869">Doorknob</a></td></tr>
<tr d-ix="33"><td>008</td><td>CJam</td><td>160305T172436Z</td><td><a href="https://codegolf.stackexchange.com/questions/74864/making-a-coin-fair/74871#74871">Martin E</a></td></tr>
<tr d-ix="34"><td>014</td><td>Retina</td><td>160305T171943Z</td><td><a href="https://codegolf.stackexchange.com/questions/74864/making-a-coin-fair/74866#74866">Martin E</a></td></tr>
<tr d-ix="35"><td>006</td><td>Jelly</td><td>160305T173319Z</td><td><a href="https://codegolf.stackexchange.com/questions/74864/making-a-coin-fair/74873#74873">Dennis</a></td></tr>
<tr d-ix="36"><td>010</td><td>Pyth</td><td>160305T173135Z</td><td><a href="https://codegolf.stackexchange.com/questions/74864/making-a-coin-fair/74872#74872">isaacg</a></td></tr>
<tr d-ix="37"><td>041</td><td>Mathematica</td><td>160305T172016Z</td><td><a href="https://codegolf.stackexchange.com/questions/74864/making-a-coin-fair/74867#74867">LegionMa</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://github.com/Thunno/Thunno2" rel="nofollow noreferrer">Thunno 2</a>, 4 <a href="https://github.com/Thunno/Thunno2/blob/main/docs/codepage.md" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>²ıUṫ
</code></pre>
<p><a href="https://Not-Thonnu.github.io/run#aGVhZGVyPSZjb2RlPSVDMiVCMiVDNCVCMVUlRTElQjklQUImZm9vdGVyPSZpbnB1dD0nMTExMCclMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAtJTNFJTIwJTIwJzEnJTBBJzExMDAwMTEwJyUyMCUyMCUyMCUyMC0lM0UlMjAlMjAnMDEnJTBBJzExMDAwMTEnJTIwJTIwJTIwJTIwJTIwLSUzRSUyMCUyMCcwJyUwQScwMCclMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAtJTNFJTIwJTIwJyclMEEnMSclMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAtJTNFJTIwJTIwJyclMEEnJyUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMC0lM0UlMjAlMjAnJyUwQScxMTAxMDAxJyUyMCUyMCUyMCUyMCUyMC0lM0UlMjAlMjAnMCclMEEnMTAxMTEwMTAxMCclMjAlMjAtJTNFJTIwJTIwJzExMTEnJmZsYWdzPUNKZQ==" rel="nofollow noreferrer">Try it online!</a></p>
<p>Port of Dennis's Jelly answer.</p>
<h4>Explanation</h4>
<pre class="lang-python prettyprint-override"><code>²ıUṫ  # Implicit input
²     # Split into pairs
 ı    # Map over this list:
  U   #  Uniquify the pair
   ṫ  #  Remove the last character
      # Implicit output
</code></pre>
</div>
<div id="pu1" class="pu"><h1><a href="https://github.com/ConorOBrien-Foxx/str" rel="nofollow noreferrer">str</a>, 11 bytes</h1>
<pre><code>gd0H=N~e&gt;*x
</code></pre>
<p><a href="https://tio.run/##Ky4p@v8/PcXAw9avLtVOq@L/f0NDA0MDA0MA" rel="nofollow noreferrer" title="str – Try It Online">Try it online!</a></p>
<p>Alternative 11 byte solution: <code>dgdb=Nue&gt;*x</code></p>
<p>If we didn't have to handle the edge case of an unpaired toss (i.e., the input was always even), then the solution would be 5 bytes: <code>dg=Nx</code>.</p>
<h2>Explanation</h2>
<p>str iterates implicitly over each character of the input. However, since it does not consume all the input at once, we can iterate over <em>pairs</em> of characters by manually taking the second character as input with <code>g</code>. Let <code>c1</code> be the first character and <code>c2</code> be the second.</p>
<pre><code>gd0H=N~e&gt;*x      stack: [c1]
g                stack: [c1, c2]
 d               stack: [c1, c2, c2] - duplicate
  0H             stack: [c1, c2, c2, c1] - get the first member of the stack
    =            stack: [c1, c2, (c2==c1)] - equality
     N           stack: [c1, c2, (c2!=c1)] - negate (inequality)
      ~          stack: [c1, (c2!=c1), c2] - swap top 2
       e         stack: [c1, (c2!=c1), c2, ``] - push empty string
        &gt;        stack: [c1, (c2!=c1), c2&gt;``] - test for end of input
         *       stack: [c1, Q] - Q is, if the two characters don't match
                                  AND we didn't read past the input
          x      stack: [c1 x Q] - c1 repeated once if Q, zero times if not
</code></pre>
</div>
<div id="pu2" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="nofollow noreferrer">Jelly</a>, 4 bytes</h1>
<pre><code>ḟ2/ḟ
</code></pre>
<p><a href="https://tio.run/##y0rNyan8///hjvlG@kDi/@H2R01rIv//Vzc0NDRQ1wFSBgYGKEwgywDMBWKIKFAcxAEywBygYgA" rel="nofollow noreferrer" title="Jelly – Try It Online">Try it online!</a></p>
<p>Full program, but the link still runs all test cases, since they still get the smash-print treatment.</p>
<pre><code> 2/     Split the input into slices of length 2, then reduce each slice by
ḟ       remove elements of right from left.
        This produces a list of empty lists and singleton lists,
        except if the length of the input is odd the last element is entirely unaffected.
   ḟ    Remove elements of the input from that result.
        This removes the odd element if there is one, and nothing else,
        since it is necessarily an element of the input, and everything else is a list.
</code></pre>
</div>
<div id="pu3" class="pu"><h1><a href="http://esolangs.org/wiki/Beeswax" rel="nofollow noreferrer">beeswax</a>, <del>45</del> 35 bytes</h1>
<p>I could golf it down by 10 bytes—not too bad.</p>
<pre><code>pgy~1z;L?gAF1&lt;&lt;?V_
&gt;&amp;?@yg&amp;?~@ KQd{b
</code></pre>
<p>I took the <em>reading a full string of coin tosses approach</em>, which makes the program pretty large. Just reading single integers one by one would make the program smaller—maybe around 22 bytes or so—but also very inconvenient to use.</p>
<p>Examples:</p>
<pre><code>julia&gt; beeswax(&quot;FairCoin.bswx&quot;)
s1110
1
Program finished!

julia&gt; beeswax(&quot;FairCoin.bswx&quot;)
s11000110
01
Program finished!

julia&gt; beeswax(&quot;FairCoin.bswx&quot;)
s1100011
0
Program finished!

julia&gt; beeswax(&quot;FairCoin.bswx&quot;)
s00

Program finished!

julia&gt; beeswax(&quot;FairCoin.bswx&quot;)
s10101001010111111100000010011001110100010110101110100001011
1110001010000111100
Program finished!
</code></pre>
<p><a href="https://github.com/m-lohmann/BeeswaxEsolang.jl" rel="nofollow noreferrer">My beeswax GitHub repository.</a></p>
<p><a href="http://rosettacode.org/wiki/Category:Beeswax" rel="nofollow noreferrer">My beeswax examples on Rosetta Code.</a></p>
</div>
<div id="pu4" class="pu"><h1>DOS/Windows Batch, <s>201</s> 162 bytes</h1>
<pre><code>@echo off
set/pi=
:a
for /f &quot;tokens=2&quot; %%a in (&quot;%i%&quot;) do goto l
exit/b
:l
for /f &quot;tokens=1,2&quot; %%a in (&quot;%i:~0,4%&quot;) do if %%a neq %%b echo %%a
set &quot;i=%i:~4%&quot;
goto a
</code></pre>
<p>Input is a space seperated string, for example <code>1 0 0 1 1</code>.
Start from cmd, otherwise the screen exits immediately</p>
</div>
<div id="pu5" class="pu"><h1>brainfuck, 33 bytes</h1>
<pre><code>,&gt;,[&lt;[-&gt;-&gt;+&lt;&lt;]&gt;[[-]&gt;.&lt;]&gt;[-]&lt;&lt;,&gt;,]
</code></pre>
<p>Compared to Java, this is very compact, however, I'm afraid of brainfuck-golfer answerer. And feel free to mention if there's a bug. Assuming EOF is 0, input doesn't contain invalid input, the cell is initially zero, and the cell value range is finite and cyclic. No other assumption is present.</p>
<p>Explanation:</p>
<p>Memory Cell Map</p>
<pre><code>+---------+---------+-----------------+
|1st input|2nd input|copy of 1st input|
+---------+---------+-----------------+
</code></pre>
<p>Instruction</p>
<pre><code>,&gt;,                               read two instruction at once | first to first cell |
                                  second to second cell
   [                              Until the input is EOF
    &lt;                             look at first cell
     [-&gt;-&gt;+&lt;&lt;]                    move the first cell to additional cells while
                                  subtracting the second cell with this at same
                                  time
              &gt;[                  if the second cell is nonzero (it means that first cell and
                                  the second cell is the same)
                [-]&gt;.&lt;            Print the copied first input
                      ]
                       &gt;[-]       clear the first input to prevent it polluting next input
                           &lt;&lt;,&gt;,  continue with next two input
                                ]
                   
</code></pre>
</div>
<div id="pu6" class="pu"><h1>Ruby, 46 bytes</h1>
<p>This separates <code>l[0]</code>, <code>l[1]</code> and <code>l[2..{end}]</code> as <code>a</code>, <code>b</code> and <code>c</code>. Then it creates a string with <code>a</code> if <code>a!=b</code> or <code>''</code> otherwise and <code>f[c]</code> if <code>c[0]</code> exists or <code>''</code> otherwise.</p>
<pre><code>f=-&gt;l{a,b,*c=l;&quot;#{a!=b ?a:''}#{c[0]?f[c]:''}&quot;}
</code></pre>
<p><strong>Ungolfed:</strong></p>
<pre><code>def f(l)
  a = l[0]
  b = l[1]
  c = l[2..l.length]
  s = ''
  if a!=b
    s += a.to_s
  end
  if c[0]       # equivalent to !c.empty?
    s += f[c]   # no .to_s because the output will be a string
  end
  puts s
end
</code></pre>
</div>
<div id="pu7" class="pu"><h2><a href="https://esolangs.org/wiki/Befunge" rel="nofollow">Befunge 93</a>, 16 bytes</h2>

<pre><code>~:~:0`!#@_-&gt;#,_$
</code></pre>

<p>A one-liner for compactness. Tested using <a href="http://www.quirkster.com/iano/js/befunge.html" rel="nofollow">this online interpreter</a>.</p>

<pre><code>~:                     Read input char a and dup
  ~                    Read input char b (-1 on EOF)
   :0`!                Push 1 if b &lt;= 0, 0 otherwise
       #@_             Halt if b &lt;= 0 (i.e. EOF)
          -            Subtract to check whether a != b
           &gt;#,_$       Output a if so
</code></pre>

<p>The last part makes use of the fact that <a href="http://catseye.tc/view/befunge-93/doc/Befunge-93.markdown" rel="nofollow">popping from an empty Befunge-93 stack yields 0</a>.</p>

<p>If <code>a != b</code>, we perform</p>

<pre><code>&gt;                      Move rightward
#                      Bridge: skip next
_                      Horizontal if - go right if 0, else left. But a != b, so we go left
,                      Output a
#                      Bridge: skip next
-                      Subtract (0 - 0 = 0)
_                      If: go right since 0 is popped
&gt;#                     Go right and skip next
_                      If: go right since 0 is popped
$                      Pop top of stack, stack is now empty
</code></pre>

<p>Otherwise, if <code>a == b</code>, we perform:</p>

<pre><code>&gt;                      Move rightward
#                      Bridge: skip next
_                      If: go right since a == b (i.e. a-b is 0)
$                      Pop top of stack and discard, keeping stack empty
</code></pre>
</div>
<div id="pu8" class="pu"><h1>Perl, <s>19</s> <s>18</s> 17 bytes</h1>

<p>@Martin Büttner Retina solution inspired a 2 byte gain</p>

<p>Includes +1 for <code>-p</code></p>

<p>Run with the input on STDIN, e.g. <code>perl -p fair.pl &lt;&lt;&lt; 11000110</code></p>

<p><code>fair.pl</code>:</p>

<pre><code>s/(.)\1|.?\K.//g
</code></pre>

<p>Not much to explain here since it is an (indirect) translation of the specification:</p>

<ul>
<li><code>(.)\1</code> If the first 2 digits are the same, drop them</li>
<li><code>.\K.</code>  Otherwise the first two digits are different. Keep (<code>\K</code>) the first one</li>
<li><code>.?\K.</code> Except that the first <code>.</code> is optional. This allows for a single match at the end of the string which then gets discarded since the kept part is empty</li>
</ul>
</div>
<div id="pu9" class="pu"><h1><a href="https://esolangs.org/wiki/Befunge" rel="nofollow noreferrer">Befunge-93</a>, 40 bytes</h1>
<pre><code>v  ,-1&lt;
      | -&lt;
&gt;~1+:~1+:|
^     &lt;  @
</code></pre>
<p>You can <a href="http://www.quirkster.com/iano/js/befunge.html" rel="nofollow noreferrer">try it here</a>. Paste code in the space under the &quot;show&quot; button, press &quot;show&quot;, define input, press &quot;run&quot;. Our use the &quot;step&quot; button to see how the program works.</p>
</div>
<div id="pu10" class="pu"><h1>Python, 72 bytes</h1>

<p>This definitely won't be the shortest, but hopefully it'll at least give someone a headache.</p>

<pre class="lang-python prettyprint-override"><code>lambda s:hex(int('110'+s[::-1],4))[:3:-1].translate({48:'',53:'',52:48})
</code></pre>
</div>
<div id="pu11" class="pu"><h1>Ruby, 66 bytes</h1>

<p>initial attempt; likely room for improvement. Run with "ruby -n" and then enter input followed by enter key.
</p>

<pre><code>$_.chomp!;i,s=0,'';(s&lt;&lt;$_[i] if $_[i]!=$_[i+1];i+=2)until !$_[i+1];p s
</code></pre>
</div>
<div id="pu12" class="pu"><h1>C#, 83 bytes</h1>

<pre class="lang-cs prettyprint-override"><code>int[]M(int[]x)=&gt;x.Select((v,i)=&gt;i%2&gt;0&amp;&amp;x[i-1]!=v?x[i-1]:2).Where(v=&gt;v&lt;2).ToArray();
</code></pre>

<p>First, replace odd-numbered items which are not equal to their predecessors with the predecessor, while setting all the rest to 2, then drop all items equal to 2.</p>
</div>
<div id="pu13" class="pu"><h1>GNU sed, 19 bytes</h1>
<pre><code>#!/bin/sed -rf
s/11|00|(.?)./\1/g
</code></pre>
<p>Simple and boring translation of <a href="/a/74866/39490">Martin Büttner♦'s Retina solution</a>.  Except that I used <code>11|00</code> in place of <code>.(\1)</code> (for the same score).  18 bytes of code, plus one for the <code>-r</code>.</p>
</div>
<div id="pu14" class="pu"><h1>C, 57 bytes</h1>

<pre class="lang-c prettyprint-override"><code>f(char*p,char*r){for(;*p*p[1];)*r=*p++,r+=*r!=*p++;*r=0;}
</code></pre>

<p>We tentatively copy a character from input <code>p</code> to result <code>r</code>, but only advance the <code>r</code> pointer if it differs from the next character.  If not, then we'll overwrite it at the next unmatched pair, or with <code>NUL</code> at the end.</p>

<h2>Test program:</h2>

<pre class="lang-c prettyprint-override"><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
int main(int argc, char **argv) {
    while (*++argv) {
        char *result = malloc(1+strlen(*argv));
        f(*argv, result);
        printf("%s =&gt; %s\n", *argv, result);
        free(result);
    }
    return EXIT_SUCCESS;
}
</code></pre>

<h2>Test output:</h2>

<pre class="lang-none prettyprint-override"><code>$ ./74864 1110 11000110 1100011 00 1 "" 1101001 1011101010
1110 =&gt; 1
11000110 =&gt; 01
1100011 =&gt; 0
00 =&gt; 
1 =&gt; 
 =&gt; 
1101001 =&gt; 0
1011101010 =&gt; 1111
</code></pre>
</div>
<div id="pu15" class="pu"><h1>Java 117 bytes</h1>
<p>(or 10 if we consider numerical system with base 117)</p>
<pre><code>String z(char[]s){String r=&quot;&quot;;for(int i=0,x=-1;++x&lt;s.length/2;i+=2)r+=(s[i]==s[i+1]?&quot;&quot;:s[i]=='0'?&quot;0&quot;:&quot;1&quot;);return r;}
</code></pre>
</div>
<div id="pu16" class="pu"><h2>Perl, <s>27</s> 21 bytes</h2>

<pre><code>say grep$_-chop,/../g
</code></pre>

<p>Byte added for the <code>-n</code> flag.</p>

<pre><code>                /../g  match groups of two chars
    grep       ,       select/filter on...
           chop        remove the last character, mutating the string
        $_-            is it different than the remaining char?
                         (subtract it, empty string is falsy)
say                    output if so
</code></pre>

<p>Test:</p>

<pre><code>llama@llama:~$ perl -nE 'say grep$_-chop,/../g'
1110
1
11000110
01
1100011
0
00

1



1101001
0
1011101010
1111
</code></pre>

<p>Thanks to <a href="https://codegolf.stackexchange.com/users/51507/ton-hospel">@TonHospel</a> for 6 bytes!</p>
</div>
<div id="pu17" class="pu"><h2><a href="https://github.com/mbuettner/hexagony" rel="nofollow noreferrer">Hexagony</a>, <s>23</s> 21 bytes</h2>

<pre><code>,){,/;(_\/'%&lt;\{)/&gt;~$&gt;
</code></pre>

<p>Unfolded:</p>

<pre><code>    , ) { ,
   / ; ( _ \
  / ' % &lt; \ {
 ) / &gt; ~ $ &gt; .
  . . . . . .
   . . . . .
    . . . .
</code></pre>

<p>This terminates with an error, but the error message goes to STDERR.</p>

<p><a href="http://hexagony.tryitonline.net/#code=LCl7LC87KF9cLyclPFx7KS8-fiQ-&amp;input=MDExMTEwMTAwMDExMA" rel="nofollow noreferrer">Try it online!</a></p>

<p>Judging by the number of mirrors it might be just about possible to fit it into side-length 3 but I've had no luck so far.</p>

<h3>Explanation</h3>

<p>Here's the usual diagram, generated with Timwi's <a href="https://github.com/Timwi/HexagonyColorer" rel="nofollow noreferrer">HexagonyColorer</a>:</p>

<p><a href="https://i.stack.imgur.com/PxJ48.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/PxJ48.png" alt="enter image description here"></a></p>

<p>The program uses only three memory edges, labelled <strong>A</strong>, <strong>B</strong>, and <strong>C</strong> here (diagram courtesy of Timwi's <a href="https://github.com/Timwi/EsotericIDE" rel="nofollow noreferrer">EsotericIDE</a>):</p>

<p><a href="https://i.stack.imgur.com/WSfxF.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/WSfxF.png" alt="enter image description here"></a></p>

<p>Execution starts on blue path. The <code>/</code> are just mirrors that redirect the instruction pointer (IP), the actual code is:</p>

<pre><code>,   Read character from STDIN into memory edge A.
)   Increment.
{   Move to memory edge B.
,   Read character from STDIN into memory edge B.
)   Increment.
'   Move to memory edge C.
%   Compute A mod B in memory edge C.
</code></pre>

<p>The <code>,</code> will set the edge to <code>-1</code> instead of the character code if we've hit EOF. Since we're incrementing both inputs that doesn't change whether they are equal or not, but it turns EOF into <code>0</code>.</p>

<p>We use modulo to check for equality, because it's either <code>1</code> or <code>49</code> (positive) for unequal characters and <code>0</code> for equal characters. It also serves as the end of the program, because when we have the <code>0</code> from EOF, the attempted division by zero will cause an error.</p>

<p>Now the <code>&lt;</code> distinguishes zeroes from positive results. The simple one first: if the characters are equal, the IP takes the red path. <code>_</code> is a mirror, <code>\</code> is also a mirror but gets ignored, and <code>&gt;</code> deflects the IP such that it wraps around the edges and starts from the top again. However, on this iteration, the roles of <strong>A</strong>, <strong>B</strong> and <strong>C</strong> are swapped cyclically (<strong>C</strong> now takes the role of <strong>A</strong> and so on).</p>

<p>If the characters are different, the green path is taken instead. This one's a bit messier. It first jumps over a no-op with <code>$</code>, then wraps around to the <code>/</code> on the left edge, then traverses the second-to-last row from right to left and finally re-enters the interesting part of the source code at the <code>{</code>. There's an essentially linear bit of code, that I'll explain in a second, before the <code>$</code> makes the IP jump over the <code>&gt;</code> to merge the two paths again.</p>

<p>Here is that linear piece of code:</p>

<pre><code>{    Move to memory edge A.
(    Decrement to recover the actual character we read.
;    Print the character back to STDOUT.
'    Move to memory edge B.
~    Multiply the value there by -1, making it negative. This is
     necessary to ensure that the path correctly wraps back to the top.
</code></pre>

<p>Note that in this case, the roles of the edges for the next iteration are also swapped cyclically, but with <strong>B</strong> taking the role of <strong>A</strong> and so on.</p>
</div>
<div id="pu18" class="pu"><h1><a href="https://esolangs.org/wiki/MATL" rel="nofollow">MATL</a>, <s>11</s> <s>9</s> 8 bytes</h1>

<pre><code>`-?6MD]T
</code></pre>

<p>Input and output are numbers separated by newlines. Ends with an error (allowed by default) when all inputs have been consumed.</p>

<p><a href="http://matl.tryitonline.net/#code=YC0_Nk1EXVQ&amp;input=MQowCjEKMQoxCjAKMQowCjEKMAo" rel="nofollow"><strong>Try it online!</strong></a></p>

<pre><code>`         % do...while loop
  -       %   take two inputs implicitly. Compute difference
  ?       %   if nonzero
    6M    %     push first of the two most recent inputs again
    D     %     display (and remove from stack)
  ]       %   end if
  T       %   true. Used as loop condition, so the loop is infinite
          % end loop implicitly
</code></pre>

<h2>Old approach, 11 bytes</h2>

<pre><code>2YCd9L)Xz0&lt;
</code></pre>

<p>Input is a string. Output is numbers separated by newlines.</p>

<p><a href="http://matl.tryitonline.net/#code=MllDZDlMKVh6MDw&amp;input=JzEwMTExMDEwMTAnCg" rel="nofollow">Try it online!</a></p>

<pre><code>2YC      % implicitly take input as a string. Generate 2D array of length-2
         % overlapping blocks as columns, padding with a zero if needed.
d        % difference of the two values in each column of that array
9L       % predefined literal [1 2 0]. This corresponds to "1:2:end" indexing
)        % keep only values at indices 1, 3, 5, ... This reduces the set of blocks
         % to non-overlapping, and discards the last (padded) block if the input had
         % odd length
Xz       % keep only nonzero entries, corresponding to blocks that had different values
0&lt;       % 1 if negative, 0 if possitive. Implicitly display
</code></pre>
</div>
<div id="pu19" class="pu"><h1>Mathematica, 36 <s> 38 </s> bytes</h1>
<p>-2 after stealing @LegionMammal978's function for determining if a 2-element list is {0,1} or {1,0}</p>
<pre><code>#&amp;@@@Select[#~Partition~2,Tr@#==1&amp;]&amp;
</code></pre>
<p>Argument is expected to be a list of integers.</p>
</div>
<div id="pu20" class="pu"><h2><a href="http://esolangs.org/wiki/Prelude" rel="nofollow">Prelude</a>, 12 bytes</h2>

<pre><code>11(-(#!)?^?)
</code></pre>

<p>This assumes an interpreter that reads and prints characters. <a href="http://prelude.tryitonline.net/#code=MTEoLSgjISk_Xj8p&amp;input=MTAxMTEwMTAxMA" rel="nofollow">You can sort of try it online.</a> But that interpreter prints integers, so for each <code>0</code> you'll get <code>48</code> and for each <code>1</code> you'll get <code>49</code> instead (and a linefeed).</p>

<h3>Explanation</h3>

<p>It's very rare that you can write a non-trivial program on a single line in Prelude (because Prelude needs more than one line to be Turing-complete).</p>

<pre><code>11      Push two 1s. We need something non-zero on the stack to enter the loop, and by
        pushing the same value twice, we make sure that the loop doesn't print anything
        on the first iteration.
(       Main loop...
  -       Subtract the last two values. This will be zero for equal values, and non-zero
          otherwise...
  (       This "loop" is simply used as a conditional: if the last two values were
          were equal, skip the code inside...
    #       Discard the conditional.
    !       Print the value below.
  )       The loop is exited because the value below is always zero.
  ?       Read the first character of the next pair from STDIN.
  ^       Duplicate it, so the lower copy can be printed.
  ?       Read the second character of the pair. This returns 0 at EOF, which
          terminates the loop.
)
</code></pre>
</div>
<div id="pu21" class="pu"><h2><a href="https://esolangs.org/wiki/Fish" rel="nofollow">>&lt;></a>, 11 bytes</h2>

<pre><code>i:i:0(?;-?o
</code></pre>

<p>>&lt;> is pretty well suited to read-a-char-at-a-time challenges like this :) <a href="http://fish.tryitonline.net/#code=aTppOjAoPzstP28&amp;input=MTExMDAxMDAwMDEw" rel="nofollow">Try it online!</a></p>

<pre><code>i:            Read char and duplicate
i             Read char
:0(?;         Halt if last char was EOF
-             Subtract
?o            Output first char if the subtraction was non-zero (i.e. not equal)
</code></pre>

<p>This all happens in a loop since the instruction pointer wraps around once it reaches the end of a line.</p>
</div>
<div id="pu22" class="pu"><h2><a href="http://github.com/mbuettner/labyrinth" rel="nofollow noreferrer">Labyrinth</a>, <s>21</s> 12 bytes</h2>

<pre><code>"(. :
""*$,@
</code></pre>

<p><s>A rare example of a compact Labyrinth program that also has no no-ops.</s> The <code>|</code> in the previous version was completely unnecessary, and removing it massively reduced the size of the program. In fact, Lab's beating Retina!</p>

<p><a href="http://labyrinth.tryitonline.net/#code=IiguIDoKIiIqJCxA&amp;input=MDExMTAwMTAwMTEwMDAwMDAwMTA" rel="nofollow noreferrer">Try it online!</a></p>

<p>The bottom-left <code>"</code> can also be a space, but having it there greatly simplifies the explanation.</p>

<h2>Explanation</h2>

<p>This one's a little trickier, so it's accompanied by images. But first, a quick primer:</p>

<ul>
<li>Labyrinth is a stack-based 2D language. Memory consists of a main stack and an auxiliary stack.</li>
<li>Labyrinth's stacks are bottomless and filled with zeroes, so performing operations on an empty stack is not an error.</li>
<li>At each junction, where there are two or more paths for the instruction pointer to go, the top of the main stack is checked to figure out where to go next. Negative is turn left, zero is straight ahead and positive is turn right. If a turn fails, the pointer tries to turn in the other direction.</li>
</ul>

<h3>Setup</h3>

<p><a href="https://i.stack.imgur.com/VrV1K.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/VrV1K.png" alt="enter image description here"></a></p>

<p>The program starts at the top-left <code>"</code>, which is a no-op. Then we perform:</p>

<pre><code>(        Decrement a bottom zero to -1. Since -1 is negative we try to turn 
         left at this junction, fail, and turn right instead.
"        No-op junction, turn left
*        Multiply top of stack (-1) with a 0 at bottom of stack, giving 0.
         This makes us go straight ahead at this junction.
$        Bitwise xor (of 0 and 0)
</code></pre>

<p>This leaves the stack with a single 0 on it, which is as good as empty for the purposes of Labyrinth.</p>

<h3>Reading input and termination</h3>

<p><a href="https://i.stack.imgur.com/7uz88.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/7uz88.png" alt="enter image description here"></a></p>

<p><code>,</code> reads a char from input, returning 48 or 49 for <code>0</code> or <code>1</code> respectively, and -1 on EOF. Since this is nonzero, either way we turn into the <code>:</code>, which duplicates the top of the stack.</p>

<p>The <code>:</code> is at a dead-end, so we turn around and execute <code>,</code> once more. Now if the last input was EOF, then we turn left and terminate with <code>@</code>, else we turn right, with the stack looking like <code>[a a b]</code> (where <code>a</code>, <code>b</code> are the two chars).</p>

<h3>Interpreting the coin toss</h3>

<p><a href="https://i.stack.imgur.com/5c5Rl.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/5c5Rl.png" alt="enter image description here"></a></p>

<p>If we didn't terminate, our next move is to execute <code>$</code> (bitwise xor) again. This yields 0 if the input chars were the same, 1 otherwise. We then multiply <code>a</code> with this result, giving either 0 or <code>a</code>. Since the <code>*</code> is at a junction, this top stack value determines what happens next.</p>

<p>In the 0 case, we go straight ahead and execute three <code>"</code> no-ops, before perform a <code>(</code> decrement. Like the setup, this makes us turn and execute <code>"*$</code>, leaving us ready to read more chars.</p>

<p><a href="https://i.stack.imgur.com/tIdrY.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/tIdrY.png" alt="enter image description here"></a></p>

<p>Otherwise, in the <code>a</code> case, we turn right at the junction since <code>a</code> is positive (48 or 49). <code>.</code> outputs the char, leaving the stack empty, and <code>(</code> decrements the top of the stack, turning a 0 to -1. Once again, this makes us turn left, executing <code>"*$</code> like in the setup, also leaving us ready to read more input.</p>
</div>
<div id="pu23" class="pu"><h1>JavaScript (ES6), 33 bytes</h1>

<pre class="lang-js prettyprint-override"><code>s=&gt;s.filter((c,i)=&gt;++i%2&amp;c!=s[i])
</code></pre>
<h3>How it works</h3>
<pre class="lang-js prettyprint-override"><code>s=&gt;s                // Take the input array.
.filter((c,i)=&gt;   ) // Filter to only the chars that are both:
++i%2&amp;              //  on an even index, and
c!=s[i]             //  not equal to the one after them.
</code></pre>
</div>
<div id="pu24" class="pu"><h2><a href="https://github.com/mbuettner/labyrinth" rel="nofollow">Labyrinth</a>, 31 bytes</h2>

<p>Not as short and neat as Sp3000's solution, but I thought I'd post this anyway as a different approach:</p>

<pre><code>"" @
,, :{"
)  { $;
*"})";.
 ""
</code></pre>

<h3>Explanation</h3>

<p>The first loop is simply</p>

<pre><code>""
,,
</code></pre>

<p>which reads in two characters at a time (the <code>"</code> are no-ops). After EOF, <code>,</code> will return <code>-1</code>, but only check for EOF at every second character. That means in any case the top of the stack will then be <code>-1</code> and the value below is either <code>-1</code> or some character code that we don't care about, because it's an unpaired coin toss.</p>

<p>Then <code>)*</code> turns the <code>-1</code> and the value below into a single <code>0</code> which we need a) to get rid of those two values and b) to enter the next loop correctly. That next loop is simply</p>

<pre><code>"}
""
</code></pre>

<p>Which shifts all the values over to the auxiliary stack. This is necessary because we want to start processing the pairs that we read first. Now the final loop:</p>

<pre><code>:{"
{ $;
)";.
</code></pre>

<p>The <code>)</code> just increments some dummy value to ensure that it's positive and the instruction pointer turns north. <code>{</code> pulls over the first digit of the next pair and <code>:</code> duplicates it. Now when we're done processing, this will have been a <code>0</code> from the bottom of the auxiliary stack. Otherwise it's either <code>48</code> or <code>49</code>. In case of a zero, we exit the loop and terminate on <code>@</code>, otherwise, the IP turns east.</p>

<p><code>{</code> pulls over the other digit of the current pair. <code>$</code> takes the XOR between them. If that is 0, i.e. the two are equal, the IP just continues moving south, <code>;</code> discards the zero, and the IP turns west into the next iteration. If the XOR was <code>1</code>, i.e. they were different, the IP turns west, discards the <code>1</code> with <code>;</code> and prints the first digit with <code>.</code>.</p>
</div>
<div id="pu25" class="pu"><h2>Haskell, <s>71</s> <s>44</s> 29 bytes</h2>

<pre><code>p(a:b:r)=[a|a/=b]++p r
p _=[]
</code></pre>

<p>Extreme golfing by <a href="https://codegolf.stackexchange.com/users/34531/nimi">nimi</a>.</p>
</div>
<div id="pu26" class="pu"><h1>C, 66 bytes</h1>

<pre><code>main(char*p,char**x){for(p=x[1];*p&amp;p[1];p+=2)write(1,p,*p^p[1]);}
</code></pre>

<p>Assuming <code>sizeof(int) == sizeof(char *)</code></p>

<h1>"clever" solution - <s>84</s> 81 bytes</h1>

<pre><code>main(int c,short**x){while(!((c=*x[1]++-12336)&amp;~511))c&gt;&gt;8^c&amp;1&amp;&amp;putchar(48|c&amp;1);}
</code></pre>

<p>Works on little-endian machine assuming <code>short</code> is 2 bytes. Input is passed as argument. The program iterates over pairs of characters and prints 0 for 0x3130 and 1 for 0x3031. On big-endian the result will be reversed (replace <code>48|c&amp;1</code> with <code>49^c&amp;1</code> to fix this).</p>
</div>
<div id="pu27" class="pu"><h2>sed, <s>34</s> 33 bytes</h2>

<pre><code>s/../&amp; /g;s/00\|11//g;s/.\b\| //g
</code></pre>

<p>Test:</p>

<pre><code>llama@llama:~$ sed 's/../&amp; /g;s/00\|11//g;s/.\b\| //g'             
1110
1
11000110
01
1100011
0
00

1



1101001
0
1011101010
1111
</code></pre>
</div>
<div id="pu28" class="pu"><h2>JavaScript (ES6), 33 bytes</h2>

<pre><code>s=&gt;s.replace(/(.)\1|(.)?./g,"$2")
</code></pre>

<p>Boring port of the Retina answer.</p>
</div>
<div id="pu29" class="pu"><h1>Mathematica, <s>41</s> 39 bytes</h1>

<pre><code>Select[#~Partition~2,Tr@#==1&amp;][[1]]&amp;
</code></pre>

<p>Less complicated and shorter than the other answer.
The box is a transpose character.</p>
</div>
<div id="pu30" class="pu"><h2>Python, 42 bytes</h2>

<pre class="lang-py prettyprint-override"><code>f=lambda L:L[1:]and L[:L[0]^L[1]]+f(L[2:])
</code></pre>

<p>Fun with recursion and bitwise xor. Takes a list of 1s and 0s as input.</p>
</div>
<div id="pu31" class="pu"><h2>Python 2, 48 bytes</h2>
<pre class="lang-py prettyprint-override"><code>lambda n:[s for s,t in zip(*[iter(n)]*2)if s!=t]
</code></pre>
<p><a href="http://ideone.com/fork/Z0IvyV" rel="nofollow noreferrer">Try it online</a></p>
<p>Thanks to Dennis and vaultah for pointing out stuff that I missed</p>
</div>
<div id="pu32" class="pu"><h2>Pyth, <s>10</s> 9 bytes</h2>

<pre><code>jkPM{Mcz2
</code></pre>

<p>Algorithm shamelessly stolen from <a href="https://codegolf.stackexchange.com/a/74873/3808">Dennis's Jelly answer</a>.</p>

<pre><code>       z    input
      c 2   chunks of 2
    {M      dedup each chunk
  PM        all-but-last element of each chunk
jk          join on empty string; can't use `s' because that gives `0' for []
</code></pre>
</div>
<div id="pu33" class="pu"><h2>CJam, <s>10</s> 8 bytes</h2>

<pre><code>l2/{)-}%
</code></pre>

<p><a href="http://cjam.aditsu.net/#code=l2%2F%7B)-%7D%25&amp;input=1011101010">Test it here.</a></p>

<h3>Explanation</h3>

<p>This is a very simple solution: in each pair, remove all instances of the last character. Repeated digits and unpaired trailing digits will be removed, as will be the second digit in any pair of unequal digits:</p>

<pre><code>"0"  --&gt; ""
"1"  --&gt; ""
"00" --&gt; ""
"01" --&gt; "0"
"10" --&gt; "1"
"11" --&gt; ""
</code></pre>

<p>This leaves only the digits we're looking for. Here's how the code computes this:</p>

<pre><code>l     e# Read input.
2/    e# Split into pairs. Odd inputs will yield a single-character string at the end.
{     e# Map this block over the pairs...
  )   e#   Pull the last character off the string.
  -   e#   Remove all occurrences of that character from the remainder (which is either
      e#   an empty string to begin with or a single-digit string).
}%
</code></pre>

<p>When the list is auto-printed at the end of the program, the empty strings are simply omitted.</p>
</div>
<div id="pu34" class="pu"><h2><a href="https://github.com/mbuettner/retina/">Retina</a>, <s>16</s> 14 bytes</h2>

<pre><code>(.)\1|(.)?.
$2
</code></pre>

<p><a href="http://retina.tryitonline.net/#code=KC4pXDF8KC4pPy4KJDI&amp;input=MTAxMTEwMTAxMDE">Try it online!</a></p>

<h3>Explanation</h3>

<p>This is fairly simple. The code defines a single regex substitution replacing all (non-overlapping) matches of <code>(.)\1|(.)?.</code> with whatever the second group captured. This combines three different cases into one:</p>

<pre><code>(.)\1 --&gt; &lt;empty&gt;
</code></pre>

<p>If two repeated digits are equal, we remove them from the string (because group 2 is unused).</p>

<pre><code>(.).  --&gt; $2
</code></pre>

<p>Otherwise, if we can match two characters, remove the second one, by replacing both of them with the first. If that's not the case the <code>?</code> will omit the group:</p>

<pre><code>.     --&gt; &lt;empty&gt;
</code></pre>

<p>This only happens if there is an unpaired trailing character, which is also removed.</p>
</div>
<div id="pu35" class="pu"><h1>Jelly, 6 bytes</h1>

<pre><code>s2Q€Ṗ€
</code></pre>

<p><a href="http://jelly.tryitonline.net/#code=czJR4oKs4bmW4oKs&amp;input=&amp;args=JzExMDAwMTEwJw" rel="noreferrer">Try it online!</a></p>

<h3>How it works</h3>

<pre><code>s2Q€Ṗ€  Main link. Argument: S (string)

s2      Split the string into pairs of characters.
  Q€    Deduplicate each pair.
        This removes the second character iff it is equal to the first.
    Ṗ€  Pop each; remove the last character of each pair/singleton.
</code></pre>
</div>
<div id="pu36" class="pu"><h1>Pyth, 10 bytes</h1>

<pre><code>hMf!qFTcz2
</code></pre>

<p><a href="https://pyth.herokuapp.com/?code=hMf%21qFTcz2&amp;input=1110%0A11000110%0A1100011%0A00%0A1%0A%0A1101001%0A1011101010&amp;test_suite=1&amp;test_suite_input=1110%0A11000110%0A1100011%0A00%0A1%0A%0A1101001%0A1011101010&amp;debug=0" rel="nofollow">Test suite</a></p>
</div>
<div id="pu37" class="pu"><h1>Mathematica, 41 bytes</h1>

<pre><code>Cases[#~Partition~2,a_/;Tr@a==1:&gt;a[[1]]]&amp;
</code></pre>

<p>Anonymous function that inputs and outputs lists of zeros and ones.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/74864/">74864</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




