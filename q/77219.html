<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::77219</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>067</td><td>Perl 5</td><td>240221T192028Z</td><td><a href="https://codegolf.stackexchange.com/questions/77219/diamondize-a-matrix/270217#270217">Xcali</a></td></tr>
<tr d-ix="1"><td>275</td><td>Vyxal</td><td>240221T131059Z</td><td><a href="https://codegolf.stackexchange.com/questions/77219/diamondize-a-matrix/270209#270209">pacman25</a></td></tr>
<tr d-ix="2"><td>019</td><td>Pip</td><td>220921T225028Z</td><td><a href="https://codegolf.stackexchange.com/questions/77219/diamondize-a-matrix/252139#252139">emanresu</a></td></tr>
<tr d-ix="3"><td>011</td><td>BQN</td><td>220921T221251Z</td><td><a href="https://codegolf.stackexchange.com/questions/77219/diamondize-a-matrix/252138#252138">DLosc</a></td></tr>
<tr d-ix="4"><td>111</td><td>Prolog SWI</td><td>211105T165107Z</td><td><a href="https://codegolf.stackexchange.com/questions/77219/diamondize-a-matrix/236913#236913">0							</a></td></tr>
<tr d-ix="5"><td>006</td><td>J</td><td>160406T084410Z</td><td><a href="https://codegolf.stackexchange.com/questions/77219/diamondize-a-matrix/77220#77220">Martin E</a></td></tr>
<tr d-ix="6"><td>056</td><td>Haskell</td><td>211105T035649Z</td><td><a href="https://codegolf.stackexchange.com/questions/77219/diamondize-a-matrix/236882#236882">Wheat Wi</a></td></tr>
<tr d-ix="7"><td>011</td><td>Japt</td><td>201103T114228Z</td><td><a href="https://codegolf.stackexchange.com/questions/77219/diamondize-a-matrix/214663#214663">Shaggy</a></td></tr>
<tr d-ix="8"><td>078</td><td>APL Dyalog Unicode</td><td>201102T134130Z</td><td><a href="https://codegolf.stackexchange.com/questions/77219/diamondize-a-matrix/214587#214587">Razetime</a></td></tr>
<tr d-ix="9"><td>002</td><td>Husk</td><td>200420T130158Z</td><td><a href="https://codegolf.stackexchange.com/questions/77219/diamondize-a-matrix/203698#203698">Kevin Cr</a></td></tr>
<tr d-ix="10"><td>016</td><td>05AB1E legacy</td><td>200420T125313Z</td><td><a href="https://codegolf.stackexchange.com/questions/77219/diamondize-a-matrix/203697#203697">Kevin Cr</a></td></tr>
<tr d-ix="11"><td>100</td><td>[C#]</td><td>200419T165417Z</td><td><a href="https://codegolf.stackexchange.com/questions/77219/diamondize-a-matrix/203673#203673">KaleSurf</a></td></tr>
<tr d-ix="12"><td>075</td><td>Groovy</td><td>160513T084529Z</td><td><a href="https://codegolf.stackexchange.com/questions/77219/diamondize-a-matrix/79850#79850">Krzyszto</a></td></tr>
<tr d-ix="13"><td>082</td><td>Haskell</td><td>160408T013901Z</td><td><a href="https://codegolf.stackexchange.com/questions/77219/diamondize-a-matrix/77363#77363">Lynn</a></td></tr>
<tr d-ix="14"><td>066</td><td>Ruby</td><td>160408T073352Z</td><td><a href="https://codegolf.stackexchange.com/questions/77219/diamondize-a-matrix/77374#77374">Value In</a></td></tr>
<tr d-ix="15"><td>017</td><td>Pyth</td><td>160408T023448Z</td><td><a href="https://codegolf.stackexchange.com/questions/77219/diamondize-a-matrix/77367#77367">Leaky Nu</a></td></tr>
<tr d-ix="16"><td>062</td><td>Octave</td><td>160406T233227Z</td><td><a href="https://codegolf.stackexchange.com/questions/77219/diamondize-a-matrix/77259#77259">beaker</a></td></tr>
<tr d-ix="17"><td>091</td><td>Python</td><td>160407T042123Z</td><td><a href="https://codegolf.stackexchange.com/questions/77219/diamondize-a-matrix/77266#77266">Dennis</a></td></tr>
<tr d-ix="18"><td>128</td><td>Python</td><td>160406T230845Z</td><td><a href="https://codegolf.stackexchange.com/questions/77219/diamondize-a-matrix/77258#77258">Luis Mas</a></td></tr>
<tr d-ix="19"><td>087</td><td>Python 2</td><td>160407T044109Z</td><td><a href="https://codegolf.stackexchange.com/questions/77219/diamondize-a-matrix/77267#77267">Sp3000</a></td></tr>
<tr d-ix="20"><td>075</td><td>JavaScript Firefox</td><td>160406T120332Z</td><td><a href="https://codegolf.stackexchange.com/questions/77219/diamondize-a-matrix/77226#77226">user8165</a></td></tr>
<tr d-ix="21"><td>077</td><td>Octave</td><td>160406T204953Z</td><td><a href="https://codegolf.stackexchange.com/questions/77219/diamondize-a-matrix/77253#77253">Luis Men</a></td></tr>
<tr d-ix="22"><td>056</td><td>Mathematica</td><td>160406T134754Z</td><td><a href="https://codegolf.stackexchange.com/questions/77219/diamondize-a-matrix/77231#77231">LegionMa</a></td></tr>
<tr d-ix="23"><td>017</td><td>CJam</td><td>160406T154633Z</td><td><a href="https://codegolf.stackexchange.com/questions/77219/diamondize-a-matrix/77237#77237">Martin E</a></td></tr>
<tr d-ix="24"><td>060</td><td>Mathematica</td><td>160406T145012Z</td><td><a href="https://codegolf.stackexchange.com/questions/77219/diamondize-a-matrix/77236#77236">Martin E</a></td></tr>
<tr d-ix="25"><td>007</td><td>Jelly</td><td>160406T090354Z</td><td><a href="https://codegolf.stackexchange.com/questions/77219/diamondize-a-matrix/77222#77222">Martin E</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://www.perl.org/" rel="nofollow noreferrer">Perl 5</a>, 67 bytes</h1>

<pre class="lang-perl prettyprint-override"><code>sub{map{[grep$_,map{shift@{$_[-$_]}}-$_..0]}0..$#_,($#_)x$#{$_[0]}}
</code></pre>
<p><a href="https://tio.run/##FYrRCoIwFEDf@4rQSyhcx6Yukgj8gb5gjGHgTKgczqAY@/XW9nI4HI4Z1wcPoC/Bvm/uORgnpnU0oDC5vc966x0oUYGS3kcSQqWnhECusIgoP5CnIVYfzjs7fLMeVLbXy3oAXQjGsEYuUTTYddhEafGELBV2xLrBtpZl@C1mm5eXDdWVE8roHw" rel="nofollow noreferrer" title="Perl 5 – Try It Online">Try it online!</a></p>
</div>
<div id="pu1" class="pu"><h1><a href="https://github.com/Vyxal/Vyxal/tree/version-2" rel="nofollow noreferrer">Vyxal</a>, 22 <a href="https://github.com/Vyxal/Vyncode/blob/main/README.md" rel="nofollow noreferrer">bits<sup>v2</a></sup>, 2.75 bytes</h1>
<pre><code>Þ`R
</code></pre>
<p><a href="https://vyxal.pythonanywhere.com/?v=2&amp;c=1#WyJ+PSIsIiIsIsOeYFIiLCIiLCJbWzExLDIsNV0sWzMsOTksM10sWzQsOCwxNV0sWzE2LDIzLDQyXV0gPT4gW1sxMV0sWzMsMl0sWzQsOTksNV0sWzE2LDgsM10sWzIzLDE1XSxbNDJdXSJd" rel="nofollow noreferrer">Try it Online!</a></p>
<p>Bitstring:</p>
<pre><code>0010101000111101000010
</code></pre>
</div>
<div id="pu2" class="pu"><h1><a href="https://github.com/dloscutoff/pip" rel="nofollow noreferrer">Pip</a>, <a href="https://chat.stackexchange.com/rooms/240/the-nineteenth-byte">19 bytes</a></h1>
<pre><code>_RMxMZD:xRL_AL BMEa
</code></pre>
<p><a href="https://dso.surge.sh/#@WyJwaXAiLCIiLCJfUk14TVpEOnhSTF9BTCBCTUVhIiwiIiwiIiwiW1sxOzI7M107WzQ7NTs2XTtbNzs4OzldXSAteHAiXQ==" rel="nofollow noreferrer">Try It Online!</a></p>
<p>I'm a bit rusty. There might be a shorter way to do this with loops but oh well.</p>
<pre><code>                ME  # Map [index item] for each item of...
                  a # Input
        --------ME  # Block
         RL         # Repeat...
        x           # The empty string
           _        # By the index
            AL      # Concatenate to...
               B    # The item
     ZD:            # Transpose, filling with &quot;&quot;
----M               # Map over each...
_RM                 # Remove
   x                # The empty string
</code></pre>
</div>
<div id="pu3" class="pu"><h1><a href="https://mlochbaum.github.io/BQN/" rel="nofollow noreferrer">BQN</a>, 11 bytes</h1>
<pre><code>⌽¨+´¨∘↕∘≢⊸⊔
</code></pre>
<p>Anonymous tacit function. Takes a 2D array and returns a list of lists. <a href="https://mlochbaum.github.io/BQN/try.html#code=RiDihpAg4oy9wqjiiqLiipTLnOKXi+KliivCtMKo4oiY4oaV4oiY4omiCgptIOKGkCBbWzExLDIsNV0sWzMsOTksM10sWzQsOCwxNV0sWzE2LDIzLDQyXV0KCkYgbQ==" rel="nofollow noreferrer">Try it at BQN online!</a></p>
<h3>Explanation</h3>
<pre><code>⌽¨+´¨∘↕∘≢⊸⊔
        ≢     Get the shape of the array (a list of two integers)
      ↕∘      Range (a 2D array of coordinate pairs)
  +´¨∘        Sum each of those pairs
              We now have an array in which the top left element is 0, the two elements
              in the next antidiagonal are 1, and so forth
         ⊸    With that as left argument and the original array as right argument,
          ⊔   Group the values of the right argument into buckets based on the
              corresponding number in the left argument
⌽¨            Reverse each antidiagonal
</code></pre>
</div>
<div id="pu4" class="pu"><h1><a href="http://www.swi-prolog.org" rel="nofollow noreferrer">Prolog (SWI)</a>, 111 bytes</h1>
<pre><code>A*B*C:-append(A,B,C).
s(A,B,C):-A*[B]*C.
N+B:-N=[A|X],X+R,Z*Q*R,maplist(s,[[]|Z],A,Y),Y*Q*B,!;maplist(=([]),B).
</code></pre>
<p><a href="https://tio.run/##NYu9DoIwFEZ33sINykcT/oxgGNo6k8gENB1INIYEpbEmLrx7LYrb/c45Vz/nab5F5j1aywgnoowGra@Pi8/AIQLqme0qI0YkV0RQrw55GdWVZEur0IYNenImDe6Dnkbz8g2kVEuvwNAF6Jzj2B3/tvKlCsADaq2UsVIhc3mMREGmyNzmv43UkQw59o6Jla0w/2ZFsdkD4pXEeyTuOXHliXreBw" rel="nofollow noreferrer" title="Prolog (SWI) – Try It Online">Try it online!</a></p>
<h2>Explanation</h2>
<p>Let's first look a version of the code that not nearly so condensed.</p>
<pre><code>snoc(Init,Last,List) :-
  append(Init,[Last],List).

diamondize([],Soln) :-
  maplist(=([]),Soln).
diamondize([FirstRow|Rest],Soln):-
  diamondize(Rest,RestSoln),
  append(BeginRestSoln,EndSoln,RestSoln),
  maplist(snoc,[[]|BeginRestSoln],FirstRow,BeginSoln),
  append(BeginSoln,EndSoln,Soln),
  !.
</code></pre>
<p>The <code>diamondize/2</code> predicate (<code>+/2</code> in the golfed version) is responsible for calculating what the diamond version of the input matrix is.
The predicate works recursively as follows: first it calculates the diamond version of the input matrix with its first row removed (<code>diamondize(Rest,RestSoln)</code>); then to calculate the diamond version of the entire input matrix it uses the fact that adding an initial row changes the diamond version by prepending a singleton list of the first element of the initial row and then pairing up each remaining element in the initial row with the first however many lists in the diamond and adding each initial row element to the end of its paired list, leaving the remaining lists in the diagonal unchanged. To do this in Prolog I use <code>append</code> to split <code>RestSoln</code> into a beginning, <code>BeginRestSoln</code>, and an end, <code>EndSoln</code>. Then I use the the builtin <code>maplist/4</code> to assert a relation between <code>BeginRestSoln</code>, the new initial row, <code>FirstRow</code>, and a new list <code>BeginSoln</code>. The <code>maplist/4</code> predicate asserts that all triples of elements of equal indices from the lists in its second, third, and fourth arguments will satisfy the predicate given as its first argument when it is called on them (note that this requires all the lists given as arguments to be of equal length). The predicate I use is <code>snoc/3</code> which asserts that when its second argument is added to the end of the list in its first argument, you get its third argument. Furthermore I add an empty list to the start of <code>BeginRestSoln</code> which means that when I <code>snoc</code> that with the first element of <code>FirstRow</code> the resulting first element of<code>BeginSoln</code> will be a singleton list of that aforementioned first element. The rest of <code>BeginSoln</code> will be the lists that began the diagonal version of the remainder of the matrix with the remaining elements of the first row added to the end, just as desired in the process described above. Finally to get the solution for the entire matrix we append <code>BeginSoln</code> with the unchanged <code>EndSoln</code>.</p>
<p>We have now covered the behavior of <code>diamondize/2</code> when the matrix is not empty, but the base case is the empty matrix. In that case the &quot;solution&quot; is considered to be a list of some undetermined length with <code>[]</code> for all its elements. This list is constructed using the <code>maplist/2</code> predicate which asserts that each element of the list given in its second argument satisfies the predicate given in its first argument. The predicate we use is <code>=([])/1</code> which is the partially applied <code>=/2</code> predicate which asserts that its two arguments unify, so our partially applied version asserts that its singular argument unifies with (ie is equal to) the empty list. However, since we do not specify a length, Prolog will attempt to satisfy the future goals with the shortest list containing only empty lists, backtracking and trying a longer such list if the future goals can't be satisfied. This behavior is very useful since in our first inductive case the predicates won't be satisfied unless the previous solution is at least one less than the length of the rows of the matrix, but we run into an issue in that longer lists of empty lists would also result in solutions that the program would consider valid, but would be invalid for this challenge. To avoid producing these solutions, we add a cut (<code>!</code>) to the end of the recursive case of <code>diamondize/2</code>, which will tell Prolog not to backtrack once we have a working solution.</p>
<p>Finally to golf the whole thing I used a number of tactics. First off, of course we can eliminate excess whitespace, and give variables and predicates shorter names. Then since <code>append/3</code> is being used a lot I can save a couple bytes by creating a copy of it with a shorter name, using an operator to name both it and what was the <code>diamondize/2</code> predicate (unfortunately since operator predicates technically can have at most two arguments, I cannot give <code>s/3</code> an operator name since I need to pass it to <code>maplist/4</code>). Finally I can consolidate the two cases of <code>+/2</code> into a single case with a disjunction.</p>
</div>
<div id="pu5" class="pu"><h2>J, 6 bytes</h2>
<pre><code>&lt;@|./.
</code></pre>
<p>This is an unnamed a monadic verb which takes a matrix and returns a list of antidiagonals:</p>
<pre><code>   input =. i.3 4
   input
0 1  2  3
4 5  6  7
8 9 10 11

   &lt;@|./. input
┌─┬───┬─────┬─────┬────┬──┐
│0│4 1│8 5 2│9 6 3│10 7│11│
└─┴───┴─────┴─────┴────┴──┘
</code></pre>
<p><a href="http://tryj.tk/" rel="nofollow noreferrer">Test it here.</a></p>
<h3>Explanation</h3>
<ul>
<li><code>/.</code> is J's built-in to apply a function to each anti-diagonal. Unfortunately, these anti-diagonals are given in the opposite order of what we want here.</li>
<li>In <code>&lt;@|.</code>, we first apply <code>|.</code> which reverses the anti-diagonal and then <code>&lt;</code> to box it (which is the only way to return a ragged array in J, since normal arrays are always rectangular, so the antidiagonals would be padded with zeroes).</li>
</ul>
</div>
<div id="pu6" class="pu"><h1><a href="https://www.haskell.org/" rel="nofollow noreferrer">Haskell</a>, 56 bytes</h1>

<pre class="lang-hs prettyprint-override"><code>a!b=zipWith(++)([]:b)$a++repeat[]
foldr1(!).map(pure&lt;$&gt;)
</code></pre>
<p><a href="https://tio.run/##DcVLDoMgEADQvafAhAWEienYr03pNbogLMYIkRSVULrp5alv82b6vF2MtVI76l9Ir1BmoZQUxt5HyUmp7JKjYmzjtd/ilFG0slsoifTN7sGfsi4UVj1tDWMph7UwzjwzBqGHowVzgjNc9q9wg2EfD4AI2Ftb/w" rel="nofollow noreferrer" title="Haskell – Try It Online">Try it online!</a></p>
</div>
<div id="pu7" class="pu"><h1><a href="https://github.com/ETHproductions/japt" rel="nofollow noreferrer">Japt</a>, 11 <a href="https://en.wikipedia.org/wiki/ISO/IEC_8859-1" rel="nofollow noreferrer">bytes</a></h1>
<p>Takes input as an array of space delimited strings, outputs a 2D array of integer strings.</p>
<pre><code>ËiEç)¸ÃÕËÔf
</code></pre>
<p><a href="https://petershaggynoble.github.io/Japt-Interpreter/?v=1.4.6&amp;header=bbg&amp;code=y2lF5ym4w9XL1GY&amp;input=W1sxIDIgM10gWzQgNSA2XSBbNyA4IDldXQotUQ" rel="nofollow noreferrer">Try it</a> (header converts 2D arrays to the required input format) or <a href="https://petershaggynoble.github.io/Japt-Interpreter/?v=1.4.6&amp;header=bbg&amp;code=y2lF5ym4w9XL1GY&amp;footer=Vq6uaVEgK1HDcSwgaSdbICsnXcNxLCBpJ1sgKydd&amp;input=WwpbWzEgMiAzXSBbNCA1IDZdIFs3IDggOV1dCltbMV1dCltbMSwyXSxbMyw0XV0KW1sxLDIsM10sWzQsNSw2XV0KW1sxMSwyLDVdLFszLDk5LDNdLFs0LDgsMTVdLFsxNiwyMyw0Ml1dCl0KLW1S" rel="nofollow noreferrer">run all test cases</a></p>
<pre><code>ËiEç)¸ÃÕËÔf     :Implicit input of array
Ë               :Map each element at 0-based index E
 i              :  Prepend
  Eç            :    E spaces
    )           :  End prepend
     ¸          :  Split on spaces
      Ã         :End map
       Õ        :Transpose
        Ë       :Map
         Ô      :  Reverse
          f     :  Filter
</code></pre>
</div>
<div id="pu8" class="pu"><h1><a href="https://www.dyalog.com/" rel="nofollow noreferrer">APL (Dyalog Unicode)</a>, 78 bytes</h1>

<pre class="lang-apl prettyprint-override"><code>{{⍵/⍨×≢¨⍵}{⍵/⍨×⍵}¨↓⍉(-⍳≢⍵)⌽⍵↑⍨1 2×≢⍵}
</code></pre>
<p><a href="https://tio.run/##SyzI0U2pTMzJT///qG@qp/@jtgkG/6urH/Vu1X/Uu@Lw9Eediw6tAPJqkYSAPKBY2@RHvZ0auo96NwPVAMU0H/XsBVKP2iYCVRkqGIH1gtT@TwMa@qi371FX86PeNY96txxabwxS1Tc1OMgZSIZ4eAb/T1MwBkKgpKE20ERLrjQFEwVTON/IAAA" rel="nofollow noreferrer" title="APL (Dyalog Unicode) – Try It Online">Try it online!</a></p>
</div>
<div id="pu9" class="pu"><h1><a href="https://github.com/barbuz/Husk/wiki/Commands" rel="nofollow noreferrer">Husk</a>, <s>3</s> 2 <a href="https://github.com/barbuz/Husk/wiki/Codepage" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>∂T
</code></pre>
<p>-1 byte thanks to <em>@mypronounismonicareinstate</em>.</p>
<p><a href="https://tio.run/##yygtzv7//1FHU8j///@jow11jHSMY3WiTXRMdcxiYwE" rel="nofollow noreferrer">Try it online.</a></p>
<p><strong>Explanation:</strong></p>

<pre class="lang-python prettyprint-override"><code> T  # Transpose the (implicit) matrix-argument; swapping rows/columns
∂   # Take the anti-diagonals of this transposed matrix
    # (after which the result is output implicitly)
</code></pre>
</div>
<div id="pu10" class="pu"><h1><a href="https://github.com/Adriandmen/05AB1E/wiki/Commands" rel="nofollow noreferrer">05AB1E (legacy)</a>, <s>17</s> 16 <a href="https://github.com/Adriandmen/05AB1E/wiki/Codepage" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>εD0*«NFÁ]øí0δKʒOĀ
</code></pre>
<p>Unfortunately 05AB1E only has a builtin for the main (anti)diagonal, and not one for all (anti)diagonals, so we'll have to do things manually..</p>
<p>-1 byte by switching to the legacy version of 05AB1E, so the <code>0δK</code> can be <code>0K</code>.</p>
<p><a href="https://tio.run/##MzBNTDJM/f//3FYXA61Dq/3cDjfGHt5xeK2B96lJ/kca/v@PjjbUMdIxjtWJNtEx1TED0uY6FjqWsbEA" rel="nofollow noreferrer">Try it online</a> or <a href="https://tio.run/##MzBNTDJM/V9Waa@k8KhtkoKSfeX/c1tdDLQOrfZzO9xYW3t4x@G1Bt6nJvkfafhfq/M/OjraUMdIxzhWJ9pEx1THDEib61joWMbG6igApaCUjhFQ3FjHBM5F0gARAomZghVZWkIlLXQMQSKGZjpGQK1GsbGxAA" rel="nofollow noreferrer">verify all test cases</a>.</p>
<p><strong>Explanation:</strong></p>

<pre class="lang-python prettyprint-override"><code>ε        # Map each row in the (implicit) input-matrix to:
 D       #  Duplicate the current row
  0*     #  Multiply each by 0, so we have a list of 0s the same length of the row
    «    #  Append the lists together
         #   i.e. [[1,2,3],[4,5,6],[7,8,9]] → [[1,2,3,0,0,0],[4,5,6,0,0,0],[7,8,9,0,0,0]]
     NF  #  Loop the (0-based) map-index amount of times:
       Á #   And rotate the row with appended 0s once towards the right each iteration
         #    → [[1,2,3,0,0,0],[0,4,5,6,0,0],[0,0,7,8,9,0]]
]ø       # After the map and inner loop: zip/transpose; swapping rows/columns
         #  → [[1,0,0],[2,4,0],[3,5,7],[0,6,8],[0,0,9],[0,0,0]]
  í      # And reverse each inner row
         #  → [[0,0,1],[0,4,2],[7,5,3],[8,6,0],[9,0,0],[0,0,0]]
0K       # Remove all 0s from each inner row
         #  → [[1],[4,2],[7,5,3],[8,6],[9],[]]
  ʒOĀ    # And filter out any empty rows
         #  → [[1],[4,2],[7,5,3],[8,6],[9]]
         # (after which the result is output implicitly)
</code></pre>
</div>
<div id="pu11" class="pu"><h1>[C#], 100 bytes</h1>

<pre><code>for(r=0;r&lt;l;r++)for(c=0;c&lt;i[r].Length;c++)o[c+r]=o[c+r]?.Prepend(i[r][c]).ToArray()??new[]{i[r][c]};
</code></pre>

<p><a href="https://tio.run/##ZY9NS8QwEIbv/oqXnFKaLe3uKi7ZWsSbeBBW8BByWGJcAyWRaVFk6W@v6YdF8TQzzzzDzJhmZRrXfxwJDiW8/VQa5yUWhcBa4BKdWNhGYLcT2PxmW4FrgeKPV1zF2Shv1@jQyYthRx13uOzB@lP7NhPrB6ZyPWOki4EViskK021wvlVxQis9cYo8lxhSM6b9ayBOZS5pX0tK02SoTazN3in62SFN7ARlUtLlFKrskey79S980JTRSfYUbomOXzypqvGl89zpZH8XfBNqmz2Tay1nCixefWjJ@VN2H5znDAJMIGQHW1vT8gblDZj6p4koNUmkTLNkjIiJ7L8B" rel="nofollow noreferrer">Try It online!</a></p>

<p>Maybe there's a shorter way of inserting elements. Prepend and ToArray seems verbose, but that's the best I found.</p>
</div>
<div id="pu12" class="pu"><h1>Groovy, <strike>77</strike> <strike>73</strike> 75</h1>

<pre><code>{i-&gt;o=[].withDefault{[]};a=0;i.each{b=0;it.each{o[a+b++].add(0,it)};a++};o}
</code></pre>

<p>Takes array of arrays as input and returns array of arrays.</p>

<p><a href="http://groovyconsole.appspot.com/script/5084993378320384" rel="nofollow">Try it</a></p>

<p>EDIT: I forgot to output the anwser, after adding it score goes up to 75.</p>
</div>
<div id="pu13" class="pu"><h1>Haskell, <s>83</s> 82 bytes</h1>

<pre><code>r=zip[0..]
\o-&gt;fst$span(any(&gt;0))[reverse[e|(x,t)&lt;-r o,(v,e)&lt;-r t,x+v==a]|a&lt;-[0..]]
</code></pre>

<p>nimi saved a byte. Thanks!</p>
</div>
<div id="pu14" class="pu"><h1>Ruby, <s>68</s> 66 bytes</h1>
<p>Anonymous function.</p>
<pre><code>-&gt;l{i=-1;k=[];l.map{|r|i-=j=-1;r.map{|e|k[i+j+=1]=[e,*k[i+j]]}};k}
</code></pre>
<ul>
<li>Because of how the splat operator works, I was able to save 2 bytes by forgoing the array addition.</li>
</ul>
</div>
<div id="pu15" class="pu"><h1><a href="https://github.com/isaacg1/pyth" rel="nofollow noreferrer">Pyth</a>, <s>41</s> 17 bytes</h1>
<pre><code>tm_&lt;dx+dYk.T+LaYk
</code></pre>
<p><a href="http://pyth.herokuapp.com/?code=tm_%3Cdx%2BdYk.T%2BLaYk&amp;input=%5B%5B1%2C2%2C3%5D%2C%5B4%2C5%2C6%5D%2C%5B7%2C8%2C9%5D%2C%5B10%2C11%2C12%5D%2C%5B13%2C14%2C15%5D%5D&amp;debug=0" rel="nofollow noreferrer">Try it online!</a></p>
<p>Inspired by <a href="https://codegolf.stackexchange.com/a/75591/48934">@Doorknob's solution to another problem</a>.</p>
<p>How it works:</p>
<pre><code>tm_&lt;dx+dYk.T+LaYk
            +L      prepend to each subarray...
              aYk   (Y += ''). Y is initialized to [],
                    so this prepends [''] to the first
                    subarray, ['', ''] to the second, etc.
                    ['' 1  2  3
                     '' '' 4  5  6
                     '' '' '' 7  8  9
                     '' '' '' '' 10 11 12
                     '' '' '' '' '' 13 14 15]
          .T        transpose, giving us
                    ['' '' '' '' ''
                     1  '' '' '' ''
                     2  4  '' '' ''
                     3  5  7  '' ''
                     6  8  10 ''
                     9  11 13
                     12 14
                     15]
 m_&lt;dx+dYk          removes all empty strings in the
                    subarrays while reversing each one
t                   remove the first subarray
</code></pre>
<hr />
<p>Previous attempt:</p>
<pre><code>JlQKlhQm_m@@Qk-dk}h.MZ,0-dtKh.mb,tJdUt+JK
</code></pre>
<p><a href="http://pyth.herokuapp.com/?code=JlQKlhQm_m%40%40Qk-dk%7Dh.MZ%2C0-dtKh.mb%2CtJdUt%2BJK&amp;input=%5B%5B1%2C2%2C3%5D%2C%5B4%2C5%2C6%5D%2C%5B7%2C8%2C9%5D%2C%5B10%2C11%2C12%5D%2C%5B13%2C14%2C15%5D%5D&amp;debug=0" rel="nofollow noreferrer">Try it online!</a></p>
<p>How it works:</p>
<pre><code>JlQKlhQm_m@@Qk-dk}h.MZ,0-dtKh.mb,tJdUt+JK    input array stored as Q
JlQ                                          J = len(Q)
   KlhQ                                      K = len(Q[0])
       m                            Ut+JK    list for d from 0 to J+K-1:
        _m       }AAAAAAAAAABBBBBBBB             reversed list for k from A to B, where:
                  h.MZ,0-dtK                       A = max(0, d-(K-1))
                       0-dtK                               0  d-(K-1)
                            h.mb,tJd               B = min(J-1, d)
                                 tJd                       J-1  d
          @@Qk-dk                                    Q[k][d-k]
</code></pre>
</div>
<div id="pu16" class="pu"><h1>Octave, <s>63</s> 62 bytes</h1>
<p>Removed one byte thanks to <s>@DonMue...</s> @LuisMendo!</p>
<pre><code>@(a)cellfun(@(x)x(x&gt;0)',num2cell(spdiags(flipud(a)),1),'un',0)
</code></pre>
<p>I went the boring route and munged the antidiagonals.</p>
<p>Sample run on <a href="http://ideone.com/iuAUhy" rel="nofollow noreferrer">ideone</a>.</p>
</div>
<div id="pu17" class="pu"><h1>Python, 91 bytes</h1>

<pre><code>e=enumerate
lambda M:[[r[n-i]for i,r in e(M)if-1&lt;n-i&lt;len(r)][::-1]for n,_ in e(M[1:]+M[0])]
</code></pre>

<p>Test it on <a href="http://ideone.com/FjgmK4" rel="nofollow">Ideone</a>.</p>

<hr>

<h1>Python + NumPy, 69 bytes</h1>

<pre><code>import numpy
lambda M:map(M[::-1].diagonal,range(1-len(M),len(M[0])))
</code></pre>

<p>Expects a 2D NumPy array as input and returns a list of NumPy arrays. Test it on <a href="http://ideone.com/kFQIgU" rel="nofollow">Ideone</a>.</p>
</div>
<div id="pu18" class="pu"><h1>Python, 128 bytes (numpy)</h1>

<pre><code>(lambda A: (lambda A,S:[[A[U][I-U] for U in range(min(S[1]-1,I),max(I-S[0]+1,0)-1,-1)] for I in range(S[1]+S[0]-1)])(A,A.shape))
</code></pre>
</div>
<div id="pu19" class="pu"><h2>Python 2, <s>88</s> 87 bytes</h2>



<pre class="lang-py prettyprint-override"><code>lambda L:[filter(None,x)[::-1]for x in map(None,[],*[i*[0]+r for i,r in enumerate(L)])]
</code></pre>

<p>Prepend 0s, zip, then remove falsy elements. Returns a list of tuples. This uses <code>map(None,...)</code> to perform <code>zip_longest</code>  (padding missing spots with <code>None</code>) and <code>filter(None,...)</code> to remove falsy elements.</p>

<p>Annoyingly, we need to add an extra <code>[]</code> row to the <code>map</code> to guarantee that a list of tuples is returned, since <code>map(None,*[[1]])</code> returns <code>[1]</code> rather than <code>[(1,)]</code> for a 1x1 matrix. The extra row gets stripped out by the <code>filter</code> though.</p>

<p><em>(Thanks to @Dennis for -1 byte)</em></p>
</div>
<div id="pu20" class="pu"><h1>JavaScript (Firefox), <s>86</s> 75 bytes</h1>

<pre class="lang-js prettyprint-override"><code>a=&gt;a.concat(a[0]).slice(1).map((_,i)=&gt;[for(v of a)if(n=v[i--])n].reverse())
</code></pre>

<p><em>Saved 11 bytes thanks to @Neil!</em></p>

<p>Works in Firefox 30+. Takes an array of arrays.</p>
</div>
<div id="pu21" class="pu"><h1>Octave, 77 bytes</h1>

<p>With a little abuse of the <code>accumarray</code> function:</p>

<pre><code>@(M)char(accumarray(((1:size(M,1))+(0:size(M,2)-1)')(:),M(:),[],@(x){num2str(x')}))
</code></pre>

<p>This defines an anonymous function. To use it, assign to a varible or use <code>ans</code>.</p>

<p>Input is the matrix with <code>:</code> as row separator. Output is a cell array containing an array for each row (Octave's equivalent to jagged arrays). This is displayed by Octave showing the indices of the cell array and the contents of each cell. <a href="http://ideone.com/7a6Yie" rel="nofollow">Try it here</a>.</p>

<p>To display the result separated by spaces and newlines only: <strong>83 bytes</strong></p>

<pre><code>@(M)char(accumarray(((1:size(M,1))+(0:size(M,2)-1)')(:),M(:),[],@(x){num2str(x')}))
</code></pre>

<p>You can also <a href="http://ideone.com/QbgMMd" rel="nofollow">try it here</a>.</p>
</div>
<div id="pu22" class="pu"><h1>Mathematica, <s>58</s> 56 bytes</h1>

<pre><code>a=Length;Reverse@#~Diagonal~b~Table~{b,1-a@#,a@#&amp;@@#-1}&amp;
</code></pre>

<p>Anonymous function, takes nested arrays.</p>
</div>
<div id="pu23" class="pu"><h2>CJam, 17 bytes</h2>

<pre><code>{eeSf.*::+W%zSf-}
</code></pre>

<p>An unnamed block (function) which expects the matrix on the stack and replaces it with its antidiagonals.</p>

<p><a href="http://cjam.aditsu.net/#code=%5B%5B0%20%201%20%202%20%203%5D%0A%20%5B4%20%205%20%206%20%207%5D%0A%20%5B8%20%209%2010%2011%5D%5D%0A%0A%7BeeSf.*%3A%3A%2BW%25zSf-%7D%0A%0A~p" rel="nofollow">Test it here.</a></p>

<p>This (found by Sp3000) works for the same byte count:</p>

<pre><code>{_,,Sf*\.+W%zSf-}
</code></pre>

<h3>Explanation</h3>

<p>This is best explained with an example. Consider the input:</p>

<pre><code>[[0  1  2  3]
 [4  5  6  7]
 [8  9 10 11]]

ee    e# Enumerate matrix, turning each row [x ... z] into [i [x ... z]] where
      e# i is the vertical index from the top.

[[0 [0  1  2  3]]
 [1 [4  5  6  7]]
 [2 [8  9 10 11]]]

Sf.*  e# Replace each i with a string of i spaces.

[[""   [0  1  2  3]]
 [" "  [4  5  6  7]]
 ["  " [8  9 10 11]]]

::+   e# Prepend these strings to the rows.

[[0  1  2  3]
 ['  4  5  6  7]
 ['  '  8  9 10 11]]   e# Note that each '  corresponds to a space character.

W%    e# Reverse the rows.

[['  '  8  9 10 11]
 ['  4  5  6  7]
 [0  1  2  3]]

z     e# Zip/transpose.

[[ '  '  0]
 [ '  4  1]
 [ 8  5  2]
 [ 9  6  3]
 [10  7]
 [11]]

Sf-   e# Remove spaces from each row.

[[ 0]
 [ 4  1]
 [ 8  5  2]
 [ 9  6  3]
 [10  7]
 [11]]
</code></pre>
</div>
<div id="pu24" class="pu"><h2>Mathematica, 60 bytes</h2>

<pre><code>#&amp;@@@#&amp;/@GatherBy[Join@@MapIndexed[List,#,{2}],Tr@*Last]&amp;
</code></pre>

<p>where <code></code> is a Unicode character which Mathematica reads as the postfix <code>\[Transpose]</code> operator.</p>

<p>This is a bit longer than the other Mathematica solution but I figured I'd post it because it doesn't use the <code>Diagonals</code> built-in and uses a completely different approach.</p>

<h3>Explanation</h3>

<pre><code>MapIndexed[List,#,{2}]
</code></pre>

<p>This first transposes the matrix (such that the antidiagonals appear in the correct order if the matrix was flattened). Then we map <code>List</code> over the cells of the matrix together with the index, which turns each matrix element <code>i</code> into <code>{i, {x, y}}</code> where <code>x</code> and <code>y</code> are the coordinates of the element in the matrix.</p>

<pre><code>Join@@...
</code></pre>

<p>This flattens the outermost dimension, so that we now have a flat list of the matrix elements (with their coordinates) in column-major order.</p>

<pre><code>GatherBy[..., Tr@*Last]
</code></pre>

<p>This groups those elements by the sum of their coordinates. Note that antidiagonals are lines of constant <code>x+y</code>, so this does exactly the grouping we want. The order within each group is preserved. Now we just need to get rid of the coordinates again. This is done via the rather cryptic:</p>

<pre><code>#&amp;@@@#&amp;/@...
</code></pre>

<p>This maps the function <code>#&amp;@@@#&amp;</code> over each group, which itself <em>applies</em> <code>#&amp;</code> to each element in the group, and <code>#</code> is simply the first argument, i.e. the original matrix element.</p>
</div>
<div id="pu25" class="pu"><h2>Jelly, 7 bytes</h2>

<pre><code>ṚŒDṙZL$
</code></pre>

<p><a href="http://jelly.tryitonline.net/#code=4bmaxZJE4bmZWkwk&amp;input=&amp;args=W1swLCAxLCAyLCAzXSwgWzQsIDUsIDYsIDddLCBbOCwgOSwgMTAsIDExXV0" rel="nofollow">Try it online!</a></p>

<h3>Explanation</h3>

<pre><code>Ṛ         Reverse the matrix vertically.
 ŒD       Get its diagonals. However these start from 
          the main diagonal, not the corners.
    ZL$   Get the width of the input matrix.
   ṙ      Rotate the list of diagonals left by that many 
          places to obtain the correct order.
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/77219/">77219</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




