<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::263856</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>175</td><td>Ruby</td><td>230809T154848Z</td><td><a href="https://codegolf.stackexchange.com/questions/263856/generate-the-vertices-of-a-geodesic-sphere/263941#263941">Level Ri</a></td></tr>
<tr d-ix="1"><td>146</td><td>Charcoal</td><td>230808T095331Z</td><td><a href="https://codegolf.stackexchange.com/questions/263856/generate-the-vertices-of-a-geodesic-sphere/263876#263876">Neil</a></td></tr>
<tr d-ix="2"><td>421</td><td>Python3</td><td>230808T231227Z</td><td><a href="https://codegolf.stackexchange.com/questions/263856/generate-the-vertices-of-a-geodesic-sphere/263899#263899">Ajax1234</a></td></tr>
<tr d-ix="3"><td>099</td><td>Pyth</td><td>230808T210237Z</td><td><a href="https://codegolf.stackexchange.com/questions/263856/generate-the-vertices-of-a-geodesic-sphere/263897#263897">CursorCo</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://www.ruby-lang.org/" rel="nofollow noreferrer">Ruby</a>, 175 bytes</h1>

<pre class="lang-ruby prettyprint-override"><code>-&gt;n{(n*n*10+2).times{|k|j=k/10;a=j/n/m=n*1.0;b=j%n/m
z=(1+(a-b)*[5**0.5-1,2][d=a&gt;b ?0:1])*~0**k
r=((c=1i**0.4)+[b/c-a*c,b-b*c+a/c-a][d])*c**k*2
p [z/s=(r.abs2+z*z)**0.5,r/s]}}
</code></pre>
<p><a href="https://tio.run/##HY1BDoMgFAX3nsJNE/iIgKmbmm8PQlwArUk1kkbaRVF7dYtdTt5M3vy2n73Hnbd@IR48KMkqWr4e0z0s67gOOAolG4OD8GLCtJeysTicEmURiWLEcEtB1wCyrLkqqk7f0LQ2v8qL6ih8JcCYzUiIQ/U4rDNl2grHDbjCcguOmYNSl3SXbKiyZ66jCEjm0thQsQiR/g@KWYRu2/Zeq27/AQ" rel="nofollow noreferrer" title="Ruby – Try It Online">Try it online!</a></p>
<p>Function that takes an argument <code>n</code> and prints the vertices in the format <code>[z,x+yi]</code>. One pair of opposite vertices is aligned with the <code>z</code> axis; these vertices are printed last. The code generates each vertex exactly once with no duplicates, per OP's comment in the post.</p>
<p><strong>Explanation</strong></p>
<p>According to <a href="https://mathworld.wolfram.com/RegularIcosahedron.html" rel="nofollow noreferrer">https://mathworld.wolfram.com/RegularIcosahedron.html</a></p>
<p><code>A construction for a icosahedron... places the end vertices at (0,0,+/-1) and the central vertices around two staggered circles of radii 2/sqrt(5) and heights +/- 1/sqrt(5)</code></p>
<p>This code produces the <code>z</code>coordinates of the icosahedron at a scaled up size of <code>0,0,sqrt(5)</code> the end vertices, which puts the other vertices at <code>z=+/-1</code>. For calculation of the x and y coordinates, the radius of the circle is conveniently set to 1, but the coordinates are doubled for compatability with the z coordinates prior to normalization.</p>
<p>The icosahedron is split into 10 identical diamonds as below. We include only the points marked with an <code>X</code> because the points marked with <code>O</code> are plotted as part of the adjacent diamond. We do however have to include the poles (marked as <code>?</code>) once.</p>
<p>Looking down the <code>z</code> axis the diamond is folded at the join of the two triangles. the polar apex is at 0+0i, and the other apex is at 1+0i. The right vertex is at a 1/10th rotation, <code>c=i**0.4 = 0.809+0.588i</code>. The left vertex is at the conjugate, <code>0.809-0.588i</code>. As the absolute value of c is 1, the conjugate is conveniently generated by <code>1/c.</code></p>
<pre class="lang-ruby prettyprint-override"><code>         North Pole  
                 ?  x+yi=0              z=sqrt(5)
                / \
               O   X
              / \ / \
             O   X   X
     x+yi   / \ / \ / \    x+yi
    =1/c   O---X---X---X  =c=i**0.4     z=1
    =0.809  \ / \ / \ /   =0.809
    -0.588i  O   X   X    +0.588i    Note: x,y coordinates at half
              \ / \ /                the scale of z coordinates   
               O   X                 (they are doubled before normalization)  
                \ /
                 O  x+yi=1              z=-1
</code></pre>
<p>We work through the <code>n*n</code> points in the diamond with increments in the value of <code>j</code>. we start at [<code>r=x+yi=c,z=1]</code>, with increasing value of <code>b=j%n</code> moving diagonally towards the bottom corner and <code>a=j/n</code> moving diagonally towards the top corner. different vectors (selected by <code>d</code> must be added to the starting point for the upper and lower triangle.</p>
<pre class="lang-ruby prettyprint-override"><code>                    x+yi                  z
    Upper triangle  a*(0-c)+b*(1/c-0)     (a-b)*(5**0.5-1)
    Lower triangle  b*(1-c)+a*(1/c-1)     (a-b)*2
</code></pre>
<p>For each value of <code>j</code> we generate 10 images by 1/10 rotation of the value <code>r=x+yi</code> by multiplying by <code>c**k</code> and flipping the <code>z</code> value by multiplying by <code>-1**k</code> (due to priority of operators in Ruby, this is represented as <code>~0**k</code>)</p>
<p>After <code>n*n*10</code> iterations, we have covered all points up to <code>a=b=n-1</code>. It remains to add the polar vertices. This just requires another 2 iterations where the value of <code>j</code> is <code>n*n</code>, <code>a=n</code> and <code>b=-1</code>.</p>
</div>
<div id="pu1" class="pu"><h1><a href="https://github.com/somebody1234/Charcoal" rel="nofollow noreferrer">Charcoal</a>, <s>162</s> 146 bytes</h1>
<pre><code>Ｎθ⊞υ⟦⁰¦¹⊘⊕₂⁵⟧≔⟦⟧ηＦυＦＥ²⊞ＯΦιν×⊖⊗κ§ι⁰Ｆ¬№υκＦΦ⊞Ｏυκ⁼⁴ΣＸＥμ⁻ξ§κπ²⊞η⟦κμ⟧ＦηＦ…¹θ⊞υＥ§ι⁰⁺×κλ×⁻θκ§§ι¹μＦηＦΦυ⬤ι№η⟦μκ⟧Ｆ…²θＦ…¹λ⊞υＥ§ι⁰⁺⁺×μν×⁻λμ§§ι¹ξ×⁻θλ§κξＩＥυ∕ι₂ΣＸι²
</code></pre>
<p><a href="https://tio.run/##jZK9bsIwFIX3PoVHW3IlQHTqhKBVGaAIuqEMBlxixT@JY9O8fXodJyRBqtQsTux77/nOcc4ps2fDZF2vde7d1qsTt7ggr087X6bYU3ScUDSl6IPJG7/gtT5brrh28H4oPLN8b4zDL4SQBJoWZSmuGh8TilL4/DYWYU9Qs25YjmcUhbmfObfMGYvfhXSgJyjShKIvoXiJV7yXWBl/krBmBI4Xbq0vvArVExKeOHcL@kvjtQu02X27HT2SawooegNwWeI5RQev8M78QF2gUxRthPYlrnqxjKKcBPVZlGxiSSEWOFBJ5zFtRfdMXzmGuIquFCTD6BE7hCBBJdqFOfLuPcoXEbPrGfROYVs1IA/CrVtQW0gZKmMiARRcZUkfV0ScRcQxtPwH9IBcDW8tksuA9yd51QT54FSSUdhV625nBfAvWemaqwGilbiJCw@zBj9ef4GiuyLorut5/XyTvw" rel="nofollow noreferrer" title="Charcoal – Try It Online">Try it online!</a> Link is to verbose version of code. Explanation:</p>
<pre><code>Ｎθ
</code></pre>
<p>Input <code>b</code>.</p>
<pre><code>⊞υ⟦⁰¦¹⊘⊕₂⁵⟧≔⟦⟧η
</code></pre>
<p>Start with one vertex and no edges of an icosahedron of side <code>2</code>.</p>
<pre><code>Ｆυ
</code></pre>
<p>Process all vertices as they are discovered.</p>
<pre><code>ＦＥ²⊞ＯΦιν×⊖⊗κ§ι⁰
</code></pre>
<p>Generate more vertices by rotating about the line <code>x=y=z</code> and reflecting in the <code>xy</code> plane. (This is the same procedure as for the regular dodecahedron in the linked question.)</p>
<pre><code>Ｆ¬№υκ
</code></pre>
<p>Ignore previously discovered vertices.</p>
<pre><code>ＦΦ⊞Ｏυκ⁼⁴ΣＸＥμ⁻ξ§κπ²⊞η⟦κμ⟧
</code></pre>
<p>Save the new vertex and also discover any edges by checking for previously found vertices that are <code>2</code> away. (Very fortunately, <code>ϕ²+1²+(ϕ-1)²=2²</code> under floating-point arithmetic.) Since only previously found vertices are checked, each edge is only detected once, and has a specific direction.</p>
<pre><code>Ｆη
</code></pre>
<p>Loop over the edges.</p>
<pre><code>Ｆ…¹θ
</code></pre>
<p>Loop over the intermediate points.</p>
<pre><code>⊞υＥ§ι⁰⁺×κλ×⁻θκ§§ι¹μ
</code></pre>
<p>Extrapolate a point along the edge. (Sadly Charcoal doesn't have a way of adding two vectors which would really simplify this. Maybe if it had octonions...)</p>
<pre><code>Ｆη
</code></pre>
<p>Loop over the edges again.</p>
<pre><code>ＦΦυ⬤ι№η⟦μκ⟧
</code></pre>
<p>Loop over the vertices that have edges to both vertices of that edge. (Note that because the edges have a specific direction, each face can only be detected once.)</p>
<pre><code>Ｆ…²θＦ…¹λ
</code></pre>
<p>Loop over the interior points of the face.</p>
<pre><code>⊞υＥ§ι⁰⁺⁺×μν×⁻λμ§§ι¹ξ×⁻θλ§κξ
</code></pre>
<p>Extrapolate a point inside the face. (Due to the normalisation, it's not necessary to interpolate.)</p>
<pre><code>ＩＥυ∕ι₂ΣＸι²
</code></pre>
<p>Normalise all the points.</p>
</div>
<div id="pu2" class="pu"><h1>Python3, 421 bytes:</h1>
<pre class="lang-py prettyprint-override"><code>def f(l,r=[]):
 if[]==l:yield r;return
 for i in l[0]:yield from f(l[1:],r+[i])
C=lambda n=0,b=[0,1,(1+5**.5)/2]:[]if n==3 else[*f([[[i,-i],[0]][i==0]for i in b[n:]+b[:n]])]+C(n+1)
def G(w):
 c,R=C(),[]
 for x in c:
  for y in c:
   if sum((a-b)**2 for a,b in zip(x,y))**.5==2:
    R+=[x,y]
    for v in range(1,w):R+=[[((w-v)*a+v*b)/w for a,b in zip(x,y)]]
 return{tuple(i/sum(j**2 for j in p)**.5 for i in p)for p in R}
</code></pre>
<p><a href="https://tio.run/##bVA9c8IwDJ2bX@ENy3FKAuWul54nBnZWnYYE4tZcMD4TPtJef3tqh0KXbnp6T3pPcn33cbDzV@eHYdtopnkrvUKCMmFGIynVlr1p2i3zb77pTt4mTB88M8xY1mJOv6z2h30cxqIk6VM0BMlStdW@3lbMqlzWCnNZSF6kCyGeFzCdUYlkdCDVnDXtsUGhOSIamRmSYTOhUSqnh1uNtqS0xtISAaVLbtMCkhh6xS8x70au1ZKDRLplvMapTSBG1D9QOIwdT3vOq6wGIWYjXck6Cj6N41fZA8SQSs1GPVunCkOXRhDV56j1lX1veCGDeRQg55fsDKJKz6KG6eW/tRRW3N741Z1c23AzjUl29xS7KHaj@d@bHcTSxXL9PTzad/siD8c/OW9sx1fcANzBJJuIlxyGHw" rel="nofollow noreferrer">Try it online!</a></p>
</div>
<div id="pu3" class="pu"><h1><a href="https://github.com/isaacg1/pyth" rel="nofollow noreferrer">Pyth</a>, 99 bytes</h1>
<pre><code>mcR.add+Ksm.&gt;L+0d3*_B1_B.n3s+mm+V*Rkhd*R-QkedStQJf&amp;SITq.aT2^K2mmsMC.b*RlNYkdfq3lT./UQf.A}RJ&gt;3PyT^K3
</code></pre>
<p><a href="https://tio.run/##K6gsyfj/Pzc5SC8xJUXbuzhXz85H2yDFWCveyTDeSS/PuFg7N1c7TCsoOyNFK0g3MDs1Jbgk0CtNLdgzpFAvMcQoztsoN7fY11kvSSsoxy8yOyWt0DgnRE8/NDBNz7E2yMvOOKAyJM7b@P9/EwA" rel="nofollow noreferrer" title="Pyth – Try It Online">Try it online!</a></p>
<p>We begin with the vertices of the regular icosahedron made by all cyclic permutations and sign flips of <span class="math-container">\$(0,1,\phi)\$</span>. Then we find all unordered pairs of edges that have distance 2, interpolate along the edge they specify. Then we find all unordered triplets where all the pairs are in the list of edges, and using partitions of the input we interpolate along the face they specify. Finally we normalize all points.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/263856/">263856</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




