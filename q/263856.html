<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::263856</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>175</td><td>Ruby</td><td>230809T154848Z</td><td><a href="https://codegolf.stackexchange.com/questions/263856/generate-the-vertices-of-a-geodesic-sphere/263941#263941">Level Ri</a></td></tr>
<tr d-ix="1"><td>146</td><td>Charcoal</td><td>230808T095331Z</td><td><a href="https://codegolf.stackexchange.com/questions/263856/generate-the-vertices-of-a-geodesic-sphere/263876#263876">Neil</a></td></tr>
<tr d-ix="2"><td>421</td><td>Python3</td><td>230808T231227Z</td><td><a href="https://codegolf.stackexchange.com/questions/263856/generate-the-vertices-of-a-geodesic-sphere/263899#263899">Ajax1234</a></td></tr>
<tr d-ix="3"><td>099</td><td>Pyth</td><td>230808T210237Z</td><td><a href="https://codegolf.stackexchange.com/questions/263856/generate-the-vertices-of-a-geodesic-sphere/263897#263897">CursorCo</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://www.ruby-lang.org/" rel="nofollow noreferrer">Ruby</a>, 175 bytes</h1>

<pre class="lang-ruby prettyprint-override"><code>-&gt;n{(n*n*10+2).times{|k|j=k/10;a=j/n/m=n*1.0;b=j%n/m
z=(1+(a-b)*[5**0.5-1,2][d=a&gt;b ?0:1])*~0**k
r=((c=1i**0.4)+[b/c-a*c,b-b*c+a/c-a][d])*c**k*2
p [z/s=(r.abs2+z*z)**0.5,r/s]}}
</code></pre>
<p><a href="https://tio.run/##HY1BDoMgFAX3nsJNE/iIgKmbmm8PQlwArUk1kkbaRVF7dYtdTt5M3vy2n73Hnbd@IR48KMkqWr4e0z0s67gOOAolG4OD8GLCtJeysTicEmURiWLEcEtB1wCyrLkqqk7f0LQ2v8qL6ih8JcCYzUiIQ/U4rDNl2grHDbjCcguOmYNSl3SXbKiyZ66jCEjm0thQsQiR/g@KWYRu2/Zeq27/AQ" rel="nofollow noreferrer" title="Ruby – Try It Online">Try it online!</a></p>
</div>
<div id="pu1" class="pu"><h1><a href="https://github.com/somebody1234/Charcoal" rel="nofollow noreferrer">Charcoal</a>, <s>162</s> 146 bytes</h1>
<pre><code>Ｎθ⊞υ⟦⁰¦¹⊘⊕₂⁵⟧≔⟦⟧ηＦυＦＥ²⊞ＯΦιν×⊖⊗κ§ι⁰Ｆ¬№υκＦΦ⊞Ｏυκ⁼⁴ΣＸＥμ⁻ξ§κπ²⊞η⟦κμ⟧ＦηＦ…¹θ⊞υＥ§ι⁰⁺×κλ×⁻θκ§§ι¹μＦηＦΦυ⬤ι№η⟦μκ⟧Ｆ…²θＦ…¹λ⊞υＥ§ι⁰⁺⁺×μν×⁻λμ§§ι¹ξ×⁻θλ§κξＩＥυ∕ι₂ΣＸι²
</code></pre>
<p><a href="https://tio.run/##jZK9bsIwFIX3PoVHW3IlQHTqhKBVGaAIuqEMBlxixT@JY9O8fXodJyRBqtQsTux77/nOcc4ps2fDZF2vde7d1qsTt7ggr087X6bYU3ScUDSl6IPJG7/gtT5brrh28H4oPLN8b4zDL4SQBJoWZSmuGh8TilL4/DYWYU9Qs25YjmcUhbmfObfMGYvfhXSgJyjShKIvoXiJV7yXWBl/krBmBI4Xbq0vvArVExKeOHcL@kvjtQu02X27HT2SawooegNwWeI5RQev8M78QF2gUxRthPYlrnqxjKKcBPVZlGxiSSEWOFBJ5zFtRfdMXzmGuIquFCTD6BE7hCBBJdqFOfLuPcoXEbPrGfROYVs1IA/CrVtQW0gZKmMiARRcZUkfV0ScRcQxtPwH9IBcDW8tksuA9yd51QT54FSSUdhV625nBfAvWemaqwGilbiJCw@zBj9ef4GiuyLorut5/XyTvw" rel="nofollow noreferrer" title="Charcoal – Try It Online">Try it online!</a> Link is to verbose version of code. Explanation:</p>
<pre><code>Ｎθ
</code></pre>
<p>Input <code>b</code>.</p>
<pre><code>⊞υ⟦⁰¦¹⊘⊕₂⁵⟧≔⟦⟧η
</code></pre>
<p>Start with one vertex and no edges of an icosahedron of side <code>2</code>.</p>
<pre><code>Ｆυ
</code></pre>
<p>Process all vertices as they are discovered.</p>
<pre><code>ＦＥ²⊞ＯΦιν×⊖⊗κ§ι⁰
</code></pre>
<p>Generate more vertices by rotating about the line <code>x=y=z</code> and reflecting in the <code>xy</code> plane. (This is the same procedure as for the regular dodecahedron in the linked question.)</p>
<pre><code>Ｆ¬№υκ
</code></pre>
<p>Ignore previously discovered vertices.</p>
<pre><code>ＦΦ⊞Ｏυκ⁼⁴ΣＸＥμ⁻ξ§κπ²⊞η⟦κμ⟧
</code></pre>
<p>Save the new vertex and also discover any edges by checking for previously found vertices that are <code>2</code> away. (Very fortunately, <code>ϕ²+1²+(ϕ-1)²=2²</code> under floating-point arithmetic.) Since only previously found vertices are checked, each edge is only detected once, and has a specific direction.</p>
<pre><code>Ｆη
</code></pre>
<p>Loop over the edges.</p>
<pre><code>Ｆ…¹θ
</code></pre>
<p>Loop over the intermediate points.</p>
<pre><code>⊞υＥ§ι⁰⁺×κλ×⁻θκ§§ι¹μ
</code></pre>
<p>Extrapolate a point along the edge. (Sadly Charcoal doesn't have a way of adding two vectors which would really simplify this. Maybe if it had octonions...)</p>
<pre><code>Ｆη
</code></pre>
<p>Loop over the edges again.</p>
<pre><code>ＦΦυ⬤ι№η⟦μκ⟧
</code></pre>
<p>Loop over the vertices that have edges to both vertices of that edge. (Note that because the edges have a specific direction, each face can only be detected once.)</p>
<pre><code>Ｆ…²θＦ…¹λ
</code></pre>
<p>Loop over the interior points of the face.</p>
<pre><code>⊞υＥ§ι⁰⁺⁺×μν×⁻λμ§§ι¹ξ×⁻θλ§κξ
</code></pre>
<p>Extrapolate a point inside the face. (Due to the normalisation, it's not necessary to interpolate.)</p>
<pre><code>ＩＥυ∕ι₂ΣＸι²
</code></pre>
<p>Normalise all the points.</p>
</div>
<div id="pu2" class="pu"><h1>Python3, 421 bytes:</h1>
<pre class="lang-py prettyprint-override"><code>def f(l,r=[]):
 if[]==l:yield r;return
 for i in l[0]:yield from f(l[1:],r+[i])
C=lambda n=0,b=[0,1,(1+5**.5)/2]:[]if n==3 else[*f([[[i,-i],[0]][i==0]for i in b[n:]+b[:n]])]+C(n+1)
def G(w):
 c,R=C(),[]
 for x in c:
  for y in c:
   if sum((a-b)**2 for a,b in zip(x,y))**.5==2:
    R+=[x,y]
    for v in range(1,w):R+=[[((w-v)*a+v*b)/w for a,b in zip(x,y)]]
 return{tuple(i/sum(j**2 for j in p)**.5 for i in p)for p in R}
</code></pre>
<p><a href="https://tio.run/##bVA9c8IwDJ2bX@ENy3FKAuWul54nBnZWnYYE4tZcMD4TPtJef3tqh0KXbnp6T3pPcn33cbDzV@eHYdtopnkrvUKCMmFGIynVlr1p2i3zb77pTt4mTB88M8xY1mJOv6z2h30cxqIk6VM0BMlStdW@3lbMqlzWCnNZSF6kCyGeFzCdUYlkdCDVnDXtsUGhOSIamRmSYTOhUSqnh1uNtqS0xtISAaVLbtMCkhh6xS8x70au1ZKDRLplvMapTSBG1D9QOIwdT3vOq6wGIWYjXck6Cj6N41fZA8SQSs1GPVunCkOXRhDV56j1lX1veCGDeRQg55fsDKJKz6KG6eW/tRRW3N741Z1c23AzjUl29xS7KHaj@d@bHcTSxXL9PTzad/siD8c/OW9sx1fcANzBJJuIlxyGHw" rel="nofollow noreferrer">Try it online!</a></p>
</div>
<div id="pu3" class="pu"><h1><a href="https://github.com/isaacg1/pyth" rel="nofollow noreferrer">Pyth</a>, 99 bytes</h1>
<pre><code>mcR.add+Ksm.&gt;L+0d3*_B1_B.n3s+mm+V*Rkhd*R-QkedStQJf&amp;SITq.aT2^K2mmsMC.b*RlNYkdfq3lT./UQf.A}RJ&gt;3PyT^K3
</code></pre>
<p><a href="https://tio.run/##K6gsyfj/Pzc5SC8xJUXbuzhXz85H2yDFWCveyTDeSS/PuFg7N1c7TCsoOyNFK0g3MDs1Jbgk0CtNLdgzpFAvMcQoztsoN7fY11kvSSsoxy8yOyWt0DgnRE8/NDBNz7E2yMvOOKAyJM7b@P9/EwA" rel="nofollow noreferrer" title="Pyth – Try It Online">Try it online!</a></p>
<p>We begin with the vertices of the regular icosahedron made by all cyclic permutations and sign flips of <span class="math-container">\$(0,1,\phi)\$</span>. Then we find all unordered pairs of edges that have distance 2, interpolate along the edge they specify. Then we find all unordered triplets where all the pairs are in the list of edges, and using partitions of the input we interpolate along the face they specify. Finally we normalize all points.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/263856/">263856</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




