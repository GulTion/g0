<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::50472</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>083</td><td>Julia 1.0</td><td>230914T152226Z</td><td><a href="https://codegolf.stackexchange.com/questions/50472/check-if-words-are-isomorphs/265220#265220">Ashlin H</a></td></tr>
<tr d-ix="1"><td>004</td><td>Vyxal</td><td>230912T090727Z</td><td><a href="https://codegolf.stackexchange.com/questions/50472/check-if-words-are-isomorphs/265153#265153">emanresu</a></td></tr>
<tr d-ix="2"><td>005</td><td>Nekomata + e</td><td>230912T053902Z</td><td><a href="https://codegolf.stackexchange.com/questions/50472/check-if-words-are-isomorphs/265146#265146">alephalp</a></td></tr>
<tr d-ix="3"><td>039</td><td>Raku</td><td>230718T022743Z</td><td><a href="https://codegolf.stackexchange.com/questions/50472/check-if-words-are-isomorphs/262954#262954">bb94</a></td></tr>
<tr d-ix="4"><td>006</td><td>Thunno 2</td><td>230714T092555Z</td><td><a href="https://codegolf.stackexchange.com/questions/50472/check-if-words-are-isomorphs/262789#262789">The Thon</a></td></tr>
<tr d-ix="5"><td>003</td><td>BQN</td><td>220106T073442Z</td><td><a href="https://codegolf.stackexchange.com/questions/50472/check-if-words-are-isomorphs/240664#240664">ovs</a></td></tr>
<tr d-ix="6"><td>032</td><td>Factor + math.extras</td><td>220106T072845Z</td><td><a href="https://codegolf.stackexchange.com/questions/50472/check-if-words-are-isomorphs/240663#240663">chunes</a></td></tr>
<tr d-ix="7"><td>007</td><td>Vyxal</td><td>220106T070732Z</td><td><a href="https://codegolf.stackexchange.com/questions/50472/check-if-words-are-isomorphs/240662#240662">emanresu</a></td></tr>
<tr d-ix="8"><td>098</td><td>JavaScript ES5</td><td>150619T100326Z</td><td><a href="https://codegolf.stackexchange.com/questions/50472/check-if-words-are-isomorphs/51859#51859">C5H8NNaO</a></td></tr>
<tr d-ix="9"><td>004</td><td>Husk</td><td>210221T164742Z</td><td><a href="https://codegolf.stackexchange.com/questions/50472/check-if-words-are-isomorphs/219458#219458">Razetime</a></td></tr>
<tr d-ix="10"><td>062</td><td>R</td><td>210221T234720Z</td><td><a href="https://codegolf.stackexchange.com/questions/50472/check-if-words-are-isomorphs/219471#219471">Dominic </a></td></tr>
<tr d-ix="11"><td>004</td><td>Jelly</td><td>210221T162004Z</td><td><a href="https://codegolf.stackexchange.com/questions/50472/check-if-words-are-isomorphs/219456#219456">caird co</a></td></tr>
<tr d-ix="12"><td>092</td><td>C gcc</td><td>181205T155940Z</td><td><a href="https://codegolf.stackexchange.com/questions/50472/check-if-words-are-isomorphs/177033#177033">Jonathan</a></td></tr>
<tr d-ix="13"><td>008</td><td>Japt</td><td>181210T212635Z</td><td><a href="https://codegolf.stackexchange.com/questions/50472/check-if-words-are-isomorphs/177336#177336">Oliver</a></td></tr>
<tr d-ix="14"><td>072</td><td>C# Visual C# Interactive Compiler</td><td>181206T074523Z</td><td><a href="https://codegolf.stackexchange.com/questions/50472/check-if-words-are-isomorphs/177067#177067">dana</a></td></tr>
<tr d-ix="15"><td>075</td><td>Python 3</td><td>150520T040708Z</td><td><a href="https://codegolf.stackexchange.com/questions/50472/check-if-words-are-isomorphs/50491#50491">DJMcMayh</a></td></tr>
<tr d-ix="16"><td>071</td><td>Powershell</td><td>181205T143306Z</td><td><a href="https://codegolf.stackexchange.com/questions/50472/check-if-words-are-isomorphs/177023#177023">mazzy</a></td></tr>
<tr d-ix="17"><td>006</td><td>Japt</td><td>181205T082811Z</td><td><a href="https://codegolf.stackexchange.com/questions/50472/check-if-words-are-isomorphs/177015#177015">Shaggy</a></td></tr>
<tr d-ix="18"><td>029</td><td>Haskell</td><td>150523T093323Z</td><td><a href="https://codegolf.stackexchange.com/questions/50472/check-if-words-are-isomorphs/50670#50670">proud ha</a></td></tr>
<tr d-ix="19"><td>009</td><td>Japt</td><td>180531T233008Z</td><td><a href="https://codegolf.stackexchange.com/questions/50472/check-if-words-are-isomorphs/165874#165874">Bubbler</a></td></tr>
<tr d-ix="20"><td>049</td><td>Clojure</td><td>171009T114317Z</td><td><a href="https://codegolf.stackexchange.com/questions/50472/check-if-words-are-isomorphs/144738#144738">NikoNyrh</a></td></tr>
<tr d-ix="21"><td>084</td><td>PCRE</td><td>171009T080514Z</td><td><a href="https://codegolf.stackexchange.com/questions/50472/check-if-words-are-isomorphs/144720#144720">jaytea</a></td></tr>
<tr d-ix="22"><td>050</td><td>JavaScript ES6</td><td>171007T161622Z</td><td><a href="https://codegolf.stackexchange.com/questions/50472/check-if-words-are-isomorphs/144610#144610">kamoroso</a></td></tr>
<tr d-ix="23"><td>004</td><td>APL Dyalog</td><td>170927T154520Z</td><td><a href="https://codegolf.stackexchange.com/questions/50472/check-if-words-are-isomorphs/143891#143891">Ad&#225;</a></td></tr>
<tr d-ix="24"><td>162</td><td>C++</td><td>171001T110241Z</td><td><a href="https://codegolf.stackexchange.com/questions/50472/check-if-words-are-isomorphs/144162#144162">HatsuPoi</a></td></tr>
<tr d-ix="25"><td>006</td><td>05AB1E</td><td>170928T142128Z</td><td><a href="https://codegolf.stackexchange.com/questions/50472/check-if-words-are-isomorphs/143971#143971">scottine</a></td></tr>
<tr d-ix="26"><td>005</td><td>Husk</td><td>170928T012627Z</td><td><a href="https://codegolf.stackexchange.com/questions/50472/check-if-words-are-isomorphs/143937#143937">ბიმო</a></td></tr>
<tr d-ix="27"><td>076</td><td>Common Lisp</td><td>170927T200757Z</td><td><a href="https://codegolf.stackexchange.com/questions/50472/check-if-words-are-isomorphs/143912#143912">Renzo</a></td></tr>
<tr d-ix="28"><td>099</td><td>PHP</td><td>170315T135810Z</td><td><a href="https://codegolf.stackexchange.com/questions/50472/check-if-words-are-isomorphs/112936#112936">J&#246;r</a></td></tr>
<tr d-ix="29"><td>038</td><td>Perl</td><td>161121T183438Z</td><td><a href="https://codegolf.stackexchange.com/questions/50472/check-if-words-are-isomorphs/100652#100652">Gabriel </a></td></tr>
<tr d-ix="30"><td>031</td><td>Ruby</td><td>160208T161256Z</td><td><a href="https://codegolf.stackexchange.com/questions/50472/check-if-words-are-isomorphs/71436#71436">histocra</a></td></tr>
<tr d-ix="31"><td>051</td><td>JavaScript</td><td>150519T211717Z</td><td><a href="https://codegolf.stackexchange.com/questions/50472/check-if-words-are-isomorphs/50477#50477">Optimize</a></td></tr>
<tr d-ix="32"><td>265</td><td>C#</td><td>150627T094130Z</td><td><a href="https://codegolf.stackexchange.com/questions/50472/check-if-words-are-isomorphs/52342#52342">fsacer</a></td></tr>
<tr d-ix="33"><td>130</td><td>Brainfuck</td><td>150619T030019Z</td><td><a href="https://codegolf.stackexchange.com/questions/50472/check-if-words-are-isomorphs/51855#51855">Mitch Sc</a></td></tr>
<tr d-ix="34"><td>049</td><td>Ruby</td><td>150523T212030Z</td><td><a href="https://codegolf.stackexchange.com/questions/50472/check-if-words-are-isomorphs/50683#50683">tylerksc</a></td></tr>
<tr d-ix="35"><td>041</td><td>Haskell</td><td>150519T231404Z</td><td><a href="https://codegolf.stackexchange.com/questions/50472/check-if-words-are-isomorphs/50487#50487">nimi</a></td></tr>
<tr d-ix="36"><td>041</td><td>Python 2</td><td>150522T030526Z</td><td><a href="https://codegolf.stackexchange.com/questions/50472/check-if-words-are-isomorphs/50612#50612">ygramul</a></td></tr>
<tr d-ix="37"><td>026</td><td>Octave</td><td>150522T030153Z</td><td><a href="https://codegolf.stackexchange.com/questions/50472/check-if-words-are-isomorphs/50611#50611">alephalp</a></td></tr>
<tr d-ix="38"><td>072</td><td>Cobra</td><td>150521T062402Z</td><td><a href="https://codegolf.stackexchange.com/questions/50472/check-if-words-are-isomorphs/50551#50551">Οurous</a></td></tr>
<tr d-ix="39"><td>050</td><td>Matlab</td><td>150520T212124Z</td><td><a href="https://codegolf.stackexchange.com/questions/50472/check-if-words-are-isomorphs/50529#50529">Luis Men</a></td></tr>
<tr d-ix="40"><td>107</td><td>Java</td><td>150519T212742Z</td><td><a href="https://codegolf.stackexchange.com/questions/50472/check-if-words-are-isomorphs/50479#50479">Ypnypn</a></td></tr>
<tr d-ix="41"><td>050</td><td>Ruby</td><td>150520T064253Z</td><td><a href="https://codegolf.stackexchange.com/questions/50472/check-if-words-are-isomorphs/50495#50495">blutoran</a></td></tr>
<tr d-ix="42"><td>009</td><td>Pyth</td><td>150520T064857Z</td><td><a href="https://codegolf.stackexchange.com/questions/50472/check-if-words-are-isomorphs/50496#50496">isaacg</a></td></tr>
<tr d-ix="43"><td>046</td><td>Mathematica</td><td>150520T063348Z</td><td><a href="https://codegolf.stackexchange.com/questions/50472/check-if-words-are-isomorphs/50493#50493">alephalp</a></td></tr>
<tr d-ix="44"><td>083</td><td>Ruby</td><td>150519T205330Z</td><td><a href="https://codegolf.stackexchange.com/questions/50472/check-if-words-are-isomorphs/50474#50474">Doorknob</a></td></tr>
<tr d-ix="45"><td>085</td><td>Python 3</td><td>150519T210636Z</td><td><a href="https://codegolf.stackexchange.com/questions/50472/check-if-words-are-isomorphs/50476#50476">TheNumbe</a></td></tr>
<tr d-ix="46"><td>078</td><td>R</td><td>150520T015401Z</td><td><a href="https://codegolf.stackexchange.com/questions/50472/check-if-words-are-isomorphs/50489#50489">flodel</a></td></tr>
<tr d-ix="47"><td>038</td><td>Bash + coreutils</td><td>150519T234448Z</td><td><a href="https://codegolf.stackexchange.com/questions/50472/check-if-words-are-isomorphs/50488#50488">Digital </a></td></tr>
<tr d-ix="48"><td>009</td><td>CJam</td><td>150519T205028Z</td><td><a href="https://codegolf.stackexchange.com/questions/50472/check-if-words-are-isomorphs/50473#50473">Dennis</a></td></tr>
<tr d-ix="49"><td>005</td><td>K</td><td>150519T214423Z</td><td><a href="https://codegolf.stackexchange.com/questions/50472/check-if-words-are-isomorphs/50481#50481">JohnE</a></td></tr>
<tr d-ix="50"><td>004</td><td>J</td><td>150519T205733Z</td><td><a href="https://codegolf.stackexchange.com/questions/50472/check-if-words-are-isomorphs/50475#50475">randomra</a></td></tr>
<tr d-ix="51"><td>062</td><td>JavaScript ES6</td><td>150519T212152Z</td><td><a href="https://codegolf.stackexchange.com/questions/50472/check-if-words-are-isomorphs/50478#50478">edc65</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="http://julialang.org/" rel="nofollow noreferrer">Julia 1.0</a>, 83 bytes</h1>

<pre class="lang-julia prettyprint-override"><code>a^b=Set(zip([a...],[b...]))
!x=allunique(first.(x))
~=length
a\b=!a^b&amp;&amp;!b^a&amp;&amp;~a==~b
</code></pre>
<p><a href="https://tio.run/##TU/RauMwEHy2vmLzEhwIhvsAHSfLChXETomcXkybgJzKra6u4rNlyPUhv56umpYrYne0oxnt7p@xtfrH6XLR@5oq4@M328X3OkmS3fy@DjCbkcmJ6rYdnf07mrix/eCT@IT8mbbGPflnoh9qOsEfptNJvdfT6VlTeq4vzegO3h4dHJ7N4SWekcicOnPw5hEo@H40JGqOPViwDnqjH1vrzBBkkW3ADua18/9iG@rvxka3Azojc4VIz6FGWvneuqckHrrWenR92I6j70aPrxoeoA5MhyrfOtxxXu/oz6vgQ/tLD4PpPXx5KHw1Dc0c5pBCkM99LkKVrBSQbcRSZOQKcCXJdruFqqoITxlLOWRisUDNmuXppuClXG3UsoLyRqzzVVYVLJdckUwqvpa5LFgp7wQomd8u5UJyLFcFIUogx34TVpQKbkMmKSvwgBJrUYj/VaGEIiwFznGOCrY4Bw6RMo4BnzeWIhc02Ts" rel="nofollow noreferrer" title="Julia 1.0 – Try It Online">Try it online!</a></p>
<p>Checks that characters map uniquely in both directions, and that both strings are the same length.</p>
</div>
<div id="pu1" class="pu"><h1><a href="https://github.com/Vyxal/Vyxal" rel="nofollow noreferrer">Vyxal</a>, 4 bytes</h1>
<pre><code>¨£β≈
</code></pre>
<p><a href="https://vyxal.pythonanywhere.com/?v=2#WyJBIiwiIiwiwqjCo86y4omIIiwiIiwiW1wiZXN0YXRlXCIsXCJkdWVsZWRcIl1cbltcImhlbGxvXCIsIFwid29ybGRcIl1cbltcImhhcHB5XCIsIFwic3VubnlcIl1cbltcImFfYi1jL2EvX1wiLCBcInEqaikoaXFpKlwiXSJd" rel="nofollow noreferrer">Try it Online!</a></p>
<pre><code>¨£   # Zipwith...
  β  # Convert &lt;str&gt; from custom base &lt;str&gt;
   ≈ # All equal?
</code></pre>
</div>
<div id="pu2" class="pu"><h1><a href="https://github.com/AlephAlpha/Nekomata" rel="nofollow noreferrer">Nekomata</a> + <code>-e</code>, 5 bytes</h1>
<pre><code>ŤuŤᵐů
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=XVC9TsMwEBYrj8CEPCc76_lyEZZip4odiBV1KKhdqsLQ9j3YWToECSEkJh4hL8HGm3D-6YIsy_f93PmzX9-f1tvn3eqw-hxFuRPFtSjXYnl6Ox425c3HPB3n6ff7Zf6a9g-P-0yffi6uRkHWgSNRiKqnhiqxvBzPZXEWAzcMAxPe-4hQAkgMXVTXuasDLXuDTrW9bTxr7pY63VbegFZo02RlsVNaGXDqLtxqlV40qlbIRGuix1IU4D4iMM4yXMQzEBIMr-Cgjgz954yl5APJGDGHD3mGHJ6TS0DezOWazUlJXfyg9Ed_" rel="nofollow noreferrer">Attempt This Online!</a></p>
<p>Takes input as a list of two strings.</p>
<pre><code>ŤuŤᵐů
Ť       Transpose; [&quot;ESTATE&quot;,&quot;DUELED&quot;] -&gt; [&quot;ED&quot;,&quot;SU&quot;,&quot;TE&quot;,&quot;AL&quot;,&quot;TE&quot;,&quot;ED&quot;]
 u      Uniquify; [&quot;ED&quot;,&quot;SU&quot;,&quot;TE&quot;,&quot;AL&quot;,&quot;TE&quot;,&quot;ED&quot;] -&gt; [&quot;ED&quot;,&quot;SU&quot;,&quot;TE&quot;,&quot;AL&quot;]
  Ť     Transpose; [&quot;ED&quot;,&quot;SU&quot;,&quot;TE&quot;,&quot;AL&quot;] -&gt; [&quot;ESTA&quot;,&quot;DUEL&quot;]
   ᵐů   Check that neither string contains duplicate characters
</code></pre>
</div>
<div id="pu3" class="pu"><h1><a href="https://github.com/nxadm/rakudo-pkg" rel="nofollow noreferrer">Raku</a>, 39 bytes</h1>

<pre class="lang-perl6 prettyprint-override"><code>{[eq] map {map {.index($^a)},.comb},@_}
</code></pre>
<p><a href="https://tio.run/##RU5Na4NAFDx3f8VDRLQVk156KYW@/ZAu6BrcTevSL2yrEIhJmhzaIP52s0kKZXjzZoY5zKbZLm/Gbg9BC3dj/9x8v0JXb6A/UbJYfTW/of9WR0OcfK67jyG@fx/GW9Kut@BfSpUsF6tmBz25mIQvP1cReA4nNYEggF29B8@fgn8NfRv609ipaPDIMApt0Ajgc5EJTs4PziGpqgqstYRRRMqAizR1nRJzOlfMyGKuMwvmQZR5wa3CXDJNuNSslLlUaOSjAC3zWSZTyZwtFNHCRfhEUBkNsyMTisoBtCiFEv9OaaEJUmDMzbBQuRluA0XmDv4UUpcdO/wA" rel="nofollow noreferrer" title="Perl 6 – Try It Online">Try it online!</a></p>
</div>
<div id="pu4" class="pu"><h1><a href="https://github.com/Thunno/Thunno2" rel="nofollow noreferrer">Thunno 2</a>, 6 <a href="https://github.com/Thunno/Thunno2/blob/main/docs/codepage.md" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>ıʠ€ạ;ạ
</code></pre>
<p><a href="https://Not-Thonnu.github.io/run#aGVhZGVyPSZjb2RlPSVDNCVCMSVDQSVBMCVFMiU4MiVBQyVFMSVCQSVBMSUzQiVFMSVCQSVBMSZmb290ZXI9JmlucHV0PSUyMkVTVEFURSUyMiUyQyUyMCUyMkRVRUxFRCUyMiZmbGFncz0=" rel="nofollow noreferrer">Try it online!</a></p>
<h4>Explanation</h4>
<pre class="lang-python prettyprint-override"><code>ıʠ€ạ;ạ  # Implicit input 
ı   ;   # Map:
 ʠ      #  Powerset of the string
  €     #  For each one:
   ạ    #   Check if all equal
     ạ  # Check if all equal
        # Implicit output
</code></pre>
</div>
<div id="pu5" class="pu"><h1><a href="https://mlochbaum.github.io/BQN/" rel="nofollow noreferrer">BQN</a>, 3 bytes<sup><a href="https://github.com/mlochbaum/BQN/blob/master/commentary/sbcs.bqn" rel="nofollow noreferrer">SBCS</a></sup></h1>
<pre class="lang-none prettyprint-override"><code>≡○⊐
</code></pre>
<p><a href="https://mlochbaum.github.io/BQN/try.html#code=RiDihpAg4omh4peL4oqQCgo+4ouI4p+cKEbCtCnCqOKfqCJFU1RBVEUi4oC/IkRVRUxFRCIKIkRVRUxFRCLigL8iRVNUQVRFIgoiWFhYIuKAvyJZWVkiCiJDQkFBQkMi4oC/IkRFRkZFRCIKIlJBTUJVTkNUSU9VU0xZIuKAvyJUSEVSTU9EWU5BTUlDUyIKIkRJU0NSSU1JTkFUSVZFIuKAvyJTSU1QTElGSUNBVElPTiIKIlNFRSLigL8iU0FXIgoiQU5UUyLigL8iUEFOVFMiCiJCQU5BTkEi4oC/IlNFUkVORSIKIkJBTkFOQSLigL8iU0VOU0VTIgoiQUIi4oC/IkNDIgoiWFhZIuKAvyJYWVkiCiJBQkNCQUNDQkEi4oC/IkFCQ0JBQ0NBQiIKIkFCQUIi4oC/IkNEIuKfqQ==" rel="nofollow noreferrer">Run online!</a></p>
<p>The builtin <em>Classify</em> <code>⊐</code> gets the pattern of letter repetitions for a given string as a vector of non-negative integers. All that's left to do is to compare the two results for equality.</p>
<pre><code>⊐ &quot;ESTATE&quot;
# ⟨ 0 1 2 3 2 0 ⟩
⊐ &quot;DUELED&quot;
# ⟨ 0 1 2 3 2 0 ⟩
(⊐ &quot;ESTATE&quot;) ≡ (⊐ &quot;DUELED&quot;)
# 1
&quot;ESTATE&quot; ≡○⊐ &quot;DUELED&quot;
# 1
</code></pre>
</div>
<div id="pu6" class="pu"><h1><a href="https://factorcode.org/" rel="nofollow noreferrer">Factor</a> + <code>math.extras</code>, 32 bytes</h1>
<pre><code>[ [ unique-indices nip ] same? ]
</code></pre>
<p><a href="https://tio.run/##bZHtaoMwGIX/exXnBtYL2GAjxrgGNBajm1L6I7iMyab1I6Ub4rW7dOtahSUkJM857xsOeVWF2XdTKrl4vIXq@33R4113tf5ApczbSn@aTvVoOm3MV9OVtUF7xJ3jDA7saI8DmExIwuClLGAexgs/g7N85VmWIc/zGaEuIS6Fx3x/0SEmoZsKmvAolUGOZM3iMPJyQUJO5fwlLmnMQy5Iwp8YJA83Afc5tddIWN/FKJlVyfOslIhEYvOzX6FLhJ3WHTPB/uNCsrmfuKB0kTBHtkho47mE2vV3siVz9dThlHycttjiUJftQd@U9UtZ6B512WCHXlX6AbtpwPj7UfeVarCavgE" rel="nofollow noreferrer" title="Factor – Try It Online">Try it online!</a></p>
<p><code>unique-indices</code> is a word that produces output like this:</p>
<pre><code>                ! &quot;ESTATE&quot;
unique-indices  ! &quot;ESTA&quot; { 0 1 2 3 2 0 }
</code></pre>
<p>We don't need the elements, only the indices, so we <code>nip</code> them to get rid of them.</p>
</div>
<div id="pu7" class="pu"><h1><a href="https://github.com/Vyxal/Vyxal" rel="nofollow noreferrer">Vyxal</a>, 7 bytes</h1>
<pre><code>ƛUẊv≈;≈
</code></pre>
<p><a href="https://vyxal.pythonanywhere.com/#WyIiLCIiLCLGm1Xhuop24omIO+KJiCIsIiIsIltcIkRJU0NSSU1JTkFUSVZFXCIsXCJTSU1QTElGSUNBVElPTlwiXSJd" rel="nofollow noreferrer">Try it Online!</a></p>
<pre><code>ƛ    ;≈ # Same upon...
  Ẋ     # Cartesian product of...
 U      # Uniquified value
        # And (implicit) value
   v≈   # For each, same?
</code></pre>
</div>
<div id="pu8" class="pu"><h1 id="javascript-es5-142-98-z2yg">JavaScript (ES5), <s>142</s> 98</h1>
<p>Quite a big one, but I didn't saw an ES5 version yet.</p>
<p><code>for(l=j=2;j--;){c=prompt();for(i=c.length;i--;)c=c.replace(RegExp(c[i],&quot;g&quot;),i);b=l==c;l=c}alert(b)</code></p>
<p>Simply replaces every occurence of the first letter with it's reverse index value. Repeats this for every character.</p>
<p>It does the same for both inputs and compares the generated pattern.</p>
<p>The comparison is quite ugly, but i din't wan't to use an array to store and compare it.</p>
</div>
<div id="pu9" class="pu"><h1><a href="https://github.com/barbuz/Husk" rel="nofollow noreferrer">Husk</a>, <sup><s>5</s></sup> 4 bytes</h1>
<pre><code>Ë´Ṫ=
</code></pre>
<p><a href="https://tio.run/##yygtzv7//3D3oS0Pd66y/f//f7SSa3CIY4irko6SS6irj6uLUiwA" rel="nofollow noreferrer" title="Husk – Try It Online">Try it online!</a></p>
<p>-1 byte from Leo using ბიმო's answer.</p>
<h2>Explanation</h2>
<pre><code>Ë´Ṫ=
Ë    check if all the elements are equal by the following predicate:
 ´Ṫ  cartesian product with self
   = by equality
</code></pre>
</div>
<div id="pu10" class="pu"><h1><a href="https://www.r-project.org/" rel="nofollow noreferrer">R</a>, 62 bytes</h1>

<pre class="lang-r prettyprint-override"><code>function(x,y,`[`=chartr)x[z&lt;-Reduce(paste0,LETTERS),x]==y[z,y]
</code></pre>
<p><a href="https://tio.run/##dVDdaoMwFL7fY3ilkMEeYF6cxCMLaCxJ3BQptDhHe7FarAXty7tj122NMELI4ftL8nXT/tR@tt1xF04f50Pd79uDP7CRbapNWO@2Xd8FQ3V5ftTN@7lu/OP21DdPLEFrUZuADeswHKsLG9e/Qb6HxoJFj3lRjglGXvDwx90g9iO654qiIKIsSwcVHICLOQ3jeJGmIeW5ElZmuUlK0tgX1GkWlQpSKYx7szRCy1QqsPJ1fp2R6SqRsRQEZMrRGrwK4M1BQVlD8Op63hMcFK3ZgRoV/scpg64POOFCLEqY/1EsSqAGOAjaxN1mMruK7zQqaPoC" rel="nofollow noreferrer" title="R – Try It Online">Try it online!</a></p>
<p>Translates (<code>chartr</code>) the characters or each string in order of occurrence into <code>ABC...XYZ</code>.
After this, isomorphic strings are identical.</p>
<p>To save bytes (at the expense of readability), we redefine the <a href="https://www.r-project.org/" rel="nofollow noreferrer">R</a> index operator <code>[</code> as an alias of the <code>chartr</code> function, and we define <code>z</code> as a string containing the uppercase alphabet.<br />
Without these golfs, the (readable) function would be:</p>
<pre class="lang-r prettyprint-override"><code>function(x,y) chartr(x,&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;,x)==chartr(y,&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;,y)
</code></pre>
</div>
<div id="pu11" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="nofollow noreferrer">Jelly</a>, 4 bytes</h1>
<pre><code>ĠṢ)E
</code></pre>
<p><a href="https://tio.run/##RU47bsMwDN11Cg5ZeoZOFEWjRCzZMOXWOkCWwBfImiXXKDpnCjq06NhexL2ISsMBCuLxffCGdzzM86nWn9fl8@2B6/L1vnzcfs/Xx@/LzmhvKLWyZswMYeSWg9sIttBN0wSlFEce0RMEbhrrDBj9mChLN2pbID/xELtQEkYhdUGUBomSMMszg0rsW2mEzHbJKVuELw5TVujX7zwmO1AeOPG/S8rq0AORzSgw2Qzb4JEMcFfoLVs74Q8" rel="nofollow noreferrer" title="Jelly – Try It Online">Try it online!</a></p>
<p><a href="https://tio.run/##RU47bsMwDN11Cg5ZeoZOFEWjRCzZMOXWOkCXIhfImqWXKQIkyNDP2JPYF1FpOEBBPL4P3vDeXg@HY63z99dyOT9wnX9u8@d1OX08/r7vjPaGUitrxswQRm45uI1gC900TVBKceQRPUHgprHOgNGPibJ0o7YF8hMPsQslYRRSF0RpkCgJszwzqMS@lUbIbJecskX44jBlhX79zmOyA@WBE/@7pKwOPRDZjAKTzbANHskAd4XesrUT/gA" rel="nofollow noreferrer">Another 4 byte version</a></p>
<h2>How they work</h2>
<pre><code>ĠṢ)E - Main link. Takes [A, B] on the left
  )  - Over each string S in the input:
Ġ    -   Group the indices of S by it's values
 Ṣ   -   Sort the lists of indices
   E - Are both equal?

ẹⱮ)E - Main link. Takes [A, B] on the left
  )  - Over each string S in the input:
 Ɱ   -   For each character C in S:
ẹ    -     Get the indices of C in S
   E - Are both equal?
</code></pre>
</div>
<div id="pu12" class="pu"><h1><a href="https://gcc.gnu.org/" rel="nofollow noreferrer">C (gcc)</a>, <s>93</s> 92 bytes</h1>

<ul>
<li>Saved a byte thanks to <a href="https://codegolf.stackexchange.com/users/52904/ceilingcat">ceilingcat</a>; performing an index shift.</li>
</ul>



<pre class="lang-c prettyprint-override"><code>m,o;r(char*p,char*h){for(o=0;*p;p++,++h)for(m=0;p[m];)o|=(p[m]==*p)^(h[m++]==*h);o|=*p!=*h;}
</code></pre>

<p><a href="https://tio.run/##bZBfa4MwFMWf209hMwaJOtjzREZMIwuoLUY3pdugWJ2FqcG2L@v62V1i/zkoQXLzO@fceJM9fGVZ11VmY7UwK5etLsx@K9G@aFrY2I@WLixhGKZhlEihSiKxqD4s1PzaUFW2rQv0CctFZRjqUCJLSrqYyNI6dHervFjXuRaFMYUb8weJdl1vCwi27S7XtOcn7X71XgNz0vYqssbnhIs9/j9SLL83@a3IuFqua4j241F/DaA8whEFJpjG1KNTgM7C6WyeHRchSRJJ0zS9IuJg7BDVhLrusEmIfScOSMRmMfdSaYheaOjPpmmAfUb44DbGSch8FuCIvarf4cyfe8xlRIJZoIxit91AAOQMo@O8gNPeid@UfGI4iLiE836/YgcHcik3DWlAbysBp8MMdiQlZECSRM2QHEe/uOT0RH5SOdUyONSPfdSrHLo/" rel="nofollow noreferrer" title="C (gcc) – Try It Online">Try it online!</a></p>
</div>
<div id="pu13" class="pu"><h1><a href="https://github.com/ETHproductions/japt" rel="nofollow noreferrer">Japt</a>, 8 bytes</h1>

<pre><code>®m!bZÃr¥
</code></pre>

<p><a href="https://tio.run/##y0osKPn//9C6XMWkqMPNRYeW/v8freQaHOIY4qqko@QS6urj6qIUCwA" rel="nofollow noreferrer" title="Japt – Try It Online">Try it online!</a></p>
</div>
<div id="pu14" class="pu"><h1><a href="http://www.mono-project.com/docs/about-mono/releases/5.0.0/#csc" rel="nofollow noreferrer">C# (Visual C# Interactive Compiler)</a>, 72 bytes</h1>



<pre class="lang-cs prettyprint-override"><code>a=&gt;b=&gt;a.Select(c=&gt;a.IndexOf(c)).SequenceEqual(b.Select(c=&gt;b.IndexOf(c)))
</code></pre>

<p><a href="https://tio.run/##fY7dCoJAFITvfQrxahcqH8BcWPUsBGLRGuqlbmsIsuIf9PamVmQGcW6Gme8MI9qtaIuB9Urs264p1G2z1FlVlYTouW4PqU0ym6Q7LkspOiQmfVBXeT/mSGA8@nUvlZBQ92mJsgWXLTk8WJpmmnrY9FKLmqKTfqEkypEBPKQhGBgZ3gV88AyMrW/i7X/YNRHH8RQnSfKbuQ6ljjv3A2Ov/mkKS8t2tYXDPITT6LeHBiGfwtNTrGOHBuPN33CGAP4TAYe5Y3gA" rel="nofollow noreferrer" title="C# (Visual C# Interactive Compiler) – Try It Online">Try it online!</a></p>

<p>This is a port of @ygramul answer...</p>

<p>My original answer is below:</p>

<h1><a href="http://www.mono-project.com/docs/about-mono/releases/5.0.0/#csc" rel="nofollow noreferrer">C# (Visual C# Interactive Compiler)</a>, 84 bytes</h1>



<pre class="lang-cs prettyprint-override"><code>a=&gt;b=&gt;a.Length==b.Length&amp;&amp;!a.Where((x,i)=&gt;b.IndexOf(b[i++],i)!=a.IndexOf(x,i)).Any()
</code></pre>

<p><a href="https://tio.run/##fY7dCoJAFITvfQrzInax7AFqhbWOEIhFa6hEF6uttRAbqEE9van9G8S5GWa@M0xaDNNCVu5ZpZOizKXaDz51cjodbVvPdFJxYifE5pYn1L48EJI8VL/f41Z4ELlA6DKQuMasudqJyyJDyUaa5rY2e4S/zAbCFlVXhKuxpo1GepCfhRbmshSeVAJlyAAW0AAMjIzZGjyYGRiPv4mn/2a7RBRFTRzH8W82dSh1pm0/uO6jv5ni8mPR2cKgHcJo@NtD/YA14fIuurFD/frab1iBD/8Jn0HbUd0A" rel="nofollow noreferrer" title="C# (Visual C# Interactive Compiler) – Try It Online">Try it online!</a></p>

<p>Less golfed...</p>

<pre class="lang-cs prettyprint-override"><code>// a and b are strings to compare
a=&gt;b=&gt;
  // ensure equal lenghts
  a.Length==b.Length&amp;&amp;
  // iterate over characters in a
  !a.Where((x,i)=&gt;
    // find next occurrence of current
    // char in b
    b.IndexOf(b[i++],i) !=
    // compare to next occurrence
    // of corresponding char in a
    a.IndexOf(x,i)
  // check for any mismatches
  // and negate the result
  ).Any()
</code></pre>
</div>
<div id="pu15" class="pu"><h1><a href="https://docs.python.org/3/" rel="nofollow noreferrer">Python 3</a>, 75 bytes</h1>



<pre class="lang-python prettyprint-override"><code>def C():s=input();return' '.join(str(s.index(c))for c in s)
print(C()==C())
</code></pre>

<p><a href="https://tio.run/##Dcw9EoIwEEDhnlNsx25DY6eTQlH8OwWEIEuxyWyWGT19TPO676WfrVEOpcxhgR7pmB1L2g3ppMF2lRbabossmE0xdyxz@KInWqKCBxbI1CRlMazauRoq5Xzpr7fh/ni@3s04@fr@rLxN4x8" rel="nofollow noreferrer" title="Python 3 – Try It Online">Try it online!</a></p>
</div>
<div id="pu16" class="pu"><h1>Powershell, 71 bytes</h1>



<pre class="lang-powershell prettyprint-override"><code>param($a,$b)filter i{($s=$_)|% t*y|%{$s|% i*f $_}}"$($a|i)"-eq"$($b|i)"
</code></pre>

<p>Less golfed test script:</p>

<pre class="lang-powershell prettyprint-override"><code>$f = {

param($a,$b)
filter i{
    ($s=$_)|% toCharArray|%{$s|% indexOf $_}  # returns an array of first position of each char
}
"$($a|i)"-eq"$($b|i)"                         # returns equality of two array.toString()

}

@(
    ,("ESTATE", "DUELED", $true)
    ,("DUELED", "ESTATE", $true)
    ,("XXX", "YYY", $true)
    ,("CBAABC", "DEFFED", $true)
    ,("RAMBUNCTIOUSLY", "THERMODYNAMICS", $true)
    ,("DISCRIMINATIVE", "SIMPLIFICATION", $true)
    ,("SEE", "SAW", $false)
    ,("ANTS", "PANTS", $false)
    ,("BANANA", "SERENE", $false)
    ,("BANANA", "SENSES", $false)
    ,("AB", "CC", $false)
    ,("XXY", "XYY", $false)
    ,("ABCBACCBA", "ABCBACCAB", $false)
    ,("ABAB", "CD", $false)
) | % {
    $a,$b,$expected = $_
    $result = &amp;$f $a $b
    "$($result-eq$expected): $result"

}
</code></pre>

<p>Output:</p>

<pre class="lang-powershell prettyprint-override"><code>True: True
True: True
True: True
True: True
True: True
True: True
True: False
True: False
True: False
True: False
True: False
True: False
True: False
True: False
</code></pre>
</div>
<div id="pu17" class="pu"><h1><a href="https://github.com/ETHproductions/japt" rel="nofollow noreferrer">Japt</a>, 6 bytes</h1>
<p>Takes input as an array of 2 strings.</p>
<pre><code>®ï¥Ãre
</code></pre>
<p><a href="https://ethproductions.github.io/japt/?v=1.4.6&amp;code=ru+lw3Jl&amp;input=WyJFU1RBVEUiLCJEVUVMRUQiXQ==" rel="nofollow noreferrer">Try it</a></p>
<pre><code>®          :Map input array
 ï         :  Cartesian product of each string with itself
  ¥        :  Reduce each pair of characters by testing for equality
   Ã       :End map
    r      :Reduce by
     e     : Array equality
</code></pre>
</div>
<div id="pu18" class="pu"><h1>Haskell, <s>33</s> 29</h1>
<h1>EDIT:</h1>
<p>this is way too late, but i found this improvement using applicatives, that were added to prelude only in march 2015.</p>
<pre><code>s%k=g s==g k
g s=(==)&lt;$&gt;s&lt;*&gt;s
</code></pre>
<p>Old version:</p>
<pre><code>s%k=g s==g k
g s=[a==b|a&lt;-s,b&lt;-s]
</code></pre>
<p>the checking function is <code>(%)</code></p>
<p>this works by generating for each string its &quot;equality record&quot;: for each two indices i j, it records whether they have equal characters. the record is ordered so that the record for two indices i, j is always in the same place*
and therefore checking the equality of the records would return whether or not the strings have the same pattern.</p>
<p>for example, the equality record of &quot;ABC&quot; is <code>[1,0,0,0,1,0,0,0,1]</code> (1 for true, 0 for false) - there is <code>True</code> where any index is compared with itself. anywhere else is a false. (skipping these checks might be more efficient, but is harder in terms of golfng)</p>
<p>*<sub>if the strings are of the same length. otherwise it returns false just because the records are of different lengths</sub></p>
</div>
<div id="pu19" class="pu"><h1><a href="https://github.com/ETHproductions/japt" rel="nofollow noreferrer">Japt</a>, 9 bytes</h1>

<pre><code>®¬m!âZÃre
</code></pre>

<p><a href="https://ethproductions.github.io/japt/?v=2.0a0&amp;code=rqxtIeJaw3Jl&amp;input=LW1SIFsKWyJFU1RBVEUiLCJEVUVMRUQiXSwKWyJEVUVMRUQiLCJFU1RBVEUiXSwKWyJYWFgiLCJZWVkiXSwKWyJDQkFBQkMiLCJERUZGRUQiXSwKWyJSQU1CVU5DVElPVVNMWSIsIlRIRVJNT0RZTkFNSUNTIl0sClsiRElTQ1JJTUlOQVRJVkUiLCJTSU1QTElGSUNBVElPTiJdLApbIlNFRSIsIlNBVyJdLApbIkFOVFMiLCJQQU5UUyJdLApbIkJBTkFOQSIsIlNFUkVORSJdLApbIkJBTkFOQSIsIlNFTlNFUyJdLApbIkFCIiwiQ0MiXSwKWyJYWFkiLCJYWVkiXSwKWyJBQkNCQUNDQkEiLCJBQkNCQUNDQUIiXSwKWyJBQkFCIiwiQ0QiXQpd" rel="nofollow noreferrer">Try it online!</a></p>

<p>Takes an array of two strings.</p>

<h3>Unpacked &amp; How it works</h3>

<pre><code>UmZ{Zq m!âZ} re

UmZ{     Map with...
Zq m       Split into chars and map...
!âZ          X=&gt;Z.â(X)
             char=&gt;str.search(char); First index of the char
}
re       Reduce with Array equality
</code></pre>
</div>
<div id="pu20" class="pu"><h2>Clojure, 49 bytes</h2>

<pre><code>#(apply =(for[s %&amp;](for[a s b s](= a b))))
</code></pre>

<p>Hey it works on any number of arguments!</p>
</div>
<div id="pu21" class="pu"><h2>PCRE, 84 bytes</h2>

<pre><code>^((.)(?=.+ (\3.|)(.))(?=((?=(\2|)?+.* \3\4(\7?(?(?=.*+\6)(?!\4).|\4))).)+ ))+. \3..$ 
</code></pre>

<p>Subject should be two space-separated words, as in the OP. Here's a cursory explanation:</p>

<blockquote>
  <p>For each letter X in the first word:</p>
  
  <blockquote>
    <p>Look ahead to the second word and establish back references to recall how far along we are as well as the letter Y in the second word corresponding to X.</p>
    
    <p>For each letter Z past the current position in the first word:</p>
    
    <blockquote>
      <p>Establish similar back references as above.</p>
      
      <p>Look ahead to the corresponding letter in the second word and check if Z = X then match a Y, otherwise match a letter that isn't Y.</p>
    </blockquote>
  </blockquote>
  
  <p>This iteration can end once we've matched up until the penultimate letter in the first word. At this point, since no further validation is necessary, all that remains is to test that the words are of equal length (the back reference containing accumulating substrings of the second word is always behind by 1 letter).</p>
</blockquote>
</div>
<div id="pu22" class="pu"><h1>JavaScript (ES6), <s>52</s> <s>51</s> 50 bytes</h1>
<p>This version doesn't use array comprehension, and takes input using currying syntax.</p>
<pre><code>a=&gt;b=&gt;(f=x=&gt;0+[...x].map(c=&gt;x.search(c)))(a)==f(b)
</code></pre>
<p><div class="snippet" data-lang="js" data-hide="true" data-console="true" data-babel="false">
<div class="snippet-code snippet-currently-hidden">
<pre class="snippet-code-js lang-js prettyprint-override"><code>const isomorph = a=&gt;b=&gt;(f=x=&gt;0+[...x].map(c=&gt;x.search(c)))(a)==f(b);
const tests = [
  {input: ["ESTATE", "DUELED"], expected: true},
  {input: ["DUELED", "ESTATE"], expected: true},
  {input: ["XXX", "YYY"], expected: true},
  {input: ["CBAABC", "DEFFED"], expected: true},
  {input: ["RAMBUNCTIOUSLY", "THERMODYNAMICS"], expected: true},
  {input: ["DISCRIMINATIVE", "SIMPLIFICATION"], expected: true},
  {input: ["SEE", "SAW"], expected: false},
  {input: ["ANTS", "PANTS"], expected: false},
  {input: ["BANANA", "SERENE"], expected: false},
  {input: ["BANANA", "SENSES"], expected: false},
  {input: ["AB", "CC"], expected: false},
  {input: ["XXY", "XYY"], expected: false},
  {input: ["ABCBACCBA", "ABCBACCAB"], expected: false},
  {input: ["ABAB", "CD"], expected: false}
];

for(const { input: [str1, str2], expected } of tests) {
  console.log(`isomorph("${str1}")("${str2}") = ${isomorph(str1)(str2)}, expected = ${expected}`);
}</code></pre>
</div>
</div>
</p>
</div>
<div id="pu23" class="pu"><h1><a href="https://www.dyalog.com/" rel="nofollow noreferrer">APL (Dyalog)</a>, <s>5</s> 4 bytes</h1>



<p>-1 thanks to ngn's hint.</p>

<p>Anonymous tacit prefix function which takes a list of two strings as argument.</p>

<pre class="lang-apl prettyprint-override"><code>≡.⍳⍨
</code></pre>

<p><a href="https://tio.run/##XU69CsIwEN59CrdM@g6X6xUPmrQkqTajILoIuvoCgkPBV3Bz9436InpJSwcJIff9Xb799bw63Pbny@n7PQ735/B4rYf@M/RvwUtFPkAgtVRFSxUVanGcx1lMXNd1QsQYM0INoDGlqCynlAOjW4uB69ZXUbSwIWfqIlowjH7czB4dG7YQeJt@9WyaiktGIWqbPZ6yALuMwAYvsMlvIjRYOclBjiz9c9bT6AMtGHEqn/p0U3lprgHlqnkW86iMqUL9AA" rel="nofollow noreferrer" title="APL (Dyalog Unicode) – Try It Online">Try it Online!</a></p>

<p>This is an inner product, but instead of the usual <code>+</code> and <code>×</code> it uses</p>

<p><code>≡</code> identicalness </p>

<p><code>.</code> and </p>

<p><code>⍳</code> the <strong>ɩ</strong>ndex (the first occurrence of each element)</p>

<p><code>⍨</code> with the entire two-element list of words used as both arguments</p>

<p>If we call the words <code>A</code> and <code>B</code>, then we can derive the previous solution as follows:</p>

<p><code>≡.⍳⍨ A B</code><br>
<code>A B ≡.⍳ A B</code><br>
<code>(A⍳A) ≡ (B⍳B)</code><br>
<code>(⍳⍨A) ≡ (⍳⍨B)</code><br>
<code>≡/ ⍳⍨¨ A B</code></p>

<h3>Previous solution</h3>

<p>Anonymous tacit prefix function which takes a list of two strings as argument.</p>

<pre class="lang-apl prettyprint-override"><code>≡/⍳⍨¨
</code></pre>

<p><a href="https://tio.run/##XU5LCsIwEN17CndZiWeYTKc40KSlSbVZFqRuBN16AcGF4BXcufcGHqUX0UlaupAQMu83ed35uNpfuuPp8P32w/Ux3J7r4f4e7q/PS5ilIufBk1qqrKGCMrXo53EWI9e2rRAhhIRQA2iMKcrzKVWD0Y1Fz2XjiiCa31BtyixYMIxu3MwOazZswfM2/urYVAXnjEKUNnkcJQF2CYH1TmCV3khosHKig2qy9M9ZR6MPtGDEqXzs007lpbkGlKvmWcyjMqYy9QM" rel="nofollow noreferrer" title="APL (Dyalog Unicode) – Try It Online">Try it online!</a></p>

<p><code>≡</code> identicalness </p>

<p><code>/</code> across</p>

<p><code>⍳</code> the <strong>ɩ</strong>ndex (the first occurrence of each element…)</p>

<p><code>⍨</code> selfie (…in itself)</p>

<p><code>¨</code> of each</p>
</div>
<div id="pu24" class="pu"><h2>C++, <s>213</s> <s>196</s> 162 bytes</h2>

<p>-51 bytes thanks to Zacharý</p>

<pre class="lang-cpp prettyprint-override"><code>#include&lt;map&gt;
#define F(X,x)for(auto&amp;e:X){if(x.end()==x.find(e))x[e]=65+x.size();e=x[e];}
auto i=[](auto a,auto b){std::map&lt;int,int&gt;c,d;F(a,c)F(b,d)return a==b;};
</code></pre>

<p>To call the lambda, you need to pass 2 arguments that are <code>std::string</code> data type</p>

<p>Code to test :</p>

<pre class="lang-cpp prettyprint-override"><code>std::initializer_list&lt;std::pair&lt;std::string, std::string&gt;&gt; test{
    {"ESTATE","DUELED"},
    {"DUELED","ESTATE"},
    {"XXX","YYY"},
    {"CBAABC","DEFFED"},
    {"RAMBUNCTIOUSLY","THERMODYNAMICS"},
    {"DISCRIMINATIVE","SIMPLIFICATION"},
    {"SEE","SAW"},
    {"ANTS","PANTS"},
    {"BANANA","SERENE"},
    {"BANAnA","SENSES"},
    {"AB","CC"},
    {"XXY","XYY"},
    {"ABCBACCBA","ABCBACCAB"},
    {"ABAB","AC"}
};

for (const auto&amp; a : test) {
    std::cout &lt;&lt; "Test with " &lt;&lt; a.first &lt;&lt; " and " &lt;&lt; a.second &lt;&lt;
        " outputs : " &lt;&lt; (i(a.first, a.second)?"TRUE":"FALSE") &lt;&lt; '\n';
}
</code></pre>

<p>for the code that tests, including <code>iostream</code> and <code>string</code> header file is required</p>
</div>
<div id="pu25" class="pu"><h1><a href="https://github.com/Adriandmen/05AB1E" rel="nofollow noreferrer">05AB1E</a>, 6 bytes</h1>

<pre><code>εæδË}Ë
</code></pre>

<p><a href="https://tio.run/##MzBNTDJM/f//3NbDy85tOdxde7j7//9odRfPYOcgT19PP8cQzzBXdR0F9WBP3wAfTzdPZ6CIv596LAA" rel="nofollow noreferrer" title="05AB1E – Try It Online">Try it online!</a></p>

<p>Takes input as a list: <code>['ESTATE', 'DUELED']</code></p>

<p><strong>Explanations:</strong></p>

<pre><code>    εæδË}Ë   Full program
    ε        Apply on each
     æ         Powerset
      δË       For each generated substring: 1 if all equal, 0 otherwise
        }    End for each
         Ë   1 if all equal, 0 otherwise
</code></pre>
</div>
<div id="pu26" class="pu"><h1><a href="https://github.com/barbuz/Husk" rel="nofollow noreferrer">Husk</a>, 5 bytes</h1>

<pre><code>¤=´×=
</code></pre>

<p><a href="https://tio.run/##yygtzv7//9AS20NbDk@3/f//v5JrcIhjiKvSfyWXUFcfVxclAA" rel="nofollow noreferrer" title="Husk – Try It Online">Try it online!</a></p>

<h3>Explanation</h3>

<pre><code>       -- implicit input A, B (strings aka character lists)       | "ab" "12"
¤=     -- apply the following function to A &amp; B, then compare:    | [1,0,0,1] == [1,0,0,1] -&gt; 1
  ´×   --   Cartesian product with itself under                   | ["aa","ba","ab","bb"] ["11","21","12","22"]
    =  --   equality                                              | [ 1  , 0  , 0  , 1  ] [ 1  , 0  , 0  , 1  ]
</code></pre>
</div>
<div id="pu27" class="pu"><h1>Common Lisp, 76 bytes</h1>

<pre><code>(lambda(a b)(equal #1=(map'list(lambda(x)(position x a))a)(setf a b a #1#)))
</code></pre>

<p><a href="https://tio.run/##NYsxDoAgEAS/coHCu9IHWJhIZ6c@4FBMSBBQMOH3SGOxzczs7myKFeNj/Q5Y0fGlD0YGTWjulx3IfsCLY9fC/OtCGEOy2QYPBZiICZPJJ7Rfm@wlEVWhlnVclQAxbWpWk2jsAw" rel="nofollow noreferrer">Try it online!</a></p>
</div>
<div id="pu28" class="pu"><h1>PHP, 99 Bytes</h1>

<pre><code>for(;$ß=$argv[1][$±++];)$×.=$$ß?"\\".$$ß:"(.)".!$$ß=++$µ;echo preg_match("#^$×$#",$argv[2]);
</code></pre>

<p>old but no PHP solution and I have solve together with <a href="https://codegolf.stackexchange.com/users/29637/christoph">@Christoph</a> and <a href="https://codegolf.stackexchange.com/users/55735/titus">@Titus</a> a <a href="https://codegolf.stackexchange.com/questions/112841/simple-code-golf-challenge-character-patterns/112864#112864">similar task</a></p>
</div>
<div id="pu29" class="pu"><h1>Perl, 38 bytes</h1>
<pre><code>($_,$a)=@ARGV;eval&quot;y/$_/$a/&quot;;say$_~~$a
</code></pre>
<p>Run as <code>perl -E '($_,$a)=@ARGV;eval&quot;y/$_/$a/&quot;;say$_~~$a' RAMBUNCTIOUSLY THERMODYNAMICS</code></p>
<p>Prints 1 if true, nothing if false.</p>
</div>
<div id="pu30" class="pu"><h1>Ruby, 31 bytes</h1>

<pre><code>-&gt;a{!!a.uniq!{|s|s.tr s,'a-z'}}
</code></pre>

<p>A Proc that takes an array of strings and checks whether any are isomorphic to each other. <code>tr s,'a-z'</code> with these arguments normalizes a string <code>s</code> by replacing each letter with the nth letter in the alphabet, where <code>n</code> is the greatest index with which that letter appears in the string. For example, <code>estate</code> becomes <code>fbedef</code>, as does <code>dueled</code>.</p>
</div>
<div id="pu31" class="pu"><h1>JavaScript, ES7, <s>62 55 54 52</s> 51 bytes</h1>
<pre class="lang-js prettyprint-override"><code>f=(x,y,g=z=&gt;[for(i of z)z.search(i)]+0)=&gt;g(x)==g(y)
</code></pre>
<p>The logic is simple. I simply convert both the inputs into their corresponding character index values, convert that array into string and compare.</p>
<pre class="lang-js prettyprint-override"><code>f=(x, y,                  // Create a function named f which takes two arguments x and y
   g=                     // There is a third default argument to f which equals to
     z=&gt;                  // and arrow function which takes argument z
     [                    // Return this array which is created using array comprehension
      for(i of z)         // For each character of z
      z.search(i)         // Use the index of that character in z in place of the character
     ]+0                  // And finally type cast that array to a string
                          // Here, the array elements are automatically joined by a ','
                          // and appended by a 0.
                          // Its funny how JS type casts Array + Number to a string
   )=&gt;                    // Now the body of function f starts
      g(x)==g(y)          // It simply returns if index map of x equals index map of y
          
</code></pre>
<p>Try the above code using the snippet below.
<div class="snippet" data-lang="js" data-hide="true" data-console="false" data-babel="false">
<div class="snippet-code snippet-currently-hidden">
<pre class="snippet-code-js lang-js prettyprint-override"><code>f=(x,y,g=z=&gt;[for(i of z)z.search(i)]+0)=&gt;g(x)==g(y)

// for cross browser testing, here is a slightly modified ES5 version of above function

if (!f) {
  function f(x, y) {
    function g(z) {
      var Z = [];
      for (var i = 0; i &lt; z.length; i++) {
        Z[i] = z.search(z[i])
      }
      return Z + 0;
    }
    return g(x) == g(y);
  }
}

B.onclick=function() {
  O.innerHTML = f(D.value, E.value);
  
};</code></pre>
<pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;pre&gt;f(&lt;input id=D /&gt;,&lt;input id=E /&gt;)&lt;/pre&gt;&lt;button id=B &gt;Run&lt;/button&gt;
&lt;br&gt;
&lt;output id=O /&gt;</code></pre>
</div>
</div>
</p>
<p><em>2 bytes saved thanks to <a href="https://codegolf.stackexchange.com/users/21348/edc65">@edc65</a></em></p>
</div>
<div id="pu32" class="pu"><h1>C#, 265 bytes</h1>

<pre><code>using System;using System.Linq;class I{static void Main(string[]a){var x=a[0].ToCharArray();var y=a[1].ToCharArray();Func&lt;char[],char[],bool&gt; l=(s,t)=&gt;s.Select(i=&gt;Array.IndexOf(s,i)).SequenceEqual(t.Select(i=&gt;Array.IndexOf(t,i)));Console.WriteLine(l.Invoke(x,y));}}
</code></pre>
</div>
<div id="pu33" class="pu"><h1>Brainfuck, <s>169</s> <s>168</s> <s>162</s> <s>144</s> <s>140</s> <s>131</s> 130</h1>

<p>Compatible with Alex Pankratov's <a href="http://swapped.cc/#!/bff" rel="nofollow">bff</a> (brainfuck interpreter used on SPOJ and ideone) and Thomas Cort's <a href="http://esoteric.sange.fi/brainfuck/impl/interp/BFI.c" rel="nofollow">BFI</a> (used on Anarchy Golf).</p>

<p>The expected input is two strings separated by a tab, with no newline after the second string. The output is <code>1</code> for isomorphs and <code>0</code> for non-isomorphs, which is convenient for checking results visually, although not the shortest option. (<strong>Update:</strong> shorter version with <code>\x01</code> and <code>\x00</code> as output and <code>\x00</code> as separator at the bottom of the answer.)</p>

<p><a href="http://ideone.com/nodXF7" rel="nofollow">Demonstration</a> on ideone.</p>

<pre><code>,+
[
  -
  ---------
  &gt;+&lt;
  [
    &gt;&gt;-&lt;
    [
      &lt;
      [
        &gt;+&lt;
        &lt;&lt;&lt;&lt;-&lt;+&gt;&gt;&gt;&gt;&gt;-
      ]
      ++[-&gt;+]
      -&gt;+[+&lt;-]
      &gt;[&lt;&lt;&lt;&lt;]
      &lt;
    ]
    &lt;[&gt;+&lt;-]
    +[-&gt;+]
    &lt;-&gt;
    &gt;&gt;&gt;
  ]
  &gt;
  [
    [[-]&lt;&lt;&lt;&lt;&lt;]
    &gt;&gt;&gt;&gt;
  ]
  &lt;,+
]
&gt;&gt;&gt;+&gt;+
[
  [&lt;-&gt;-]
  &lt;[&gt;&gt;&gt;&gt;&gt;]
  &lt;&lt;&lt;&lt;
]
-&lt;[&gt;]
+++++++[&lt;+++++++&gt;-]
&lt;.
</code></pre>

<p>This problem turns out to be very nice for brainfuck.</p>

<p>The basic idea with indexing is to go backwards from the end of the current string prefix. If the character has not previously occurred, we can take the length of the string prefix. For example:</p>

<pre><code>STATES
123255
</code></pre>

<p>The indexing in the code is actually slightly different but uses the same principle.</p>

<p>The memory layout is in blocks of 5:</p>

<pre><code>0 0 0 0 0 0 c 0 i p 0 c 0 i p 0 c 0 i p 0 0 0 0
</code></pre>

<p><code>c</code> stands for character, <code>i</code> for index, and <code>p</code> for previous (index). When the first string is being processed, all the <code>p</code> slots are zero. The cell to the left of <code>c</code> is used to hold a copy of the current character that we are trying to find the index of. The cell to the left of the current <code>i</code> is used to hold a <code>-1</code> for easy pointer navigation.</p>

<p>There are many conditions that need to be considered carefully. At the end, we check for isomorphs by comparing the <code>(i,p)</code> pairs, and we reach the cluster of zero cells to the left of the leftmost <code>(i,p)</code> pair if and only if the strings are isomorphs. Here is a commented version of the code to make it easier to follow:</p>

<pre><code>,+
[                       while there is input
  -
  ---------
  &gt;+&lt;                   increment char (adjust later)
  [                     if not tab
    &gt;&gt;-&lt;                set navigation flag
    [                   loop to find index
      &lt;                 travel to copy
      [
        &gt;+&lt;             restore char
        &lt;&lt;&lt;&lt;-&lt;+&gt;&gt;&gt;&gt;&gt;-   compare chars and create copy
      ]
      ++[-&gt;+]           travel between navigation flags
      -&gt;+[+&lt;-]          increment index by 2 and go back
      &gt;[&lt;&lt;&lt;&lt;]           proceed if not fallen off string
      &lt;                 compare chars
    ]
    &lt;[&gt;+&lt;-]             restore char (or no op)
    +[-&gt;+]              go back to navigation flag
    &lt;-&gt;                 adjust char
    &gt;&gt;&gt;                 alignment
  ]
  &gt;
  [                     if tab
    [[-]&lt;&lt;&lt;&lt;&lt;]          erase chars and go to beginning
    &gt;&gt;&gt;&gt;                alignment
  ]
  &lt;,+
]
&gt;&gt;&gt;+&gt;+                  check string lengths and start loop
[
  [&lt;-&gt;-]                compare indices
  &lt;[&gt;&gt;&gt;&gt;&gt;]              realign if not equal
  &lt;&lt;&lt;&lt;                  proceed
]
-&lt;[&gt;]                   cell to left is zero iff isomorphs
+++++++[&lt;+++++++&gt;-]
&lt;.
</code></pre>

<p><strong>Update:</strong></p>

<p>Here is a version that prints <code>\x01</code> for isomorphs and <code>\x00</code> for non-isomorphs. This is arguably a more accurate interpretation of Truthy and Falsey for brainfuck, because of the way <code>[</code> and <code>]</code> work. The only difference is at the very end.</p>

<p>Additional: Now using <code>\x00</code> as a separator to save 10 bytes.</p>

<pre><code>+
[
  -
  &gt;+&lt;
  [
    &gt;&gt;-&lt;
    [
      &lt;
      [
        &gt;+&lt;
        &lt;&lt;&lt;&lt;-&lt;+&gt;&gt;&gt;&gt;&gt;-
      ]
      ++[-&gt;+]
      -&gt;+[+&lt;-]
      &gt;[&lt;&lt;&lt;&lt;]
      &lt;
    ]
    &lt;[&gt;+&lt;-]
    +[-&gt;+]
    &lt;-&gt;
    &gt;&gt;&gt;
  ]
  &gt;
  [
    [[-]&lt;&lt;&lt;&lt;&lt;]
    &gt;&gt;&gt;&gt;
  ]
  &lt;,+
]
&gt;&gt;&gt;+&gt;+
[
  [&lt;-&gt;-]
  &lt;[&gt;&gt;&gt;&gt;&gt;]
  &lt;&lt;&lt;&lt;
]
-&lt;[&gt;]
&lt;+.
</code></pre>
</div>
<div id="pu34" class="pu"><h1>Ruby, 49 bytes</h1>

<pre><code>a.map{|s|s.chars.map{|c|s.index(c)}}.uniq.size==1
</code></pre>

<p>This is a function which takes in variable arguments which are stored into the 'a' variable. The algorithm is to map the characters in each word to the index of their first occurrence in the word. Once this is done, if there is only 1 unique element (aka both mappings are the same) then they are isomorphs.</p>
</div>
<div id="pu35" class="pu"><h1>Haskell, <s>45</s> 41 bytes</h1>

<pre><code>h l=map(`lookup`zip l[1..])l
x!y=h x==h y
</code></pre>

<p>Returns <code>True</code> or <code>False</code>, e.g <code>"ESTATE" ! "DUELED"</code> -> <code>True</code>.</p>

<p>Uses the map-char-to-first-index method as seen in many other answers. Association lists come in handy, because earlier entries trump. <code>"aba"</code> becomes <code>[(a,1),(b,2),(a,3)]</code> where <code>lookup</code> always fetches <code>a</code> -> <code>1</code>.</p>

<p>Edit: @Mauris found 4 bytes to save.</p>
</div>
<div id="pu36" class="pu"><h1>Python 2, 41 bytes</h1>

<pre><code>f=lambda a,b:map(a.find,a)==map(b.find,b)
</code></pre>
</div>
<div id="pu37" class="pu"><h1>Octave, 26 bytes</h1>
<pre><code>@(s,t)isequal(s==s',t==t')
</code></pre>
</div>
<div id="pu38" class="pu"><h1>Cobra, 72 bytes</h1>

<pre class="lang-cobra prettyprint-override"><code>do(a='',b='')=(for i in a get a.indexOf(i))==for i in b get b.indexOf(i)
</code></pre>
</div>
<div id="pu39" class="pu"><h1>Matlab, 50 bytes</h1>

<pre><code>f=@(s,t)isequal(bsxfun(@eq,s,s'),bsxfun(@eq,t,t'))
</code></pre>

<p>The function is defined as anonymous to save some space.</p>

<p>Example:</p>

<pre><code>&gt;&gt; f=@(s,t)isequal(bsxfun(@eq,s,s'),bsxfun(@eq,t,t'));
&gt;&gt; f('ESTATE','DUELED')
ans =
     1
&gt;&gt; f('ANTS','PANTS')
ans =
     0
</code></pre>
</div>
<div id="pu40" class="pu"><h1>Java, 107</h1>

<pre><code>(s,t)-&gt;java.util.Arrays.equals(s.chars().map(s::indexOf).toArray(),t.chars().map(t::indexOf).toArray())
</code></pre>

<p>Maps each character of <code>s</code> and <code>t</code> to its location, and checks for equality.</p>

<p>Expanded:</p>

<pre><code>class Isomorphs {
    public static void main(String[] args) {
        java.util.function.BiFunction&lt;String, String, Boolean&gt; f =
            (s, t) -&gt; java.util.Arrays.equals(
                                              s.chars().map(s::indexOf).toArray(),
                                              t.chars().map(t::indexOf).toArray()
                                             )
           ;
        System.out.println(f.apply("XXY", "XYY"));
    }
}
</code></pre>
</div>
<div id="pu41" class="pu"><h1>Ruby, 50 bytes</h1>

<p>30 bytes shorter ruby code. Written before I took a look at the solutions, checks for each character of both strings whether the index of that character's first occurence matches; ie. transforms a string to its normalized form <code>01121</code> etc and compares those.</p>

<pre><code>-&gt;x,y{g=-&gt;z{z.chars.map{|c|z=~/#{c}/}};g[x]==g[y]}
</code></pre>

<p>Test cases on <a href="https://ideone.com/0tfSD3" rel="nofollow">ideone</a> As an additional bonus, this breaks ideone's code highlighting.</p>
</div>
<div id="pu42" class="pu"><h1>Pyth, 9 bytes</h1>
<pre><code>qFmmxdkdQ
</code></pre>
<p>Takes input in the following form:</p>
<pre><code>&quot;ESTATE&quot;, &quot;DUELED&quot;
</code></pre>
<p>If that is not acceptable, the following code is 10 bytes:</p>
<pre><code>qFmmxdkd.z
</code></pre>
<p>and uses this input form:</p>
<pre><code>ESTATE
DUELED
</code></pre>
<p>Uses the index of char in string representation.</p>
</div>
<div id="pu43" class="pu"><h1>Mathematica, 46 bytes</h1>
<pre><code>Equal@@Values@*PositionIndex/@Characters@{##}&amp;
</code></pre>
</div>
<div id="pu44" class="pu"><h1>Ruby, 83 bytes</h1>



<pre class="lang-ruby prettyprint-override"><code>t=-&gt;x{y=0;z=?`;x.gsub!(y[0],z.succ!)while y=x.match(/[A-Z]/);x};f=-&gt;a,b{t[a]==t[b]}
</code></pre>

<p>It's a function <code>f</code> that takes two arguments and returns <code>true</code> or <code>false</code>.</p>

<p>Explanation:</p>

<pre class="lang-ruby prettyprint-override"><code>test = -&gt; str {
    y = nil  # we're just initializing this; it doesn't matter to what
             # this is the variable we use to store the `match' result
    z = '`'  # backtick is the ASCII character before `a'
    while y = str.match(/[A-Z]/) do  # while there is an uppercase letter in str
        str.gsub!(y[0], z.succ!)  # replace all instances of the uppercase letter
                                  # with the next unused lowercase letter
    end
    str  # return the new string
}
# self-explanatory
f=-&gt;a,b{test[a]==test[b]}
</code></pre>
</div>
<div id="pu45" class="pu"><h1>Python 3, 85 bytes</h1>



<pre class="lang-python prettyprint-override"><code>f=lambda a,b:''.join(map(lambda g:dict(zip(a,b))[g],a))==b
g=lambda a,b:f(a,b)&amp;f(b,a)
</code></pre>
</div>
<div id="pu46" class="pu"><h2>R, 78</h2>

<pre><code>function(x,y)identical((g=function(z)match(a&lt;-strsplit(z,"")[[1]],a))(x),g(y))
</code></pre>

<p>De-golfed:</p>

<pre><code>word_to_num &lt;- function(word) {
   chars &lt;- strsplit(word,"")[[1]]
   match(chars, chars)
}
are_isomorph &lt;- function(word1, word2) identical(word_to_num(word1), 
                                                 word_to_num(word2))
</code></pre>
</div>
<div id="pu47" class="pu"><h1>Bash + coreutils, 38</h1>
<pre><code>[ `tr $@&lt;&lt;&lt;$1``tr $2 $1&lt;&lt;&lt;$2` = $2$1 ]
</code></pre>
<p>Note we are using the usual shell idea of truthy/falsy here - zero means SUCCESS or TRUE and non-zero means error or FALSE:</p>
<pre><code>$ for t in &quot;ESTATE DUELED&quot; &quot;DUELED ESTATE&quot; &quot;XXX YYY&quot; &quot;CBAABC DEFFED&quot; &quot;RAMBUNCTIOUSLY THERMODYNAMICS&quot; &quot;DISCRIMINATIVE SIMPLIFICATION&quot; &quot;SEE SAW&quot; &quot;ANTS PANTS&quot; &quot;BANANA SERENE&quot; &quot;BANANA SENSES&quot; &quot;AB CC&quot; &quot;XXY XYY&quot; &quot;ABCBACCBA ABCBACCAB&quot;; do
&gt; ./isomorph.sh $t
&gt; echo $t $?
&gt; done
ESTATE DUELED 0
DUELED ESTATE 0
XXX YYY 0
CBAABC DEFFED 0
RAMBUNCTIOUSLY THERMODYNAMICS 0
DISCRIMINATIVE SIMPLIFICATION 0
SEE SAW 1
ANTS PANTS 1
BANANA SERENE 1
BANANA SENSES 1
AB CC 1
XXY XYY 1
ABCBACCBA ABCBACCAB 1
$ 
</code></pre>
</div>
<div id="pu48" class="pu"><h1>CJam, 9 bytes</h1>

<pre><code>r_f#r_f#=
</code></pre>

<p>Prints <code>1</code> if the words are isomorphs and <code>0</code> if they're not.</p>

<p>Try it online in the <a href="http://cjam.aditsu.net/#code=r_f%23r_f%23%3D&amp;input=ESTATE%20DUELED">CJam interpreter</a>.</p>

<h3>How it works</h3>

<pre><code>r    e# Read a whitespace separated token from STDIN.
_    e# Push a copy.
f#   e# Get the indexes of all characters from the first copy in the second.
r_f# e# Repeat for the second word.
=    e# Check for equality.
</code></pre>
</div>
<div id="pu49" class="pu"><h1>K, 5 bytes</h1>

<p>This has a delightfully elegant solution in K!</p>

<pre><code>~/=:'
</code></pre>

<p>The "group" operator (monadic <code>=</code>) creates precisely the signature we want for word isomorphism; gathering vectors of the indices of each element of a vector, with the groups ordered by appearance:</p>

<pre><code>  ="ABBAC"
(0 3
 1 2
 ,4)

  ="DCCDF"
(0 3
 1 2
 ,4)
</code></pre>

<p>Taking a pair of strings as a vector, we just need to apply group to each element (<code>=:'</code>) and then reduce with "match" (<code>~</code>), the deep-equality operator:</p>

<pre><code>  ~/=:'("RAMBUNCTIOUSLY";"THERMODYNAMICS")
1
  ~/=:'("BANANA";"SERENE")
0
</code></pre>
</div>
<div id="pu50" class="pu"><h1>J, 4 bytes</h1>

<pre><code>-:&amp;=
</code></pre>

<p>Usage</p>

<pre><code>   'THERMODYNAMICS' (-:&amp;=) 'RAMBUNCTIOUSLY'  NB. parens are optional
1 
</code></pre>

<p>Explanation</p>

<ul>
<li><p><code>=</code> with 1 argument creates an equality-table comparing the elements of the input and its nub.</p>

<pre><code>='ESTATE' gives the binary matrix

= | E S T A T E    
--+------------
E | 1 0 0 0 0 1
S | 0 1 0 0 0 0
T | 0 0 1 0 1 0
A | 0 0 0 1 0 0
</code></pre></li>
<li><p><code>-:</code> with 2 arguments checks their equality (like <code>==</code> generally does). This works for different size matrices (or even different types) too.</p></li>
<li><p><code>f&amp;g</code> applies g to both input separately and then applies f to the two results together so <code>x f&amp;g y == f(g(x), g(y))</code>.</p></li>
<li><p>So in our case we compare the two equality-tables.</p></li>
</ul>

<p><a href="http://tryj.tk/">Try it online here.</a></p>
</div>
<div id="pu51" class="pu"><h1>JavaScript (ES6), 62</h1>

<p>Using an aux function <code>h</code> that maps each word to an array containing the position of each letter in the word, for instance: PASS -> [1,2,3,3]. Return true if the function <code>h</code> applied the two words gives the same result. </p>

<p><div class="snippet" data-lang="js" data-hide="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>f=(a,b,h=w=&gt;0+[for(c of(n=k=[],w))k[c]=k[c]||++n])=&gt;h(b)==h(a)

// TEST

;[
// True
 ['ESTATE','DUELED']
,['DUELED','ESTATE']
,['XXX','YYY']
,['CBAABC','DEFFED']
,['RAMBUNCTIOUSLY','THERMODYNAMICS']
,['DISCRIMINATIVE','SIMPLIFICATION']

// False:

,['SEE','SAW']
,['ANTS','PANTS']
,['BANANA','SERENE']
,['BANANA','SENSES']
,['XXY','XYY']
,['ABCBACCBA','ABCBACCAB']
]
.forEach(t=&gt;(f(t[0],t[1])?OK:KO).innerHTML+=t+'\n')</code></pre>
<pre class="snippet-code-html lang-html prettyprint-override"><code>Ok&lt;br&gt;
&lt;pre id=OK&gt;&lt;/pre&gt;&lt;br&gt;
KO&lt;br&gt;
&lt;pre id=KO&gt;&lt;/pre&gt;</code></pre>
</div>
</div>
</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/50472/">50472</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




