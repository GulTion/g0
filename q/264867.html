<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::264867</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>008</td><td>x86 machine code</td><td>230906T031745Z</td><td><a href="https://codegolf.stackexchange.com/questions/264867/add-two-really-big-numbers/264960#264960">Peter Co</a></td></tr>
<tr d-ix="1"><td>063</td><td>JavaScript Node.js</td><td>230905T093036Z</td><td><a href="https://codegolf.stackexchange.com/questions/264867/add-two-really-big-numbers/264925#264925">l4m2</a></td></tr>
<tr d-ix="2"><td>211</td><td>TypeScript's Type System</td><td>230906T000322Z</td><td><a href="https://codegolf.stackexchange.com/questions/264867/add-two-really-big-numbers/264953#264953">noodle m</a></td></tr>
<tr d-ix="3"><td>049</td><td>Ruby</td><td>230904T115457Z</td><td><a href="https://codegolf.stackexchange.com/questions/264867/add-two-really-big-numbers/264887#264887">noodle m</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>x86 machine code, <s>10</s> 8 bytes</h1>
<p>A function that adds two little-endian binary Bigintegers of the same (non-zero) length, updating the destination in-place, using add-with-carry as a building block as it was designed for this.</p>
<p>It takes 2 pointer args and a count of how many bytes, like <code>add_bignum(uint8_t *edi_dst, uint8_t *esi_src, size_t count_ecx)</code>.  (That matches the x86-64 SysV calling convention if you use a dummy 3rd arg to fill the EDX slot.)  But this machine code only works in 32-bit mode; the <code>inc</code> would decode as a REX prefix in 64-bit mode (or need to be changed to the 2-byte encoding.  Or 3-byte to handle 64-bit pointers.)</p>
<p>It returns CF = carry-out from the top element.  (If you want that to be part of the output, zero-extend the inputs with an extra 0 element at the top, and include that in the count.)</p>
<pre><code>; NASM listing: machine code | source
               add_bignum:
 F8               clc                ; CF=0, no carry-in to the bottom.
                                     ; Peeling a first iteration using ADD would cost more bytes
               .loop:                ;do {
 AC               lodsb                ; eax = [esi]; esi+=4
 10 07            adc   [edi], al 
 47               inc   edi            ; edi++ without affecting CF, only other FLAGS
 E2 FA            loop  .loop        ; }while(--ecx);
 C3               ret   
</code></pre>
<p>Normally you can use <code>scasd</code> to increment RDI by 4, as long as it's a valid pointer, but that does a compare as well as load which overwrite FLAGS, breaking the chain of carry propagation through CF.  Some shenanigans like pointing ESP at this array and using 1-byte <code>pop eax</code> then <code>adc [esi], eax</code> and a dummy <code>lodsd</code> to increment ESI might work, but would probably cost more bytes than <code>lea edi, [edi+4]</code> (and a signal handler could clobber the array).  Maybe we could expect our caller to pass one of the bigints by value on the stack.  And we'd still have to push the return address back again.</p>
<p>So definitely the smallest (and lowest performing) is to use 1-byte &quot;limbs&quot;, making the pointer increment a single-byte (in 32-bit mode) <code>inc</code>, which sets the other FLAGS (all of SPAZO), but not CF.  Other code can process the same bigint in larger chunks; the limb size is only relevant to the count the caller passes, not anything else about the layout.</p>
<hr />
<p>Add-with-carry (<a href="https://www.felixcloutier.com/x86/adc" rel="nofollow noreferrer"><code>adc</code></a>) chains the carry-out from the top of one chunk into the carry-in for the next chunk.  As the loop iterates, it's like one wide <a href="https://en.wikipedia.org/wiki/Adder_(electronics)#Ripple-carry_adder" rel="nofollow noreferrer">ripple-carry adder</a> over the full width of the arrays.  (With carry-lookahead or whatever optimizations exist inside the CPU's ALUs happening within each chunk to run it with single-cycle latency.  But as far as the result is concerned, it's like one long chain of full-adders, with the same hardware reused by software feeding the carry-out of the last instruction to the carry-in of the next.  Carry only propagates from low to high in both addition and subtraction.  It doesn't matter what element-size you use for it, as long as you get all the bytes of your bigints and chain the carry correctly.)</p>
<p>Bigint performance notes: the <code>loop</code> instruction is <a href="https://stackoverflow.com/questions/35742570/why-is-the-loop-instruction-slow-couldnt-intel-have-implemented-it-efficiently">slow except on recent AMD CPUs</a>, where it's actually really handy for loops that want to preserve FLAGS.  It's too bad Intel didn't make it fast. Normal bigint loops on Sandybridge and later use <code>dec ecx / jnz</code> which leaves only CF unmodified, because Sandybridge has cheap partial-flag merging instead of stalling.  And Broadwell and later don't merge at all; uops that want both parts of FLAGS just read it as 2 separate inputs, which is why <code>cmovbe</code> and <code>cmova</code> are still 2 uops while others are down to 1 uop.  So the bigint looping problem has been solved that way, <a href="https://stackoverflow.com/questions/32084204/problems-with-adc-sbb-and-inc-dec-in-tight-loops-on-some-cpus">unlike on older P6-family CPUs</a> where partial-flag stalls are a real problem.</p>
<p>Also, for performance, memory <em>source</em> <code>adc</code> is better on Intel CPUs, with a separate <code>mov</code> store.  (Fun fact: memory destination <code>adc</code> has an extra uop beyond what you'd expect because of arcane microarchitectural reasons involving lack of TLB coherency across the uops of one instruction, <a href="https://stackoverflow.com/a/32258855/224132">according to Andy Glew</a>.)</p>
<p>Also obviously using 64-bit operand-size would go twice as fast as 32-bit, or 8x as fast as bytes, for the same number of bytes.  (Instruction fetch/decode isn't the bottleneck on modern CPUs with a uop cache, so the code-size differences aren't very significant for a hot loop).  That costs an extra REX prefix on most instructions so I didn't use it in the initial version with 32-bit elements.</p>
<p>TL:DR: un-golfing this code to something that performs well is more than just the obvious changes.  Look at the hand-written asm in GMP for production-quality example.  (e.g. <a href="https://github.com/sethtroisi/libgmp/blob/master/mpn/x86_64/coreisbr/aors_n.asm" rel="nofollow noreferrer">https://github.com/sethtroisi/libgmp/blob/master/mpn/x86_64/coreisbr/aors_n.asm</a> is the add-or-sub template for <code>adc</code> or <code>sbb</code> loops for Sandybridge-family.  It uses some <code>jrcxz</code> instead of just <code>dec/jnz</code> at the bottoms of loops, but I think the main unrolled loop uses <code>dec/jnz</code>.)</p>
</div>
<div id="pu1" class="pu"><h1><a href="https://nodejs.org" rel="nofollow noreferrer">JavaScript (Node.js)</a>, 63 bytes</h1>

<pre class="lang-javascript prettyprint-override"><code>f=(a,b,c=0)=&gt;(c-=~a.pop()+~b.pop()+2)||a+b?f(a,b,c/10|0)+c%10:a
</code></pre>
<p><a href="https://tio.run/##LZDrasJAEIX/71PkT2GXxDiXvU1L2gepUtcYpUVM0FIUxFdPN2kXljk78505sF/pJ13a8@fwvTj1u24c941O1bZqGzDNq24XzSPVQz9oUz62/4LM/Z7K7dv@j1wi3MGU7RPCcxpfNog@FmUBiKSIEZCZ53d0UWxUZEksWWfB2txHH1jEIkXLSlgiWW8zyBijy3NhAAlWvEyFg4rsIJLzBJCNmQehzAWL2WNz@LwdAgZRCNOZUmahMDD67GJBZHKBIU5bMRMkmYlCnjlfFCJwOUQ29bkbjqnttFrq1a40xaosZrE8VIX@qK7VLX9V258u/bGrj/1B7/V7XdfXdTWV29oYM/4C" rel="nofollow noreferrer" title="JavaScript (Node.js) â€“ Try It Online">Try it online!</a></p>
<p>no bigint</p>
</div>
<div id="pu2" class="pu"><h1><a href="https://www.typescriptlang.org/" rel="nofollow noreferrer">TypeScript</a>'s Type System, 211 bytes</h1>
<pre class="lang-typescript prettyprint-override"><code>//@ts-ignore
type D&lt;A,B,C,X=[...A,...B,...C]&gt;=X extends[1,1,1,1,1,1,1,1,1,1,...infer R]?[[1],R]:[[],X]
type F&lt;A,C=[]&gt;=A extends[[...infer G,infer X],[...infer H,infer Y]]?[...F&lt;[G,H],D&lt;X,Y,C&gt;[0]&gt;,D&lt;X,Y,C&gt;[1]]:[]
</code></pre>
<p><a href="https://www.typescriptlang.org/play?#code/PTAEEEBNNAXB3A9qATgUwIYBssE9QBGAlgOagB2ArgLYFooDOoAtKAEwCMHhusaDAKAEgAArAbNS5ROgGxcABzSgAIgB5wAGgBCmgMKaAGgF4A2gDpLWy+d029AXQB8xw6DQAPPuUgNTHTQCgwJDg4JsicgAzelAAJQcAflN-B00EgC4UtMMHOUVlADENfTNnY3B3LzQfPwtLSJiUUABxTUbY3M168w7mgAl26NiATQcknuLTNv609UNNEf0nUwAGZ015xeXUhyy84TAoxEQ+FCF5JVAAVXIMFFw1ADkq718KGjoUTVAAFVeau8OKYHKBjKAQU4wX9TAAiLA1EiwAAWsNBnjeTCeAlAoESfxxoAyNzuD2ePx6vx+HGcAG58lcAMqwFC-RC3e64FSkIjiNSMgG1UAMFmREhQ8ECjGApgAAwAJABvPqqHmwQW+QlUWj0AC+SpVcX4sF1ssJ+NMHLJ3JIvKcPxszNZ7NJXLVDDURpFTjyuOJIPpl2UAFkMAorbg2So0ABjIjUbDPDVMYEOSHQxWE0wAaVAkVAAGs0LhEFFQE89uWc2n4YiUWj6brAwVVbbxGynWKNMmPjqUOnwZVpULTISVSoe9qvppCRFhs04pPPvQQTPfXjQArFSp9dv3R3ReQSJ6nKbCcTYbDm1dfsbu8P3iKUGKftoe0+xRLW7yGAfn0e1EJEBQDECQpBkNBmHoFAZGJIhQEgRByAAcnVGI0CwUAsCIIsEMwbCj1AeBeWROBkSIJgUHIQlQ3DV0o1jeNEymJ02QjG0fw0e1QFYl1OQ4vltB9JwnAEJx6QZZRbxFbhwWk2A1FhLgADYAA5YR+WFVi4NhYXEw5cVAAA9RJJL+Y02GheTFLYABmDhtNspyNNALSOFUgBWVSAE4ABZ1P04DcRMsz5Nsqy71hNhfLYPzoo83zVl83yXKU5SAHZbO8vyODYVTfNsvSDOC0yg3MkVfIikVFNWbystU6LlP8vz7NUzzUtq2zVlq9LfO85TvJ6gr0qKoLjNKlt5I8qqFK01TbI81YGo85S2G6rLsoa2rdM01Zeo4AqDo4NS4t8xb0o4dLvNGsAStC41lJmxTLvs5SNqyrhbLYDzMqWoaOFS2KHKW7y2Der63o4UG1o8lbYpuwyQqAA" rel="nofollow noreferrer">Try it at the TypeScript Playground!</a></p>
<p>This is a generic type <code>F</code> taking type <code>A</code> which is a tuple of two  lists of unary numbers (using unary not for the numbers themselves but for the individual digits, as allowed by OP) padded with leading zeroes (<code>[]</code>s) to the length of the output.</p>
<p>For example: <code>F&lt;[[[1],[1],[1,1,1,1,1,1],[1,1,1,1,1,1,1,1]],[[],[1],[1],[1,1]]]&gt;</code> (1168 + 0112) <code>= [[1],[1,1],[1,1,1,1,1,1,1,1],[]]</code> (1280)</p>
<h2>Explanation</h2>
<pre class="lang-typescript prettyprint-override"><code>//@ts-ignore                  Ignore any compilation errors in
type D&lt;                    // Helper type D to extract some repeated code
  A,B,C,                   //   Input three unary numbers A,B,C
  X=[...A,...B,...C]       //   X is their sum (by concatenating)
&gt;=
  X extends                //   Does X match the pattern
    [/* ... */,...infer R] //     A tuple of ten 1s, selecting the rest as R
                           //     (If X &gt;= 10, let R = X - 10)
    ?[[1],R]:[[],X]        //   If so, return [1, R], else [0, X]
                           //   (Returns [carry, digit])

type F&lt;                    // Recursive main type F
  A,                       //   A is tuple of two lists of unary digits
  C=[]                     //   C is the digit to carry, default 0
&gt;=
  // Match A to get the last and other digits of each number
  // X and Y are the current digits of each, G and H are the rest
  A extends[[...infer G,infer X],[...inger H,infer Y]]
    ?[                     // If it matched, return the list of
      ...F&lt;                //   The rest, taken by recursing with
        [G,H],D&lt;X,Y,C&gt;[0]  //     G and H, with the carry taken from D&lt;X,Y,C&gt;
      &gt;,D&lt;X,Y,C&gt;[1]]       //   With the last digit (taken from D) appended
    :[]                    // If the match failed, return the empty list
</code></pre>
<p>This might be golfable under 200 bytes but my guess is that I'll only shave off at most four or five.</p>
</div>
<div id="pu3" class="pu"><h1><a href="https://www.ruby-lang.org/" rel="nofollow noreferrer">Ruby</a>, <s>78 67 59</s> 49 bytes</h1>
<pre class="lang-ruby prettyprint-override"><code>-&gt;a,b{c=0;a.zip(b).map{s=_1+_2+c;c=s&gt;9?1:0;s%10}}
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=TY_BTsMwDIbvfYpQBNq0rbLjtI03dTwIoKprMyga7dR0CNj2JFw4wJkLb8BT8DYkG0IcEsfO__22X966zeLp9WPVNjd5UVV1X7eNyN43_XKiv3EyL8aLbZnBrIie6_VgMYzui_XWZjmOcjkqZ2Vm53yBU5jZM4T9_hf87ExRrerG2MgU5a2oWrHz6S4QwseoMivTm9xulsv68WQQXjXh0P0VY7EQ2VFi16u6H4RiJMJDV7Hd2b7bCXdF5W3RWV8cnE_7Nq-HUWceTGfN3pmsN70V4enWu-ydm3v93-7SN7mO7tq6-aPCwDTVcfbX7y_ERLu2gCgDSQhIRIdcx5qVDqSSrKSKFSjl6pikxKxQakUBMLGWKlFOSah17EEmAE4VJ-wDpQFoikHLOJEAjnUEsPTKVKHDlBvg0AFSTDnAlDBxMmJEknFKoL0POkAyAmiWCZE7yFJC7Fz5uMsP" rel="nofollow noreferrer">Attempt This Online!</a></p>
<p>My first Ruby submission! This is probably a little golfable but I'm pretty happy with it considering I have almost zero Ruby experience. Suggestions are welcome!</p>
<p>Implements long addition on two lists of digits in reverse order padded to the length of the output with zeroes, and outputs a list of digits in reverse order. Explanation:</p>
<ul>
<li><p><code>-&gt;a,b{...}</code> Proc (anonymous function) taking parameters <code>a</code> and <code>b</code></p>
<ul>
<li><p><code>c=0;</code> Set the <code>c</code> (the carried digit) to 0</p>
</li>
<li><p><code>a.zip(b)</code> Zip <code>a</code> with <code>b</code> to get a list of pairs of digits</p>
</li>
<li><p><code>.map{...}</code> Map each pair of digits to</p>
<ul>
<li><p><code>s=_1+_2+c;</code> Set <code>s</code> to the sum of the two digits and the carry</p>
</li>
<li><p><code>c=s&gt;9?1:0;</code> Set <code>c</code> to 1 if <code>s</code> is greater than 9, or 0 otherwise</p>
</li>
<li><p><code>s%10</code> Return the ones place of <code>s</code> by taking it modulo 10</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/264867/">264867</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




