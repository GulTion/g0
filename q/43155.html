<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::43155</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>045</td><td>ARM Assembly</td><td>150104T090209Z</td><td><a href="https://codegolf.stackexchange.com/questions/43155/convert-rgb-integer-value-into-rgb-values/43167#43167">rsaxvc</a></td></tr>
<tr d-ix="1"><td>010</td><td>dc</td><td>150105T231945Z</td><td><a href="https://codegolf.stackexchange.com/questions/43155/convert-rgb-integer-value-into-rgb-values/43243#43243">Digital </a></td></tr>
<tr d-ix="2"><td>nan</td><td>C  56 characters</td><td>150105T145459Z</td><td><a href="https://codegolf.stackexchange.com/questions/43155/convert-rgb-integer-value-into-rgb-values/43216#43216">user1525</a></td></tr>
<tr d-ix="3"><td>000</td><td>AVR ABI</td><td>150104T094213Z</td><td><a href="https://codegolf.stackexchange.com/questions/43155/convert-rgb-integer-value-into-rgb-values/43168#43168">rsaxvc</a></td></tr>
<tr d-ix="4"><td>031</td><td>C/C++</td><td>150104T085021Z</td><td><a href="https://codegolf.stackexchange.com/questions/43155/convert-rgb-integer-value-into-rgb-values/43165#43165">rsaxvc</a></td></tr>
<tr d-ix="5"><td>028</td><td>Python</td><td>150104T041933Z</td><td><a href="https://codegolf.stackexchange.com/questions/43155/convert-rgb-integer-value-into-rgb-values/43163#43163">tysonsmi</a></td></tr>
<tr d-ix="6"><td>044</td><td>Ruby</td><td>150104T180349Z</td><td><a href="https://codegolf.stackexchange.com/questions/43155/convert-rgb-integer-value-into-rgb-values/43191#43191">britisht</a></td></tr>
<tr d-ix="7"><td>023</td><td>Python 3</td><td>150104T163412Z</td><td><a href="https://codegolf.stackexchange.com/questions/43155/convert-rgb-integer-value-into-rgb-values/43187#43187">Uri Gran</a></td></tr>
<tr d-ix="8"><td>013</td><td>Ostrich 0.5.0</td><td>150104T001021Z</td><td><a href="https://codegolf.stackexchange.com/questions/43155/convert-rgb-integer-value-into-rgb-values/43158#43158">Doorknob</a></td></tr>
<tr d-ix="9"><td>2622</td><td>JavaScript</td><td>150104T033643Z</td><td><a href="https://codegolf.stackexchange.com/questions/43155/convert-rgb-integer-value-into-rgb-values/43162#43162">Oriol</a></td></tr>
<tr d-ix="10"><td>010</td><td>J</td><td>150104T131944Z</td><td><a href="https://codegolf.stackexchange.com/questions/43155/convert-rgb-integer-value-into-rgb-values/43176#43176">ɐɔıʇǝɥʇu</a></td></tr>
<tr d-ix="11"><td>025</td><td>Erlang</td><td>150104T130452Z</td><td><a href="https://codegolf.stackexchange.com/questions/43155/convert-rgb-integer-value-into-rgb-values/43175#43175">c.P.u1</a></td></tr>
<tr d-ix="12"><td>031</td><td>Java 35</td><td>150104T010723Z</td><td><a href="https://codegolf.stackexchange.com/questions/43155/convert-rgb-integer-value-into-rgb-values/43159#43159">TheNumbe</a></td></tr>
<tr d-ix="13"><td>040</td><td>Rebol</td><td>150104T103723Z</td><td><a href="https://codegolf.stackexchange.com/questions/43155/convert-rgb-integer-value-into-rgb-values/43171#43171">draegtun</a></td></tr>
<tr d-ix="14"><td>008</td><td>APL</td><td>150104T102529Z</td><td><a href="https://codegolf.stackexchange.com/questions/43155/convert-rgb-integer-value-into-rgb-values/43170#43170">ngn</a></td></tr>
<tr d-ix="15"><td>022</td><td>Mathematica</td><td>150104T000754Z</td><td><a href="https://codegolf.stackexchange.com/questions/43155/convert-rgb-integer-value-into-rgb-values/43157#43157">Martin E</a></td></tr>
<tr d-ix="16"><td>011</td><td>CJam</td><td>150104T000202Z</td><td><a href="https://codegolf.stackexchange.com/questions/43155/convert-rgb-integer-value-into-rgb-values/43156#43156">Martin E</a></td></tr>
<tr d-ix="17"><td>025</td><td>Ruby</td><td>150104T095500Z</td><td><a href="https://codegolf.stackexchange.com/questions/43155/convert-rgb-integer-value-into-rgb-values/43169#43169">blutoran</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>ARM Assembly, 45</h1>
<pre><code>UXTB r1, r0, 16
UXTB r2, r0, 8
UXTB r3, r0, 0
</code></pre>
<p>Assuming N is passed in to R0, R1 contains Red, R2 contains Blue, and R3 contains Green. The result list is stored in r1,r2,r3.</p>
<p>Assembles to 12B of ARM instructions or 6B of 16-bit Thumb instructions.</p>
</div>
<div id="pu1" class="pu"><h1>dc, 10</h1>
<p>dc is a stack-based language so I'm assuming input and output on the stack is OK:</p>
<pre><code>256~r256~r
</code></pre>
</div>
<div id="pu2" class="pu"><h1>C - 56 characters, but no calculations required</h1>

<p>C doesn't really have lists, but would just like to point out that if you know the architecture (and there are macros to do this for you) you can retrieve RGB with no calculation, just defining types.</p>

<p>Something like this:</p>

<pre><code>enum {B, G, R};
typedef union {int i; unsigned char u[3];}T;
</code></pre>

<p>Then you access like this:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
    T t;

    // Set the color
    t.i = 0x45A19C;

    // Pull out the primaries
    printf("%u %u %u\n", t.u[R], t.u[G], t.u[B]);

    return 0;
}
</code></pre>
</div>
<div id="pu3" class="pu"><h1>AVR ABI, 0</h1>

<p>Quantities larger than the registers in the AVR's registers are represented with multiple registers. So, when passing in a 32-bit 'n' to a function, it is passed as 4x8-bit registers. Effectively R(r24),G(r23), and B(r22) are directly addressable without any additional work by virtue of the CPU's register addressing.</p>

<p>Here's some 'C' code for the unpacking operation:</p>

<pre><code>unsigned char r( unsigned long n ){return n&gt;&gt;16&amp;255;}
unsigned char g( unsigned long n ){return n&gt;&gt;8&amp;255;}
unsigned char b( unsigned long n ){return n&gt;&gt;0&amp;255;}
</code></pre>

<p>disassembled examples from avr-gcc 4.8:</p>

<pre><code>.global r
.type   r, @function
r:
ret
.size   r, .-r

.global g
.type   g, @function
g:
mov r24,r23
ret
.size   g, .-g

.global b
.type   b, @function
b:
mov r24,r22
ret
.size   b, .-b
</code></pre>

<p>For red, GCC just emits the return code since the red byte just happens to be in the return register already. For green and blue it copies the corresponding register into the return register and returns. The actual packing/unpacking is handled by the ABI - when done somewhere other than a function call boundary, it's handled purely by the register addressing. Both the copies and return opcode are overhead required to view this happening in the CPU - the compiler can use these registers directly if not required to place the result in the return register. Free RGB packing/unpacking is available when handing any 32-bit integer.</p>

<p>Another way to think about it is that the AVR's registers represent large numbers as a list of 8-bit registers, and that list happens to unpack RGB for us.</p>
</div>
<div id="pu4" class="pu"><h1>C/C++, 31</h1>

<pre><code>int r=n&gt;&gt;16,g=n&gt;&gt;8&amp;255,b=n&amp;255;
</code></pre>

<p>Convergently evolved to TheBestOne's answer, with the same size.</p>

<h1>C/C++, 31</h1>

<pre><code>int c[]={n&gt;&gt;16,n&gt;&gt;8&amp;255,n&amp;255};
</code></pre>

<p>This one actually makes a list(array). I'm not sure if it would count without "int c[]=". If so, it would be 23 bytes</p>

<p>Also added Uri Zarfaty's optimization to not mask the red channel, as by this point blue and green are already shifted away.</p>
</div>
<div id="pu5" class="pu"><h1>Python, 28 bytes</h1>
<p>The final value is stored in <code>c</code></p>
<pre><code>c=[n&gt;&gt;16&amp;255,n&gt;&gt;8&amp;255,n&amp;255]
</code></pre>
</div>
<div id="pu6" class="pu"><h1>Ruby, 44</h1>

<p>Not a winner, but this makes use of Ruby's (very useful) optional parameters to <code>String#to_i</code> and <code>Integer#to_s</code>. They both take a <code>base</code>.</p>

<pre class="lang-ruby prettyprint-override"><code>f=-&gt;i{i.to_s(16).scan(/../){|x|p x.to_i 16}}
</code></pre>
</div>
<div id="pu7" class="pu"><h2>Python 3, 23 bytes</h2>

<pre><code>*c,=n.to_bytes(3,'big')
</code></pre>

<p>If bare expressions are allowed then the following is one byte shorter:</p>

<pre><code>[n&gt;&gt;16,n&gt;&gt;8&amp;255,n&amp;255]
</code></pre>
</div>
<div id="pu8" class="pu"><h1><a href="https://github.com/KeyboardFire/ostrich-lang/releases/tag/v0.5.0-alpha" rel="nofollow">Ostrich 0.5.0</a>, 13 bytes</h1>

<pre><code>n16 6?+256B1&gt;
</code></pre>

<p>Might as well post this just to promote Ostrich, even though it's essentially the same as @MartinBüttner's. (The only thing I changed was <code>b</code> -> <code>B</code>, since all built-in functions are either symbols or capital letters in Ostrich, and <code>G</code> -> <code>16 </code> since Ostrich doesn't have that fancy built-in number (which it really should).)</p>

<p>Idential translation to Golfscript (18 bytes):</p>

<pre><code>n 16 6?+256base 1&gt;
</code></pre>
</div>
<div id="pu9" class="pu"><h1>JavaScript, <del>26</del> 22</h1>

<pre><code>[n&gt;&gt;16,n&gt;&gt;8&amp;255,n&amp;255]
</code></pre>

<p>Inspired by <a href="https://codegolf.stackexchange.com/a/43159/12784">TheBestOne's answer</a>. I don't know bitwise operators very much, but it seems to work.</p>
</div>
<div id="pu10" class="pu"><h1>J (10)</h1>

<pre><code>(3#256)#:]
</code></pre>

<p>Demonstration:</p>

<pre><code>    f=:(3#256)#:]
    f 4563356
69 161 156
    f 12
0 0 12
</code></pre>
</div>
<div id="pu11" class="pu"><h1>Erlang, 25 Bytes</h1>

<pre><code>binary_to_list(&lt;&lt;N:24&gt;&gt;).
</code></pre>

<p>Using the bit syntax, extracts 24 bits from N, which results in a binary of size 3.</p>
</div>
<div id="pu12" class="pu"><h1>Java <del>35</del> 31 bytes.</h1>
<p>Yay!!! A java answer under 40 bytes.</p>

<pre class="lang-java prettyprint-override"><code>new int[]{n&gt;&gt;16,n&gt;&gt;8&amp;255,n&amp;255}
</code></pre>
<p>Interestingly, java integers are always stored as Binary numbers.</p>
<p>Consequently this snippet returns [69,161,156] whether n = <code>0x45A19C</code>, <code>4563356</code>, or <code>0b10001011010000110011100</code>.</p>
</div>
<div id="pu13" class="pu"><h1>Rebol - <strike>43</strike> 40</h1>

<pre><code>x: to-tuple to-hex n reduce[x/6 x/7 x/8]
</code></pre>

<p>Example:</p>

<pre><code>&gt;&gt; n: 4563356
== 4563356

&gt;&gt; x: to-tuple to-hex n reduce [x/6 x/7 x/8]
== [69 161 156]
</code></pre>

<p><br/>
Alternative 40 char solution:</p>

<pre><code>map-each x[-16 -8 0][(shift n x)and 255]
</code></pre>
</div>
<div id="pu14" class="pu"><h1>APL, 8 characters</h1>
<p><a href="http://tryapl.org/?a=n%u21904563356%20%u22C4%20n%u22A4%u23683%u2374256&amp;run" rel="nofollow noreferrer"><code>n⊤⍨3⍴256</code></a></p>
<pre><code>3⍴256  is 256 256 256
B⊤⍨A   is A⊤B
A⊤B    encodes B in a number system specified by A
         It doesn't have to use a uniform radix, e.g.:
         365 24 60 60 1000 ⊤ time
</code></pre>
</div>
<div id="pu15" class="pu"><h1>Mathematica, 22 bytes</h1>

<pre><code>IntegerDigits[n,256,3]
</code></pre>

<p>Basically the same as my CJam answer. But I don't know a lot of languages that handle base conversion with arbitrary bases, so I thought I'd post both versions.</p>

<p>This one handles leading zeroes by using <code>IntegerDigits</code>' third parameter which pads the result to specified number of digits.</p>
</div>
<div id="pu16" class="pu"><h1>CJam, 11 bytes</h1>

<pre><code>NG6#+256b1&gt;
</code></pre>

<p>This assumes that the base-10 integer is stored in <code>N</code> (there are no lower-case variable names), and it leaves the required list on the stack. This simply gets the digits in base 256. To take care of leading zeroes, we first add 256<sup>3</sup> = 16<sup>6</sup>. This will always give us 4 digits, the first one being <code>1</code>, so at the end we slice off that extraneous digit with <code>1&gt;</code>:</p>

<pre><code>N           "Push N.";
 G6#        "16^6.";
    +       "Add.";
     256b   "Get base-256 digits.";
         1&gt; "Slice off leading digit.";
</code></pre>

<p><a href="http://cjam.aditsu.net/" rel="nofollow">Test it here.</a> You can use the following framework to initialise <code>N</code> and view the stack afterwards:</p>

<pre><code>4563356:N;
NG6#+256b1&gt;
ed
</code></pre>

<p>Of course, if I'm allowed to just have the input on the stack, instead of storing it in <code>N</code>, the solution is only 10 bytes, <code>G6#+256b1&gt;</code>.</p>
</div>
<div id="pu17" class="pu"><h1>Ruby, 25</h1>

<pre><code>[16,8,0].map{|x|n&gt;&gt;x&amp;255}
</code></pre>

<p>The javascript answer by @Oriol is valid ruby as well, but at least this uses ruby features... (and it's a byte shorter).</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/43155/">43155</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




