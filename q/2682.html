<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::2682</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>nan</td><td></td><td>230810T003941Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/263959#263959">l4m2</a></td></tr>
<tr d-ix="1"><td>nan</td><td></td><td>230602T195217Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/261478#261478">Dadsdy</a></td></tr>
<tr d-ix="2"><td>nan</td><td>Instead of a>b&&A[x]=y</td><td>230114T171231Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/256713#256713">l4m2</a></td></tr>
<tr d-ix="3"><td>nan</td><td></td><td>221223T154231Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/255978#255978">l4m2</a></td></tr>
<tr d-ix="4"><td>011</td><td>If f returns 0 and 1</td><td>221223T140312Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/255973#255973">l4m2</a></td></tr>
<tr d-ix="5"><td>003</td><td>When using regexps</td><td>211115T212752Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/237339#237339">Ad&#225;</a></td></tr>
<tr d-ix="6"><td>002</td><td>You can produce undefined with 0[0] to save 5 bytes. This is</td><td>211103T225050Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/236846#236846">smitop</a></td></tr>
<tr d-ix="7"><td>nan</td><td>For ES6 arrow functions with 2 parameters</td><td>210212T060139Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/218925#218925">emanresu</a></td></tr>
<tr d-ix="8"><td>nan</td><td></td><td>210614T151956Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/229660#229660">hypers</a></td></tr>
<tr d-ix="9"><td>nan</td><td></td><td>210528T054808Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/226386#226386">emanresu</a></td></tr>
<tr d-ix="10"><td>nan</td><td></td><td>210510T124957Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/225366#225366">Rydwolf </a></td></tr>
<tr d-ix="11"><td>nan</td><td></td><td>210213T201508Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/218994#218994">Alex bri</a></td></tr>
<tr d-ix="12"><td>nan</td><td></td><td>210207T083553Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/218707#218707">HK boy</a></td></tr>
<tr d-ix="13"><td>nan</td><td></td><td>201205T062857Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/216015#216015">Rydwolf </a></td></tr>
<tr d-ix="14"><td>nan</td><td></td><td>110527T135317Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/2696#2696">mellamok</a></td></tr>
<tr d-ix="15"><td>nan</td><td>If you need to do something different depending on several different values for a string</td><td>200624T035943Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/206421#206421">Steve Be</a></td></tr>
<tr d-ix="16"><td>nan</td><td></td><td>141204T005311Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/42154#42154">Claudia</a></td></tr>
<tr d-ix="17"><td>nan</td><td></td><td>200519T192359Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/204985#204985">VFDan</a></td></tr>
<tr d-ix="18"><td>002</td><td>The 9**999 is Infinity shortcut</td><td>200206T090425Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/199027#199027">Kamil Ki</a></td></tr>
<tr d-ix="19"><td>nan</td><td></td><td>200201T030757Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/198742#198742">Python_4</a></td></tr>
<tr d-ix="20"><td>nan</td><td></td><td>190822T131538Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/190612#190612">Kamil Ki</a></td></tr>
<tr d-ix="21"><td>nan</td><td></td><td>190822T093036Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/190578#190578">Kamil Ki</a></td></tr>
<tr d-ix="22"><td>nan</td><td></td><td>170613T085218Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/126112#126112">Tomas La</a></td></tr>
<tr d-ix="23"><td>nan</td><td></td><td>181115T024637Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/175967#175967">JBDouble</a></td></tr>
<tr d-ix="24"><td>nan</td><td></td><td>180912T162606Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/172081#172081">kamoroso</a></td></tr>
<tr d-ix="25"><td>nan</td><td></td><td>180413T162708Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/162154#162154">l4m2</a></td></tr>
<tr d-ix="26"><td>nan</td><td>If you are using the same function more than once</td><td>180626T081906Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/167462#167462">Xzibitee</a></td></tr>
<tr d-ix="27"><td>054</td><td>When stringifying dates</td><td>180620T110240Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/167129#167129">Neil</a></td></tr>
<tr d-ix="28"><td>nan</td><td></td><td>180130T204001Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/154406#154406">Newbie p</a></td></tr>
<tr d-ix="29"><td>nan</td><td></td><td>170924T124246Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/143631#143631">Unihedro</a></td></tr>
<tr d-ix="30"><td>nan</td><td></td><td>151019T000933Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/61143#61143">Mama Fun</a></td></tr>
<tr d-ix="31"><td>nan</td><td>If you are ever in a situation where you have an array a and you need to get its last element as an array of itself</td><td>170731T135712Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/136826#136826">Ron Mart</a></td></tr>
<tr d-ix="32"><td>nan</td><td></td><td>110601T165538Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/2714#2714">zzzzBov</a></td></tr>
<tr d-ix="33"><td>nan</td><td></td><td>170320T191736Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/113405#113405">ETHprodu</a></td></tr>
<tr d-ix="34"><td>nan</td><td></td><td>140807T122438Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/35872#35872">bebe</a></td></tr>
<tr d-ix="35"><td>nan</td><td></td><td>161215T150702Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/103241#103241">Christia</a></td></tr>
<tr d-ix="36"><td>nan</td><td></td><td>141204T011150Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/42161#42161">Claudia</a></td></tr>
<tr d-ix="37"><td>nan</td><td>If iterating through own properties</td><td>141204T010833Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/42160#42160">Claudia</a></td></tr>
<tr d-ix="38"><td>nan</td><td></td><td>150521T190846Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/50599#50599">Cyoce</a></td></tr>
<tr d-ix="39"><td>nan</td><td></td><td>161122T174141Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/100756#100756">ETHprodu</a></td></tr>
<tr d-ix="40"><td>nan</td><td></td><td>160519T170256Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/80195#80195">joeytwid</a></td></tr>
<tr d-ix="41"><td>nan</td><td></td><td>160811T060623Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/89482#89482">jrich</a></td></tr>
<tr d-ix="42"><td>nan</td><td></td><td>150521T185655Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/50598#50598">Cyoce</a></td></tr>
<tr d-ix="43"><td>nan</td><td>Abuse uninitialized variables</td><td>141204T010135Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/42155#42155">Claudia</a></td></tr>
<tr d-ix="44"><td>nan</td><td></td><td>160518T170559Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/80147#80147">Scott</a></td></tr>
<tr d-ix="45"><td>nan</td><td></td><td>140107T144443Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/17887#17887">Florent</a></td></tr>
<tr d-ix="46"><td>nan</td><td></td><td>151222T012338Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/67327#67327">ETHprodu</a></td></tr>
<tr d-ix="47"><td>nan</td><td></td><td>151222T020942Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/67330#67330">ETHprodu</a></td></tr>
<tr d-ix="48"><td>nan</td><td></td><td>160211T191801Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/71763#71763">Cyoce</a></td></tr>
<tr d-ix="49"><td>nan</td><td>If you need to check for NaN</td><td>141128T162824Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/41996#41996">ProgramF</a></td></tr>
<tr d-ix="50"><td>nan</td><td></td><td>120304T181750Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/5045#5045">ajax3332</a></td></tr>
<tr d-ix="51"><td>nan</td><td></td><td>151101T031911Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/62488#62488">Mama Fun</a></td></tr>
<tr d-ix="52"><td>nan</td><td></td><td>151016T023816Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/60969#60969">bren</a></td></tr>
<tr d-ix="53"><td>nan</td><td></td><td>151016T003122Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/60961#60961">Mama Fun</a></td></tr>
<tr d-ix="54"><td>nan</td><td></td><td>151016T002746Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/60960#60960">Mama Fun</a></td></tr>
<tr d-ix="55"><td>nan</td><td></td><td>151015T224214Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/60951#60951">George R</a></td></tr>
<tr d-ix="56"><td>nan</td><td>Very simple one</td><td>151010T143302Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/60293#60293">Ant&#243</a></td></tr>
<tr d-ix="57"><td>nan</td><td>Repeated characters</td><td>120321T165533Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/5228#5228">ajax3332</a></td></tr>
<tr d-ix="58"><td>nan</td><td>When it comes to comparing strings against eachother</td><td>150728T232557Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/53998#53998">Sebastia</a></td></tr>
<tr d-ix="59"><td>nan</td><td></td><td>120321T060623Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/5222#5222">ajax3332</a></td></tr>
<tr d-ix="60"><td>nan</td><td></td><td>141204T013117Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/42163#42163">Claudia</a></td></tr>
<tr d-ix="61"><td>nan</td><td></td><td>150210T191637Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/45555#45555">CocoaBea</a></td></tr>
<tr d-ix="62"><td>nan</td><td></td><td>140722T104028Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/34927#34927">CocoaBea</a></td></tr>
<tr d-ix="63"><td>nan</td><td>If returning void</td><td>141204T010452Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/42158#42158">Claudia</a></td></tr>
<tr d-ix="64"><td>nan</td><td></td><td>141204T010352Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/42157#42157">Claudia</a></td></tr>
<tr d-ix="65"><td>000</td><td>Return 1 for true</td><td>141204T010237Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/42156#42156">Claudia</a></td></tr>
<tr d-ix="66"><td>nan</td><td></td><td>140816T104638Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/36271#36271">bebe</a></td></tr>
<tr d-ix="67"><td>nan</td><td></td><td>140802T232108Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/35648#35648">Doorknob</a></td></tr>
<tr d-ix="68"><td>nan</td><td>For strings and arrays</td><td>140603T190545Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/30097#30097">Toothbru</a></td></tr>
<tr d-ix="69"><td>nan</td><td>You can use ~s instead of +s+1</td><td>140224T210500Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/22017#22017">Toothbru</a></td></tr>
<tr d-ix="70"><td>nan</td><td></td><td>140221T100147Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/21633#21633">ˈvɔlə</a></td></tr>
<tr d-ix="71"><td>nan</td><td>In cases where you are using the ternary operator to chose between two numbers</td><td>110609T150547Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/2803#2803">mellamok</a></td></tr>
<tr d-ix="72"><td>nan</td><td></td><td>131228T152437Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/16433#16433">Konijn</a></td></tr>
<tr d-ix="73"><td>nan</td><td>Use Mozilla's nonstandard "expression closures" feature to save many characters in a script that only needs to work in the SpiderMonkey/Firefox or Rhino engines. For example</td><td>110527T020501Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/2687#2687">PleaseSt</a></td></tr>
<tr d-ix="74"><td>nan</td><td></td><td>120327T073451Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/5297#5297">Kae Vere</a></td></tr>
<tr d-ix="75"><td>nan</td><td></td><td>120319T183919Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/5206#5206">ajax3332</a></td></tr>
<tr d-ix="76"><td>nan</td><td></td><td>110608T111224Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/2788#2788">Andy E</a></td></tr>
<tr d-ix="77"><td>nan</td><td></td><td>130711T040838Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/12032#12032">Eliseo D</a></td></tr>
<tr d-ix="78"><td>nan</td><td></td><td>120815T041206Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/6990#6990">ajax3332</a></td></tr>
<tr d-ix="79"><td>nan</td><td>Something worth noting is that you can use a string in place of zero in some instances to save a couple of bytes here and there in loops</td><td>131024T082424Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/12998#12998">Dom Hast</a></td></tr>
<tr d-ix="80"><td>006</td><td>If you can accept Spidermonkey for now specific scripts</td><td>131013T154215Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/12819#12819">Konrad B</a></td></tr>
<tr d-ix="81"><td>nan</td><td></td><td>130515T234233Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/11699#11699">ajax3332</a></td></tr>
<tr d-ix="82"><td>nan</td><td></td><td>120326T223508Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/5284#5284">ajax3332</a></td></tr>
<tr d-ix="83"><td>nan</td><td>Some extra tricks that I don't see very often</td><td>120830T221131Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/7123#7123">FireFly</a></td></tr>
<tr d-ix="84"><td>nan</td><td></td><td>120405T183313Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/5404#5404">Griffin</a></td></tr>
<tr d-ix="85"><td>nan</td><td>If you're initializing a variable to 1 in every iteration of a loop for example</td><td>120118T165309Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/4691#4691">mellamok</a></td></tr>
<tr d-ix="86"><td>nan</td><td></td><td>110527T011206Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/2683#2683">mellamok</a></td></tr>
<tr d-ix="87"><td>nan</td><td>This one is lesser known and lesser used</td><td>120116T110947Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/4656#4656">Andy E</a></td></tr>
<tr d-ix="88"><td>nan</td><td></td><td>111128T234341Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/4005#4005">user3156</a></td></tr>
<tr d-ix="89"><td>nan</td><td></td><td>110820T004533Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/3506#3506">Thomas E</a></td></tr>
<tr d-ix="90"><td>nan</td><td></td><td>110601T144526Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/2711#2711">pimvdb</a></td></tr>
<tr d-ix="91"><td>nan</td><td>for a given array</td><td>110607T191054Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/2769#2769">vsync</a></td></tr>
<tr d-ix="92"><td>nan</td><td></td><td>110527T134710Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/2695#2695">mellamok</a></td></tr>
<tr d-ix="93"><td>nan</td><td></td><td>110527T014726Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/2686#2686">PleaseSt</a></td></tr>
<tr d-ix="94"><td>nan</td><td>Initialize arrays with [] instead of Array</td><td>110527T012042Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/2685#2685">mellamok</a></td></tr>
<tr d-ix="95"><td>nan</td><td></td><td>110527T011412Z</td><td><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript/2684#2684">mellamok</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>Length of deprecating array +1</h1>
<pre><code>1+X.length
X.push(0)   // 1 byte shorter
</code></pre>
</div>
<div id="pu1" class="pu"><h1>Test Equality to Zero</h1>
<p>Instead of</p>
<pre><code>num==0
</code></pre>
<p>You can use</p>
<pre><code>!num
</code></pre>
</div>
<div id="pu2" class="pu"><p>Instead of <code>a&gt;b&amp;&amp;(A[x]=y)</code>, write <code>A[a&gt;b&amp;&amp;x]=y</code>, so long as <code>A[false]</code> isn't used</p>
</div>
<div id="pu3" class="pu"><h1>Pass expression rather than function</h1>
<pre><code>g`x+y`
</code></pre>
<p>is shorter than</p>
<pre><code>g(x=&gt;y=&gt;x+y)
</code></pre>
<p>if <code>g</code> is used for 2 times</p>
<pre><code>eval(z,x=p+1,y=q-1)
</code></pre>
<p>is 9 bytes longer than</p>
<pre><code>z(p+1,q-1)
</code></pre>
<p>and</p>
<pre><code>eval(z)
</code></pre>
<p>is only 1 byte longer than</p>
<pre><code>z(x,y)
</code></pre>
<p>Recent use <a href="https://codegolf.stackexchange.com/a/255970/">here</a></p>
</div>
<div id="pu4" class="pu"><p>If <code>f</code> returns <code>0</code> and <code>1</code>, then <code>f(0)|f(1)</code> can be <code>f(f(1))</code></p>
</div>
<div id="pu5" class="pu"><p>When using regexps, if you need <code>.</code> to exclude <code>\n</code>, so you can't use the <code>/s</code> flag, you can uniquely (other regex engines do not allow this) write <code>[^]</code> instead of <code>[\s\S]</code> saving 3 bytes.</p>
</div>
<div id="pu6" class="pu"><p>You can produce <code>undefined</code> with <code>0[0]</code> to save 5 bytes. This is 2 bytes shorter than the more traditional <code>void 0</code> method of creating <code>undefined</code>.</p>
</div>
<div id="pu7" class="pu"><h1>For ES6 arrow functions with 2 parameters, nest functions</h1>
<pre class="lang-javascript prettyprint-override"><code>f=(x,k)=&gt;x+k
f=x=&gt;k=&gt;x+k
</code></pre>
<p>Only works in some cases. E.g. for recursive functions, this doesn't help because calling is one byte longer:</p>
<pre class="lang-javascript prettyprint-override"><code>f(1,2)
f(1)(2)
</code></pre>
</div>
<div id="pu8" class="pu"><p>I have adapted to my needs the <strong>Unicode shortcuts</strong> method by <strong>@bebe</strong>.</p>
<p>The problem which many have faced with the original solution is due to the fact that some of the functions/properties belong to a class prototype while others to a class itself. These need to be handled separately.</p>
<p>The minified code now takes 132 bytes:</p>
<pre><code>[Number,S=String,Array].map(r=&gt;{f=(r=&gt;Object.getOwnPropertyNames(r).map((e,t)=&gt;r[S.fromCharCode(t+248)]=r[e])),f(r),f(r.prototype)})
</code></pre>
<p>Of course, you can drop <em>Number</em> and <em>Array</em> if unused from the initial array to save a couple of bytes. <em>String</em> is used in the code itself so removing it doesn't help a lot.</p>
<p>Part of the problems came from <em>Math</em> having no protype thus requiring its special handling. Besides the name in the initial array it also takes another 5 bytes to skip prototype handing. So use the variant below only if you need <em>Math</em>:</p>
<pre><code>[Number,S=String,Array,Math].map(r=&gt;{f=(r=&gt;Object.getOwnPropertyNames(r).map((e,t)=&gt;r[S.fromCharCode(t+248)]=r[e])),f(r),r.E||f(r.prototype)})
</code></pre>
<p>I use the same code  for <strong>Node.js</strong> (v12.19.0) and <strong>Chrome</strong> (90.0.4430.212 x64).</p>
<pre><code>Code Char Number          Number.prototype String        String.prototype  Array    Array.prototype Math
248  ø    length            constructor    length        length            length    length         abs
249  ù    name              toExponential  name          constructor       name      constructor    acos
250  ú    prototype         toFixed        prototype     anchor            prototype concat         acosh
251  û    isFinite          toPrecision    fromCharCode  big               isArray   copyWithin     asin
252  ü    isInteger         toString       fromCodePoint blink             from      fill           asinh
253  ý    isNaN             valueOf        raw           bold              of        find           atan
254  þ    isSafeInteger     toLocaleString               charAt                      findIndex      atanh
255  ÿ    parseFloat                                     charCodeAt                  lastIndexOf    atan2
256  Ā    parseInt                                       codePointAt                 pop            ceil
257  ā    MAX_VALUE                                      concat                      push           cbrt
258  Ă    MIN_VALUE                                      endsWith                    reverse        expm1
259  ă    NaN                                            fontcolor                   shift          clz32
260  Ą    NEGATIVE_INFINITY                              fontsize                    unshift        cos
261  ą    POSITIVE_INFINITY                              fixed                       slice          cosh
262  Ć    MAX_SAFE_INTEGER                               includes                    sort           exp
263  ć    MIN_SAFE_INTEGER                               indexOf                     splice         floor
264  Ĉ    EPSILON                                        italics                     includes       fround
265  ĉ                                                   lastIndexOf                 indexOf        hypot
266  Ċ                                                   link                        join           imul
267  ċ                                                   localeCompare               keys           log
268  Č                                                   match                       entries        log1p
269  č                                                   matchAll                    values         log2
270  Ď                                                   normalize                   forEach        log10
271  ď                                                   padEnd                      filter         max
272  Đ                                                   padStart                    flat           min
273  đ                                                   repeat                      flatMap        pow
274  Ē                                                   replace                     map            random
275  ē                                                   search                      every          round
276  Ĕ                                                   slice                       some           sign
277  ĕ                                                   small                       reduce         sin
278  Ė                                                   split                       reduceRight    sinh
279  ė                                                   strike                      toLocaleString sqrt
280  Ę                                                   sub                         toString       tan
281  ę                                                   substr                                     tanh
282  Ě                                                   substring                                  trunc
283  ě                                                   sup                                        E
284  Ĝ                                                   startsWith                                 LN10
285  ĝ                                                   toString                                   LN2
286  Ğ                                                   trim                                       LOG10E
287  ğ                                                   trimStart                                  LOG2E
288  Ġ                                                   trimLeft                                   PI
289  ġ                                                   trimEnd                                    SQRT1_2
290  Ģ                                                   trimRight                                  SQRT2
291  ģ                                                   toLocaleLowerCase
292  Ĥ                                                   toLocaleUpperCase
293  ĥ                                                   toLowerCase
294  Ħ                                                   toUpperCase
295  ħ                                                   valueOf
296  Ĩ                                                   replaceAll (*)
</code></pre>
<p><strong>Notes:</strong></p>
<p><em>replaceAll</em> (marked with an asterisk) exists only for <em>Chrome</em>.</p>
<p>Some comments where criticizing the usage of non-standard alphabet. If you manage to find another consistent range of Unicode characters that <strong>can</strong> be used as property names in JS then feel free to improve this answer. I couldn't find better than the original.</p>
</div>
<div id="pu9" class="pu"><h1>Removing something from a string</h1>
<p>When you want to remove a certain substring from a string, split by that and join.</p>
<pre class="lang-js prettyprint-override"><code>.replace(/h/g,'') // 17 bytes
.split`h`.join`` // 16 bytes
.replaceAll('h','') // 19 bytes
</code></pre>
<p>Sadly the ES2021 replaceAll is longer.</p>
</div>
<div id="pu10" class="pu"><h1>Compressing Long Strings</h1>
<p>If you have a very long, repetitive string, you can compress it using something similar to:</p>
<pre class="lang-js prettyprint-override"><code>``.replace(/./gs,p=&gt;p.charCodeAt().toString(2).padStart(7,0)).match(/.{n}/g).map(p=&gt;+(&quot;0b&quot;+p))
</code></pre>
<p>The <code>``</code> should contain any code points between 0 and 127, with some needing to be escaped. These are: <code>0x00</code> (<code>\0</code> or <code>\x00</code>, depending on whether a digit is following), <code>0x0d</code> (<code>\r</code>), <code>0x5c</code> (<code>\\</code>), and <code>0x60</code> (<code>\`</code>). In some very rare cases you may need to escape a <code>$</code> if it is followed by a <code>{</code>.</p>
<p>You should replace <code>n</code> with the number of bits the output should be grouped into, and you can put any code you want in the final <code>map</code> and use <code>+(&quot;0x&quot;+p)</code> to get the decimal value wherever necessary.</p>
<p>This adds roughly 100 bytes of overhead, compared to <code>atob</code>/<code>btoa</code>'s 8. This method fits just under 7 bits per character in the string (due to escaping), and takes advantage of the fact that JS lets you put pretty much any code points into a string.</p>
<p>In order for this to be shorter, the data compressed needs to be one of:</p>
<ul>
<li>Binary or numeric data, which is difficult to work with using <code>atob</code> and <code>btoa</code></li>
<li>A string that has few distinct characters and is longer than 100 or so characters</li>
</ul>
<p>In order to create a compressed string, convert each chunk of the string to binary using whatever encoding you want, then break it into chunks 7 bits wide. You may need to add some padding, which will be ignored if it is under 7 bits. Then, convert these into code points and paste them into the string.</p>
</div>
<div id="pu11" class="pu"><h3>output</h3>
<p>sometimes you can use <code>throw</code> instead of <code>alert</code> to save 1 byte</p>
<pre><code>throw !0
alert(!0)  
</code></pre>
<p>Do note that the program terminates, so you can't use it for loops.</p>
</div>
<div id="pu12" class="pu"><ol>
<li>Checking if a string includes a character, e.g. 0:</li>
</ol>
<pre class="lang-javascript prettyprint-override"><code>if(s.indexOf(0)!=-1)
if(~s.indexOf(0))    // -3
if(s.includes(0))    // -3
if(s.match(/0/))     // -4
if(/0/.exec(s))      // -5
</code></pre>
<p><code>exec</code> is shorter than <code>match</code>.</p>
<ol start="2">
<li>Ceiling a division:</li>
</ol>
<pre class="lang-javascript prettyprint-override"><code>Math.ceil(a/b)
(a+b-1)/b|0    // -3
</code></pre>
<p>Even shorter (if you don't mind editing a):</p>
<pre class="lang-javascript prettyprint-override"><code>--a/b+1|0     // -5
-~(--a/b)     // -5 too
</code></pre>
<ol start="3">
<li>String to array</li>
</ol>
<pre class="lang-javascript prettyprint-override"><code>// s is a string
Array.from(s)
[...s]        // -7
</code></pre>
</div>
<div id="pu13" class="pu"><h2>Converting an array of strings into numbers</h2>
<p>Take the array <code>[&quot;32&quot;, &quot;0x30&quot;, &quot;0o10&quot;, &quot;7.642&quot;, &quot;1e3&quot;]</code>. The simple way to convert this to numbers would be <code>.map(n=&gt;+n)</code> or <code>.map(Number)</code>.</p>
<p>However, assuming you know everything is a valid number, you can simply use <code>.map(eval)</code>, saving at least a byte.</p>
</div>
<div id="pu14" class="pu"><p>You can check if a value is *truish by simply passing it:</p>
<pre><code>if(val){...}
</code></pre>
<blockquote>
<p>*everything different than <code>0</code>, <code>0n</code>, <code>&quot;&quot;</code>,
<code>false</code>, <code>null</code>, <code>undefined</code> and <code>NaN</code> is evaluated to <em>true</em> !</p>
</blockquote>
<p>This method can be applied with many other functions and operators:</p>
<ul>
<li><strong>ternary operator</strong> <code>val?&quot;true&quot;:&quot;false&quot;;</code></li>
<li><strong>for loop</strong> <code>for(;val;){...}</code></li>
<li><strong>while loop</strong> <code>while(val){...}</code></li>
<li>etc...</li>
</ul>
</div>
<div id="pu15" class="pu"><p>If you need to do something different depending on several different values for a string, instead of:</p>
<pre class="lang-js prettyprint-override"><code>if(v=='hello'){
  j=1
}else if(v=='goodbye'){
  j=2
//...
</code></pre>
<p>consider:</p>
<pre class="lang-js prettyprint-override"><code>j={hello:1,goodbye:2,...}[v]
</code></pre>
</div>
<div id="pu16" class="pu"><h1>Use shorthands instead of primitives</h1>
<p>Most of these are done by any sane minifier, but not all.</p>
<ul>
<li><p><strong>2 bytes saved</strong></p>
<pre><code>true
!0
</code></pre>
</li>
<li><p><strong>3 bytes saved</strong></p>
<pre><code>false
!1
</code></pre>
</li>
<li><p><strong>5 bytes saved</strong></p>
<pre><code>Infinity
1/0
</code></pre>
</li>
<li><p><strong>5 bytes saved</strong></p>
<pre><code>undefined
0[0]   (any digit works)
</code></pre>
</li>
</ul>
</div>
<div id="pu17" class="pu"><h1>Abusing template literals</h1>
<p>You can often save two bytes on parentheses by replacing</p>
<pre class="lang-js prettyprint-override"><code>a.join('+')
</code></pre>
<p>with</p>
<pre class="lang-js prettyprint-override"><code>a.join`+`
</code></pre>
<p>This works for most properties that take in a single string.</p>
<p><em>This has been used in other answers, but there isn't an answer dedicated to this specifically.</em></p>
</div>
<div id="pu18" class="pu"><p>The <code>9**999</code> is <code>Infinity</code> shortcut (2 characters shorter)</p>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>console.log( 9**999===Infinity )</code></pre>
</div>
</div>
</p>
</div>
<div id="pu19" class="pu"><h2>Square root hack</h2>

<p>Use <code>(x+2)**(1/2)</code> instead of <code>Math.sqrt(x+2)</code>.</p>
</div>
<div id="pu20" class="pu"><h1>Add elements to Array</h1>

<p>The <code>concat</code> is more useful than <code>push</code> in many situations because it returns whole array e.g. we want from <code>d=[{a:1,b:2,c:3},{a:7,b:8,c:9}]</code> generate 'pivot object' <code>p={"a":[1,7],"b":[2,8],"c":[3,9]}</code> </p>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>let p={}, d=[{a:1,b:2,c:3},{a:7,b:8,c:9}]; 

d.map(x=&gt; Object.keys(x).map(k=&gt; p[k]= (p[k]||[]).concat(x[k]) ))

console.log(JSON.stringify(p));</code></pre>
</div>
</div>
</p>
</div>
<div id="pu21" class="pu"><h1>Remove duplicates from array</h1>

<pre><code>a.filter(e=&gt;!(t[e]=e in t)) 
</code></pre>

<p><div class="snippet" data-lang="js" data-hide="true" data-console="true" data-babel="false">
<div class="snippet-code snippet-currently-hidden">
<pre class="snippet-code-js lang-js prettyprint-override"><code>let unique= (a,t={})=&gt; a.filter(e=&gt;!(t[e]=e in t));

// "stand-alone" version working with global t:
// a1.filter((t={},e=&gt;!(t[e]=e in t)));

// Test data
let a1 = [5,6,0,4,9,2,3,5,0,3,4,1,5,4,9];
let a2 = [[2, 17], [2, 17], [2, 17], [1, 12], [5, 9], [1, 12], [6, 2], [1, 12]];
let a3 = ['Mike', 'Adam','Matt', 'Nancy', 'Adam', 'Jenny', 'Nancy', 'Carl'];

// Results
console.log(JSON.stringify( unique(a1) ))
console.log(JSON.stringify( unique(a2) ))
console.log(JSON.stringify( unique(a3) ))</code></pre>
</div>
</div>
</p>

<p><strong>O(n)</strong> <a href="https://jsperf.com/uniquefilter/1" rel="nofollow noreferrer">performance</a>; we assume your array is in <code>a</code> and <code>t={}</code>. Explanation <a href="https://stackoverflow.com/a/53453045/860099">here</a> </p>

<p>And shorter but slower version (which not work with 2D arrays)</p>

<pre><code>[...new Set(a)]
</code></pre>

<p><div class="snippet" data-lang="js" data-hide="true" data-console="true" data-babel="false">
<div class="snippet-code snippet-currently-hidden">
<pre class="snippet-code-js lang-js prettyprint-override"><code>let unique = a =&gt; [...new Set(a)];

// Test data
let a1 = [5, 6, 0, 4, 9, 2, 3, 5, 0, 3, 4, 1, 5, 4, 9];
let a3 = ['Mike', 'Adam', 'Matt', 'Nancy', 'Adam', 'Jenny', 'Nancy', 'Carl'];

// Results
console.log(JSON.stringify(unique(a1)))
console.log(JSON.stringify(unique(a3)))</code></pre>
</div>
</div>
</p>
</div>
<div id="pu22" class="pu"><h3>Use <code>^</code> instead of <code>!=</code> or <code>==</code> when comparing to an integer</h3>

<pre><code>//x!=3?a:b
  x^3?a:b

//x==3?a:b
  x^3?b:a
</code></pre>

<h3>Replace calls to built-in Math functions with shorter expressions</h3>

<pre><code>//Math.ceil(n)
  n%1?-~n:n

//Math.floor(n)
  ~~n
  0|n

//Math.abs(n)
  n&lt;0?-n:n

//Math.round(n)
  n+.5|0

//Math.min(x,y)
  x&lt;y?x:y

//Math.max(x,y)
  y&lt;x?x:y
</code></pre>
</div>
<div id="pu23" class="pu"><p>Use the simplest shortening method available - your variable declaration!</p>

<pre><code>var myName = "Jack";
</code></pre>

<p>Obviously is very long compared to:</p>

<pre><code>m="Jack"
</code></pre>

<p>It's a whole 12 characters shorter. You have all 64 of these single-character variable names available:</p>

<pre><code>abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_
</code></pre>

<p>And also - never use spaces or semicolons in your variable naming - changing <code>m = "Mum";</code> to <code>m="Mum"</code> saves another three characters.</p>
</div>
<div id="pu24" class="pu"><h1>Shortening Promise Chains with <code>async</code>/<code>await</code></h1>

<p>Sometimes you can shorten longer promise chains with <code>async</code>/<code>await</code>.  The main benefit is from getting rid of the beginning of the arrow function in each <code>then</code> callback.  <code>.then(x=&gt;x</code> (10) gets replaced with <code>await(</code> (-4), but you first pay with <code>async</code> (+6).  So to make up for the initial overhead of 6 bytes, you'd need at least two <code>then</code> chains to get any benefit.</p>

<pre><code>+-------------+----------------+
| then chains | async overhead |
+-------------+----------------+
| 0           | +6             |
| 1           | +2             |
| 2           | -2             |
| 3           | -4             |
| …           | …              |
+-------------+----------------+
</code></pre>

<h2>Example 1</h2>

<pre><code>x=&gt;x().then(y=&gt;y.foo()).then(z=&gt;z.bar())
async x=&gt;await(await(x()).foo()).bar()
</code></pre>

<h2>Example 2</h2>

<pre><code>u=&gt;fetch(u).then(r=&gt;r.text()).then(t=&gt;/\0/.test(t))
async u=&gt;/\0/.test(await(await fetch(u)).text()))
</code></pre>
</div>
<div id="pu25" class="pu"><h1>Abuse literals</h1>

<p>The recent sample: Check whether <code>"c"</code> is uppercase or lowercase, doesn't matter if not letter</p>

<pre><code>"c"&lt;{} // returns false, lower case
"C"&lt;{} // returns true, upper case
</code></pre>
</div>
<div id="pu26" class="pu"><p>If you are using the same function more than once, it's often useful to reference the function to a new function name. I.e:</p>

<p>Instead of:</p>

<pre><code>Math.sqrt(4)
Math.sqrt(16)
Math.sqrt(100)
</code></pre>

<p>you can do:</p>

<pre><code>r=Math.sqrt
r(4)
r(16)
r(100)
</code></pre>
</div>
<div id="pu27" class="pu"><p>When stringifying dates, <code>.toJSON</code> saves 5 bytes over <code>.toISOString</code>. Apparently this was supported as far back as Firefox 4, but this answer is only the sixth on PPCG to mention it.</p>
</div>
<div id="pu28" class="pu"><p>This is one of my favorites - 
ES6 </p>

<pre><code>'da,dad,sa'.split``
 ["d", "a", ",", "d", "a", "d", ",", "s", "a"]

'da,dad,sa'.split`,`
["da", "dad", "sa"]
</code></pre>
</div>
<div id="pu29" class="pu"><p>Comparing numbers by absolute value:</p>

<pre><code>a*a&lt;b*b // 7 bytes
</code></pre>

<p>Vastly shorter than <code>Math.abs</code> (8 bytes without counting <code>()</code>), and like calling the function this will allow casting strings to numbers on the fly.</p>

<p>Sorting by arrays of multiple values, comparing them all one by one (e.g. finding minimum time durations in <code>01:23:45</code> notation):</p>

<pre><code>a.map(v=&gt;v.split`:`).sort(([h,m,s],[g,n,a])=&gt;h-g||m-n||s-a)[0].join`:`
</code></pre>

<p>This example sorts <code>00:00:00</code> &lt; <code>01:00:00</code> &lt; <code>01:00:01</code> &lt; <code>22:59:59</code> &lt; <code>23:00:00</code> and finds the smallest element. This works because <code>||</code> short-circuits for any value that isn't <code>false</code>like and so the expression <code>h-g||m-n||s-a</code> will evaluate the next value in the chain only when the last difference was <code>0</code>.</p>
</div>
<div id="pu30" class="pu"><h1>Rounding</h1>
<p>I know that alternatives to <code>Math.floor()</code> have been posted, but what about the others?</p>
<h2>Flooring:</h2>
<pre><code>Math.floor(x) //before
0|x           //after
</code></pre>
<h2>Rounding:</h2>
<pre><code>Math.round(x) //before
0|x+.5        //after
</code></pre>
<h2>Ceiling:</h2>
<pre><code>Math.ceil(x) //before
x%1?-~x:x    //after - credits to @Tomas Langkaas
</code></pre>
</div>
<div id="pu31" class="pu"><p>If you are ever in a situation where you have an array <code>a</code> and you need to get its last element as an array of itself, use <code>Array#slice()</code>:</p>

<pre><code>[a[a.length-1]]    // 15
a.slice(-1)        // 11
</code></pre>
</div>
<div id="pu32" class="pu"><h3>Fancy For Loops</h3>



<p>you can use the standard for loop in non-standard ways</p>

<pre class="lang-javascript prettyprint-override"><code>for ( a; b; c )
</code></pre>

<p>is essentially equivalent to:</p>

<pre class="lang-javascript prettyprint-override"><code>a;
while ( b )
{
  ...
  c;
}
</code></pre>

<p>so a good trick is to write your code with a <code>while</code> loop, and then split it into the <code>a,b,c</code> parts in a <code>for</code> loop.</p>

<p>A couple examples <a href="https://codegolf.stackexchange.com/questions/1977/what-is-the-average-of-n-the-closest-prime-to-n-the-square-of-n-and-the-closest/1978#1978">I've written</a>:</p>

<pre class="lang-javascript prettyprint-override"><code>for(x=y=n;!z;x--,y++)z=i(x)?x:i(y)?y:0
for(a=b=1;b&lt;n;c=a+b,a=b,b=c);
</code></pre>

<h3>Chain your setters</h3>

<p>If you're initializing or resetting multiple values, chain the value to all the variables that need it:</p>

<pre class="lang-javascript prettyprint-override"><code>a=b=1;
</code></pre>

<h3>Implicit Casting</h3>

<p>Don't check your types, just use them as they are. <code>parseInt()</code> costs <code>10</code> characters. If you need to cast out of a string, be creative:</p>

<pre class="lang-javascript prettyprint-override"><code>a='30';
b='10';
c = a + b; //failure
c = parseInt(a) + parseInt(b) //too long

c = -(-a-b); //try these
c = ~~a+~~b;
c = +a+ +b;
c = a- -b;
</code></pre>

<h3>Avoid Semicolons</h3>

<p>JavaScript has automatic semi-colon insertion. Use it often and well.</p>

<h3>One-liners</h3>

<p>Save on brackets by shoving as much as possible into single lines, or parameters:</p>

<pre class="lang-javascript prettyprint-override"><code>a( realParam1, realParam2, fizz='buzz' )
</code></pre>

<h3>Increment/Decrement operators</h3>

<pre class="lang-javascript prettyprint-override"><code>a = a - 1;
foo(a);
</code></pre>

<p>and</p>

<pre class="lang-javascript prettyprint-override"><code>foo(a);
a = a - 1;
</code></pre>

<p>can easily be rewritten as</p>

<pre class="lang-javascript prettyprint-override"><code>foo(--a);
</code></pre>

<p>and</p>

<pre class="lang-javascript prettyprint-override"><code>foo(a--);
</code></pre>

<p>respectively.</p>

<h3>Use <code>this</code> or <code>self</code> instead of <code>window</code> in global context</h3>

<p>self explanatory 2 character savings.</p>

<h3>Use bracket notation for repeat property access</h3>

<p>This is definitely a balancing act between property name length and number of accesses. Instead of calling <code>a.longFunctionName()</code> with dot notation twice, it's shorter to save the name and call the function via bracket notation:</p>

<pre class="lang-javascript prettyprint-override"><code>a.longFunctionName(b)
a.longFunctionName(c)
//42
</code></pre>

<p>-vs-</p>

<pre class="lang-javascript prettyprint-override"><code>a[f='longFunctionName'](b)
a[f](c)
//34
</code></pre>

<p>this is especially effective with functions like <code>document.getElementById</code> which can be reduced to <code>d[e]</code>.</p>

<p>Note:</p>

<p>With bracket notation, the cost is <code>6 + name.length</code> characters the first time. Each subsequent access has a cost of <code>3</code> characters.</p>

<p>For dot notation, all accesses cost <code>name.length + 1</code> (+1 for the <code>.</code>) characters.</p>

<p>Use this method if <code>6 + name.length + (3 * (accesses - 1)) &lt; accesses * (name.length + 1)</code>.</p>

<p>len = length of property name<br>
i = minimum accesses to take advantage</p>

<pre class="lang-javascript prettyprint-override"><code>len | i 
========
1   | ∞ 
2   | ∞ 
3   | 7 
4   | 4 
5   | 3 
6   | 3 
7   | 3 
8+  | 2 
</code></pre>

<p>The number of accesses can also span multiple objects. If you access <code>.length</code> 4 or more times on different arrays, you can use the same variable holding the string <code>'length'</code>.</p>
</div>
<div id="pu33" class="pu"><h3>Free commas!</h3>

<p>Often you'll want to include a comma in a string, perhaps like so:</p>

<pre><code>f=(x,y,z)=&gt;x+","+y+z
</code></pre>

<p>By abusing the string representation of arrays, this can be shortened by two bytes:</p>

<pre><code>f=(x,y,z)=&gt;[x,y]+z
</code></pre>

<p>This particular instance only works if you have three variables you want to concatenate as shown. You can use the same trick with two, but you need to be careful. There are three variants you might try:</p>

<pre><code>f=(x,y)=&gt;[x,y]
f=(x,y)=&gt;[x,]+y
f=(x,y)=&gt;x+[,y]
</code></pre>

<p>The first one will return an actual array rather than a string, which defeats the purpose. The second one <em>looks</em> like it will work, but in fact most modern browsers will remove the trailing comma when parsing the array. The third one will work though, at the same byte count as the second.</p>

<hr>

<p>To put this to good use, say you have a function which creates the range <code>[0...n]</code>:</p>

<pre><code>f=x=&gt;x?[...f(x-1),x]:[0]
</code></pre>

<p>If returning a string with a separator is allowed, you might do something like this, saving a few bytes:</p>

<pre><code>f=x=&gt;x?f(x-1)+" "+x:0
</code></pre>

<p>However, you can save another byte with an array literal:</p>

<pre><code>f=x=&gt;x?f(x-1)+[,x]:0
</code></pre>

<p>Note that depending on how you arrange the recursion, you may end up with a leading or trailing separator, so you'll need to make sure your output format is allowed by the challenge.</p>

<p><a href="https://codegolf.stackexchange.com/a/113056/42545">Example usage</a></p>
</div>
<div id="pu34" class="pu"><p><strong>Unicode shortcuts</strong></p>

<p>If you use a hell of a built-in property at a big golfing challenge you can alias every property to a one character equivalent:</p>

<pre><code>[Math,Number,S=String,Array].map(b=&gt;
    Object.getOwnPropertyNames(b).map((p,i)=&gt;
        b.prototype[S.fromCharCode(i+248)]=b[p]
    )
)
</code></pre>

<p>After executing the code above you can use it like this:<br/>
<code>"foo".Č(/.*/,'bar') // replaces foo with bar</code></p>

<p><strong>This costs 118 bytes, so it might not be useful in certain situations</strong></p>

<p>It may be browser dependent and i'm not sure if it's shorter than <code>with(Array){join(foo),...}</code> or defining variables as used properties <code>with(Array){j=join,m=map...}</code> but still it is worth mentioning. </p>

<pre><code>    Math        Number              String              Array

ø   toSource    prototype           prototype           prototype
ù   abs         NaN                 quote               join
ú   acos        POSITIVE_INFINITY   substring           reverse
û   asin        NEGATIVE_INFINITY   toLowerCase         sort
ü   atan        MAX_VALUE           toUpperCase         push
ý   atan2       MIN_VALUE           charAt              pop
þ   ceil        MAX_SAFE_INTEGER    charCodeAt          shift
ÿ   clz32       MIN_SAFE_INTEGER    contains            unshift
Ā   cos         EPSILON             indexOf             splice
ā   exp         isFinite            lastIndexOf         concat
Ă   floor       isInteger           startsWith          slice
ă   imul        isNaN               endsWith            filter
Ą   fround      toInteger           trim                isArray
ą   log         parseFloat          trimLeft            lastIndexOf
Ć   max         parseInt            trimRight           indexOf
ć   min         length              toLocaleLowerCase   forEach
Ĉ   pow         name                toLocaleUpperCase   map
ĉ   random      arguments           normalize           every
Ċ   round       caller              match               some
ċ   sin                             search              reduce
Č   sqrt                            replace             reduceRight
č   tan                             split   
Ď   log10                           substr  
ď   log2                            concat  
Đ   log1p                           slice   
đ   expm1                           fromCharCode    
Ē   cosh                            fromCodePoint   
ē   sinh                            localeCompare   
Ĕ   tanh                            length  
ĕ   acosh                           name    
Ė   asinh                           arguments   
ė   atanh                           caller  
Ę   hypot           
ę   trunc           
Ě   sign            
ě   cbrt            
Ĝ   E           
ĝ   LOG2E           
Ğ   LOG10E          
ğ   LN2         
Ġ   LN10            
ġ   PI          
Ģ   SQRT2           
ģ   SQRT1_2         
</code></pre>
</div>
<div id="pu35" class="pu"><p>Instead of checking if something is a string like this:</p>

<pre><code>var a = "aString";
if (typeof a === 'string') {
    runSomething();
}
</code></pre>

<p>You can do this:</p>

<pre><code>var a = "aString";
a===''+a&amp;&amp;runSomething();
</code></pre>
</div>
<div id="pu36" class="pu"><h1>ES6-specific: avoid <code>Function#bind()</code></h1>

<p>Self-explanatory, <strong>7 bytes saved</strong></p>

<pre><code>f.bind(null,x,...xs)
_=&gt;f(x,...xs)
</code></pre>

<h1>Use sloppy mode to avoid variable declarations</h1>

<p>Here, <strong>8 bytes saved</strong></p>

<pre><code>a.forEach(e=&gt;{let b=e+1,c=d(b)+2;f(e);g(b);h(c);i(b,c)})
a.forEach(e=&gt;{f(e);g(b=e+1);h(c=d(b)+2);i(b,c)})

// Even better, reuse variables and use `Array#map()`
// Drops an additional 6 bytes
a.map(e=&gt;{f(e++);g(e);h(b=d(e)+2);i(e,b)})
</code></pre>

<p>This also holds in ES5. Here, <strong>8 bytes saved</strong></p>

<pre><code>a.forEach(function(e){let b=e+1,c=d(b)+2;f(e);g(b);h(c);i(b,c)})
a.forEach(function(e){f(e);g(b=e+1);h(c=d(b)+2);i(b,c)})

// Even better, reuse variables and use `Array#map()`
a.map(function(e){f(e++);g(e);h(b=d(e)+2);i(e,b)})
</code></pre>
</div>
<div id="pu37" class="pu"><h1>If iterating through own properties, prefer Object.keys.</h1>

<p><strong>15 bytes saved</strong></p>

<pre><code>for(let p in o)if(o.hasOwnProperty(e)){/* ... */}
for(let p of Object.keys(o)){/* ... */}
Object.keys(o).map(p=&gt;{/* ... */})
</code></pre>

<p>This is also the case for ES5, where it is <strong>7 bytes saved</strong>.</p>

<pre><code>for(var p in o)if(o.hasOwnProperty(e)){/* ... */}
Object.keys(o).map(function(p){/* ... */})
</code></pre>

<p>If you do that more than once, alias it as a function.</p>

<p>In this ES6 example, <strong>6 bytes saved</strong>. It still saves bytes in ES5, but only if used 3 times or more.</p>

<pre><code>Object.keys(o).map(p=&gt;{/* ... */})Object.keys(o).map(p=&gt;{/* ... */})
i=f=&gt;Object.keys(o).map(f);i(p=&gt;{/* ... */});i(p=&gt;{/* ... */})
</code></pre>
</div>
<div id="pu38" class="pu"><p>Use valueOf to make shorter function calls.
Instead of:</p>



<pre class="lang-js prettyprint-override"><code>function f(){...}
f()
</code></pre>

<p>use</p>

<pre class="lang-js prettyprint-override"><code>f={valueOf:function(){...}}
+f
</code></pre>

<p>If you call the function <code>f</code> frequently enough, you will save characters because <code>+f</code> is 1 shorter than <code>f()</code>.</p>

<p>If you use<code>f</code> even more than that, you can use <code>__defineGetter__</code>:</p>

<pre class="lang-js prettyprint-override"><code>__defineGetter__('f',function(){...})
f
</code></pre>

<p>This trick also works for a function that takes 1 argument.</p>

<pre class="lang-js prettyprint-override"><code>function f(v){...}
f(x)
</code></pre>

<p>Becomes</p>

<pre class="lang-js prettyprint-override"><code>__defineSetter__('f',function(v){...})
f=x
</code></pre>

<p>But now it will always return <code>v</code>.</p>

<hr>

<p>Edit: I forgot to mention this, but it only works for a function that doesn't take arguments.</p>
</div>
<div id="pu39" class="pu"><h2>Determining if an array is empty</h2>

<p>The empty array is truthy in JavaScript, i.e. <code>[]?b:c</code> returns <code>b</code>. This leaves us to find our own ways to determine if an array is empty. The most obvious way is <code>.length</code>:</p>

<pre><code>a.length?b:c
</code></pre>

<p>However, this can be shortened by 2 bytes with the <code>in</code> operator:</p>

<pre><code>0 in a?b:c
</code></pre>

<p>Note: unlike in Python, <code>x in y</code> checks whether <code>y</code> has a <em>key</em> <code>x</code>; it's a shorthand for <code>y.hasOwnProperty(x)</code>.</p>

<p>This is, I believe, the shortest code that unconditionally detects whether <code>a</code> is empty. However, there are a few alternatives that work in various scenarios:</p>

<pre><code>a[0]?b:c
</code></pre>

<p>This works iff the first item in <code>a</code> is guaranteed to be truthy. For example, <code>a=[1];a[0]</code> returns <code>1</code>, which is truthy; <code>a=[];a[0]</code> returns <code>undefined</code>, which is falsy; but <code>a=[0];a[0]</code> returns 0, which is also falsy. But in general, this trick works on arrays of chars or positive numbers.</p>

<pre><code>a+""?b:c
</code></pre>

<p>When arrays are casted to strings, the brackets are left out. <code>[1,2,3]+""</code> returns the string <code>"1,2,3"</code>. So casting <code>a</code> to a string will return the empty string (falsy) for the empty array, and a truthy string otherwise.</p>

<p>Caveat: If <code>a</code> contains a single array which contains either nothing or a single array containing... etc., e.g. <code>[[]]</code>, <code>[[[[[[]]]]]]</code>, it will still be casted to the empty string.</p>

<pre><code>a+a?b:c
</code></pre>

<p>This is practically exactly the same as the above example, but a byte shorter. When <code>+</code> is called on two arrays, JS stupidly converts them both to strings and concatenates <em>those</em>. So <code>a+a</code> returns exactly the same thing as <code>a+""</code>, but doubled.</p>
</div>
<div id="pu40" class="pu"><h1>Function</h1>

<p>If you need a function in as few bytes as possible, and any function will do (perhaps you just want to access some of the goodies from <code>Function.prototype</code>), then here are some options (starting with large ones):</p>

<pre><code>Function.prototype
[].map
Date
CSS     (available in modern browsers)
Map     (ES6: available in Node and modern browsers)
Set     (ES6: available in Node and modern browsers)
URL     (available in very old browsers, but not in Node)
</code></pre>

<p>So if you want a reference to the <code>call</code> function, you can get it like this:</p>

<pre><code>c=URL.call
</code></pre>
</div>
<div id="pu41" class="pu"><h1>2 to a power</h1>

<p>If for some reason you need to calculate 2 to the <code>n</code>th power,</p>

<p><code>1&lt;&lt;n</code> is shorter than <code>Math.pow(2,n)</code>.</p>

<p>If you needed to calculate 2 to the <code>n+1</code>th power,</p>

<p><code>2&lt;&lt;n</code> is even shorter than <code>1&lt;&lt;n+1</code></p>

<p>Likewise for <code>4&lt;&lt;n</code> for <code>n+2</code>, <code>8&lt;&lt;n</code> for <code>n+3</code>, <code>16&lt;&lt;n</code> for <code>n+4</code>, etc.</p>

<p><br>
<em>(sorry if this is too obvious)</em></p>
</div>
<div id="pu42" class="pu"><p><strong>Use Bitwise as Logic Operators When Dealing With Booleans</strong></p>

<pre><code>a = 1 //although this would usually be a boolean expression
b = 0 //same
if(a&amp;&amp;b)c()
if(a&amp;b)c()
</code></pre>

<p>Then, use <code>&amp;&amp;</code> lazy evaluation to make a chain of ampersands:</p>

<pre><code>a&amp;b&amp;&amp;c()
if(a&amp;&amp;b)c()
</code></pre>

<p><strong>Saves 3 characters</strong></p>
</div>
<div id="pu43" class="pu"><h1>Abuse uninitialized variables, mostly for <code>null</code> and <code>undefined</code></h1>

<ul>
<li><p><code>undefined</code> varies, some better than others</p>

<ul>
<li><p>One-time use (<strong>5 bytes saved</strong>):</p>

<pre><code>undefined
1..a       (any digit+letter works)
</code></pre></li>
<li><p>Multiple uses (<strong>8 per use - 5 bytes saved</strong>, <strong>10 bytes for 2 uses</strong>)</p>

<pre><code>undefined;undefined
var u;u;u
</code></pre></li>
<li><p>Existing declaration (<strong>8 per use - 5 bytes saved</strong>, <strong>5 bytes for 1 use</strong>, <strong>13 bytes for 2 uses</strong>)</p>

<pre><code>var x;undefined
var x,u;u

var x;undefined;undefined
var x,u;u;u
</code></pre></li>
</ul></li>
<li><p><code>null</code> varies, generally better replaced in larger golfs</p>

<ul>
<li><p>If there is a declaration <em>anywhere</em>, replace it unless <code>null</code> is specifically required (<strong>3 per use - 2 bytes saved</strong>).</p>

<pre><code>var x;null
var x,n;n
</code></pre></li>
<li><p>Single uses:</p>

<ul>
<li><p>If no variable declaration exists, do not change.</p></li>
<li><p>If any <code>undefined</code> exists (in any form), declare an unused variable (<strong>5 bytes saved if one of each</strong>).</p>

<pre><code>v==null;undefined
var u;v==u;u
</code></pre></li>
<li><p>If more than two such tests exist, declare an unused variable (two are equal).</p>

<pre><code>a==null;b==null;c==null
var u;a==u;b==u;c==u
</code></pre></li>
<li><p>Otherwise, keep as <code>null</code></p></li>
</ul></li>
<li><p>Multiple uses:</p>

<ul>
<li><p>Declare an unused variable, unless <code>null</code> is specifically required (2 is equivalent).</p>

<pre><code>null;null;null
var u;u;u;u
</code></pre></li>
</ul></li>
</ul></li>
<li><p>Prefer to avoid these tests when possible. Aim for implicit boolean tests (<code>if(0);</code>)</p></li>
</ul>
</div>
<div id="pu44" class="pu"><p>Use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/with" rel="noreferrer"><code>with</code></a> to import methods and properties from objects into the local scope.</p>

<p>It becomes more apparent with longer class names or repeated use of the same one:</p>

<pre class="lang-js prettyprint-override"><code>a=Math.max(1,2),b=Math.min(2,7),c=Math.sqrt(100)
with(Math)a=max(1,2),b=min(2,7),c=sqrt(100)
</code></pre>
</div>
<div id="pu45" class="pu"><p><strong>tl;dr:</strong> Use ES6 features!</p>

<h3>Arrow functions</h3>

<p>Doc: <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/arrow_functions" rel="nofollow">https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/arrow_functions</a><br>
Example:</p>

<pre class="lang-js prettyprint-override"><code>s = x =&gt; x*x
// s = function (x) {
//   return x * x;
// }
</code></pre>
</div>
<div id="pu46" class="pu"><h1>Converting a number from hexadecimal</h1>

<p>Instead of using the lengthy <code>parseInt</code> to convert a number from hexadecimal:</p>

<pre><code>parseInt(a,16)
</code></pre>

<p>Add <code>"0x"</code> to the beginning, then convert to a number with a usual technique:</p>

<pre><code>+("0x"+a)   // 5 bytes saved
</code></pre>

<p>Even better solution, abusing order of operations:</p>

<pre><code>"0x"+a-0    // another byte saved
</code></pre>

<p>Note that this last one will not work in all situations, depending on the surrounding operators.</p>

<p>In ES6, you can also use this trick to convert from octal or binary:</p>

<pre><code>"0b"+a-0   // binary
"0o"+a-0   // octal
</code></pre>
</div>
<div id="pu47" class="pu"><h1>Prefer <code>.map</code> over <code>.reduce</code></h1>
<p>Consider the following code for summing an array:</p>
<pre><code>a.reduce(function(x,y){return x+y})
</code></pre>
<p>Pretty long, right? What if I told you that you could get rid of the <code>return</code>? Well, you can:</p>
<pre><code>a.map(function(x){t+=x},t=0)    // 7 bytes saved
</code></pre>
<p>(Although an even shorter way is <code>eval(a.join(&quot;+&quot;))</code>.)</p>
<p>How about reducing by multiplication, where you have to specify the starting number anyway?</p>
<pre><code>a.reduce(function(x,y){return x*y},1)  // Looooong
a.map(function(x){t*=x},t=1)    // An easy 9 bytes shorter
</code></pre>
<p>(Again, <code>eval(a.join(&quot;*&quot;))</code> works as well.)</p>
<p>Here, let's try one that doesn't work with <code>eval(a.join())</code>:</p>
<pre><code>a.reduce(function(x,y){return x+f(y)})
a.map(function(x){t+=f(x)},t=0)
</code></pre>
<p>Note that this doesn't work <em>quite</em> as well with ES6, although it's still a little shorter:</p>
<pre><code>a.reduce((x,y)=&gt;x+f(y))
a.map(x=&gt;t+=f(x),t=0)
</code></pre>
<p><strong>Note:</strong> in all of the <code>.map</code> versions, you will need to call <code>t</code> afterwards to get the actual value.</p>
</div>
<div id="pu48" class="pu"><h1>Conditionally reverse an array with <code>.sort</code></h1>

<p>Let's say you have an array, <code>l</code>, and you want to reverse it if and only if <code>someBoolean</code>. </p>

<p>The naïve way to do it would be <code>if(someBoolean)l.reverse()</code></p>

<p>Instead, you can abuse the way that JavaScript's <code>sort</code> function works.</p>

<pre><code>if(someBoolean)l.reverse() // before
someBoolean&amp;&amp;l.reverse()   // golfier before
l.sort(_=&gt;someBoolean)     // after
                      ^^^^
</code></pre>
</div>
<div id="pu49" class="pu"><p>If you need to check for NaN, don't use <code>isNaN(x)</code>, but use <code>x!=x</code>, which is shorter and also works.</p>

<pre class="lang-javascript prettyprint-override"><code>if(isNaN(x)){
if(x!=x){
</code></pre>

<p>Note that this only works if <code>typeof(x) === "number"</code>; if it's a string for example, <code>isNaN("string")</code> returns <code>true</code>, but <code>"string" != "string"</code> returns <code>false</code>. Thanks to Cyoce for pointing this out!</p>
</div>
<div id="pu50" class="pu"><p><strong>Adding Values with Implicit Casting</strong></p>

<p>Improved <a href="https://codegolf.stackexchange.com/a/2714/3563">zzzzBov solution</a>:</p>

<pre><code>//not so good
-(-a-b)==c;

//best
a- -b==c;
a-+-b==c;
</code></pre>

<p>We save <code>2</code> characters by using these solutions.</p>
</div>
<div id="pu51" class="pu"><h1>Use atob() and btoa() to compress/decompress strings</h1>
<pre><code>alert('adifonoiewnfqowinfiodnasfoinqeiwnfqoiwnfoiansdfoinqowfe') //before
alert(btoa('iØ¢z&quot;{ ßª&quot;ø¨vv¬~§©è°ú¨    ß¢&amp;§±×èz¨Á÷')) //after
</code></pre>
<p>Great for some <a href="/questions/tagged/restricted-source" class="post-tag" title="show questions tagged &#39;restricted-source&#39;" rel="tag">restricted-source</a> challenges. Only works on strings with <code>a-zA-Z0-9</code> and no other chars.</p>
</div>
<div id="pu52" class="pu"><h1>Stack Ternary Operators</h1>

<p>Need to test many conditions, try this:</p>

<pre><code>a ? b : c ? d : e ? f : g
</code></pre>

<h1>Use the comma operator</h1>

<p>Using an arrow function, and need to return something else than what your doing? Feel no need to break out the <code>{b;return a}</code> and instead use the comma operator:</p>

<pre><code>   f=&gt;{f.map(b=&gt;...);return a}
   f=&gt;(f.map(b=&gt;...),a)
</code></pre>

<h1>Take advantage of =</h1>

<p>Assignment without <code>var</code> can be vital to shave off bytes. Since it returns the value, you can:</p>

<p>Assign variables in function calls:</p>

<pre><code>Array(100).fill(100);p=100
Array(p=100).fill(p)
</code></pre>

<p>Stack variable assignment:</p>

<pre><code>a=1,b=1,c=1
a=b=c=1
</code></pre>

<p>Assign variables in control structures:</p>

<pre><code>if(b=1) {...}
</code></pre>

<p>Since <code>1</code> is truthy (If tested against a boolean it will convert to <code>true</code>), the block will run</p>
</div>
<div id="pu53" class="pu"><h1><code>document.getElementById</code></h1>

<p>This one's a HUGE byte-saver.</p>

<pre><code>document.getElementById('a').innerHTML="foo"; //before
a.innerHTML="foo"; //after
</code></pre>
</div>
<div id="pu54" class="pu"><h1><code>setInterval</code> Hacks</h1>
<p>Pass a string instead of a function to setInterval.</p>
<pre><code>setInterval(function(){console.log(0)},1) //before
setInterval('console.log(0)',1) //after
</code></pre>
<p>You can also omit the last argument if you don't care about the speed at which your interval will execute. NOTE: This does not work in Firefox...</p>
<pre><code>setInterval('console.log(0)',1) //before
setInterval('console.log(0)') //after
setInterval`console.log(0)` //after - ES6 only
</code></pre>
</div>
<div id="pu55" class="pu"><h1>Array sum / product / quotient</h1>

<p><strong>ES5</strong>: 17 bytes</p>

<pre><code>eval(a.join('+'))
</code></pre>

<p><strong>ES6</strong>: 15 bytes</p>

<pre><code>eval(a.join`+`)
</code></pre>

<p>Of course you can swap the <code>+</code> for anything you want, e.g., <code>*</code> for product or <code>/</code> for quotient. </p>
</div>
<div id="pu56" class="pu"><p>Very simple one, even so, no one had mentioned it.</p>

<p>If you're using <code>Math.min()</code> or <code>Math.max()</code> you can save 6 chars by doing this:</p>

<pre><code>Math.min(a,b)  // 13 chars
a&lt;b?a:b        //  7 chars

Math.max(a,b)
a&gt;b?a:b
</code></pre>
</div>
<div id="pu57" class="pu"><p><strong>Repeated characters</strong></p>

<p>Be creative when trying to repeat the same character:</p>

<pre><code>"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
s="a";while(s.length&lt;32)s+=s
for(s="a";s.length&lt;32;s+=s)
for(s="aa",i=4;i--;s+=s)
s="aaaaaaaa",s+=s,s+=s
s="aaaaaaaa",s+=s+s+s
Array(33).join("a")
</code></pre>

<p>With ES6, this becomes even shorter:</p>

<pre><code>'a'.repeat(32)
</code></pre>

<p><strong>Note:</strong> It is unlikely that you use it to form a string, but the idea can be applied to form large numbers too</p>
</div>
<div id="pu58" class="pu"><p>When it comes to comparing strings against eachother, you’d normally use</p>



<pre class="lang-js prettyprint-override"><code>x=='*'
</code></pre>

<p>If it is the case that <code>x</code> only has a few <em>fixed options</em>, e.g. <code>x</code> can <em>only</em> be one of the lowercase letters <em>or</em> the asterisk (<code>*</code>), then you can use JavaScript’s string comparison like this:</p>

<pre class="lang-js prettyprint-override"><code>x&lt;'a'
</code></pre>

<p>In the case of <em>limited options</em>, this will be <code>true</code> if and only if <code>x=='*'</code> and <code>false</code> otherwise, saving <em>one amazing byte</em>! This is based on the Unicode table.</p>

<p>For an actual example, see <a href="https://codegolf.stackexchange.com/revisions/53980/6">this revision of an answer of mine</a>.</p>
</div>
<div id="pu59" class="pu"><p><strong>Transforming to a Boolean</strong>:</p>

<pre><code>if(b){b=true}else{b=false}
b=b?true:false;
b=b?!0:!1;
b=!!b;
</code></pre>

<p><strong>Note:</strong> This changes <code>0</code>, <code>""</code>,<code>false</code>, <code>null</code>, <code>undefined</code> and <code>NaN</code> to <code>false</code> (everything else to <code>true</code>)</p>
</div>
<div id="pu60" class="pu"><h1><code>Array#concat()</code> and the spread operator</h1>

<p>This largely depends on the situation.</p>

<hr>

<h2>Combining multiple arrays.</h2>

<p>Prefer the concat function unless cloning.</p>

<p><strong>0 bytes saved</strong></p>

<pre><code>a.concat(b)
[...a,...b]
</code></pre>

<p><strong>3 bytes wasted</strong></p>

<pre><code>a.concat(b,c)
[...a,...b,...c]
</code></pre>

<p><strong>3 bytes saved</strong></p>

<pre><code>a.concat()
[...a]
</code></pre>

<p><strong>6 bytes saved</strong></p>

<pre><code>// Concatenate array of arrays
[].concat.apply([],l)
[].concat(...l)
</code></pre>

<hr>

<h2>Prefer using an already existing array to <code>Array#concat()</code>.</h2>

<p>Easy <strong>4 bytes saved</strong></p>

<pre><code>[].concat(a,b)
a.concat(b)
</code></pre>
</div>
<div id="pu61" class="pu"><p><strong>Converting a string to an int/float by subtracting a empty array</strong></p>

<p>Before(22 bytes)</p>

<pre><code>parseFloat("12.52463")
</code></pre>

<p>After(13 bytes, saved 9 bytes)</p>

<pre><code>"12.52463"-[]
</code></pre>
</div>
<div id="pu62" class="pu"><p>Convert ints to strings by adding an empty string</p>

<p>For example:</p>

<pre><code>39323+""
</code></pre>

<p>Returns:</p>

<pre><code>"39323"
</code></pre>

<p><strong>Update</strong>:</p>

<p>Adding <code>[]</code> works too</p>
</div>
<div id="pu63" class="pu"><h1>If returning void, see if it is shorter to return something useful. This is kinda language-agnostic here.</h1>

<p>This isn't an easy apply-anywhere thing, either, though. Word of warning, make sure your parentheses are balanced.</p>

<p>In ES6, in this example, <strong>6 bytes saved</strong></p>

<pre><code>let l=x=&gt;console.log(m+x),x=1,a;l(a=f(x));l(a=g(a));l(h(a))
let l=x=&gt;(console.log(m+x),x),x=1;l(h(l(g(l(f(x))))))
</code></pre>

<p>In ES5, it is only <strong>1 byte saved</strong></p>

<pre><code>function l(x){console.log(m+x)}var x=1,a;l(a=f(x));l(a=g(a));l(h(a))
function l(x){console.log(m+x);return x}var x=1;l(h(l(g(l(f(x))))))
</code></pre>
</div>
<div id="pu64" class="pu"><h1>Prefer <code>Array#map()</code> to <code>Array#forEach()</code></h1>

<p>Self-explanatory, a flat <strong>4 bytes saved</strong></p>

<pre><code>a.forEach(function(e){/* ... */})
a.map(function(e){/* ... */})
</code></pre>
</div>
<div id="pu65" class="pu"><h1>Return <code>1</code> for <code>true</code>, <code>0</code> for <code>false</code> as much as possible</h1>

<p>This should be relatively self-explanatory.</p>

<pre><code>function f(x){return x?(d(x),!1):!0}
function f(x){return x?(d(x),0):1}
function f(x){return !x&amp;&amp;d(x)&amp;0}
if(f(v)){/* ... */}

// ES6 versions
let f=x=&gt;x?(d(x),!1):!0
let f=x=&gt;x?(d(x),0):1
let f=x=&gt;!x&amp;&amp;d(x)&amp;0
if(f(v)){/* ... */}
</code></pre>
</div>
<div id="pu66" class="pu"><h2>Exception abusing</h2>
<p>in case string/character literals are prohibited, you can use a try catch block:</p>
<pre><code>try{something0}catch(e){str=e.message.split(0)[0]}
</code></pre>
<p>now <code>str</code> equals <code>&quot;something&quot;</code></p>
<p>if more strings are needed you can chain it with a number (e.g. zeros)</p>
<pre><code>try{something0foo0bar0}catch(e){arr=e.message.split(0)}
</code></pre>
<p>now <code>arr</code> equals <code>[&quot;something&quot;, &quot;foo&quot;, &quot;bar&quot;, &quot; is not defined&quot;]</code></p>
</div>
<div id="pu67" class="pu"><h1>Shorter random number generation</h1>

<p>If you need a random boolean (<code>0</code> or <code>1</code>):</p>

<pre><code>new Date&amp;1 // equivalent to Math.random()&lt;0.5
</code></pre>

<p>If you need a random integer <code>0 &lt;= n &lt; 1337</code>:</p>

<pre><code>new Date%1337 // equivalent to Math.floor(Math.random()*1337))
</code></pre>

<p>This works because a <code>Date</code> is stored internally in JavaScript as the amount of milliseconds since an epoch, so the <code>new Date</code> is being coerced into <code>123somebignumber456</code> when you try to do integer math on it.</p>

<p>Of course, these "random" numbers really won't be as random, especially if you call them multiple times in quick succession, so keep that in mind.</p>
</div>
<div id="pu68" class="pu"><p>For strings and arrays, instead of using <code>a=b.length&gt;a.length?b:a</code> to set <strong><code>a</code></strong> to <strong><code>b</code></strong> if <code>b.length &gt; a.length</code>, you can use <code>a=b[a.length]?b:a</code>.</p>

<p><strong>Note:</strong> If <strong><code>b</code></strong> is an array and contains either <strong><code>0</code></strong> or <strong><code>false</code></strong>, you'll have to use <code>a=b[a.length]!=null?b:a</code> (still one character shorter).</p>
</div>
<div id="pu69" class="pu"><p><strong>You can use <code>-~s</code> instead of <code>+s+1</code>, and <code>~-s</code> instead of <code>+s-1</code>,</strong> if <code>s</code> is a string or a number between <code>-(2^31)-1</code> and <code>2^31</code>.</p>
</div>
<div id="pu70" class="pu"><p>Instead of writing <code>true</code> you can use <code>!0</code>.</p>
</div>
<div id="pu71" class="pu"><p>In cases where you are using the ternary operator to chose between two <em>numbers</em>, and the conditional is either a <em>boolean</em> or <em>number</em> <code>1 or 0</code>, you can do math operations instead:</p>

<pre><code>(x ? num1 : num2) conclusions:

    1)if num1 equals num2, there ARE savings
    2)if num1 is (+1) or (-1) than num2, there ARE savings
    3)if either num1 or num2 equals to 0, there ARE savings
    4)it is MORE LIKELY to find greater savings on num1&gt;num2 instead of num1&lt;num2
    5)in method (*A) and (*B), savings are NOT GUARANTEED

    a)num1&gt;num2
        i)(num1==(num2+1))
            ex1: (x?5:4) to (x+4)
            ex2: (x?8:7) to (x+7)
        ii)num2==0
            ex1: (x?3:0) to (x*3)
            ex2: (x?7:0) to (x*7)
        iii)
            (*A) or (*B) //one might be shorter

    b)num1&lt;num2
        i)((num1+1)==num2)
            ex1: (x?4:5) to (5-x)
            ex2: (x?7:8) to (8-x)
        ii)num1==0
            ex1: (x?0:3) to (!x*3)
            ex2: (x?0:7) to (!x*7)
        iii)
            (*A) or (*B) //one might be shorter

    c)num1==num2
        i)
            ex1: (x?5:5) to (5)
            ex2: (x?-3:-3) to (-3)

    (*A) use ((x*(num1-num2))+num2)
        ex1: (x?8:4)   to ((x*4)+4)
        ex2: (x?4:8)   to ((x*-4)+8)

        ex3: (x?6:-4)  to ((x*10)-4)
        ex4: (x?-4:6)  to ((x*-10)+6)

        ex5: (x?4:-6)  to ((x*10)-6)
        ex6: (x?-6:4)  to ((x*-10)+4)

        ex7: (x?-5:-9) to ((x*4)-9)
        ex8: (x?-9:-5) to ((x*-4)-5)

    (*B) use ((!x*(num2-num1))+num1)
        ex1: (x?8:4)   to ((!x*-4)+8)
        ex2: (x?4:8)   to ((!x*4)+4)

        ex3: (x?6:-4)  to ((!x*-10)+6)
        ex4: (x?-4:6)  to ((!x*10)-4))

        ex5: (x?4:-6)  to ((!x*-10)+4)
        ex6: (x?-6:4)  to ((!x*10)-6)

        ex7: (x?-5:-9) to ((!x*-4)-5)
        ex8: (x?-9:-5) to ((!x*4)-9)
</code></pre>

<p><strong>Note:</strong> In addition to this, you will need to remove the unnecessary <code>0-</code>, <code>+0</code>, <code>+-</code> etc.</p>

<p><strong>Note2:</strong> there is an isolated case where <code>(x) !== (x?1:0)</code>, as <code>x</code> must be <code>typeof === "number"</code> for it to work. However, in the case of <code>(-x)</code> it works just fine.</p>

<p><strong>Note3:</strong> In case you don't find savings, simply use the former <code>(x?y:z)</code></p>

<p>Previously I thought method B couldn't ever beat A, however exceptions do exist:</p>

<pre><code>(x?97:100) //original

(-3*x+100)
(3*!x+97)
</code></pre>

<p>I created a <a href="https://github.com/ajax333221/Ternary-Optimizer" rel="noreferrer">github project</a> that makes the simplification for us (<a href="http://jsfiddle.net/Q7T2a/1/embedded/result/" rel="noreferrer"><strong>jsFiddle demo</strong></a>)</p>
</div>
<div id="pu72" class="pu"><p>Use <code>if(~a.indexOf(b))</code> instead of <code>if(a.indexOf(b)!=-1)</code></p>
</div>
<div id="pu73" class="pu"><p>Use Mozilla's nonstandard "expression closures" feature to save many characters in a script that only needs to work in the SpiderMonkey/Firefox or Rhino engines. For example,</p>

<pre><code>function foo(){return bar}
</code></pre>

<p>becomes</p>

<pre><code>function foo()bar
</code></pre>

<p>See the <a href="https://stackoverflow.com/questions/2350718/are-there-any-short-tricks-in-javascript-1-8-that-i-can-use-to-reduce-my-golf-s">Stack Overflow page</a> for more such tricks.</p>
</div>
<div id="pu74" class="pu"><p>Combine nested for loops:</p>

<pre><code>// before:
for(i=5;i--;)for(j=5;j--;)dosomething(i,j)

// after:
for(i=25;i--;)dosomething(0|i/5,i%5)
</code></pre>

<p>Example with different values for <code>i</code>/<code>j</code>:</p>

<pre><code>// before:
for(i=4;i--;)for(j=7;j--;)dosomething(i,j)

// after:
for(i=28;i--;)dosomething(0|i/7,i%7)
</code></pre>
</div>
<div id="pu75" class="pu"><p><strong>Looping Tip I</strong></p>

<p>You can save <code>1</code> character when looping by changing the <code>i</code> on the last time used:</p>

<pre><code>//not so god
for(i=0;i&lt;3;i++){
  alert(i);
}

//best
for(i=0;i&lt;3;){
  alert(i++);
}
</code></pre>

<p><strong>Note:</strong> works with <code>--</code> too (but modify the loop accordingly to avoid infinite looping)</p>

<hr>

<p><strong>Looping Tip II</strong></p>

<p>There are certain scenarios where you can save one character by playing with the incrementing operator and values:</p>

<pre><code>for(i=0;i++&lt;9;)
for(i=0;++i&lt;10;)
</code></pre>

<p><strong>Note:</strong> you need to pay attention when for example <code>0 to -1</code>. and <code>9 to 10, 99 to 100</code>, so play around until you find a way to save the character</p>
</div>
<div id="pu76" class="pu"><h3>Taking advantage of short-circuit operators</h3>

<p>Rather than long <code>if</code> statements or using ternary operators, you can make use of <code>&amp;&amp;</code> and <code>||</code> to shorten your code.  For instance:</p>

<pre><code>var match = RegExp('[?&amp;]' + name + '=([^&amp;]*)').exec(window.location.search);

return match ? decodeURIComponent(match[1].replace(/\+/g, ' ')) : null;
</code></pre>

<p>can become</p>

<pre><code>var match = RegExp('[?&amp;]' + name + '=([^&amp;]*)').exec(window.location.search);

return match &amp;&amp; decodeURIComponent(match[1].replace(/\+/g, ' '));
</code></pre>

<p>The <code>||</code> operator is often used in this way for setting defaults:</p>

<pre><code>evt = evt || window.event;
</code></pre>

<p>This is the same as writing </p>

<pre><code>if (!evt)
    evt = window.event;
</code></pre>

<h3>Creating repetitive strings using <em>Array</em></h3>

<p>If you want to initialize a long string of a particular character, you can do so by creating an array with a length of <em>n+1</em>, where <em>n</em> is the number of times you wish to repeat the character:</p>

<pre><code>// Create a string with 30 spaces
str = "                              ";

// or
str = Array(31).join(" ");
</code></pre>

<p>The larger the string, the bigger the saving.</p>

<h3>Parsing numbers</h3>

<p>Use <code>+</code> and <code>~</code> operators instead of <code>parseFloat()</code> or <code>parseInt()</code> when coalescing a string type that is <em>just a number</em> to a number type:</p>

<pre><code>var num = "12.6";
parseFloat(num) === +num;  // <em>+</em> is <b>10</b> characters shorter than <em>parseFloat()</em>

var num2 = "12"
parseInt(num2) === +num2;   // <em>+</em> is <b>8</b> characters shorter than <em>parseInt()</em>

var num3 = "12.6"
parseInt(num3) === ~~num3;  // <em>~~</em> is <b>7</b> characters shorter than <em>parseInt()</em>

var num4 = "12.6"
parseInt(num4) === num4|0;  // <em>|0</em> is <b>7</b> characters shorter than <em>parseInt()</em>
</code></pre>

<p>Be wary though, other types can be coalesced with these operators (for instance, <code>true</code> would become <code>1</code>) an empty string or a string containing just white space would become <code>0</code>.  This could be useful in certain circumstances, however.</p>
</div>
<div id="pu77" class="pu"><p>There's a few other ideas that come to mind:</p>

<p><strong>Ternary operators with functions</strong></p>

<p>Ternary operators also work well as a substitute for if..then..else statements with functions...</p>

<pre><code>if(a==b){
   c();
}else{
   if(a==d){
       e();f();
   }
   g();
}
</code></pre>

<p>can be replaced with </p>

<p><code>(a==b)?c():(((a==d)&amp;&amp;(e()|f()))|g())</code></p>

<p>You can take this further by abusing functions that don't take parameters:</p>

<p><code>a==b?c():g(a==d&amp;&amp;f(e()))</code></p>

<p>If <code>a</code>, <code>b</code>, and <code>d</code> are numbers, you can use subtraction to test for 0.</p>

<p><code>a-b?g(a-d||f(e())):c()</code></p>

<p><strong>Decimal Base Exponents</strong></p>

<p>Another is the reduction of decimal base exponents... for example <code>1000000</code> can be replaced with <code>1e6</code></p>
</div>
<div id="pu78" class="pu"><p><strong>How to compare a number with help of how numbers turn into booleans:</strong></p>

<p>If you are going to check if something is equal to a <em>positive number</em>, you can subtract that amount and reverse what was inside the <code>if</code> and <code>else</code> blocks:</p>

<pre><code>//simplified examples:
x==3?"y":"n"; &lt;- 13 Chars
x-3?"n":"y"; &lt;- 12 Chars

//expanded examples:
if(x==3){
    yes();
}else{
    no();
}

if(x-3){
    no();
}else{
    yes();
}
</code></pre>

<p>And in case you are wanting to compare with a <em>negative number</em> (*different than <code>-1</code>), you just simply need to <em>add</em> this number instead of subtracting.</p>

<p>*well, you can surely use <code>x.indexOf(y) + 1</code>, but in the special case of <code>-1</code> you have the opportunity to use <code>~x.indexOf(y)</code> instead.</p>
</div>
<div id="pu79" class="pu"><p>Something worth noting is that you can use a string in place of zero in some instances to save a couple of bytes here and there in loops:</p>

<pre><code>s='';for(i=0;i++&lt;9;)s+=i
for(i=s='';i++&lt;9;)s+=i
// s="123456789", i=10
</code></pre>
</div>
<div id="pu80" class="pu"><p>If you can accept Spidermonkey (for now) specific scripts, you can use <a href="http://wiki.ecmascript.org/doku.php?id=harmony%3aarrow_function_syntax">ECMAScript 6 arrow functions</a>. Insteading of writing code like the following.</p>

<pre><code>a.map(function(x){return x*2}) // function? return?
</code></pre>

<p>You can shorten it like this.</p>

<pre><code>a.map(x=&gt;x*2)
</code></pre>
</div>
<div id="pu81" class="pu"><p><a href="https://github.com/jed/140bytes/wiki/Byte-saving-techniques#split-using-0">Splitting with numbers to save the quotemarks:</a></p>

<pre><code>"alpha,bravo,charlie".split(",") // before
"alpha0bravo0charlie".split(0)   // after
</code></pre>
</div>
<div id="pu82" class="pu"><p><strong>Less/Greater than "10/100/1000..." vs "9/99/999...":</strong></p>

<pre><code>//for(i=0;i&lt;20;i++){
    if(i&lt;10){}else{}
    if(i&gt;9){}else{}
//}
</code></pre>

<p><strong>Note:</strong> Just remember to swap what is inside the <code>if</code> with the <code>else</code></p>
</div>
<div id="pu83" class="pu"><p>Some extra tricks that I don't see very often, that are more JS-specific:</p>

<ul>
<li><p>Use array literals and indexing as a sort of <code>switch</code> as an expression.  You can leave out "unnecessary" elements and they'll default to <code>undefined</code> (which is a falsy value, by the way).  E.g. <code>[,1,,-1][i%4]</code> would evaluate to either 1 or -1 depending on whether i is 1,5,9,13,... or 3,7,11,15,... (and we don't care about the other cases).</p></li>
<li><p>Similarly, use object literals when you want arbitrary strings for the keys.</p></li>
<li><p>This one is common to all C-style languages: (ab)use the fact that that <code>&amp;</code> and <code>|</code> works just as well as <code>&amp;&amp;</code> and <code>||</code> with boolean values, albeit with different precedence.  Keep in mind that the single-character variants aren't short-circuiting though!</p></li>
<li><p><code>-~x</code> is the same as <code>x+1</code>, and <code>~-x</code> is the same as <code>x-1</code>.  Sometimes the {bitwise,arithmetic} negation variants are useful to avoid extra parens; for instance, <code>4*~-n</code> rather than <code>4*(n-1)</code>.</p></li>
<li><p><code>~9</code> could be used as a two-character literal for the value <code>-10</code> (I've never had a use for this, but it's a fun curiosity).</p></li>
</ul>
</div>
<div id="pu84" class="pu"><p>Treat strings like you do C Strings.</p>

<p>Given <code>s="hello"</code></p>

<pre><code>s[0]
</code></pre>

<p>is equivalent to</p>

<pre><code>s.charAt(0)
</code></pre>

<p>and</p>

<pre><code>s.split("")[0]
</code></pre>
</div>
<div id="pu85" class="pu"><p>If you're initializing a variable to <code>1</code> in every iteration of a loop (for example, resetting a variable in an outer loop for an inner loop), like the following (from <a href="https://codegolf.stackexchange.com/questions/4630/finding-not-quite-prime-numbers/4632#answer-4632">my answer to this question</a>):</p>

<pre><code>for(j=n-2;p=1,j++&lt;=n;r|=p)for(i=1;++i&lt;j;)p=j%i?p:0;
          ^^^^
</code></pre>

<p>Since the result of a condition like <code>j++&lt;=n</code> is <code>1</code> whenever its true, you can just assign the condition directly to the variable (because when it becomes false, the loop will stop executing and will no longer matter):</p>

<pre><code>for(j=n-2;p=j++&lt;=n;r|=p)for(i=1;++i&lt;j;)p=j%i?p:0;
          ^^^^^^^^
</code></pre>

<p>You can usually <strong>save 2 characters</strong> using this method.  Regards to <code>@ugoren</code> for the idea in the comments to that answer.</p>

<hr>

<p>For another example, I also applied this trick to <a href="https://codegolf.stackexchange.com/questions/4665/find-columns-where-all-characters-are-the-same/4669#4669">my answer here</a> with the expression <code>w=r=++c&lt;S.length</code> in my outer for loop, saving a total of 4 characters.</p>
</div>
<div id="pu86" class="pu"><p>Use the comma operator to avoid braces (also <a href="https://codegolf.stackexchange.com/questions/2203/tips-for-golfing-in-c">applies to C</a>):</p>

<pre><code>if(i&lt;10)m+=5,n-=3;
</code></pre>

<p>Instead of</p>

<pre><code>if(i&lt;10){m+=5;n-=3}
</code></pre>

<p>which is one character longer.</p>
</div>
<div id="pu87" class="pu"><p>This one is lesser known and lesser used, but can be impressive if used in the right situation.  Consider a function that takes no arguments and always returns a different number when called, and the returned number will be used in a calculation:</p>

<pre><code>var a = [ 
    Math.random()*12|0,
    Math.random()*11|0,
    Math.random()*10|0,
    /* etc... */ 
];
</code></pre>

<p>You might normally shorten this function using a single-letter variable name:</p>

<pre><code>var r=Math.random,a=[r()*12|0,r()*11|0,r()*10|0,r()*9|0,r()*8|0,r()*7|0,r()*6|0,r()*5|0];
</code></pre>

<p>A better way to reduce the length is by abusing <code>valueOf</code>, which gives you a saving of 2 characters per invocation. Useful if you call the function more than 5 times:</p>

<pre><code>var r={valueOf:Math.random},a=[r*12|0,r*11|0,r*10|0,r*9|0r*8|0,r*7|0,r*6|0,r*5|0];
</code></pre>
</div>
<div id="pu88" class="pu"><p>You can use the object literal form of get/set to avoid using the keyword <code>function</code>.</p>

<pre><code>var obj = {
  get f(){
    console.log("just accessing this variable runs this code");
    return "this is actually a function";
  },
  set f(v){
    console.log("you can do whatever you want in here, passed: " + v);
  }
};

1 &amp;&amp; obj.f; // runs obj.[[get f]]
obj.f = Infinity; // runs obj.[[set f]](Infinity)
</code></pre>
</div>
<div id="pu89" class="pu"><p>Sometimes declaring a variable (or more) as function parameters can save some strokes by avoiding the <code>var</code> keyword. This use case is fairly rare though:</p>

<p><code>function f(){var i}</code> => <code>function f(i){}</code></p>

<p>Also you can use short circuit operators to avoid if statements:</p>

<p><code>if(a)b</code> => <code>a&amp;&amp;b</code></p>

<p><code>if(!a)b</code> => <code>a||b</code></p>

<p>To coerce to a number: <code>str-0</code></p>
</div>
<div id="pu90" class="pu"><p>Another thing I came across is forcing a multidimensional array into a single-dimensional array like this:</p>

<pre><code>[[1,2],[3,4]].join().split(",") // ["1", "2", "3", "4"]
</code></pre>

<p>It does convert everything into strings, so basically only numbers/strings are possible, but it can come in handy. Calculating with strings automatically converts it into numbers anyway.</p>

<p><strong>EDIT:</strong> As Austin Hyde pointed out, you can flatten one level like this:</p>

<pre><code>[].concat.apply([],[[1,2],[3,4]])
</code></pre>

<p>Although it only takes it down one level, the data types remain.</p>
</div>
<div id="pu91" class="pu"><p>for a given array, we know a <code>for..in</code> loop might lead to errors because stuff might
be added to the Array.Prototype, so we revert to a normal <code>for</code> loop:</p>

<p><strong>So instead of this iteration:</strong></p>

<pre><code>for (var i=0; i&lt;arr.length; i++ )
</code></pre>

<p><strong>lets do this:</strong>   </p>

<pre><code>for (var i=arr.length; i--; )
</code></pre>

<p>if we just want to iterate the Array not caring it goes backwards</p>
</div>
<div id="pu92" class="pu"><p>Converting a <code>while</code> loop into a <code>for</code> loop is often equivalent:</p>

<pre><code>while(i--);
for(;i--;);
</code></pre>

<p>But the second form can have variable initialization combined:</p>

<pre><code>i=10;while(i--);
for(i=10;i--;);
</code></pre>

<p>Notice the second form is one character shorter than the first form.</p>
</div>
<div id="pu93" class="pu"><p>Use a bitwise operation to round a number toward zero:</p>

<pre><code>// do this
T=Math.random()*6+1|0

// or do this
T=~~(Math.random()*6+1)
</code></pre>

<p>(Source: <a href="https://codegolf.stackexchange.com/questions/958/random-dice-tipping/959#959">Random dice tipping</a>)</p>

<p><a href="https://developer.mozilla.org/en/JavaScript/Reference/Operators/Operator_Precedence" rel="nofollow noreferrer">Operator precedence</a> determines which will be shorter in your program.</p>
</div>
<div id="pu94" class="pu"><p>Initialize arrays with <code>[]</code> instead of <code>Array()</code>, and add to arrays with <code>[.length]</code>:</p>

<pre><code>a=[];       // initialize a new array
a[0]=15;    // insert element to end of array
a[1]=30;    // insert another element to end of array
</code></pre>
</div>
<div id="pu95" class="pu"><p>Sneak variable initialization into the prompt() call for getting user input</p>

<pre><code>n=prompt(i=5);     // sets i=5 at the same time as getting user input
</code></pre>

<p>instead of using</p>

<pre><code>n=prompt();i=5;
</code></pre>

<p>As a side-effect, it displays the input value in the prompt window while saving 1 character.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/2682/">2682</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




