<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::206609</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>253</td><td>Python</td><td>240430T161349Z</td><td><a href="https://codegolf.stackexchange.com/questions/206609/identify-the-smallest-possible-tile-in-the-matrix/272901#272901">Ajax1234</a></td></tr>
<tr d-ix="1"><td>195</td><td>J</td><td>200702T123506Z</td><td><a href="https://codegolf.stackexchange.com/questions/206609/identify-the-smallest-possible-tile-in-the-matrix/206664#206664">xash</a></td></tr>
<tr d-ix="2"><td>342</td><td>JavaScript ES6</td><td>200701T135925Z</td><td><a href="https://codegolf.stackexchange.com/questions/206609/identify-the-smallest-possible-tile-in-the-matrix/206630#206630">Arnauld</a></td></tr>
<tr d-ix="3"><td>173</td><td>APL Dyalog Unicode</td><td>200701T174345Z</td><td><a href="https://codegolf.stackexchange.com/questions/206609/identify-the-smallest-possible-tile-in-the-matrix/206640#206640">fireflam</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://www.python.org" rel="nofollow noreferrer">Python</a>, 253 bytes</h1>
<pre class="lang-python prettyprint-override"><code>from math import*
R=range
def C(b):
 d={}
 for i in b:
  for j in i:d[j]=d.get(j,0)+1
 return d
def f(b):
 d=C(b)
 K={i:int(d[i]/gcd(*d.values()))for i in d}
 for x in R(len(b)):
  for y in R(len(b[0])):
   if C(T:=[j[:y+1]for j in b[:x+1]])==K:return T
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=jVPLToNAFE3cOV9x002HttYO0IckrFw2cdG4Q2KoA-00LZBhato0fombbvSf9F9MvDNQxKQxhszAuXPOuYcbeH3P92qZpcfj21YlV5OPr0RmG9hEaglik2dSdcjMl1G6iAmPE7ilc8sjwP3DC4EkkyBApDDHkkErjYTHg1Xo8_4iVnTVG1hdRkDGaitT4MYlObloOwJT_yA8kSrKAxFeL5447fD-c7TexgW1LKtuw6ueOw1mdB2nKLdOvfeNajAIywMQOvO95werwNt3WVinnAfeDnFo-f7Uq9Ldl0P4vBjrlCp7nGeR5JSj1WVFCYLOJsoppu2B6Bf5WijMGP7MIhFrFUt6l6VxD3jFaD-kbWSRgoEPrVaLDICBDQ64ZAgjGMMEbv5d0_pc6nkltM5YMJwUKezKn6GO_drPq2yjcmoV9iIuYC_yVy_HqNymClzsYZS4bKJ3F58d4uApw_NRxbNhWPEYvtV5f9f4D-tZmcvMAlcDl3dTbeDznkPjOWpkLlc5nxLZxFRKZDgVi9gNznn_kfYvv5_Tz_QN" rel="nofollow noreferrer">Attempt This Online!</a></p>
</div>
<div id="pu1" class="pu"><h1><a href="http://jsoftware.com/" rel="nofollow noreferrer">J</a>, 195 bytes</h1>
<p>A bit long, but blazing fast! There should be some micro-optimizations still left, but I believe there could be an overall better strategy, maybe one without boxes.</p>
<pre><code>((]&gt;@{.@\:[:&gt;./@(*i.@#)[:(#*0*/@,@:=])&amp;&gt;]([:(~.@#~0,@:=(_&amp;e.&amp;,+0+/@,@:&gt;])&quot;2)[:,/|:@|.^:(&lt;4)@[(-~%2*/@,@:&gt;[+&amp;*-~)/@,:&quot;2/(|.~*{.@#&amp;(,/)(#:i.)@$)&quot;2@])&amp;.&gt;^:(&lt;_)&lt;@,:@[)[:(/:*/@:$&amp;&gt;)[:,/&lt;@|:\@|:\)&amp;.:&gt;:
</code></pre>
<p><a href="https://tio.run/##jY/BTsMwDIbveQqrHZndtWmadQO8LYqExIkT1670xKTxClR99eKmOwyJAYqc5re//rY/xsQsT3BgWEIOFliiMPD0@vI8IrY@fJpw5Ia9KQNmZxNSahjTzGZlyAMfWtK@RUkNUhrslMJOvxudr@wqIr6lxMlPedlz6M0b476m0GAx3LnZxDcrnRUDieDEldibIZO2qca8JEz5bCgsxCRIM@Mng472woZmmqVkceGF9rHHPvR8nEJQ9jzSiLsTgdWJ2ZnOAcYVSVmowMEaarWBLdzDAzz@O0fqZ89K2OrbfZsUT1WDeKq/PGN38Yq0hFPTXct7rdZSraS@vXAONheukolveVqIJ@4mcaXnb8xeaVK/DDfHvPCsnIqZWUXmQil3xdAX" rel="nofollow noreferrer" title="J – Try It Online">Try it online!</a></p>
<h3>How it works</h3>
<pre><code>&amp;.:&gt;:
</code></pre>
<p>Add 1 to the matrix, so we can use 0 as a special value.</p>
<pre><code>[:,/&lt;@|:\@|:\
</code></pre>
<p>Get all possible tiles that contain the upper left digit.</p>
<pre><code>[:(/:*/@:$&amp;&gt;)
</code></pre>
<p>Sort them according to their dimension.</p>
<pre><code>](…)&amp;.&gt;^:(&lt;_)&lt;@,:@[
</code></pre>
<p>Use the initial matrix as seed, and execute – with the possible tiles on the left side – until the result does not change, while storing the results:</p>
<pre><code>(|.~*{.@#&amp;(,/)(#:i.)@$)&quot;2@]
</code></pre>
<p>Shift the matrices so the first non-zero digit is in the upper left.</p>
<pre><code>|:@|.^:(&lt;4)@[
</code></pre>
<p>On the left side, rotate all the tiles.</p>
<pre><code>(-~%2*/@,@:&gt;[+&amp;*-~)/@,:&quot;2/
</code></pre>
<p>For each tile and each matrix, pad the tile and matrix to the same size (<code>/@,:&quot;2</code>). The final result will be the subtraction, but we'll do some checks here by setting faulty results to infinity. With this we later don't have to keep track which tile produced which result. We add the signum of the tile and the matrix, then everything should be 1 (or 0, if the rotated tile stuck out and we added some 0 with padding. But it these cases, as every tile is &gt;0, we'll have some negative numbers there.) We divide the subtraction by this check and it's either the original number or infinity.</p>
<pre><code>(_&amp;e.&amp;,+0+/@,@:&gt;])&quot;2
</code></pre>
<p>We check if there is infinity in a matrix or a value below 0.</p>
<pre><code>[:(~.@#~0,@:=(…)
</code></pre>
<p>And filter these out. The <code>~.</code> is not necessary, but it reduces duplicates and speeds things quite a lot in the <code>1 1 1,1 1 1,1 1 1</code> cases.</p>
<pre><code>[:(#*0*/@,@:=])&amp;&gt;
</code></pre>
<p>After the function's result does not change anymore, we have a matrix where each column represents a tile, and each row contains the possible placements for N tiles. We're interested in placements that result in a matrix filled with 0, so we check for them. We now have something like</p>
<pre><code>0 0 0 0 0 0 0 0 0  0 tiles
0 0 0 0 0 0 0 0 1  1 tiles (the right-most tile is the whole matrix)
0 0 1 0 0 0 1 0 0  2 tiles
</code></pre>
<hr />
<pre><code>[:&gt;./@(*i.@#)
</code></pre>
<p>We multiple each row with its index and reduce them, so we get for example <code>0 0 2 0 0 0 2 0 1</code>.</p>
<pre><code> &gt;@{.@\:
</code></pre>
<p>Using this as an index we sort the tiles, take the first one, unpack it and with the decrement we have the final tile.</p>
</div>
<div id="pu2" class="pu"><h1>JavaScript (ES6), <s> 354 352 345 </s> 342 bytes</h1>
<p>I/O: matrix of integers.</p>
<p>This is quite long but pretty fast -- at least with those test cases.</p>

<pre class="lang-javascript prettyprint-override"><code>m=&gt;m[b=P='map']((r,h)=&gt;r[P]((_,w)=&gt;(M=m.slice(~h)[P](r=&gt;r.slice(~w)),a=~w*~h,g=(x,y,F)=&gt;a&gt;b|q.some((r,Y)=&gt;r.some((v,X)=&gt;~v?v^m[Y][X]:![x=X,y=Y]))?0:1/y?[...P+0][P](z=&gt;(F=k=&gt;!M[P]((r,Y)=&gt;r[P]((v,X)=&gt;k^1?q[y-Y][x-X]=v|k:(z|=~(q[y-X]||0)[x-Y],T[X]=T[X]||[])[Y]=v),T=[]))(1)&amp;T.reverse(M=T)|z||g(F())|F(-1)):(o=M,b=a))(q=m[P](r=&gt;r[P](_=&gt;-1)))))&amp;&amp;o
</code></pre>
<p><a href="https://tio.run/##jZFNc9owEIbv@hXKBbSNcDGQtGVmzanc6DATDjCOkzFEgAO2QSbmYzT8dbKWTUNvNSNp991H767Ne5iH2UxHm10jSd/UZY6XGL3Yn@IQ63G4qQdCaLkE9LQ/pPhV7ikWA4ydbB3NlDgvoShoAq7KHkCGeN5/Oy/lAsVBHmWfLoXe1GydLI1VYTkBe8NmuRxTds57@UvsTwJ/HHTv/AOO5REnAUCv2XW/H3u@4zjD@2ZQtDvRDH1coXc3sGNVfjYu3VYvbm/rHxtkd2iMA8zNqitOBs@iUMeBMU2gyiSQI@qHxWaMHwD1xxzkCCkG4UJt5GiVK50peukRmJMxC9EXAKYvGi5AV6Q4kFMMid5ifP0WxfmKXkHQU6ulF622H5FWoj7P6kCe4Vs/WqunYzITTXB26dNOR8lCgJNt1tFO1J@T54TAeap/h7OlyDh6jPNZmmTpWjnrdCHmIvuCCaW/S2jCuL7KvFL/fMRTpWmQW@Y9jRKLQBUWJvye25PBpcld3uJt3mEP/JH/4D/5L/a/GnNJdP/ZmaVYhxPF/lL2IlWtTKvFir1DcZu1qepS/bHiWvyh4lxqRn3tz/andZOXp1VvcutSrnKmMmsxq5SZZSqKtb6YTw" rel="nofollow noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a></p>
<h3>How?</h3>
<p>Whatever the tiling is, it is guaranteed that each corner of the matrix is also a corner of the tile that we're looking for. The two outer <code>map()</code> loops extract each possible tile <span class="math-container">\$M\$</span> from the bottom-right side of the input matrix <span class="math-container">\$m\$</span> and compute its area <span class="math-container">\$a\$</span>.</p>
<pre class="lang-javascript prettyprint-override"><code>m.map((r, h) =&gt;           // for each row r[] at position h in m[]:
  r.map((_, w) =&gt;         //   for each value at position w in r[]:
    (                     //
      M =                 //     build M[]:
        m.slice(~h)       //       keep the last h + 1 rows of m[]
        .map(r =&gt;         //       for each of them:
          r.slice(~w)     //         keep the last w + 1 columns
        ),                //
      a = ~w * ~h,        //     area = (w + 1) * (h + 1)
      ...                 //     attempt to do a tiling with M
    )                     //
  )                       //   end of map()
)                         // end of map()
</code></pre>
<p>We build a matrix <span class="math-container">\$q\$</span> with the same dimensions as <span class="math-container">\$m\$</span>, initially filled with <span class="math-container">\$-1\$</span>.</p>
<pre class="lang-javascript prettyprint-override"><code>q = m.map(r =&gt; r.map(_ =&gt; -1))
</code></pre>
<p>At each iteration of the recursive function <span class="math-container">\$g\$</span>, we look for the position <span class="math-container">\$(x,y)\$</span> of the last cell in <span class="math-container">\$q\$</span> still set to <span class="math-container">\$-1\$</span>, going from left to right and from top to bottom.</p>
<p>By definition, this cell has either a cell already set or a border on its right, and ditto below it. So it must be the bottom-right corner of a new tile, such as the cell marked with an 'x' below:</p>
<p><a href="https://i.stack.imgur.com/WQGXD.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/WQGXD.png" alt="matrix" /></a></p>
<p>Simultaneously, we test whether there's a cell in <span class="math-container">\$q\$</span> whose value is not <span class="math-container">\$-1\$</span> and is different from the value in <span class="math-container">\$m\$</span> at the same position. If such a tile is found, we abort the recursion.</p>
<pre class="lang-javascript prettyprint-override"><code>q.some((r, Y) =&gt;          // for each row r[] at position Y in q[]:
  r.some((v, X) =&gt;        //   for each value v at position X in r[]:
    ~v ?                  //     if v is not equal to -1:
      v ^ m[Y][X]         //       abort if v is not equal to M[Y][X]
    :                     //     else:
      ![x = X, y = Y]     //       set (x, y) = (X, Y)
  )                       //   end of some()
)                         // end of some()
</code></pre>
<p>If all cells of <span class="math-container">\$q\$</span> are matching the cells of <span class="math-container">\$m\$</span> and the area of <span class="math-container">\$M\$</span> is less than (or equal to) the best area found so far, we update the output <span class="math-container">\$o\$</span> to <span class="math-container">\$M\$</span>.</p>
<p>Otherwise, we invoke the following code 4 times:</p>
<pre class="lang-javascript prettyprint-override"><code>F(1) &amp; T.reverse(M = T) | z || g(F()) | F(-1)
</code></pre>
<p>The behavior of the helper function <span class="math-container">\$F\$</span> depends on the parameter <span class="math-container">\$k\$</span>:</p>
<ul>
<li>If <span class="math-container">\$k=1\$</span>, it computes the transpose <span class="math-container">\$T\$</span> of <span class="math-container">\$M\$</span> and checks whether all cells in <span class="math-container">\$q\$</span> between <span class="math-container">\$(x-w,y-h)\$</span> and <span class="math-container">\$(x,y)\$</span> are set to <span class="math-container">\$-1\$</span>. The result of this test is saved in <span class="math-container">\$z\$</span>.</li>
<li>If <span class="math-container">\$k\$</span> is undefined, it copies the content of <span class="math-container">\$M\$</span> to <span class="math-container">\$q\$</span> at <span class="math-container">\$(x-w,y-h)\$</span>.</li>
<li>If <span class="math-container">\$k=-1\$</span>, it cancels the previous operation by restoring all updated values to <span class="math-container">\$-1\$</span>.</li>
</ul>
<p>It is defined as follows:</p>
<pre class="lang-javascript prettyprint-override"><code>F = k =&gt;                  // k = parameter
  !M.map((r, Y) =&gt;        // for each row r[] at position Y in M[]:
    r.map((v, X) =&gt;       //   for each value v at position X in r[]:
      k ^ 1 ?             //     if k is not equal to 1:
        q[y - Y][x - X] = //       set q[y - Y][x - X]
          v | k           //       to v if k is undefined, or -1 if k = -1
      :                   //     else:
        ( z |=            //       update z:
            ~( q[y - X]   //         read q at (x - Y, y - X)
              || 0        //
            )[x - Y],     //         set z if it's not equal to -1
          T[X] =          //       compute T by writing v at the
            T[X] || []    //       relevant position
        )[Y] = v          //
    ),                    //   end of inner map()
    T = []                //   initialize T to an empty array
  )                       // end of outer map()
</code></pre>
<p>Therefore, the code block mentioned above can be interpreted as follows:</p>
<pre class="lang-javascript prettyprint-override"><code>F(1)                      // compute the transpose T[] of M[] and test whether
&amp;                         // M[] can be copied at (x-w, y-h) in q[]
T.reverse(M = T)          // reverse T[] and assign it to M[], which means
|                         // that M[] has been rotated 90° counterclockwise
z ||                      // if z = 0:
  g(F()) |                //   copy M[] to q[] and do a recursive call
  F(-1)                   //   restore q[] to its previous state
</code></pre>
</div>
<div id="pu3" class="pu"><h1><a href="https://www.dyalog.com/" rel="nofollow noreferrer">APL (Dyalog Unicode)</a>, <s>189</s> 173 bytes</h1>

<pre class="lang-apl prettyprint-override"><code>{{A[⍵]⍴⍨⊃⌽⍵}{{⊃⍵[⊃⍋⍴¨⍵]},↑⍵[⍸(~0∊∊)¨⍵]}{⊃((×/⍵)÷⍨⍴,A){⍺≤1:⊂¨↓⍵⋄R←⍵∇⍨⍺-1⋄,{0&lt;≢R:⍵[⍸{((⊢≡∪)⊃,/⍵)∧((1≡⊃∘⍴∘∪)¨↓{A[⍵]}¨⍵)}¨⍵]⋄⍬}R∘.(,∘⊂)↓⍵}⊃⍪/{(,⍳1-⍵-⍴A)∘.+,¯1+⍳⍵}¨⍵(⌽⍵)}¨,⍳⍴A←⍵}
</code></pre>
<p><a href="https://tio.run/##7VE9S8RAEO39FdPdLtnzEuOdetjkL6Q9LA5EmwNtZYmFHjEfrigi2iqCEgQLExTB5u6fzB@JM5soBzY2dkLYnZ33Zt6byXh/0t0@GE/2dutaa4HZMZ5@oKkkmjIYUbAVac1ZU43slRMwe7SAwvjC5s2bPnQxyfgzVdTCXCbE/LrH7eavaChdqkBqNO@Y3ntDzI6IGl8Sjvk0xPhcCMK6nsTkxHrIp0q7m5jehcMvIaGZnt5iUrAWaSgrgMmDEB4D5DK5ISk@k0JaCd3OYq3J1iG1R/MUhURcZlOKDNme1lIkmrmLnhYKzQt7KwPpeF1uIbnIUbNnzyHse2rRbi9qZZQFy4BmY069Q4HGsyu6OtBhAzb@3/xfb76Z9OfmKaa/As2DtjqAPlW54MEK@LAKfRjAGqzDxtICyQefSL@mLJz1Jw" rel="nofollow noreferrer" title="APL (Dyalog Unicode) – Try It Online">Try it online!</a></p>
<p>Slow when there are few distinct values in the grid (can't eliminate possibilities quickly).</p>
<p>Enumerates all possible rectangles (not many), then tries adding one at a time, checking for overlap and equal elements.</p>
<p><strong>Explanation</strong></p>
<pre class="lang-apl prettyprint-override"><code>⍳⍴A←⍵    ⍝ Set A to be the given matrix, and generate all dimensions of smaller rectangles
¨,       ⍝ For each smaller dimension (e.g. 5 4):
¨⍵(⌽⍵)     ⍝ Apply the following for both the dimension and its transpose:
  {(,⍳1-⍵-⍴A)∘.+,¯1+⍳⍵}  ⍝ Get all possible vectors of the indices of each cell in each possible translated submatrix
  
  ((×/⍵)÷⍨⍴,A)     ⍝ The number of these matrices needed to get the right area to tile the grid
  {⍺≤1:...∇⍺-1⋄⍬}  ⍝ Repeat that many times, starting with ⍬ (empty vector):
    R←⍵∇⍨⍺-1       ⍝ Take R to be the result of the previous step
    R∘.(,∘⊂)↓⍵}⊃⍪/ ⍝ Add to R all possible existing submatrix sequences
    ⍵[⍸...]        ⍝ Filter for those that:
     ((⊢≡∪)⊃,/⍵)   ⍝ Have no overlapping tiles and
     ((1≡⊃∘⍴∘∪)¨↓{A[⍵]}¨⍵)  ⍝ Consist of the same sequence of entries
  {⊃⍵[⊃⍋⍴¨⍵]}  ⍝ Get the first possibility, sorted by area
{A[⍵]⍴⍨⊃⌽⍵}  ⍝ Get the corresponding elements from the original matrix, and correct the shape
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/206609/">206609</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




