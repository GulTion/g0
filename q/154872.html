<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::154872</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>135</td><td>Tamsin</td><td>240219T154628Z</td><td><a href="https://codegolf.stackexchange.com/questions/154872/panfix-to-parenthesized-infix/270158#270158">Mukundan</a></td></tr>
<tr d-ix="1"><td>134</td><td>Retina 0.8.2</td><td>180205T014506Z</td><td><a href="https://codegolf.stackexchange.com/questions/154872/panfix-to-parenthesized-infix/154891#154891">Neil</a></td></tr>
<tr d-ix="2"><td>226</td><td>Python 3</td><td>180211T230027Z</td><td><a href="https://codegolf.stackexchange.com/questions/154872/panfix-to-parenthesized-infix/155530#155530">R. Kap</a></td></tr>
<tr d-ix="3"><td>166</td><td>Haskell</td><td>180205T125211Z</td><td><a href="https://codegolf.stackexchange.com/questions/154872/panfix-to-parenthesized-infix/154921#154921">Laikoni</a></td></tr>
<tr d-ix="4"><td>163</td><td>Prolog SWI</td><td>180206T033725Z</td><td><a href="https://codegolf.stackexchange.com/questions/154872/panfix-to-parenthesized-infix/154983#154983">DLosc</a></td></tr>
<tr d-ix="5"><td>189</td><td>Clean</td><td>180205T102413Z</td><td><a href="https://codegolf.stackexchange.com/questions/154872/panfix-to-parenthesized-infix/154901#154901">Οurous</a></td></tr>
<tr d-ix="6"><td>050</td><td>Perl</td><td>180204T231922Z</td><td><a href="https://codegolf.stackexchange.com/questions/154872/panfix-to-parenthesized-infix/154883#154883">Ton Hosp</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://github.com/catseye/Tamsin" rel="nofollow noreferrer">Tamsin</a>, 135 bytes</h1>
<pre><code>e=&quot;_&quot;|o-&gt;O&amp;{!(e&amp;m(O)&amp;e&amp;m(O))&amp;o-&gt;E&amp;O&lt;-[O,E]}&amp;e-&gt;L&amp;m(O)&amp;e-&gt;R&amp;m(O)-&gt;O&amp;'('+L+O+R+')'.o=&quot;+&quot;|&quot;*&quot;.m([X,Y])=m(X)-&gt;X&amp;&lt;&lt;Y&gt;&gt;-&gt;Y&amp;''+X+Y.m(X)=&lt;&lt;X&gt;&gt;.
</code></pre>
<p><a href="https://tio.run/##TY0xb8MgEIV3/4oLkQBzwa0622zZIiFlspVGiCYMVgWuYjJUSX67i0nTRnrHfXr3jovWj32YJtcQQ66DVJpeFtxRz3VJ762kyV5TXcudXq33N@qk2vwGpNpmmvcYZ7hBjVtkJauGhiC5EkEqz3ftqtuXjedtCra0rjulpOooY9hiV81@U9etUtXkbR@ggYsDqUADha9TH2ImviDvgSSw4bt8YSzRbNxSZ6yaUKDJQjRPXAghTFaqIo0MFigec/FXWQKLJaRlcf8CnwL/DgIs4TB470J0R/hwB3seHfQRov10I9jTcA5HeHsdi8dpk@@n5wc" rel="nofollow noreferrer" title="Tamsin – Try It Online">Try it online!</a></p>
</div>
<div id="pu1" class="pu"><h1><a href="https://github.com/m-ender/retina/wiki/The-Language/a950ad7d925ec9316e3e2fb2cf5d49fd15d23e3d" rel="nofollow noreferrer">Retina 0.8.2</a>, <s>138</s> 134 bytes</h1>
<pre><code>.+
($&amp;)
+`\((\d+)(_|((?&lt;i&gt;(?&lt;i&gt;\d+))|_(?&lt;-i&gt;\k&lt;i&gt;)+)+(?(i)$.))\1(_|((?&lt;i&gt;(?&lt;i&gt;\d+))|_(?&lt;-i&gt;\k&lt;i&gt;)+)+(?(i)$.))\1\)
(($2)$1($4))
\(_\)
_
</code></pre>
<p><a href="https://tio.run/##lU7LCsJADLznOxaZJFioeBT7Ez0uZIV6KIIH8dh/X5O1VG8izOQxE3bncX3O90sdi0qZaqeEtGPSkoE8KcMWYDjN51ZC4cV83vtyc4WVFQNmTh1z7v88z0xAOnDqkY7MlGEumaeZPE9VUWtQta@ZRMQanOSWuaThiDeJQePyp0KxvF@VjQ0SXny5crM/SsSwFRHFyws" rel="nofollow noreferrer" title="Retina 0.8.2 – Try It Online">Try it online!</a> Link includes the faster test cases. Explanation: The regex engine uses backtracking to split the string up into tokens which are then pushed on or popped from the <code>i</code> balancing group. There is a run of always at least one operator pushed at the start before the first variable. After a variable, at least one operator is popped, at which point either a pushed operator run or another variable is legal. Operators get pushed to the group in duplicate so that they can be popped correctly. Example:</p>
<pre><code>Input           Stack
Push *          * *
Push *++*+***   * * *++*+*** *++*+***
Push +          * * *++*+*** *++*+*** + +
Push +          * * *++*+*** *++*+*** + + + +
Variable _
Pop +           * * *++*+*** *++*+*** + + +
Variable _
Pop +           * * *++*+*** *++*+*** + +
Pop +           * * *++*+*** *++*+*** +
Variable _
Pop +           * * *++*+*** *++*+***
Pop *++*+***    * * *++*+***
Variable _
Pop *++*+***    * *
Pop *           *
Push *          * * *
Variable _
Pop *           * *
Push *          * * * *
Variable _
Pop *           * * *
Variable _
Pop *           * *
Pop *           *
Pop *
</code></pre>
<p>Unfortunately this doesn't help us capture the results in order to bracket them, so the outer operator is matched manually. The brackets are added outside-in, so the first stage wraps the entire expression in brackets and the last stage removes them now that they have propagated down to the variables.</p>
</div>
<div id="pu2" class="pu"><h1>Python 3, 226 bytes</h1>



<pre class="lang-python prettyprint-override"><code>from re import*
P=r'([*+]+)'+r'(\(.+?\)|_)\1'*2;R=lambda i,J=lambda i,o:i[:o]+sub(P,lambda o:'('+o[2]+o[1]+o[3]+')',i[o:],1),s=search:s(P,i)and R([J(i,o)for o in range(len(i))if s(P,J(i,o))or J(i,o)[0]+J(i,o)[-1]=='()'][0])or i
</code></pre>

<p>Defines an anonymous function named <code>R</code>.</p>

<p><a href="https://tio.run/##RY9Ba8MwDIXv@xW@SbLdsbQ3j7B7TyVXxxR3TVpBYwUnPQz23zOHBgbi6fH49EDjz3yXdFiWPsugcqd4GCXP@u1UA3ptgiEwGbDFd/PV0u@Z2gr0/rOpH3G4XKNie/y34tg7CWZ6XvBkt1gcIBjx@1CkWuUQDBBY9uKCrchO9dTF/H13U7liiumqGvRHLIXUS1aiOKkc063DR5eQibhXK/tCqCAv5z@C2dyuCnV5gSCUcCV4GTOnGRsErc/bFFkXEC1/" rel="nofollow noreferrer">Try it Online!</a></p>
</div>
<div id="pu3" class="pu"><h1><a href="https://www.haskell.org/" rel="nofollow noreferrer">Haskell</a>, <s>167</s> 166 bytes</h1>



<pre class="lang-hs prettyprint-override"><code>head.e
e('_':r)=["_",r]
e(x:r)=[x]%r
e _=[]
o%t@(c:r)|[x,u]&lt;-e t,n&lt;-length o,[y,v]&lt;-e$drop n u,all((==o).take n)[u,v]=['(':x++o++y++")",drop n v]|p&lt;-o++[c]=p%r
o%_=[]
</code></pre>

<p><a href="https://tio.run/##lVLbboMwDH3nKyy0qkkMlaa9VU21D9ie9pihCDG6TqWAKJ2Y1G8fc5IG2H2DXCxfjo8db9PDLi@KfiPv@22ePizyIGfdsuGnbj3HuVSqS6ImOV2uriSJsybIQUuVBNWsvWaZcVRddExWcQ5tVK7iIi8f2y1UkXqJno364qGpaijhGKVFwZiUFV@06S6HkqsjuUg1Z/Nlh1ghviCGPIzOEc/JqV7FpFZZImtKXc1M6n6fPpUgYZ/Wt8DqY3vXNjclLGDDQQUAEKJAbReinshhBD9/cQzxGhgzARyZRidxHpAlFIQhUJhL02@hnUJ7wYi06BBjMo9KuAZW8yGMC0pAy6YwxD2A2b@y/ZK4AdUOzLL8D8p7MEPW1W3qJL6udNPTP2gor8f57O1x0TbC9OvsQg76w43ONnnAoZ@mcWRkQwjnwsG7IfAvL4Ztl/i5KRN4tM1E@0gohkFAX8fkdDU4@Z2BTD7diHxug@Vvx@ys4J66xXJ7YD9qvitgkuADd5yMmJ5MqZmz5J8jNs4sHf1rtinSx0MfZ3X9Bg" rel="nofollow noreferrer" title="Haskell – Try It Online">Try it online!</a> Example usage: <code>head.e "**_**_**_*_****_*"</code> yields <code>((_*(_*(_*_)))*_)</code>. All characters except <code>_</code> are interpreted as operators, <code>_</code> itself denotes an identifier.</p>
</div>
<div id="pu4" class="pu"><h1><a href="http://www.swi-prolog.org" rel="noreferrer">Prolog (SWI)</a>, <s>194</s> 163 bytes</h1>

<p><sup><em>Saved a whopping 31 bytes using <a href="https://codegolf.stackexchange.com/a/153160/16766">this tip</a> from <a href="https://codegolf.stackexchange.com/users/20059/0">0 '</a>!</em></sup></p>

<pre><code>[C|T]/O/R:-C\=x,(T/P/R,concat(C,P,O);O=C,R=T).
[x|R]-x-R.
L-X-R:-L/O/A,A-Y-B,B/O/C,C-Z-D,D/O/R,atomics_to_string(['(',Y,O,Z,')'],X).
X^P:-string_chars(X,L),L-P-[].
</code></pre>

<p>The operator <code>^</code> takes for its left argument a string containing a panfix expression and sets its right argument to a string containing the corresponding parenthesized infix expression. It uses <code>x</code> as the literal in place of <code>_</code>.</p>

<p><a href="https://tio.run/##LUzNCoJAGLz7FNLF3ZhP74aHXI@CsniwzEQkSrA23A09@O62YTDMD8PMe1SDupOe@nWtxFLUQRbIkMQlmsGKIA8kOvXqWsMEcmT8kEUCMiq471TzImuaSfpOSiXZVWrHRxzpRDFi6wUEnSlB8jtFa9Sz73RjVKPN2L/urPKYhxMynOFxr0ZpX8trHtLWN92jHTUrkXKklFNV@2tI7m6/n/@w9JOde3XlTX8GA3cae3NjW@L@@gU" rel="noreferrer" title="Prolog (SWI) – Try It Online">Try it online!</a></p>

<h3>Explanation</h3>

<p>Since Prolog is a declarative language, we just have to describe the relation between a panfix and a parenthesized expression.</p>

<p>The explanation uses this slightly ungolfed version:</p>

<pre><code>oper([C|T],O,R) :- C\=x, oper(T,P,R), concat(C,P,O).
oper([C|T],C,T).

expr([x|R],x,R).
expr(L,X,R) :- oper(L,O,A), expr(A,Y,B), oper(B,O,C), expr(C,Z,D), oper(D,O,R),
               atomics_to_string(['(',Y,O,Z,')'],X).

parenthesize(X,P) :- string_chars(X,L), expr(L,P,[]).
</code></pre>

<p>Our main production is <code>parenthesize</code>, which takes in a panfix expression <code>X</code> as a string and sends out the corresponding parenthesized infix expression <code>P</code> as a string. It uses <code>string_chars</code> to convert the input string into a list of characters and then simply passes it on to <code>expr</code>.</p>

<p><code>expr</code> takes in a list of characters <code>L</code>, parses the first panfix expression it finds in <code>L</code>, and sends out the parenthesized equivalent <code>X</code> and the remainder of the list of characters <code>R</code>. There are two possible kinds of expressions:</p>

<ul>
<li>If the first character of <code>L</code> is <code>x</code>, then the expression is <code>x</code> and the remainder is everything after the <code>x</code>.</li>
<li>Otherwise, parse an operator <code>O</code> (see <code>oper</code> below); parse an expression <code>Y</code>; parse <code>O</code> again; parse another expression <code>Z</code>; and parse <code>O</code> a third time. The remainder is everything after the third instance of <code>O</code>. The expression is the result of joining <code>Y</code>, <code>O</code>, and <code>Z</code>, surrounded by parentheses, into a string.</li>
</ul>

<p><code>oper</code> takes in a list of characters, where the first character is <code>C</code> and the rest are <code>T</code>; it parses an operator (i.e. a run of one or more operator characters) and sends out the operator <code>O</code> and the remainder of the list of characters <code>R</code>. To form an operator, the character <code>C</code> must be something other than <code>x</code>; also, either</p>

<ul>
<li>an operator <code>P</code> must be parseable from <code>T</code>, with remainder <code>R</code>; in this case, <code>O</code> is the concatenation of <code>C</code> and <code>P</code>; or,</li>
<li><code>O</code> is the single character <code>C</code>; in this case, <code>R</code> is just <code>T</code>.</li>
</ul>

<h3>A worked example</h3>

<p>Let's take the input <code>+*+x+x++*x+*</code> for an example.</p>

<ul>
<li>We want to parse an expression from <code>+*+x+x++*x+*</code>. This doesn't start with <code>x</code>, so we parse an operator from the beginning.</li>
<li><code>oper</code> will parse as big of an operator as possible, so we try <code>+*+</code>.

<ul>
<li>Next we parse an expression from <code>x+x++*x+*</code>. This has to be <code>x</code>.</li>
<li>Now we try to parse the same operator, <code>+*+</code>, from <code>+x++*x+*</code>. However, this <em>fails</em>.</li>
</ul></li>
<li>So we backtrack and try parsing the operator <code>+*</code> instead.

<ul>
<li>We parse an expression from <code>+x+x++*x+*</code>. This doesn't start with <code>x</code>, so we need to parse an operator.</li>
<li>The only possibility is <code>+</code>.</li>
<li>Now parse a subexpression from <code>x+x++*x+*</code>. This has to be <code>x</code>.</li>
<li>Now parse <code>+</code> again from <code>+x++*x+*</code>.</li>
<li>Now parse another subexpression from <code>x++*x+*</code>. This has to be <code>x</code>.</li>
<li>Finally, parse <code>+</code> again from <code>++*x+*</code>.</li>
<li>The expression has been successfully parsed. We return the string <code>(x+x)</code>.</li>
</ul></li>
<li>Back at the previous recursion level, we parse the operator <code>+*</code> again from <code>+*x+*</code>.</li>
<li>Now parse another subexpression from <code>x+*</code>. This has to be <code>x</code>.</li>
<li>Finally, parse <code>+*</code> again from <code>+*</code>.</li>
<li>The expression has been successfully parsed. We return the string <code>((x+x)+*x)</code>.</li>
</ul>

<p>Since there are no more characters left, we have successfully translated the expression.</p>
</div>
<div id="pu5" class="pu"><h1><a href="https://clean.cs.ru.nl" rel="nofollow noreferrer">Clean</a>, <s>200</s> <s>192</s> 189 bytes</h1>

<pre><code>import StdEnv,Text
f"_"=["_"]
f l=["("+a+p+b+")"\\p&lt;-[l%(0,i)\\i&lt;-[0..indexOf"_"l]|endsWith(l%(0,i))l],t&lt;-[tl(init(split p l))],n&lt;-indexList t,a&lt;-f(join p(take n t))&amp;b&lt;-f(join p(drop n t))]
</code></pre>

<p><a href="https://tio.run/##jVLbTsMwDH2mXxEFgXJpp33A9gYPSJNAGhIPaxVlawuBNI1aDw2Jb6fk0m0dT6i245zjY7dWd7qSZmjacq8r1EhlBtXYtgO0hvLefKbP1QGSGgu83LhQJDXSLiOYS275lmOK89wuso2@IfNU0TxX7jKfzZQpq8OjF@riuzJl/6LgjYxVVBcpuDrQRBkFpLdaAbJIU1qkZpEF8Ur1gCCVi6wm760yyBKQHxUyCCi93U7gsmtthIthDbKD5BopY/fQoyXaJFeYMy6CcS4mOU4dx1zGOPOHcE8oiIA4Jj515gIbJRHwHoCgjJRXO01s6Of9AxmVPIzzc8YCR4s/J4/c@fV9n/g97OTB2JkPUycxToj5BeGoURT46Ke@Z@S4OTHZjN9FkSzdP2RRPa5/@NnVWr72Q/awGu6@jGzULl6etIS67Zpf" rel="nofollow noreferrer" title="Clean – Try It Online">Try it online!</a></p>

<p>Defines the function <code>f</code>, taking <code>String</code>, and returning a singleton <code>[String]</code> with the result inside.</p>

<p>Some neat stuff:</p>

<ul>
<li>Doesn't use regex</li>
<li>Works with any character for operators <em>except <code>_</code></em></li>
</ul>
</div>
<div id="pu6" class="pu"><h1>Perl, <s>78</s> <s>60</s> <s>58</s> <s>57</s> 50 bytes</h1>

<p>Includes <code>+1</code> for <code>p</code></p>

<p>Uses <code>1</code> for <code>+</code> and <code>2</code> for <code>*</code> (or in fact any digit works for any operator)</p>

<pre><code>perl -pe 's/\b((\d+)((?1)|_)\2((?3))\2)\b/($3 $2 $4)/&amp;&amp;redo' &lt;&lt;&lt; 22_22_22_2_2222_2
</code></pre>

<p>For convenient testing versus the given examples you can use this which does the translations and space removal for you:</p>

<pre><code>perl -pe 'y/+*/12/;s/\b((\d+)((?1)|_)\2((?3))\2)\b/($3 $2 $4)/&amp;&amp;redo;y/ //d;y/12/+*/' &lt;&lt;&lt; "**_**_**_*_****_*"
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/154872/">154872</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




