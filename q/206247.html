<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::206247</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>103</td><td>Charcoal</td><td>200618T191533Z</td><td><a href="https://codegolf.stackexchange.com/questions/206247/can-this-polyomino-tile-the-toroidal-grid/206270#206270">Neil</a></td></tr>
<tr d-ix="1"><td>163</td><td>Python 2</td><td>200618T081012Z</td><td><a href="https://codegolf.stackexchange.com/questions/206247/can-this-polyomino-tile-the-toroidal-grid/206249#206249">fireflam</a></td></tr>
<tr d-ix="2"><td>233</td><td>JavaScript ES7</td><td>200618T124015Z</td><td><a href="https://codegolf.stackexchange.com/questions/206247/can-this-polyomino-tile-the-toroidal-grid/206258#206258">Arnauld</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://github.com/somebody1234/Charcoal" rel="nofollow noreferrer">Charcoal</a>, <s>120</s> <s>115</s> 103 bytes</h1>
<pre><code>ＮθＮηＷＳ⊞υ⌕Ａι#≔⟦⟧ζＦθＦηＦ²«≔ＥθＥη⁰εＦＬυＦ§υμ§≔§ε⎇λ⁺κν⁺ιμ⎇λ⁺ιμ⁺κν¹Ｆ²Ｆ²⊞ζ⍘⭆⎇μ⮌εε⪫⎇ν⮌ξξω²»ＦζＦζＦ¬＆ικ⊞ζ｜ικ⁼⌈ζ⊖Ｘ²×θη
</code></pre>
<p><a href="https://tio.run/##ZVFdT8IwFH1mv@IGXtqkJrrwxtOImmAUF/XN@DDZlTV0HbQdQ4y/fd52G5DYZDu995z72VWRmVWVqbZd6G3tlnX5iYbt@Cy6tAuym0IqBBbcr85IvWacQ1rbgtUC7qXOE6WYFDCejDnpE2vlWrP3DwFHMr8qA5QXAhY9xhx@olGvfMq2bCfAQyHgmnMBSIGjoHxEvXZUifeRiVvoHA@@dEm@LsXgHBAFvKHRmflmSkCqass2AjTv7zLE/tcE/6WejJtTJ/G59zD8UcA8s9ivpAM/w5C1FPCCezQWGYaRBDxUUp94feYPxPmv8RVjv8Tfbm/HvuaAy8qxuXSNtJjo3De84fyin456Nj0zi1LqyrG7XZ0pS4s@yLIuKZuAW1wZLFE7zFlaNfTWMS1Elmj9WxTcn1nbTqNpNKETAUD3o3t7tVd/" rel="nofollow noreferrer" title="Charcoal – Try It Online">Try it online!</a> Link is to verbose version of code. Takes inputs in the order width, height, newline-terminated polyomino and outputs a Charcoal boolean i.e. <code>-</code> only if the polyomino tiles the torus. Explanation:</p>
<pre><code>ＮθＮη
</code></pre>
<p>Input the size of the grid.</p>
<pre><code>ＷＳ⊞υ⌕Ａι#
</code></pre>
<p>Input the polyomino and convert it to a list of horizontal indices.</p>
<pre><code>≔⟦⟧ζ
</code></pre>
<p>Start building up a list of polyomino placements.</p>
<pre><code>ＦθＦηＦ²«
</code></pre>
<p>Loop through each vertical and horizontal offset and direction.</p>
<pre><code>≔ＥθＥη⁰ε
</code></pre>
<p>Start with an empty grid.</p>
<pre><code>ＦＬυＦ§υμ
</code></pre>
<p>Loop over each cell of the polyomino...</p>
<pre><code>§≔§ε⎇λ⁺κν⁺ιμ⎇λ⁺ιμ⁺κν¹
</code></pre>
<p>... place the optionally transposed cell in the grid, but offset by the outer indices.</p>
<pre><code>Ｆ²Ｆ²⊞ζ↨⭆⎇μ⮌εε⪫⎇ν⮌ξξω²
</code></pre>
<p>For each of four reflections of the grid, push the grid to the list of placements, represented as a base 2 integer (e.g. a grid with just the bottom right square filled would be 1 etc.)</p>
<pre><code>»ＦζＦζ
</code></pre>
<p>Start a breadth first search over the pairs of placements.</p>
<pre><code>Ｆ¬＆ικ
</code></pre>
<p>If this pair do not overlap...</p>
<pre><code>⊞ζ｜ικ
</code></pre>
<p>... then push the merged pair to the list of placements.</p>
<pre><code>⁼⌈ζ⊖Ｘ²×θη
</code></pre>
<p>Check whether we pushed a completed grid.</p>
</div>
<div id="pu1" class="pu"><h1><a href="https://docs.python.org/2/" rel="nofollow noreferrer">Python 2</a>, <s>300</s> <s>265</s> 163 bytes</h1>
<p><em>-35 bytes after suggestions from @xnor, @ovs, and largely @user202729 (removing evenly divisible check allowed for a one-liner + lambda)</em></p>
<p><em>-102 bytes following encouragement + general suggestions by @user202729</em></p>

<pre class="lang-python prettyprint-override"><code>lambda l,w,h:all(w*h-len({((e-(p&4)*e//2)*1j**p+p/8+p/8/w*1j)%w%(1j*h)for e in l for p in c})for c in combinations(range(8*w*h),w*h/len(l)))
from itertools import*
</code></pre>
<p>Takes input as a list of complex coordinates of each cell of the polyomino. Outputs False for Truthy and True for Falsey (quirky de Morgan optimization).</p>
<p><a href="https://tio.run/##XVLtbusgDP3PU1hU2yBji/ox3apS7ot0@8Ey2nBHgAtEaTTt2TsgS5cuErZzfOzjxNghNEavzsfq@ax4@/rGQbGeNTuuFOmL5kEJTT4IEQ/E3m5oIcpyRYvlv6Kw97bcplP28Z3e9Dckwg09GAcCpAYFKbQprD8zXOfYtK9S8yCN9sRxfRRkW0QlyqIpk5yilKKDMy3IIFwwRnmQrTUuFOeae@Ghgj1aQHBdaIYYEIxxdIvo2BP7Q9kMy@CGrSM4QmiE1hma8bL5bvF0YS/QpcXmmp8LflR/BFIKAEYzL57SKOMpPeWnYQ5ceTH8nn49nydKJmzJtrnCN67T7xAMiJOouyDgfyfrdzWgqQW6fNWKoheU9uDThvMu0t/c5Ul85R@9VTIQ/Kwx3S93LxlX1X4MUuHAlNR5uUJ3rXA8COLp2GDinFjdcHfNSVUzWnrkARKvqvACX2ey6iO3Vug3crof0u3KBOukDnF4uGN3DPpv3zDA1V/M4EjyzaXnLw" rel="nofollow noreferrer" title="Python 2 – Try It Online">Try it online</a> with many testcases. Since this brute-forces, I have commented out a few cases to run fast enough for TIO.</p>
<p>Thoroughly commented:</p>
<pre class="lang-python prettyprint-override"><code>lambda l,w,h:
    all(                        # we want any configuration to work, but De Morgan gives any(L==len) &lt;==&gt; not all(L!=len) &lt;==&gt; not all(L-len)
        w*h-len(                      # if two polyominos in a configuration overlap, then there are duplicate cells
                                    #   so the length of the set is less
                {                   # create a set consisting of each possible position+orientation of L/len(l) polyominos:
                    (                   # here, e is a single cell of the given polyomino
                        (               # reflect e across the imaginary axis if p &gt;= 4 (mod 8)
                            e-          # e-e.real*2 = e-e//.5 reflects across the Im axis
                            p&amp;4             # Only reflect if the 2^2 bit is nonzero: gives 4* or 0* following
                            *e//2           # floor(z) = z.real when z is complex, so
                        )                   # e//2 (floor division) gives z.real/2 (complex floor division only works in Python 2)
                        *1j**p          # rotate depending on the 2^0 and 2^1 bits. i**x is cyclic every 4
                        +p/8              # translate horizontally (real component) by p&gt;&gt;3 (mod this later)
                        +p/8/w*1j           # translate vertically (im component) by p&gt;&gt;3 / w
                    )%w%(1j*h)          # mod to within grid (complex mods only work in Python 2)
                    for e in l      # find where each cell e of the given polyomino goes
                    for p in c      # do this for each c (each set of position+orientation integers)
                }
        )
        for c in combinations(           # iterate c over all sets of w*h/len(l) distinct integers from 0 to 8*L-1
            range(8*w*h)              # each of these 8*L integers corresponds to a single position/orientation of a polyomino
                                    # Bits 2^0 and 2^1 give the rotation, and 2^2 gives the reflection
                                    # The higher bits give the position from 0 to L=w*h-1  ==&gt; (0,0) to (w-1,h-1)
            ,w*h/len(l)        # w*h/len(l) is the number of polyominos needed since len(l) is the number of cells per polyomino
                                    # can't switch to *[range(8*w*h)]*(w*h/len(l)) because Python 3 does not allow short complex operations as above
        )
    )
from itertools import*
</code></pre>
<p>A new 169-byte solution that replaces <code>combinations</code> with recursion:</p>
<pre class="lang-python prettyprint-override"><code>g=lambda l,w,h,k=[]:all(g(l,w,h,k+[((e-(p&amp;4)*e//2)*1j**p+p/8+p/8/w*1j)%w%(1j*h)for e in l])for p in range(8*w*h))if w*h&gt;len(k)else len(set(k))-w*h
from itertools import*
</code></pre>
<p>This has the advantage of removing <code>combinations</code> (12 characters on its own) and one for loop, but the self-invocation takes many bytes. Currying would not save length.</p>
</div>
<div id="pu2" class="pu"><h1>JavaScript (ES7), 233 bytes</h1>
<p>Takes input as <code>(w)(h)(p)</code>, where <span class="math-container">\$p\$</span> is a binary matrix describing the polyomino. Returns <span class="math-container">\$0\$</span> or <span class="math-container">\$1\$</span>.</p>
<p>Similar to my original answer, but uses a more complex expression to update the cells of the matrix instead of explicitly rotating the polyomino.</p>

<pre class="lang-javascript prettyprint-override"><code>w=&gt;h=&gt;g=(p,m=Array(w*h).fill(o=1))=&gt;+m.join``?(R=i=&gt;i--?m.map((F,X)=&gt;(F=k=&gt;p.map((r,y)=&gt;r.map((v,x)=&gt;k|=v?m[Z=i&amp;2?p[0].length+~x:x,~~(X/w+(i&amp;1?Z:W))%h*w+(X+(i&amp;1?W:Z))%w]^=1:0,W=i&amp;4?p.length+~y:y))&amp;&amp;k)(F()||g(p,m)))|!o||R(i):0)(8):o=0
</code></pre>
<p><a href="https://tio.run/##hZDRboJAEEXf/Qr7UJzRlbKtTZpNBtIXPsA00UhpJFZhFViCViQh/jouIba0MWkyDzt3zt47u9vgGOxXucwO41R9rusN1QXZEdkhQcYSes3zoIRiGKG5kXEMijgi2aPE3CqZLpcOTEmSLcdjJzGTIANw2VwD4NKO7KyVclZqKW@bIzvpZlfR0Um8BUnj0ck8yzfjdRoeotH5JE7sfIb5QzECaXBnIWaI99FQt/NWmYmFVgr/g7iw2ExbTJzs@34pSkTD2CG4gFUVNs9AxOpOVdUUJAoL4QWFIqteqXSv4rUZqxAG3lv@dYhKf4C9rr6BJ2zK6/X7Hvd7Pv6dP2NT7ZxxZvnseryJTzp2t4luYMeuRX@xg/fUc4N4/8/Wt2N48w8/e/NrkKUzG7y@AA" rel="nofollow noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a></p>
<hr />
<h1>JavaScript (ES7), <s> 311 ... 252 </s> 250 bytes</h1>
<p>Takes input as <code>(w)(h)(p)</code>, where <span class="math-container">\$p\$</span> is a binary matrix describing the polyomino. Returns a Boolean value.</p>
<p>Not quite as desperately long as I was expecting. :p</p>

<pre class="lang-javascript prettyprint-override"><code>w=&gt;h=&gt;g=(p,m=Array(w*h).fill(o=1),P)=&gt;+m.join``?[...13**7+''].some(i=&gt;(p.sort(_=&gt;i-7).map((r,y)=&gt;r.map((v,x)=&gt;(P[x]=P[x]||[])[y]=v),P=[]),m.map((F,X)=&gt;(F=k=&gt;P.map((r,y)=&gt;r.map((v,x)=&gt;k|=v?m[~~(X/w+y)%h*w+(X+x)%w]^=1:0))&amp;&amp;k)(F()||g(p,m))),p=P,!o)):o=0
</code></pre>
<p><a href="https://tio.run/##hY9Ba4NAEIXv@RXpIXFGN1uXtKQExtCLZw89BLbbRtIkmqgrmmoE6V@3igRsSSkMy5udb9@bPfqFn2@zMD3PEv2xa/bUlOQE5BwIUhbTc5b5FZRmgHwfRhFoEsg8JMeK@VGHyWazkpxzMTfNhWUYiuc63kFIDqStzM7wTk44WyCP/RQgY1X7NOubgl3aBjx5UdQddS0VykpR0SZQq1ncgy5bd6BLJ3K8P41ONRWrWH59wfq@tCqcBGZpwdq64KRUbySWNuJ0ekJwAev60P0OEVlKHrvTiEtNdrPVSa6jHY/0AQz5kn2eg0oZOBre72GOXcnReCyFGin8PX/Ervo5E8xW7Cpv4g8Du9vEMHBg16M/WOM1ka4f5f9sfTtGIDwN9hbXILvN7PDmGw" rel="nofollow noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a></p>
<h3>How?</h3>
<p>The following code builds all possible transformations <span class="math-container">\$P\$</span> of the polyomino <span class="math-container">\$p\$</span>:</p>
<pre class="lang-javascript prettyprint-override"><code>[...13 ** 7 + '']         // this expands to ['6','2','7','4','8','5','1','7']
.some(i =&gt;                // for each value i in the above list:
  ( p.sort(_ =&gt; i - 7)    //   reverse the rows of p[], except when i = '8'
    .map((r, y) =&gt;        //   for each row r[] at position y in m[]:
      r.map((v, x) =&gt;     //     for each value v at position x in r[]:
        ( P[x] =          //       transpose p[y][x]
          P[x] || [] )    //              to P[x][y]
        [y] = v           //
      ),                  //     end of inner map()
      P = []              //     start with an empty array
    )                     //   end of outer map()
    (...)                 //   more fun things happen here!
    p = P,                //   get ready for the next transformation
    !o                    //   success if o is cleared
  )                       //
)                         // end of some()
</code></pre>
<p>We use a flat array of <span class="math-container">\$w\times h\$</span> entries to describe the matrix. All of them are initially set to <span class="math-container">\$1\$</span>.</p>
<p>The function <span class="math-container">\$F\$</span> inserts the polyomino in the matrix at the position <span class="math-container">\$(X,Y)\$</span> by XOR'ing the cells. It returns <span class="math-container">\$0\$</span> if the operation was done without setting any cell back to <span class="math-container">\$1\$</span>.</p>
<pre class="lang-javascript prettyprint-override"><code>F = k =&gt;                  // expects k undefined for the first call
  P.map((r, y) =&gt;         // for each row r[] at position y in P[]:
    r.map((v, x) =&gt;       //   for each value v at position x in r[]:
      k |=                //     update k:
        v ?               //       if v is set:
          m[~~(X / w + y) //         toggle the value at (X + x, Y + Y),
            % h * w +     //         taking the wrapping around into account
            (X + x) % w   //
          ] ^= 1          //         k is set if the result is not 0
        :                 //       else:
          0               //         leave k unchanged
    )                     //   end of inner map()
  ) &amp;&amp; k                  // end of outer map(); return k
</code></pre>
<p>For each position <span class="math-container">\$(X,Y)\$</span> in the matrix:</p>
<ul>
<li><p>We do a first call to <span class="math-container">\$F\$</span>. If successful, it is followed by a recursive call to the main function <span class="math-container">\$g\$</span>.</p>
</li>
<li><p>We just need to call <span class="math-container">\$F\$</span> a second time to remove the polyomino -- or to clear the mess if it was inserted at an invalid position.</p>
</li>
</ul>
<p>Hence the code:</p>
<pre class="lang-javascript prettyprint-override"><code>F(F() || g(p, m))
</code></pre>
<p>The recursion stops when there's no more <span class="math-container">\$1\$</span>'s in the matrix (success) or there's no more valid position for the polyomino (failure).</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/206247/">206247</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




