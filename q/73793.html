<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::73793</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>006</td><td>Japt</td><td>240214T003934Z</td><td><a href="https://codegolf.stackexchange.com/questions/73793/sum-of-binary-substrings/270062#270062">noodle m</a></td></tr>
<tr d-ix="1"><td>006</td><td>Vyxal 3 s</td><td>240213T191709Z</td><td><a href="https://codegolf.stackexchange.com/questions/73793/sum-of-binary-substrings/270057#270057">pacman25</a></td></tr>
<tr d-ix="2"><td>070</td><td>Mathematica</td><td>160222T171550Z</td><td><a href="https://codegolf.stackexchange.com/questions/73793/sum-of-binary-substrings/73807#73807">Calculat</a></td></tr>
<tr d-ix="3"><td>148</td><td>C#</td><td>160224T103723Z</td><td><a href="https://codegolf.stackexchange.com/questions/73793/sum-of-binary-substrings/74043#74043">DW.com</a></td></tr>
<tr d-ix="4"><td>071</td><td>C</td><td>160223T161936Z</td><td><a href="https://codegolf.stackexchange.com/questions/73793/sum-of-binary-substrings/73978#73978">Toby Spe</a></td></tr>
<tr d-ix="5"><td>064</td><td>Retina</td><td>160223T151350Z</td><td><a href="https://codegolf.stackexchange.com/questions/73793/sum-of-binary-substrings/73966#73966">FryAmThe</a></td></tr>
<tr d-ix="6"><td>022</td><td>CJam</td><td>160222T225955Z</td><td><a href="https://codegolf.stackexchange.com/questions/73793/sum-of-binary-substrings/73896#73896">Peter Ta</a></td></tr>
<tr d-ix="7"><td>010</td><td>Pyth</td><td>160222T155534Z</td><td><a href="https://codegolf.stackexchange.com/questions/73793/sum-of-binary-substrings/73796#73796">FryAmThe</a></td></tr>
<tr d-ix="8"><td>138</td><td>PowerShell v2+</td><td>160222T172146Z</td><td><a href="https://codegolf.stackexchange.com/questions/73793/sum-of-binary-substrings/73809#73809">AdmBorkB</a></td></tr>
<tr d-ix="9"><td>021</td><td>CJam</td><td>160222T160232Z</td><td><a href="https://codegolf.stackexchange.com/questions/73793/sum-of-binary-substrings/73797#73797">GamrCorp</a></td></tr>
<tr d-ix="10"><td>078</td><td>JavaScript ES6</td><td>160222T170432Z</td><td><a href="https://codegolf.stackexchange.com/questions/73793/sum-of-binary-substrings/73803#73803">Neil</a></td></tr>
<tr d-ix="11"><td>111</td><td>Python 3</td><td>160222T163119Z</td><td><a href="https://codegolf.stackexchange.com/questions/73793/sum-of-binary-substrings/73799#73799">shooqie</a></td></tr>
<tr d-ix="12"><td>007</td><td>Jelly</td><td>160222T155522Z</td><td><a href="https://codegolf.stackexchange.com/questions/73793/sum-of-binary-substrings/73795#73795">Dennis</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://github.com/ETHproductions/japt" rel="nofollow noreferrer">Japt</a>, <s>7</s> 6 <a href="https://en.wikipedia.org/wiki/ISO/IEC_8859-1" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>n¢ã xÍ
</code></pre>
<p><a href="https://petershaggynoble.github.io/Japt-Interpreter/?v=1.4.6&amp;code=bqLjIHjN&amp;input=MTE" rel="nofollow noreferrer">Try it</a></p>
<pre><code>n        The input subtracted from:
 ¢         The input as a binary string
  ã        Substrings, including the original string
    x      Sum this list after mapping each substring to:
     Í       It converted to decimal
</code></pre>
<p>The <code>n</code> is only necessary because <code>ã</code> includes the original string.</p>
<p>It should be 5 bytes:</p>
<pre><code>n¢ãÍx
</code></pre>
<p>As according to the docs, when passed a function <code>f</code>, <code>ã</code> “returns all substrings of <code>S</code> after passing each through <code>f</code>.”
But there's a bug in the interpreter, and Japt isn't maintained anymore, so 6 bytes it is.</p>
</div>
<div id="pu1" class="pu"><h1><a href="https://github.com/Vyxal/Vyxal/tree/version-3" rel="nofollow noreferrer">Vyxal 3</a> <code>s</code>, 6 bytes</h1>
<pre><code>bṢḶṪᵛB
</code></pre>
<p><a href="https://vyxal.github.io/latest.html#WyJzIiwiIiwiYuG5ouG4tuG5quG1m0IiLCIiLCIxMSIsIjMuNC4yIl0=" rel="nofollow noreferrer">Try it Online!</a></p>
</div>
<div id="pu2" class="pu"><h1>Mathematica, <s>73</s> 70 bytes</h1>
<pre><code>Tr[FromDigits[#,2]&amp;/@StringCases[#~IntegerString~2,__,Overlaps-&gt;All]]&amp;
</code></pre>
<p>Function. Integer-&gt;Integer</p>
</div>
<div id="pu3" class="pu"><p><strong>C#, 148 bytes</strong></p>

<pre><code>int x(int i){int s,r=0,j=i,p=System.Convert.ToString(i,2).Length+1,k;for(;--p&gt;-1;){k=j;s=-1;for(;++s&lt;p;)r+=(k&gt;&gt;=1);j=(i&amp;((1&lt;&lt;p-1)-1))&lt;&lt;1;}return r;}
</code></pre>

<p>Or, if I add Import "using static System.Math;" then 138 with</p>

<pre><code>int x(int i){int s,r=0,j=i,p=(int)Round(Log(i,2)+1.49,0),k;for(;--p&gt;-1;){k=j;s=-1;for(;++s&lt;p;)r+=(k&gt;&gt;=1);j=(i&amp;((1&lt;&lt;p-1)-1))&lt;&lt;1;}return r;}
</code></pre>

<p>OOP languages like C# won't win such a race, but I wanted to try it anyway. Here is a more beautified version + tester.</p>

<pre><code>class Program
{
    // Tester: 50 bytes
    static void Main(string[] args)
    {
        int i=2;
        do System.Console.WriteLine($"{i} -&gt; {x(i++)}"); while (i &lt; 12);
        System.Console.Read();
    }
    // Function: 65 bytes (size according to ILDASM.exe)
    static int x(int iOrg)
    {
        int pos, shift, retVal=0, iPrev=iOrg, iTemp;
        pos = System.Convert.ToString(iOrg, 2).Length;
        do {
            iTemp = iPrev; shift = 0;
            do retVal += (iTemp &gt;&gt;= 1); while (++shift &lt; pos);
            iPrev = (iOrg &amp; ((1 &lt;&lt; pos - 1) - 1)) &lt;&lt; 1;
        } while (--pos &gt; -1); 
        return retVal;
    }
}
</code></pre>

<p>The nested do-while adds the right-shifted value of iTemp (after assigning it) as long as shift+1 is smaller then pos.
The next line calculates the next shifted value of iPrev</p>

<pre><code>x1 = 1 &lt;&lt; p -1; // 1 &lt;&lt; 4 -1 = 8 [1000]
x2 = x1 - 1;    // 8 -  1 = 7    [0111]
x3 = i &amp; x2;    // 1011 &amp; 0111 = 0011 
x4 = x3 &lt;&lt; 1;   // 0011 &lt;&lt; 1 = 00110
i2 = x4;
</code></pre>

<p>x1 und x2 calculate the mask, x3 applies it and then left-shifts it, since the last digit is always dropped. For 11, it looks like this:</p>

<pre><code>START -&gt; _1011[11]
101
10
1   --&gt;  X0110[6], r=0+5+2+1=8
 011
 01
 0  --&gt;  XX110[6], r=8+4=12
  11
  1 --&gt;  XXX10[2], r=12+4=16
   1 -&gt;  XXXX0[X], r=16+1=17
</code></pre>
</div>
<div id="pu4" class="pu"><h1>C, 71 bytes</h1>

<pre class="lang-c prettyprint-override"><code>f(n){int a=0,m=0,i;for(;++m&lt;n;m+=m)for(i=n;i+i&gt;m;i/=2)a+=i&amp;m;return a;}
</code></pre>

<p>We maintain an accumulator <code>a</code> and mask <code>m</code>.  The mask starts at 1 and gets one bit longer each time around the outer loop.  In the inner loop, a copy <code>i</code> of the input is successively shifted right until it is shorter than the mask, accumulating the masked value each time.</p>

<h3>Test program</h3>

<pre class="lang-c prettyprint-override"><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
int main(int argc, char **argv) {
    while (*++argv) {
        int n = atoi(*argv);
        printf("%d -&gt; %d\n", n, f(n));
    }
    return 0;
}
</code></pre>

<h3>Test output</h3>

<pre class="lang-none prettyprint-override"><code>./73793 $(seq 0 11)
0 -&gt; 0
1 -&gt; 0
2 -&gt; 1
3 -&gt; 2
4 -&gt; 3
5 -&gt; 5
6 -&gt; 7
7 -&gt; 9
8 -&gt; 7
9 -&gt; 10
10 -&gt; 14
11 -&gt; 17
</code></pre>
</div>
<div id="pu5" class="pu"><h1><a href="https://github.com/mbuettner/retina" rel="nofollow">Retina</a>, 64</h1>

<pre><code>.*
$*
+`(1+)\1
$1a
a1
1
r&amp;!M`.*
&amp;!M`.*
^.*

+`1(a*)\b
a$.1$*1;
;
</code></pre>

<p><a href="http://retina.tryitonline.net/#code=LioKJCoKK2AoMSspXDEKJDFhCmExCjEKciYhTWAuKgomIU1gLioKXi4qCgorYDEoYSopXGIKYSQuMSQqMTsKOw&amp;input=MTE" rel="nofollow">Try it online!</a></p>

<p>A high level stage by stage description: convert decimal to unary, unary to binary, get prefixes, get suffixes of prefixes, dump the original number, convert binary to unary, return count. I'll write a more detailed description once I'm done golfing, a lot of these stages seem suspicious...</p>
</div>
<div id="pu6" class="pu"><h2>CJam (22 bytes)</h2>

<p>This is one byte longer than the current best CJam answer, but the approach can probably be adapted to some other languages quite profitably.</p>

<pre><code>3,ri_2b_,,:).*\+fbW%:-
</code></pre>

<p><a href="http://cjam.aditsu.net/#code=3%2Cri_2b_%2C%2C%3A).*%5C%2BfbW%25%3A-&amp;input=11" rel="nofollow">Online demo</a></p>

<h3>Analysis</h3>

<p>Suppose that the question were</p>

<blockquote>
  <p>calculate the sum of the sub-strings of the binary number</p>
</blockquote>

<p>without the bit</p>

<blockquote>
  <p>whose length is shorter than the original number</p>
</blockquote>

<p>Then it's not too hard to show that the most significant bit occurs with total weight <code>1*(2^B-1)</code> where <code>B</code> is the number of bits; the second-most significant bit occurs with total weight <code>2*(2^(B-1)-1)</code>; down to the Bth-most significant bit, which occurs with total weight <code>B*(2^1-1)</code>.</p>

<p>Taking into account now the subtraction of the original number, <code>x</code>, we end up with the sum</p>

<pre><code>sum_i (x &amp; 2^i) * 2^i * 2*(B-i)  -  sum_i (x &amp; 2^i) * (B-i)  -  x
</code></pre>

<h3>Dissection</h3>

<pre><code>3,        e# Put [0 1 2] on the stack - we'll need it later
ri_       e# Get the input x and copy it
2b        e# Convert the copy to base 2
_,,:).*   e# Pointwise multiply by 1 plus the index
\+        e# Append x to the resulting array, giving A
fb        e# Map a base conversion
W%:-      e# Reverse and fold a subtraction
</code></pre>

<p>The conversion to base 2 gives the first part of the main sum plus <code>x</code>; to base 1 gives the second part plus <code>x</code>; and to base 0 gives just <code>x</code>, so subtracting the base-1 from the base-2 the <code>x</code>s cancel, and subtracting the base-0 gives the desired result.</p>
</div>
<div id="pu7" class="pu"><h1>Pyth, 10</h1>

<pre><code>sPiR2.:.BQ
</code></pre>

<p><a href="http://pyth.herokuapp.com/?code=sPiR2.%3A.BQ&amp;input=11&amp;test_suite_input=2%0A3%0A4%0A5%0A6%0A7%0A8%0A9%0A10%0A11&amp;debug=0" rel="nofollow">Try it online</a> or run the <a href="http://pyth.herokuapp.com/?code=sPiR2.%3A.BQ&amp;input=11&amp;test_suite=1&amp;test_suite_input=2%0A3%0A4%0A5%0A6%0A7%0A8%0A9%0A10%0A11&amp;debug=0" rel="nofollow">Test Suite</a></p>

<h3>Explanation:</h3>

<pre><code>sPiR2.:.BQ    ##   Q = eval(input())
       .BQ    ##   get binary string of Q
     .:       ##   get all substrings of that
  iR2         ##   convert them all to base 10
sP            ##   sum all but the last element, which is the input number
</code></pre>
</div>
<div id="pu8" class="pu"><h2>PowerShell v2+, 138 Bytes</h2>

<pre><code>param($a)$a=[convert]::ToString($a,2);(($b=$a.length-1)..1|%{$l=$_;0..($b-$l+1)|%{[convert]::ToInt32($a.substring($_,$l),2)}})-join'+'|iex
</code></pre>

<p>Ooof. That conversion to/from binary is expensive.</p>

<p>Takes input <code>$a</code>, then uses the <a href="https://msdn.microsoft.com/en-us/library/14kwkz77(v=vs.110).aspx" rel="nofollow">.NET call <code>[convert]::ToString($a,2)</code></a> to turn it into the binary representation. From there, we go through two loops -- the first counts backwards from the end of the string down to <code>1</code>, and the second counts upward from <code>0</code>. (The first is how long of a substring to pull out, and the second is the index of where in the string to start the substring.) We set a helper <code>$l</code> along the way to pass that through to the inner loop.</p>

<p>Inside the inner loop, we use another <a href="https://msdn.microsoft.com/en-us/library/1k20k614(v=vs.110).aspx" rel="nofollow">.NET call <code>[convert]::ToInt32()</code></a> to convert the appropriate <code>.substring()</code> from base <code>2</code> into an integer. Each of those is then left on the pipeline. We encapsulate all of that with parens <code>()</code> and <code>-join</code> them together with a <code>+</code>, then toss that off to <code>iex</code> (short for <code>Invoke-Expression</code> and similar-ish to <code>eval</code>).</p>

<p><sub>I <em>think</em> this technically requires v2 or newer to properly call the .NET calls.</sub></p>
</div>
<div id="pu9" class="pu"><h1>CJam, <s>27</s> 21 bytes</h1>
<p>Shoutout to Dennis for helping me save 6 bytes!</p>
<pre><code>q~:Q{)Q2bew2fb~}%1bQ-
</code></pre>
<p>Works only with the newest version of CJam (available on TIO). <a href="http://cjam.tryitonline.net/#code=cX46UXspUTJiZXcyZmJ-fSUxYlEt&amp;input=MTE" rel="nofollow noreferrer">Try it online</a>!</p>
<p><strong>Old version:</strong></p>
<pre><code>qi2b_,,0-\f{ew}{{2b}%}%e_:+
</code></pre>
<p><a href="http://cjam.aditsu.net/#code=qi2b_%2C%2C0-%5Cf%7Bew%7D%7B%7B2b%7D%25%7D%25e_%3A%2B&amp;input=11" rel="nofollow noreferrer">Try it online</a>.</p>
</div>
<div id="pu10" class="pu"><h2>JavaScript (ES6), 78 bytes</h2>

<pre><code>n=&gt;[...n.toString(2)].map(c=&gt;[...s+=c].map((_,i)=&gt;n-='0b'+s.slice(i)),s='')|-n
</code></pre>

<p>The outer <code>map</code> builds up leading substrings of <code>n</code>'s binary representation; the inner one extracts trailing substrings of the leading substrings, thus covering all possible substrings, including the original binary representation.</p>

<p>Each substring is converted from binary back to decimal and subtracted from the original input as this is slightly shorter than adding them together and subtracting the original input.</p>
</div>
<div id="pu11" class="pu"><h2>Python 3, 111 characters</h2>
<pre><code>N=bin(int(input()))[2:];L=len(N);r=range;print(sum(int(n,2)for n in[N[j:j+i]for i in r(1,L)for j in r(L-i+1)]))
</code></pre>
<p><strong>EDIT</strong>: Explanation:</p>
<pre><code>N=bin(int(input()))[2:]
</code></pre>
<p>Convert input string to an int, then the int to a binary string and remove its first two characters, since the <code>bin</code> method returns a string in the format of <code>0b...</code></p>
<p>Take all substrings of the binary string, convert them to decimal using <code>int(n, 2)</code> and sum them.</p>
<pre><code>[N[j:j+i]for i in r(1,L)for j in r(L-i+1)]
</code></pre>
<p>is a list of all substrings. Ungolfed version:</p>
<pre><code>def all_substrings(N):
    result = []
    for i in range(1, len(N)):
        for j in range(len(N) - i + 1):
            result.append(N[j:j+i])
    return result
</code></pre>
<p>Hope this helps.</p>
</div>
<div id="pu12" class="pu"><h1>Jelly, <s>10</s> 7 bytes</h1>

<pre><code>BṡRḄFS_
</code></pre>

<p><a href="http://jelly.tryitonline.net/#code=QuG5oVLhuIRGU18&amp;input=&amp;args=MTE">Try it online!</a></p>

<h3>How it works</h3>

<pre><code>BṡRḄFS_  Main link. Input: n

B        Convert n to base 2.
  R      Yield [1, ..., n].
 ṡ       Get all overlapping slices of lengths 1 to n.
         This yields empty arrays if the slice size is longer than the binary list.
   Ḅ     Convert each binary list to integer.
    F    Flatten the resulting, nested list.
     S   Compute the sum of the result.
      _  Subtract n from the sum.
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/73793/">73793</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




