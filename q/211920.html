<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::211920</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>016</td><td>Haskell + hgl + TypeApplications</td><td>240315T162754Z</td><td><a href="https://codegolf.stackexchange.com/questions/211920/parse-a-nested-parentheses/271848#271848">Wheat Wi</a></td></tr>
<tr d-ix="1"><td>122</td><td>Python 2</td><td>201003T182241Z</td><td><a href="https://codegolf.stackexchange.com/questions/211920/parse-a-nested-parentheses/211995#211995">pan</a></td></tr>
<tr d-ix="2"><td>076</td><td>Haskell</td><td>201004T131053Z</td><td><a href="https://codegolf.stackexchange.com/questions/211920/parse-a-nested-parentheses/212023#212023">Wheat Wi</a></td></tr>
<tr d-ix="3"><td>031</td><td>Retina 0.8.2</td><td>201001T233325Z</td><td><a href="https://codegolf.stackexchange.com/questions/211920/parse-a-nested-parentheses/211921#211921">Neil</a></td></tr>
<tr d-ix="4"><td>022</td><td>Perl 5</td><td>201002T101610Z</td><td><a href="https://codegolf.stackexchange.com/questions/211920/parse-a-nested-parentheses/211936#211936">Nahuel F</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://www.haskell.org" rel="nofollow noreferrer">Haskell</a> + <a href="https://gitlab.com/wheatwizard/haskell-golfing-library" rel="nofollow noreferrer">hgl</a> + TypeApplications, 16 bytes</h1>
<pre><code>st&lt;gj&lt;uP(ν @())
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=m708I7E4OzUnZ8FN52pdZQWfxLz00sT0VIWQyoJUx4KCnMzkxJLM_LxiBWXdWq7M3IL8ohKFwtLEnMy0zNQUhYCi1JzSlFSYRMDS0pI0XYtNabbFJTbpWTalARrn9io4aGhqQiRueuUmZuYp2Cqk5HMpKBQUKagopCkoaWgqeABdkK-EJBaTp6GgoRlTohmT54EsDhRV0NQEIiWIiQsWQGgA" rel="nofollow noreferrer">Attempt This Online!</a></p>
<h2>Explanation</h2>
<p><code>ν</code> is the general purpose read parser, so when given the <code>()</code> type it basically does exactly the desired task. However, there are two issues</p>
<ol>
<li>The question wants the remainder, and parsers are generally set up to get the value not the remainder.</li>
<li>The question actually wants what is considered the lowest priority parse, i.e. the parse that trims the least whitespace. Parsers generally like to get higher priority parses</li>
</ol>
<p>To solve this we just dump the most verbose parser output using <code>uP</code>.  <code>gj</code> gets the lowest priority pair and <code>st</code> grabs the result from the pair.</p>
<h1><a href="https://www.haskell.org" rel="nofollow noreferrer">Haskell</a> + <a href="https://gitlab.com/wheatwizard/haskell-golfing-library" rel="nofollow noreferrer">hgl</a>, 17 bytes</h1>
<pre><code>st&lt;gj&lt;uP(mp()&lt;ν)
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=m708I7E4OzUnZ8FNxczcgvyiEoXC0sSczLTM1BSFgKLUnNKUVC6oRMDS0pI0XYvNabbFJTbpWTalARq5BRqaNuf2akJkbnrlJmbmKdgqpORzKSgUFCmoKKQpKGloKngALchXQhKLydNQ0NCMKdGMyfNAFgeKKmhqApESxMQFCyA0AA" rel="nofollow noreferrer">Attempt This Online!</a></p>
<h2>Explanation</h2>
<p>This is basically the same as the last one, except without type application we can't tell it what type to parse directly.  Instead we want to map a function across the parser with the type <code>() -&gt; a</code> where <code>a</code> is any type. This will force a type of <code>()</code> onto the output.  Taking <code>()</code> as an input is pretty uncommon.  The shortest I could find is <code>mp()</code>, which uses the semigroup action to combine two <code>()</code>s.</p>
<h1>18 bytes</h1>
<pre><code>gk$mp()&lt;ivP ν*&gt;h'
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=m708I7E4OzUnZ8FN52pdZQWfxLz00sT0VIWQyoJUx4KCnMzkxJLM_LxiBWXdWq7M3IL8ohKFwtLEnMy0zNQUhYCi1JzSlFSYRMDS0pI0XYstabbp2Sq5BRqaNpllAQrn9mrZZahDpG565SZm5inYKqTkcykoFBQpqCikKShpaCp4AN2Qr4QkFpOnoaChGVOiGZPngSwOFFXQ1AQiJYiJCxZAaAA" rel="nofollow noreferrer">Attempt This Online!</a></p>
<p>This version has no post processing after the parse, i.e. the top level function performs a parse.</p>
<h2>Explanation</h2>
<p>This solves the two issues in a different way. It uses <code>ivP</code> to invert the parse priorities on <code>ν</code>. Then to get the remainder use <code>h'</code> which parses anything, and <code>*&gt;</code> to discard the results from <code>ν</code> in favor of <code>h'</code>.  This means it first parses with <code>ν</code>, inverts the priorities and then parses whatever is left as the result.</p>
<p>At the top level we use <code>gk</code> to get the highest priority parse.</p>
<h1><a href="https://www.haskell.org" rel="nofollow noreferrer">Haskell</a> + <a href="https://gitlab.com/wheatwizard/haskell-golfing-library" rel="nofollow noreferrer">hgl</a> (no <code>ν</code>), 28 bytes</h1>
<pre class="lang-haskell prettyprint-override"><code>g=p__&lt;*enP(g?&lt;&gt;p__)
</code></pre>
<pre><code>gk$g*&gt;h'
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=m708I7E4OzUnZ8FNxczcgvyiEoXC0sSczLTM1BSFgKLUnNKUVC6oRMDS0pI0XYt9abbp2SrpWnYZ6lzptgXx8TZaqXkBGun2NnZAjiZE0U2v3MTMPAVbhZR8LgWFgiIFFYU0BSUNTQUPoF35SkhiMXkaChqaMSWaMXkeyOJAUQVNTSBSgpi4YAGEBgA" rel="nofollow noreferrer">Attempt This Online!</a></p>
<h1>Reflection</h1>
<p>I think these do decently, but I have a lot of notes on how to improve.</p>
<ul>
<li>There should be a version of <code>gk</code> to get the lowest priority parse.</li>
<li>There should be some parse runners that return the remainder rather than the result.</li>
<li>While I did have fun trying to find the shortest way to coerce the type of <code>ν</code>, extremely polymorphic <code>ν</code> should come with built-in ways to do this. The way to do this would be to make a version of <code>ν</code> which a witness value as input, and always returns something of the same type. If this were 3 bytes it would actually save bytes over using a type application in this case.</li>
<li>You might notice <code>uP&lt;ν</code> is really just an expensive way to do <code>reads</code>.  I don't actually export any version of <code>reads</code>. This sort of makes sense, I haven't really invested the time into making <code>Read</code> related functions, but if <code>ν</code> exists, <code>reads</code> should probably exist.</li>
<li><code>(p__*&gt;)</code> and <code>(&lt;*p__)</code> to trim leading and trailing whitespace respectively are both way too expensive, there should be built in shortcuts.</li>
<li>There should be a flip of <code>mpY</code>.</li>
<li><code>lSo</code> and <code>lMy</code> should return a specific type, probably <code>Nat</code>.</li>
<li>I noticed there's no version of <code>py</code> which counts the number of results. It wouldn't be helpful in any way here, but I feel like that should exist.</li>
</ul>
</div>
<div id="pu1" class="pu"><h1>Python 2, 122 bytes</h1>

<pre class="lang-python prettyprint-override"><code>def f(s,c=0,p='('):a=s[:1];return[f(s[1:],c+&quot;()&quot;.find(a)%-3+1,[p,a][a&gt;p])if(a in(p,')'))|a.isspace()else 0,s][`c`+p==&quot;0)&quot;]
</code></pre>
<p>Returns <code>0</code> on error.</p>
<p><a href="https://tio.run/##TVDRasMwDHzvV6iGYIm4JeneUtzn/oMx1CQ2DQTb2B5jsH/P3Gzrek@nk3ScFD/LPfjTuk7WgcMsRtmJKDlyGozMauj1OdnynryqXdUPWowtQ2JHN/sJDTWHt7YXKgqjlblETbNDA7PHKDhxoi9znHOOZrRIdskWOpG1uo23NkrJOmJ6LTaXDBJwBxUPc/HDAIHgapcl/CmISA88a6g13C1hOP9qnL/M/u8Rvmxdn3RzF/AR0jLtq0g7FxKUegBssYZtLKbZF2RNgsMFmsSgASyi/qvULOs3" rel="nofollow noreferrer" title="Python 2 – Try It Online">Try it online!</a></p>
<h3>Python 3, 125 bytes</h3>

<pre class="lang-python prettyprint-override"><code>def f(s,c=0,p='('):a=s[:1];return[f(s[1:],c+&quot;()&quot;.find(a)%-3+1,[p,a][a&gt;p])if(a in(p,')'))|a.isspace()else 0,s][(c,p)==(0,')')]
</code></pre>
<p>Returns <code>0</code> on error.</p>
<p><a href="https://tio.run/##TVBBisMwDLz3FdpAsETVktBbinvuH4wPJrGpIcTG9rIs7N9TN93tVqfRaGaQFL/LLSyndZ2sA4eZR9lxlAIFDUZmNfT6nGz5TIuqU9UPmsd9g9QcnV8mNNQeTvueVWSjlblETd6hAb9gZEGC6Mccfc7RjBbJztlCx1krHDmSlNhtIr0Wm0sGCbiDWo98fiJAILjaeQ5/DCLSo1491B5uljCcfzkh3rT/PsI31/UFt3SGr5Dm6aOStHMhQak3wLbWsMli8kvBpk1wuECbGmgBC9eXlbrLegc" rel="nofollow noreferrer" title="Python 3 – Try It Online">Try it online!</a></p>
<hr />
<h3>Python 2 (non-recursive), <s>173</s> <s>170</s> <s>166</s> 153 bytes</h3>

<pre class="lang-python prettyprint-override"><code>def p(s):c=i=a=0;t="""
while i&lt;len(s):
 if~-s[i].isspace():
&#9;if%r!=s[i]:break
&#9;c+=%s
 i+=1""";exec t%('(','1')+t%(')',"-1\n\tif c==0:a=s[i+1:]");return a
</code></pre>
<p>Returns <code>0</code> on error.</p>
<p><a href="https://tio.run/##TZDBboMwEETP4SsmlizvCqhCj1D3nH9ocqDECKvIINtV2kt/nRraptnT7NvZ0WrnzzhM7nFZLqbHTIHrTlvd6kMTtRAiuw52NLBPo3HrMIPtv8rwYs8PNoS57QwluLO99Hu94vrVm/Yt23W5liG5c12lmMZ8mA5RkiJVqEpxvmpWhSirkztF26PT@lC3a0Ze1WfBjTfx3Tu0SzQhBmhQhlSCWBQ/CgTG0Yzj9EeIiNe69Ug9BsM0Nb9MqTvv/x7T3dbxJrf0AtfJj5d9gpz1k0eEddjOqjfb7K2LENKjfIb0AhIUi/TOyLx8Aw" rel="nofollow noreferrer" title="Python 2 – Try It Online">Try it online!</a></p>
<p>We could save another 2 bytes if we returned the original string on error, but then inputs <code>'()'</code> and <code>''</code> would give the same output <code>''</code>.</p>
<ul>
<li>-4 bytes, thanks to @ovs !</li>
</ul>
</div>
<div id="pu2" class="pu"><h1><a href="https://www.haskell.org/" rel="nofollow noreferrer">Haskell</a>, <s>83</s> 76 bytes</h1>

<pre class="lang-hs prettyprint-override"><code>c?(a:b)|elem a&quot; \t\n\r\v\r&quot;=c?b|a==c=[b]
_?_=[]
f x='('?x&gt;&gt;=(:)&lt;*&gt;f&gt;&gt;=(')'?)
</code></pre>
<p><a href="https://tio.run/##ZYzBCoMwEETvfsWQi7ul9ANKY36g/QIjsorSko2ISvHQf7cR2kvL7mHezDB3mUOnum2tIzk3/Oq0ixADv/jBT/7pJ2Nb17zE2taWTZXVrrZllfVYbU65W4vC0pkvh6LfVc654y3KY7BRxlsNGqfHsOCEnjOghAEhPRODAQ0STfKPMMQfgT1PlwoMjTL/@PgPiJgJVwnzdy2VRFXDlxOEWXeotjc" rel="nofollow noreferrer" title="Haskell – Try It Online">Try it online!</a></p>
<p>Since this question to imitate Haskell's parsing I thought it would be nice to give this a try using Monadic parsing in Haskell.  The result is actually really short. I use <code>[]</code> as my monad because it is just way shorter than <code>Maybe</code> or <code>Either</code>.</p>
<hr />
<h3>What is monadic parsing?</h3>
<p>Put simply monadic parsing is a type of parsing in which a parser is a function from a string to some optional type of a the remaining string and some data</p>
<pre class="lang-hs prettyprint-override"><code>type Parser a = String -&gt; Option (a, String)
</code></pre>
<p>Here our <code>Option</code> type is a list, and we are just validating rather than producing any data, so our parser looks like:</p>
<pre class="lang-hs prettyprint-override"><code>type Parser a = String -&gt; [ String ]
</code></pre>
<p>Where our parser takes some string and returns all possible suffixes of valid parses.  The empty string represents a failure to parse because no suffixes means that no valid parse was found.</p>
<p>This way of structuring things makes it super easy to combine parsers.  For example if we have a parser <code>p</code> which parses the regex <code>\s*(</code> and a parser <code>q</code> which parses the regex <code>\s*)</code> then we can make a parser that parses the expression <code>\s*(\s*)</code> using the Kleisli arrow</p>
<pre class="lang-hs prettyprint-override"><code>(&gt;=&gt;) :: (a -&gt; m b) -&gt; (b -&gt; m c) -&gt; (a -&gt; m c)
</code></pre>
<p>Meaning the result is <code>p &gt;=&gt; q</code>.  We can also do other combinators.</p>
<hr />
<p>So here's how I use it in my answer.</p>
<p>The first thing we do is implement <code>?</code>, which takes a character <code>c</code> returns a parser the regex <code>\s*c</code> (where <code>c</code> is the character).  Essentially this consumes a prefix made of any amount of whitespace followed by a single character.  This is only ever called on <code>(</code> and <code>)</code>.</p>
<p>With this we implement <code>f</code> which is the parser that the challenge asks for.  We don't actually have the Kleisli arrow in Prelude but I will write it as if we did for clarity and then show how we remove Kleisli arrows.</p>
<pre class="lang-hs prettyprint-override"><code>f = ('('?) &gt;=&gt; (:)&lt;*&gt;f &gt;=&gt; (')'?)
</code></pre>
<p>So we have three parsers first, it must start with some whitespace followed by a <code>(</code> then some gobbledygook parser and then it must end with some whitespace followed by a <code>)</code>.</p>
<p>The gobbledygook <code>(:)&lt;*&gt;f</code> can be expressed more clearly as</p>
<pre class="lang-hs prettyprint-override"><code>\ x -&gt; x : f x
</code></pre>
<p>Which is to say it is it matches everything the <code>f</code> parser does but also matches the empty string.</p>
<p>So our <code>f</code> parser matches:</p>
<blockquote>
<p>Parentheses enclosing, either the empty string or another f.</p>
</blockquote>
<p>Now to remove our Kleisli arrows we use <code>&gt;&gt;=</code> which has the similar type signature:</p>
<pre class="lang-hs prettyprint-override"><code>(&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b
</code></pre>
<p>So we take an argument from f, pass it to the first parser and change all of our <code>(&gt;=&gt;)</code>s to <code>(&gt;&gt;=)</code>s.</p>
</div>
<div id="pu3" class="pu"><h1><a href="https://github.com/m-ender/retina/wiki/The-Language/a950ad7d925ec9316e3e2fb2cf5d49fd15d23e3d" rel="nofollow noreferrer">Retina 0.8.2</a>, <s>32</s> 31 bytes</h1>
<pre><code>^(\s*\()+(?&lt;-1&gt;\s*\))+(?(1)$.)

</code></pre>
<p><a href="https://tio.run/##K0otycxL/K@q4Z7wP04jplgrRkNTW8PeRtfQDsTRBHE0DDVV9DS5/v/X0ORS0FDQVPBIzcnJ59LQ0NAEAS7X3IKSSoXikqLMvHSwKJDQBMpxaXhocoHV6iiU5xflpCgCAA" rel="nofollow noreferrer" title="Retina 0.8.2 – Try It Online">Try it online!</a> Link includes test cases. Returns the original string on error. Considers the given control characters as white space, plus any Unicode characters (such as space) in the Separator group, plus U+0085. If only the minimal white space is desired, this can be achieved by prefixing <code>e`</code>. Explanation:</p>
<pre><code>^(\s*\()+
</code></pre>
<p>Match some open parentheses at the start of the string.</p>
<pre><code>(?&lt;-1&gt;\s*\))+
</code></pre>
<p>Match some close parentheses.</p>
<pre><code>(?(1)$.)
</code></pre>
<p>Check that the same number of open and close parentheses were matched.</p>
<pre><code>
</code></pre>
<p>Delete the matched parentheses.</p>
<p>Alternative solution, also 31 bytes:</p>
<pre><code>r`^(?&lt;-1&gt;\s*\()+(\s*\))+(.*)
$2
</code></pre>
<p><a href="https://tio.run/##K0otycxL/K@q4Z7wvyghTsPeRtfQLqZYK0ZDU1sDRGsCaT0tTS4Vo///NTS5FDQUNBU8UnNy8rk0NDQ0QYDLNbegpFKhuKQoMy8dLAokNIFyXBoemlxgtToK5flFOSmKAA" rel="nofollow noreferrer" title="Retina 0.8.2 – Try It Online">Try it online!</a> Link includes test cases. If only the minimal white space is desired, this can be achieved by prefixing <code>e</code>. Explanation:</p>
<pre><code>r`
</code></pre>
<p>Start matching at the end of the string and work backwards (like a lookbehind would).</p>
<pre><code>(.*)
</code></pre>
<p>Match as much result as possible.</p>
<pre><code>(\s*\))+
</code></pre>
<p>Match some close parentheses.</p>
<pre><code>^(?&lt;-1&gt;\s*\()+
</code></pre>
<p>Match the open parentheses at the start of the string. The number of close parentheses must be at least as many as the number of open parentheses for the balancing group to succeed, but it can't be more because the <code>(.*)</code> ensures that as few close parentheses are matched as possible.</p>
<pre><code>$2
</code></pre>
<p>Keep everything except the matched parentheses.</p>
<p>Previous 32-byte solution that returns the empty string on error:</p>
<pre><code>1!`(?&lt;=^(?&lt;-1&gt;\s*\()+(\s*\))+).*
</code></pre>
<p><a href="https://tio.run/##K0otycxL/K@q4Z7w31AxQcPexjYOSOga2sUUa8VoaGprgGhNTW1NPa3//zU0uRQ0FDQVPFJzcvK5NDQ0NEGAyzW3oKRSobikKDMvHSwKJDSBclwaHppcYLU6CuX5RTkpigA" rel="nofollow noreferrer" title="Retina 0.8.2 – Try It Online">Try it online!</a> Link includes test cases. If only the minimal white space is desired, this can be achieved by prefixing <code>e</code>. Explanation:</p>
<pre><code>1!`
</code></pre>
<p>Output the matched part of the first match.</p>
<pre><code>(?&lt;=^(?&lt;-1&gt;\s*\()+(\s*\))+)
</code></pre>
<p>Ensure that the match starts after balanced parentheses. Note that this is a lookbehind, so the match is processed right-to-left - the <code>)</code>s are matched first, then a <code>(</code> can be matched for each <code>)</code>. There can't be too many <code>)</code>s because the lookbehind would have matched earlier, meaning that this is no longer the first match.</p>
<pre><code>.*
</code></pre>
<p>Match the rest of the string. This actually counts as part of the match, and therefore becomes the resulting output.</p>
</div>
<div id="pu4" class="pu"><h1><a href="https://www.perl.org/" rel="nofollow noreferrer">Perl 5</a>, (-p) 22 bytes</h1>

<pre class="lang-perl prettyprint-override"><code>s/^(\s*\((?1)?\s*\))//
</code></pre>
<p><a href="https://tio.run/##HYo7CoAwEET7PcXazYoSLKytBA8hVooEYhKSgHh5188Uw2PexC25XjWbBXOuZ2DoZPhIxBhVCDFYeNqcCwRAvtB4xHJxLsn6/V/fktcRJqH/2/AZklurO8Rig8/axgc" rel="nofollow noreferrer" title="Perl 5 – Try It Online">Try it online!</a></p>
<p>Using recursive regex. The shorter <code>\s*\((?0)?\s*\)</code> didn't work because of start anchor missing.</p>
<p>The error case is given by the result of substitution operation :</p>
<ul>
<li>1 - success</li>
<li>&quot;&quot; - failed</li>
</ul>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/211920/">211920</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




