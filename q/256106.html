<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::256106</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>330</td><td>APLNARS</td><td>240119T193429Z</td><td><a href="https://codegolf.stackexchange.com/questions/256106/implement-the-riemann-r-function/269379#269379">Rosario</a></td></tr>
<tr d-ix="1"><td>081</td><td>Julia</td><td>230105T075825Z</td><td><a href="https://codegolf.stackexchange.com/questions/256106/implement-the-riemann-r-function/256373#256373">ceilingc</a></td></tr>
<tr d-ix="2"><td>099</td><td>Python + SymPy</td><td>230101T185657Z</td><td><a href="https://codegolf.stackexchange.com/questions/256106/implement-the-riemann-r-function/256243#256243">The Thon</a></td></tr>
<tr d-ix="3"><td>008</td><td>Wolfram Language Mathematica</td><td>221228T114926Z</td><td><a href="https://codegolf.stackexchange.com/questions/256106/implement-the-riemann-r-function/256108#256108">Ad&#225;</a></td></tr>
<tr d-ix="4"><td>145</td><td>C gcc</td><td>230102T010221Z</td><td><a href="https://codegolf.stackexchange.com/questions/256106/implement-the-riemann-r-function/256254#256254">ceilingc</a></td></tr>
<tr d-ix="5"><td>028</td><td>Python + mpmath</td><td>230101T154735Z</td><td><a href="https://codegolf.stackexchange.com/questions/256106/implement-the-riemann-r-function/256241#256241">zoomlogo</a></td></tr>
<tr d-ix="6"><td>044</td><td>Vyxal</td><td>230101T125248Z</td><td><a href="https://codegolf.stackexchange.com/questions/256106/implement-the-riemann-r-function/256233#256233">lyxal</a></td></tr>
<tr d-ix="7"><td>040</td><td>PARI/GP</td><td>221229T030104Z</td><td><a href="https://codegolf.stackexchange.com/questions/256106/implement-the-riemann-r-function/256130#256130">alephalp</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>APL(NARS), 330 chars</h1>
<pre><code>F←{0⌈(⌊1+10⍟⍵)-⍨⌊3.322÷⍨⎕fpc-1}

r←p z q;n;t;w;m;d;y;h;e
→2×⍳∼q=1⋄r←∞⋄→0
t←q×¯1v⋄r←q-q⋄e←÷10x*p⋄n←0v⋄w←1v
→7×⍳e&gt;w×←0.5v
y←d←1v⋄h←n+1⋄m←0v
h-←1⋄y+←(t*⍨m+1)×d×←¯1×h÷m+←1⋄→5×⍳m&lt;n
r+←w×y⋄n+←1⋄→3
r÷←1-2*1+t

r←R q;L;n;d;m;e;y
y←q×1v⋄r←1v⋄L←⍟y⋄n←0⋄d←1v⋄e←÷10x*2+F q
r+←m←(÷n×(⌊⎕fpc÷4.1)z n+1)×d×←L÷n+←1⋄→2×⍳e&lt;∣m

⍪{{⍵⍕⍨1⌈¯8+F⍵}R⍵}¨10v*1..31
</code></pre>
<p>32+ 24+16+33+14+18+38+15+10 +18+39+45 +28=330</p>
<p>z should be the Riemann Zeta function that stop calc until p digits
after the decimal point, with input one number that should be
integer, float, big float,complex, big float clomplex and one output that
has to be big float or big float complex (I'm not sure of this speech 100%).
It seems if the number is not a complex the calculation in z function is done
not use complex operations but only float or big float operations. I'm not sure is safe to use ∞ as result for zeta in case input 1.</p>
<p>R it seems to be the Riemann R function cut on the possible digits
it can reach from the instruction (⌊⎕fpc÷4.1) for speed reason,
seen what the question ask too.</p>
<p>It seems:</p>
<ol>
<li><p>⎕fpc it is the lenght in bit of the float point number of type &quot;NumbeRv&quot;</p>
</li>
<li><p>⌊1+10⍟⍵ it should be the lenght in decimal digit of the integer part of number in ⍵</p>
</li>
<li><p>⌊3.322÷⍨⎕fpc-1 it should be the lenght in decimal digit of each float type &quot;NumbeRv&quot;</p>
</li>
<li><p>F ⍵ it should be the max lenght in decimal digit of fractional part number in ⍵,
so it is the right place where end the computation</p>
</li>
<li><p>It seems is asked one decimal ¯8 + teoretical possible 128 bit precision for the calculus and for
show the number</p>
</li>
<li><p>In function (r←p z q), if it was used the instruction r←q-q
the calculation in z not use big complex float, but only big float</p>
</li>
<li><p>It seems 2+F q is safe as precision for R q (not for all other numbers return z function in R)</p>
<pre><code>   ⍪{{⍵⍕⍨1⌈¯8+F⍵}R⍵}¨10v*1..31
</code></pre>
<p>4.56458314100509023986577469558<br />
25.6616332669241825932267979404<br />
168.359446281167348064913310987<br />
1226.93121834343310855421625817<br />
9587.43173884197341435161292391<br />
78527.3994291277048588702921410<br />
664667.447564747767985346699888<br />
5761551.86732016956230886495974<br />
50847455.4277214275139488757726<br />
455050683.306846924463153241582<br />
4118052494.63140044176104610771<br />
37607910542.2259102347456960174<br />
346065531065.826027197892925730<br />
3204941731601.68903475050075412<br />
29844570495886.9273782222867278<br />
279238341360977.187230253927299<br />
2623557157055978.00387546001566<br />
24739954284239494.4025216514448<br />
234057667300228940.234656688561<br />
2220819602556027015.40121759224<br />
21127269485932299723.7338640440<br />
201467286689188773625.159011875<br />
1925320391607837268776.08025287<br />
18435599767347541878146.8033590<br />
176846309399141934626965.830969<br />
1699246750872419991992147.22186<br />
16352460426841662910939464.5782<br />
157589269275973235652219770.569<br />
1520698109714271830281953370.16<br />
14692398897720432716641650390.6<br />
142115097348080886394439772958.2</p>
</li>
</ol>
<p>one calculation that takes 15' here...
it is possible change the number of bit of big float for to have</p>
<pre><code>   ⎕fpc←64
   ⍪{{⍵⍕⍨F⍵}R⍵}¨10v*⍳3
4.56458314100509191 
25.6616332669242044 
168.359446281167561 
</code></pre>
<p>with the last 3 or 4 decimal digits wrong it seems for the instruction<br />
(⌊⎕fpc÷4.1) that should be (⌊⎕fpc÷3.322) for to have what it seems to me
the exact solution (with about 2x the time for calculus here some second
only for this)</p>
<pre><code>   ⍪{{⍵⍕⍨F⍵}R⍵}¨10v*⍳3
4.56458314100509024 
25.6616332669241826 
168.359446281167348 
</code></pre>
</div>
<div id="pu1" class="pu"><h1><a href="https://julialang.org" rel="nofollow noreferrer">Julia</a>, <s>141 138 133 125</s> 81 bytes</h1>
<pre><code>h(x,a=big(1.))=1-sum(k-&gt;(a*=log(x)/k)/sum(n-&gt;(-1)^n/n/n^k,1:99)/k*(1-2^-k),a:200)
</code></pre>
<p>-44 thanks to @MarcMush</p>
<p><a href="https://tio.run/##FYlBDsIgEADvfQXH3QaEraeS4MGDzyDBqBShYGqb8HvEmdvM@0jBUW1tgcqduQcPdEI0JL7HClFcwI0mFQ8VZUT5j7lHQWiz7NrISc9znyOQmKyIyJ2elML2KhsLhvSZBtb5bCHvKQNbgJS9Bn9Lxe0QEBkOz/xoPw" rel="nofollow noreferrer" title="Julia 1.0 – Try It Online">Try it online!</a></p>
<p>Slightly less golfed.</p>
<pre><code>function h(x)
  B=BigFloat
  a=y=B(1);
  for K=1:200
    q=0;
    k=B(K);
    for n=1:99
      q-=(-1)^n/n/n^k
    end;
    a*=log(x)/k;
    y+=a/q/k*(1-2^-k)
  end;
  y
end
</code></pre>
<h1><a href="https://julialang.org" rel="nofollow noreferrer">Julia</a> using zeta() builtin, <s>209</s> 205 bytes</h1>
<pre><code>using Base.MPFR
function h(x)B=BigFloat;a=y=B(1);for K=1:187 k=B(K);a*=log(x)/k;z=B();ccall((:mpfr_zeta,:libmpfr),Int8,(Ref{BigFloat},Ref{BigFloat},Int8),z,k+1,Base.MPFR.ROUNDING_MODE[]);y+=a/k/z end;y end
</code></pre>
<p><a href="https://tio.run/##VY9LC8IwEITv/RU5ZjVYgwelIZfiAxEfFDyJSqxtjY2p1BRsxd9ek4OCe1iYYdj95lopKeizbauH1BkKxSPpLTfTyEsrHRtZaHTBTwh5KLOpKoRhgtc8xBRYWpRowWlAR0OUW2sBTHS4KjKb93PWWAtYHAulMA5u97Q8NokRJFDy5BSQuTYjgqMkfX2Pv8m/cgkgDcm7lPzIetF6uxrPV7Pjcj2e7PbA6i4Xfu43KNFnVrvdOjhp4QbUQ3bupdRGaWzL0P7h@wBLAASey38A" rel="nofollow noreferrer" title="Julia 1.0 – Try It Online">Try it online!</a></p>
<p>Slightly golfed less.</p>
<pre><code>using Base.MPFR
function h(x)
  B=BigFloat;
  a=y=B(1);
  for K=1:187
    k=B(K);
    a*=log(x)/k;
    z=B();
    ccall((:mpfr_zeta,:libmpfr),Int8,(Ref{BigFloat},Ref{BigFloat},Int8),z,k+1,Base.MPFR.ROUNDING_MODE[]);
    y+=a/k/z
  end;
  y
end
</code></pre>
</div>
<div id="pu2" class="pu"><h1><a href="https://www.python.org" rel="nofollow noreferrer">Python</a> + <a href="https://SymPy.org" rel="nofollow noreferrer">SymPy</a>, <s>103</s> 99 bytes</h1>
<pre class="lang-python prettyprint-override"><code>lambda x:1+Sum(ln(x)**k/k/gamma(k+1)/zeta(k+1),(k,1,oo)).evalf(50)
from sympy import*;k=Symbol('k')
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=LY27boMwFED3fsXdfK_jAKaqVKViz85aRXISTFy_kDEV9Fe6IEXtP_VvOpDpnOmc799hybcY1rtu3n-mrPevfxen_PmqYD7IXTt5dAFn4tyWtuyV9wrtTlL51eXNBFohRYxERfepnMaXip50ih7GxQ8LGD_ElPmbbdrFn6NDZhk9VkcdExgwAZIKfYdSPNd0GJIJGZlGkBWcmBhzQkOF-5jGjLVgwEgwgoYJjbLi3NCjt64b_wE" rel="nofollow noreferrer">Attempt This Online!</a> Takes ~30s on ATO for all 31 test cases.</p>
<ul>
<li>Thanks to Simd for posting <a href="https://chat.stackexchange.com/transcript/message/62679526#62679526">this chat message</a></li>
<li>-4 thanks to ceilingcat</li>
</ul>
</div>
<div id="pu3" class="pu"><h1><a href="https://www.wolfram.com/wolframscript/" rel="nofollow noreferrer">Wolfram Language (Mathematica)</a>, 8 bytes</h1>
<pre><code>RiemannR
</code></pre>
<p><a href="https://tio.run/##y00syUjNTSzJTE78n2b7PygTyMnLC/ofUJSZV@KQ5mBokGBpyYXgoXNR@Bpg1XHGhpr/AQ" rel="nofollow noreferrer" title="Wolfram Language (Mathematica) – Try It Online">Try it online!</a></p>
</div>
<div id="pu4" class="pu"><h1><a href="https://gcc.gnu.org/" rel="nofollow noreferrer">C (gcc)</a>, <s>193 183 173 165 154</s> 145 bytes</h1>

<pre class="lang-c prettyprint-override"><code>typedef _Float128 X;X logq();i,k;r(X x,X*y){for(X a=*y=k=1,q;k&lt;187;*y-=(ldexp(a*=logq(x)/k++,-k)-a)/q)for(i=23,q=0;--i;)q+=(i%2?k:-k)*pow(i,~k);}
</code></pre>
<p><a href="https://tio.run/##NY5NT4QwEIbv/IrJGkyntLtbOLixVG/evXEwmoavbcpXESNkgz9dBBJPM5P3fSZPyss0XZZh6vIsL@DjpWr1IMILJDKBqi0dQWmYlT1JYGQJnfBWtNuhFZ2UVYI5aWNxeZB04opUWT52RFO1oyOebBAwbpFrPDncSKPCiDl1lpwbiS5QxPjhs31cS7Rrv4lhPxblvNyZumv7IXZfOqv1cD1en7xam4bgzYP9UTOAUUKaOAqlCQKENQBIYJLb7Mlq4oihu4k4IzK4n3DPun6FC3IQ53c/A/8Yha/FW3NghsHemL15@U2LSpefC6/@Dda1/gM" rel="nofollow noreferrer" title="C (gcc) – Try It Online">Try it online!</a></p>
<p>This estimates the Riemann R function from the Gram series. Note that this uses a horribly obfuscated but faster converging implementation of the Riemann zeta function.</p>
<p><span class="math-container">$$\zeta(s)=\frac{1}{1-2^{1-s}}\sum_{n=1}^{\infty}\frac{(-1)^{n+1}}{n^s}$$</span></p>
<p>-1 thanks to @Simd. -8 thanks to @c--.</p>
<p>Slightly golfed less:</p>
<pre class="lang-c prettyprint-override"><code>typedef _Float128 X;
X logq();
i,k;
r(X x,X*y){
  for(X a=*y=k=1,q;k&lt;200;){
    /* estimate the Riemann zeta function */
    for(i=99,q=0;--i;)
      q+=(i%2?k:-k)*pow(i,~k);
    *y-=(ldexp(a*=logq(x)/k++,-k)-a)/q
  }
}
</code></pre>
</div>
<div id="pu5" class="pu"><h1><a href="https://www.python.org" rel="nofollow noreferrer">Python</a> + <a href="https://mpmath.org/" rel="nofollow noreferrer">mpmath</a>, 28 bytes</h1>
<pre class="lang-python prettyprint-override"><code>from mpmath import*
riemannr
</code></pre>
<p><a href="https://staging.ato.pxeger.com/run?1=NY5BCsIwEEX3OcXsmoRakgoigjcRIWBrR8wkTKYLz-KmGz2FF_E2FkuX__F5_z_f-SFDoml6jdJv9p-eU4SYY5ABMObEYhVjFwMRL5XvKebmkgscYedUnxgQkIADXTvt621rDgogM5Loyjs4V_WcoQhrNM39NhbRrfmzVay9sxbNjMyysd75AQ" rel="nofollow noreferrer">Attempt This Online!</a></p>
<h2>Not using the builtin, 84 bytes</h2>
<pre class="lang-python prettyprint-override"><code>from mpmath import*
f=lambda x:1+nsum(lambda k:log(x)**k/k/fac(k)/zeta(k+1),[1,inf])
</code></pre>
<p><a href="https://staging.ato.pxeger.com/run?1=NY9LCsIwFEXnXcWb-RJr2yiIFLoLHYlC_MTGNB_SV6huxUknuid3o0id3XMHB87jFW5UezcMz47UbPVeq-gt2GAl1aBt8JF4oqpG2sNJQl-KqWs7iyObsvEX7BnnJje5kkc0LL-fSaKZCpZuRaqd2rHRvbEhO4UWKlgWifIRNGgHUbrLGUW6mLMyAQhRO8KJKGA_Sb8MLUXULGuuXUs4Z79PoSg41-y7R_k_4AM" rel="nofollow noreferrer">Attempt This Online!</a></p>
</div>
<div id="pu6" class="pu"><h1><a href="https://github.com/Vyxal/Vyxal" rel="nofollow noreferrer">Vyxal</a>, 44 bytes</h1>
<pre><code>Þ∞KƛƛÞ∞K$›eĖṠ2l≬₈vḞ≈c*n¡*?∆Lne$/;∑;2l≬₈vḞ≈c›
</code></pre>
<p><a href="https://vyxal.pythonanywhere.com/#WyIiLCIiLCLDnuKInkvGm8abw57iiJ5LJOKAumXEluG5oDJs4oms4oKIduG4nuKJiGMqbsKhKj/iiIZMbmUkLzviiJE7Mmziiazigoh24bie4omIY+KAuiIsIiIsIjEwIl0=" rel="nofollow noreferrer">Try it Online!</a></p>
<p>I think this is correct. <a href="https://vyxal.pythonanywhere.com/#WyIiLCIiLCLDnuKInkvGm8abw57iiJ5LJOKAumXEluG5oDJs4oG94omIYypuwqEqP+KIhkxuZSQvO+KIkTsybOKBveKJiGPigLoiLCIiLCIxMCJd" rel="nofollow noreferrer">Might be 38 if there's an exact limit convergance somehow</a>.</p>
<p>Precision is met by having a) things evaluated to 256 decimal places when approximating and b) exact values used until an approximation is needed. Good luck getting this to return an actual answer in the time we have left in the universe. The algorithm should be correct though.</p>
<h2>Explained</h2>
<p>The main idea to find the sums of things with an infinite upper bound is to check every overlapping pair of items in an infinite list of the sum applied from <code>1..1</code>, <code>1..2</code>, <code>1..3</code>, and so on until the pair has all the same items. This is basically checking for convergence manually.</p>
<pre><code>Þ∞Kƛ...;2l≬₈vḞ≈c›
Þ∞Kƛ   ;          # Calculate the gram series for all possible upper bounds
        2l        # get all the overlapping pairs
          ≬₈vḞ≈c  #  and get the first where the items to 256 decimal places are the same
                › # increment
</code></pre>
<pre><code>ƛÞ∞K$e›ĖṠ2l≬₈vḞ≈c*n¡*?∆Lne$/;∑  # Note that the context variable is set to whatever number in a prefix in the prefix is being gram seriesed is being zeta'd
 Þ∞K                            # To each prefix of an infinite list of positive integers
    $e›ĖṠ2l≬₈vḞ≈c                # Zeta function
                 *              # times k
                  n¡*           # times k!
                     ?∆Lne$/    # log(input) ** k divided by above
                            ;∑  # sum the result of apply to each k
</code></pre>
<pre><code>$e›ĖṠ2l≬₈vḞ≈c # the top of the stack is the prefix list
$e›           # each number in each prefix to the power of k + 1
   Ė          # reciprocal of each number in each prefix
    Ṡ         # sum of each prefix
     2l       # overlapping pairs of sums
       ≬₈vḞ≈c # first item where pair is all the same to 256 decimal places.
</code></pre>
</div>
<div id="pu7" class="pu"><h1><a href="https://pari.math.u-bordeaux.fr" rel="noreferrer">PARI/GP</a>, 40 bytes</h1>
<pre><code>x-&gt;1+suminf(k=1,log(x)^k/k/k!/zeta(k+1))
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=m728ILEoMz69YMHiNAXbpaUlaboWNzUqdO0MtYtLczPz0jSybQ11cvLTNSo047L1gVBRvyq1JFEjW9tQUxOqXjctv0gjT8FWwVBHwRiIC4oy80o0lAwN4pQU8hSUFHTtgESaBpCfpwnTtGABhAYA" rel="noreferrer">Attempt This Online!</a></p>
<p>Using the <a href="https://math.stackexchange.com/q/1506980/99103">Gram series</a>.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/256106/">256106</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




