<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::251161</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>nan</td><td>Random Hit</td><td>230411T183442Z</td><td><a href="https://codegolf.stackexchange.com/questions/251161/radiation-hardening-koth/259975#259975">The Empt</a></td></tr>
<tr d-ix="1"><td>256</td><td>Knight</td><td>220824T081522Z</td><td><a href="https://codegolf.stackexchange.com/questions/251161/radiation-hardening-koth/251317#251317">Aiden Ch</a></td></tr>
<tr d-ix="2"><td>nan</td><td>Piet + asciipiet</td><td>220826T052501Z</td><td><a href="https://codegolf.stackexchange.com/questions/251161/radiation-hardening-koth/251361#251361">Aiden Ch</a></td></tr>
<tr d-ix="3"><td>nan</td><td>The Bloody Awful</td><td>220828T114935Z</td><td><a href="https://codegolf.stackexchange.com/questions/251161/radiation-hardening-koth/251402#251402">Oskar Sk</a></td></tr>
<tr d-ix="4"><td>256</td><td>Protect and Shoot Randomly  05AB1E</td><td>220826T113422Z</td><td><a href="https://codegolf.stackexchange.com/questions/251161/radiation-hardening-koth/251374#251374">Kevin Cr</a></td></tr>
<tr d-ix="5"><td>003</td><td>Bastarf Mark III</td><td>220822T141403Z</td><td><a href="https://codegolf.stackexchange.com/questions/251161/radiation-hardening-koth/251257#251257">Oskar Sk</a></td></tr>
<tr d-ix="6"><td>003</td><td>Tailstrike  Python</td><td>220826T174724Z</td><td><a href="https://codegolf.stackexchange.com/questions/251161/radiation-hardening-koth/251382#251382">Oskar Sk</a></td></tr>
<tr d-ix="7"><td>nan</td><td></td><td>220825T183338Z</td><td><a href="https://codegolf.stackexchange.com/questions/251161/radiation-hardening-koth/251344#251344">Oskar Sk</a></td></tr>
<tr d-ix="8"><td>255</td><td>Python3</td><td>220825T112801Z</td><td><a href="https://codegolf.stackexchange.com/questions/251161/radiation-hardening-koth/251335#251335">Number B</a></td></tr>
<tr d-ix="9"><td>nan</td><td>The Newline Killer</td><td>220825T072253Z</td><td><a href="https://codegolf.stackexchange.com/questions/251161/radiation-hardening-koth/251332#251332">Number B</a></td></tr>
<tr d-ix="10"><td>nan</td><td>Sorry</td><td>220825T081705Z</td><td><a href="https://codegolf.stackexchange.com/questions/251161/radiation-hardening-koth/251334#251334">Bubbler</a></td></tr>
<tr d-ix="11"><td>168</td><td>Brainfuck</td><td>220819T123802Z</td><td><a href="https://codegolf.stackexchange.com/questions/251161/radiation-hardening-koth/251198#251198">Number B</a></td></tr>
<tr d-ix="12"><td>nan</td><td></td><td>220823T221742Z</td><td><a href="https://codegolf.stackexchange.com/questions/251161/radiation-hardening-koth/251305#251305">Oskar Sk</a></td></tr>
<tr d-ix="13"><td>nan</td><td>Jelly with LANG=C.ISO88591</td><td>220818T174014Z</td><td><a href="https://codegolf.stackexchange.com/questions/251161/radiation-hardening-koth/251173#251173">ais523</a></td></tr>
<tr d-ix="14"><td>nan</td><td>Jelly with LANG=C.ISO88591</td><td>220822T213843Z</td><td><a href="https://codegolf.stackexchange.com/questions/251161/radiation-hardening-koth/251268#251268">ais523</a></td></tr>
<tr d-ix="15"><td>nan</td><td>Tapestry</td><td>220823T104509Z</td><td><a href="https://codegolf.stackexchange.com/questions/251161/radiation-hardening-koth/251280#251280">mousetai</a></td></tr>
<tr d-ix="16"><td>nan</td><td>V vim</td><td>220819T035059Z</td><td><a href="https://codegolf.stackexchange.com/questions/251161/radiation-hardening-koth/251190#251190">tsh</a></td></tr>
<tr d-ix="17"><td>nan</td><td></td><td>220822T111008Z</td><td><a href="https://codegolf.stackexchange.com/questions/251161/radiation-hardening-koth/251256#251256">Oskar Sk</a></td></tr>
<tr d-ix="18"><td>nan</td><td></td><td>220822T024013Z</td><td><a href="https://codegolf.stackexchange.com/questions/251161/radiation-hardening-koth/251255#251255">huanglx</a></td></tr>
<tr d-ix="19"><td>003</td><td>MVP  Python</td><td>220821T014134Z</td><td><a href="https://codegolf.stackexchange.com/questions/251161/radiation-hardening-koth/251226#251226">huanglx</a></td></tr>
<tr d-ix="20"><td>nan</td><td>Vyxal</td><td>220819T193117Z</td><td><a href="https://codegolf.stackexchange.com/questions/251161/radiation-hardening-koth/251205#251205">naffetS</a></td></tr>
<tr d-ix="21"><td>nan</td><td>A Pear Tree</td><td>220819T183916Z</td><td><a href="https://codegolf.stackexchange.com/questions/251161/radiation-hardening-koth/251204#251204">ais523</a></td></tr>
<tr d-ix="22"><td>nan</td><td>Befunge98 FBBI</td><td>220819T140351Z</td><td><a href="https://codegolf.stackexchange.com/questions/251161/radiation-hardening-koth/251201#251201">ais523</a></td></tr>
<tr d-ix="23"><td>nan</td><td>Ghost</td><td>220819T125517Z</td><td><a href="https://codegolf.stackexchange.com/questions/251161/radiation-hardening-koth/251199#251199">mousetai</a></td></tr>
<tr d-ix="24"><td>nan</td><td></td><td>220818T115924Z</td><td><a href="https://codegolf.stackexchange.com/questions/251161/radiation-hardening-koth/251162#251162">alephalp</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>Random Hit, Python</h1>
<pre class="lang-python prettyprint-override"><code>###
exec( &quot;import random
i = input()
j = random.randint(0 , len(i))
print( j + ' ' + i[j] )&quot; )
###
exec( &quot;import random
i = input()
j = random.randint(0 , len(i))
print( j + ' ' + i[j] )&quot; )
###
</code></pre>
<p>You just need to install python, random is a built-in function. This selects a random character and removes it.</p>
<hr />
<h3>Edit</h3>
<p>Fixed issue with quote escaping and added unnecessary whitespace to program</p>
</div>
<div id="pu1" class="pu"><h1><a href="https://github.com/knight-lang/knight-lang" rel="nofollow noreferrer">Knight</a>, 256 bytes, rookie v4</h1>
<pre><code>( (:( (:(:( (:( ( ( ( :(:(:( ( (: ( ( ( (:( (
;
=
s
''
;
=
i
~
1
;
WWWW
&gt;
9999
=
i
+
1
i
=
s
+
s
IIII?=a+''PPPP'null'''+aAAAAJ10OOOOU+++''=a%RRRR-LLLLsTTTT' 'GGGGs aTTTT;;;;;;lnulnuunlsaaiaisas++=%%%%&gt;&gt;&gt;&gt;~~~~''''''''PARLTGIWARTLGPabcdefghijklmnopq101110100
</code></pre>
<p>Base64 encoded:</p>
<pre><code>KCAoOiggKDooOiggKDooICggKCAoIDooOig6KCAoICg6ICggKCAoICg6KCAoCjsKPQpzCicnCjsKPQppCn4KMQo7CldXV1cKPgo5OTk5Cj0KaQorCjEKaQo9CnMKKwpzCklJSUk/PWErJydQUFBQJ251bGwnJycrYUFBQUFKMTBPT09PVSsrKycnPWElUlJSUi1MTExMc1RUVFQnICdHR0dHcyBhVFRUVDs7Ozs7O2xudWxudXVubHNhYWlhaXNhcysrPSUlJSU+Pj4+fn5+ficnJycnJycnUEFSTFRHSVdBUlRMR1BhYmNkZWZnaGlqa2xtbm9wcTEwMTExMDEwMA==
</code></pre>
<p>V2: I added more buffer at the beginning of my code. Hopefully that allows it to stay alive longer.</p>
<p>V3: I change the comments to parentheses so that I don't get destroyed by Number Basher's newline killer. It should also work well in fending against parentheses killer as well.</p>
<p>V4: Added some stuff at the end to counter any strategies which delete characters from the end.</p>
<h3>Installation</h3>
<p>Idk yet, here's a link to the code in an online interpreter instead with some test input: <a href="https://knight-lang.netlify.app/#WyIoICg6KCAoOig6KCAoOiggKCAoICggOig6KDooICggKDogKCAoICggKDooIChcbjtcbj1cbnNcbicnXG47XG49XG5pXG5+XG4xXG47XG5XV1dXXG4+XG45OTk5XG49XG5pXG4rXG4xXG5pXG49XG5zXG4rXG5zXG5JSUlJPz1hKycnUFBQUCdudWxsJycnK2FBQUFBSjEwT09PT1UrKysnJz1hJVJSUlItTExMTHNUVFRUJyAnR0dHR3MgYVRUVFQ7Ozs7OztsbnVsbnV1bmxzYWFpYWlzYXMrKz0lJSUlPj4+Pn5+fn4nJycnJycnJ1BBUkxUR0lXQVJUTEdQYWJjZGVmZ2hpamtsbW5vcHExMDExMTAxMDAiLCLigbhcblxuwrnCucK7wrnCq1xuwrlcbuG5m+KBuOG6iE3hu4vigbjhuohN4buL4oG44bqITeG7i+KBuOG6iE3hu4vigbjhuohN4buL4oG44bqITeG7i+KBuOG6iE3hu4vigbjhuohN4buLXG5cbsK5XG5cbsK5IOG4t1xuXG7CucKrIMK7XG5cblxuIMK5XG5cblxuXG5cbsKrYVxuXG5vYW9cblxuwqvCu8KrwrvCqyDCu8KrwrvCq8K7IMKrIMK7wqsgwrtcblxu4bi3wrnCuSDCuVxuXG7huZtcbuKAnOKAnOKAnOKAnOKAnOKAnOKAnOKAnOKAnOKAnOKAnOKAnOKAnOKAnOKAnOKAnOKAnOKAnOKAnOKAnOKAnOKAnOKAnOKBucaI4oKswrVU4buLwrVK4bif4rGuYOG7i+G5meG5ouG5quKCrMmX4oKsSsWSZ+G6iE5NWMKp4buL4bmtwq5fMcKkS8iu4buL4oCc4oCc4oCc4oCc4oG5xojigqzCtVThu4vCtUrhuJ/isa5g4buL4bmZ4bmi4bmq4oKsyZfigqxKxZJn4bqITk1Ywqnhu4vhua3Crl8xwqRLyK7hu4vigJzigJzigJzigJzigbnGiOKCrMK1VOG7i8K1SuG4n+KxrmDhu4vhuZnhuaLhuarigqzJl+KCrErFkmfhuohOTVjCqeG7i+G5rcKuXzHCpEvIruG7i+KAncK1wrXhuohN4buLwrnCucK54oG6VlZW4oG6Il0=" rel="nofollow noreferrer">Try It Online!</a></p>
</div>
<div id="pu2" class="pu"><h1><a href="https://www.dangermouse.net/esoteric/piet.html" rel="nofollow noreferrer">Piet</a> + <a href="https://github.com/dloscutoff/ascii-piet" rel="nofollow noreferrer">ascii-piet</a>, 256 bytes (4×86=344 codels), picture perfect v3</h1>
<pre class="lang-none prettyprint-override"><code>jsamtfjsamtfjsamtfjsaqdusiiiiaaaabbbbddddffffjjjjvvvvtttteeeeeeeeeeeeeeeeeeeeeeeeeeeeEc?b?bed??j???bkaubuebmvmk                eeeeeeeeeeeeeeeeeeeeeeeeeee             e  Edjfvetejkbbraqmusqemqudsiadbdiab              eeeeeeeeeeeeeeeeeee               ee eE
</code></pre>
<p>Base64 encoded</p>
<pre><code>anNhbXRmanNhbXRmanNhbXRmanNhcWR1c2lpaWlhYWFhYmJiYmRkZGRmZmZmampqanZ2dnZ0dHR0ZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZUVjP2I/YmVkPz9qPz8/YmthdWJ1ZWJtdm1rICAgICAgICAgICAgICAgIGVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZSAgICAgICAgICAgICBlICBFZGpmdmV0ZWprYmJyYXFtdXNxZW1xdWRzaWFkYmRpYWIgICAgICAgICAgICAgIGVlZWVlZWVlZWVlZWVlZWVlZWUgICAgICAgICAgICAgICBlZSBlRQ==
</code></pre>
<p><a href="http://piet.bubbler.space/#eJzdUUEOgyAQ_Mue14QFUepXjAermJjY1sT21PTvZYFGjta0PZSdLEOWBGbmDt2lt1DVtUGFVCARCiSFm445kkTNXCQoEuQJZAK1wsSiWCIWld9AgzVpJON_FHrpf2QYJu5hcmAJmpn2t3LWT9zc5F18XMr2d1fC6iWrVKyjDC4bluMjkjFU8qEGawi9fBlTLrxZIU3xivgHLuzweiUse0dkf4WmQVjsDBVkWQYI03hynAQvd7RLB9XQTotFGM_z7eqG7bHr7QCPJ_r61AY" rel="nofollow noreferrer">Try Piet online!</a></p>
<p>This bot probably won't do too well, considering that all it does is remove the first character each time, but hopefully it survives moderately well to place top 10 :P</p>
<p>V2: Hopefully fixed the vulnerability that I noticed when I took a look in the leaderboards.</p>
<p>V3: Fixes a vulnerability where removing the first 5 characters is fatal. Also added some protection against Thief, which hopefully works.</p>
<p>(credits to @Bubbler for the installation and run instructions)</p>
<h1>Installation</h1>
<pre><code>pip install Pillow
git clone https://github.com/cincodenada/bertnase_npiet.git piet
cd piet
./configure
make npiet
cd ..
git clone https://github.com/dloscutoff/ascii-piet.git ascii-piet
</code></pre>
<h1>Run</h1>
<p>Save the source code in the text file <code>src.txt</code>:</p>
<pre><code>python3 ascii-piet/ascii2piet.py src.txt src.png &amp;&amp; piet/npiet -q src.png
</code></pre>
</div>
<div id="pu3" class="pu"><h2>The Bloody Awful, Batch</h2>
<p>This is the most cursed I could come up with that doesn't involve having to install an Itanic emulator and learning Itanium assembler.</p>
<pre class="lang-cmd prettyprint-override"><code>@@@@@@@@@@@@@@@   echo   off   

@@@@@@@@@@@@@@@   echo   off   

:::   The bloody awful   :::

::: Mmmmm         whitespace



set  /p  i=

&lt;NUL   set  /p  x=2 %i:~2,1%

exit  /b


set  /p  i=

&lt;NUL   set  /p  x=2 %i:~2,1%

exit  /b
</code></pre>
<p>It has CRLF line endings, so you may need to use the base64</p>
<pre><code>QEBAQEBAQEBAQEBAQEBAICAgZWNobyAgIG9mZiAgIA0KDQpAQEBAQEBAQEBAQEBAQEAgICBlY2hv
ICAgb2ZmICAgDQoNCjo6OiAgIFRoZSBibG9vZHkgYXdmdWwgICA6OjoNCg0KOjo6IE1tbW1tICAg
ICAgICAgd2hpdGVzcGFjZQ0KDQoNCg0Kc2V0ICAvcCAgaT0NCg0KPE5VTCAgIHNldCAgL3AgIHg9
MiAlaTp+MiwxJQ0KDQpleGl0ICAvYg0KDQoNCnNldCAgL3AgIGk9DQoNCjxOVUwgICBzZXQgIC9w
ICB4PTIgJWk6fjIsMSUNCg0KZXhpdCAgL2INCg==
</code></pre>
<h3>Installation</h3>
<p>Wine is required.  Probably just <code>apt-get install wine</code>.
I have tested that it works with just wine64 (no wine32 installed) on Debian, but I have not tested at all on Ubuntu.</p>
<p>Run with <code>wine cmd /c bloody-awful.bat</code></p>
<h3>Strategy</h3>
<p>It doesn't seem to be possible to just read a byte from &quot;standard input&quot; in batch/cmd.  This bot will read the first line (excluding line terminator) and select one character from it.  The safest character to pick would be the first on the line, but even that isn't 100% safe since the line can be completely empty.</p>
<p>I choose to pick the 3rd character since that seems likely enough to exist and will get to the good parts slightly faster than picking the 1st.</p>
<p>For hardening, there is highly redundant at symbols before the redundant <code>echo off</code>s as well as plenty of whitespace (including after 'off') to mitigate against attacks from comment skippers and whitespace deleters.</p>
<p>All critical code is duplicated but not actually redundant, but it's enough to keep the Burrowing Wheel distracted with the useless comment for a while.</p>
<h3>And now for something completely different</h3>
<p><a href="https://www.youtube.com/watch?v=vDlMLqdvHzI" rel="nofollow noreferrer">A recipe for a nice smoothie</a></p>
</div>
<div id="pu4" class="pu"><h1>Protect and Shoot Randomly - <a href="https://github.com/Adriandmen/05AB1E/wiki/Commands" rel="nofollow noreferrer">05AB1E</a>, 256 <a href="https://github.com/Adriandmen/05AB1E/wiki/Codepage" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>III.....āÀÀÀÀÀ€RðýIII.....āÀÀÀÀÀ€RðýIII.....āÀÀÀÀÀ€RðýIII.....āÀÀÀÀÀ€RðýIII.....āÀÀÀÀÀ€RðýIII.....āÀÀÀÀÀ€RðýIII.....āÀÀÀÀÀ€RðýIII.....āÀÀÀÀÀ€RðýIII.....āÀÀÀÀÀ€RðýIII.....āÀÀÀÀÀ€RðýIII.....āÀÀÀÀÀ€Rðý))))))))))˜˜˜˜˜˜˜˜˜˜.r.r.r.r.r.r.r.r.r.r        MMMMMMMMMM
</code></pre>
<p>Input is a multi-line string.</p>
<p><a href="https://tio.run/##yy9OTMpM/f/f09NTDwSONB5ugMFHTWuCDm84vHdUDrucJhycnoMJ9YowoQIU@MLB//9KSko5tjmpeeklGdYaemaGFlo5mrZ1@jF6elr61pm2mXklGipqQDFrlXjbTD0lBSW94tKk4pIilXidTB1DZd33@/cCEdcwMgMYIgA" rel="nofollow noreferrer">Try it online.</a> (Using the current highest voted answer as example input program.)</p>
<p>My initial idea was to always target the middle character of a given program, but this proved to be too tricky in combination with the radiant hardening (primarily because 05AB1E's middle builtin <code>Ås</code> will give two results if the argument has an even length). So instead, a much more boring but more stable approach: it (tries to) output a random target.</p>
<h2>Encoding:</h2>
<p>05AB1E uses a <a href="https://github.com/Adriandmen/05AB1E/wiki/Codepage" rel="nofollow noreferrer">custom codepage</a>, so here are the raw bytes instead:</p>
<pre><code>\x49\x49\x49\x2E\x2E\x2E\x2E\x2E\xA0\xC0\xC0\xC0\xC0\xC0\x80\x52\xF0\xFD\x49\x49\x49\x2E\x2E\x2E\x2E\x2E\xA0\xC0\xC0\xC0\xC0\xC0\x80\x52\xF0\xFD\x49\x49\x49\x2E\x2E\x2E\x2E\x2E\xA0\xC0\xC0\xC0\xC0\xC0\x80\x52\xF0\xFD\x49\x49\x49\x2E\x2E\x2E\x2E\x2E\xA0\xC0\xC0\xC0\xC0\xC0\x80\x52\xF0\xFD\x49\x49\x49\x2E\x2E\x2E\x2E\x2E\xA0\xC0\xC0\xC0\xC0\xC0\x80\x52\xF0\xFD\x49\x49\x49\x2E\x2E\x2E\x2E\x2E\xA0\xC0\xC0\xC0\xC0\xC0\x80\x52\xF0\xFD\x49\x49\x49\x2E\x2E\x2E\x2E\x2E\xA0\xC0\xC0\xC0\xC0\xC0\x80\x52\xF0\xFD\x49\x49\x49\x2E\x2E\x2E\x2E\x2E\xA0\xC0\xC0\xC0\xC0\xC0\x80\x52\xF0\xFD\x49\x49\x49\x2E\x2E\x2E\x2E\x2E\xA0\xC0\xC0\xC0\xC0\xC0\x80\x52\xF0\xFD\x49\x49\x49\x2E\x2E\x2E\x2E\x2E\xA0\xC0\xC0\xC0\xC0\xC0\x80\x52\xF0\xFD\x49\x49\x49\x2E\x2E\x2E\x2E\x2E\xA0\xC0\xC0\xC0\xC0\xC0\x80\x52\xF0\xFD\x29\x29\x29\x29\x29\x29\x29\x29\x29\x29\x98\x98\x98\x98\x98\x98\x98\x98\x98\x98\x2E\x72\x2E\x72\x2E\x72\x2E\x72\x2E\x72\x2E\x72\x2E\x72\x2E\x72\x2E\x72\x2E\x72\x20\x20\x20\x20\x20\x20\x20\x20\x4D\x4D\x4D\x4D\x4D\x4D\x4D\x4D\x4D\x4D
</code></pre>
<h2>Installation, Compilation, Execution:</h2>
<p><a href="https://github.com/Adriandmen/05AB1E" rel="nofollow noreferrer">Quoted from the 05AB1E docs</a>:</p>
<blockquote>
<p>05AB1E is written in <strong>Elixir</strong> using the <strong>Mix</strong> build tool, which comes with Elixir.</p>
<h3>Installation</h3>
<ol>
<li>Clone this repository (e.g. with <code>git clone https://github.com/Adriandmen/05AB1E.git</code>).</li>
<li>Install <strong>Elixir 1.9.0</strong> or higher using one of the installation options <a href="https://elixir-lang.org/install.html" rel="nofollow noreferrer">here</a>.</li>
<li>Install the package manager <strong>Hex</strong> with <code>mix local.hex</code>.</li>
</ol>
<h3>Compilation</h3>
<p>Retrieve/update all necessary dependencies using <code>mix deps.get</code> (if necessary).
In the terminal, compile the project using <code>MIX_ENV=prod mix escript.build</code>. On <strong>Windows</strong> in the command prompt, compile with <code>set &quot;MIX_ENV=prod&quot; &amp;&amp; mix escript.build</code>.</p>
<h3>Execution</h3>
<p>After running the build command, a compiled binary file <code>osabie</code> will be generated. For example, running the file <code>test.abe</code> is done by running:</p>
<pre><code>escript osabie test.abe
</code></pre>
<p>Normally, an 05AB1E file ends with <code>.abe</code>, but any other file extension can also be used.</p>
</blockquote>
<ul>
<li><a href="https://tio.run/##S0oszvifnJ@Saqv039PTUw8EjjQeboDBR01rgg5vOLx3VA67nCYcnJ6DCfWKMKECFPjCwX8lrtTkjHwF3TwF3VQFFVBsKNgpgCi9/OLEpMxUrtTi5KLMghIF/fyCEn2IGJRCVvZfSUkpxzYnNS@9JMNaQ8/M0EIrR9O2Tj9GT09L3zrTNjOvRENFDShmrRJvm6mnpKCkV1yaVFxSpBKvk6ljqKz7fv9eIOIaRmYAQwQA" rel="nofollow noreferrer">Here is the same program as in my earlier TIO (with a multiline string input), which is run using Bash as example.</a></li>
<li><a href="https://tio.run/##S0oszvifnFiiYKeQnJ@SqpdfnJiUmapgY6Pg6u/239PTUw8EjjQeboDBR01rgg5vOLx3VA67nCYcnJ6DCfWKMKECFPjCwX8dLmDwc3GVZ2TmpCoUpSamKGTmcaXkcykopBYnF2UWlCjo5xeU6ENiC0qhRaCNggpYT17q/xzbnNS89JIMaw09M0MLrRxN2zr9GD09LX3rTNvMvBINFTWgmLVKvG2mnpKCkl5xaVJxSZFKvE6mjqGy7vv9e4EoJm9YGcIFAA" rel="nofollow noreferrer">Alternatively, here is another Bash example program using <code>\n</code> in the input (as standard single line STDIN input), making use of <code>EOF</code>s.</a></li>
</ul>
<h2>Explanation:</h2>
<p>Primarily focuses on <a href="/questions/tagged/radiation-hardening" class="post-tag" title="show questions tagged &#39;radiation-hardening&#39;" rel="tag" aria-labelledby="radiation-hardening-container">radiation-hardening</a>, while trying to output a random index + character pair.<br />
Let me start with an explanation of the core of the program:</p>

<pre class="lang-python prettyprint-override"><code>I.ā€Rðý.rM
I           # Push the input multiline-string
 .ā         # Enumerate it, pairing each character with its 0-based index
   €R       # Reverse each inner pair from [char,index] to [index,char]
            # (05AB1E does have a single-byte builtin for this `í`,
            #  but this caused errors if certain characters were removed)
      ý     # Join each inner pair
     ð      # with a space (&quot; &quot;) delimiter to a string
       .r   # Shuffle the list of strings
         M  # Push a copy of the maximum (inner-most) value to the stack,
            # which basically takes the first character in the list in this case
            # (which is output implicitly as result)
</code></pre>
<p><strong>Things to improve the radiation hardening:</strong></p>
<ul>
<li>Two I already mentioned: using <code>M</code> to get the first item in the list. I could have used <code>н</code>, but I can use multiple <code>MMM</code> in a row without changing the functionality, whereas multiple <code>ннн</code> would have resulted in the first digit of the index instead of the correct result-string.</li>
<li>And using <code>€R</code> instead of <code>í</code>, since <code>.í</code> can cause errors if <code>ā</code> is removed, and <code>€ðý</code> or <code>Rðý</code> are both fine, and doesn't give too much trash.</li>
<li><code>)))˜˜˜</code> are used to wrap the entire stack into a list, and then flatten it. The multiple <code>)))</code> do of course result in an additional surrounding list every time, but the multiple <code>˜˜˜</code> are no-ops, as long as at least one of them is executed. If the <code>)</code> is removed, it uses the last resulting list (if applicable), so the example C program that focuses on removing parenthesis won't do too much harm here.</li>
<li>The multiple <code>.r.r.r</code> to shuffle doesn't matter much either. And if either character is removed: <code>..</code> is a no-op, and <code>r</code> is a reverse of the entire stack, which should only contain a single item (the list) at this point anyway.</li>
<li>Removing some other characters does result in trash in the list we shuffle and output a value from, but the chances aren't too high because we have repeated the program 11 times. E.g. Removing <code>ý</code> will put the indices and characters in the list as separated items, plus the additional pushed space (<a href="https://tio.run/##yy9OTMpM/f/f09NTDwSONB5ugMFHTWuCDm/QhIPTczDh//9KSko5tjmpeeklGdYaemaGFlo5mrZ1@jF6elr61pm2mXklGipqQDFrlXjbTD0lBSW94tKk4pIilXidTB1DZd33@/cCEdcwMgMYIgA" rel="nofollow noreferrer">try it online</a>). Removing <code>ð</code> or <code>R</code> will simply discard the list (<a href="https://tio.run/##yy9OTMpM/f/f09NTDwSONB5ugMFHTWuCDu/VhIPTczDh//9KSko5tjmpeeklGdYaemaGFlo5mrZ1@jF6elr61pm2mXklGipqQDFrlXjbTD0lBSW94tKk4pIilXidTB1DZd33@/cCEdcwMgMYIgA" rel="nofollow noreferrer">try it online</a> or <a href="https://tio.run/##yy9OTMpM/f/f09NTDwSONB5ugMFHTWsObzi8VxMOTs/BhP//Kykp5djmpOall2RYa@iZGVpo5Wja1unH6Olp6Vtn2mbmlWioqAHFrFXibTP1lBSU9IpLk4pLilTidTJ1DJV13@/fC0Rcw8gMYIgAAA" rel="nofollow noreferrer">try it online</a>). Removing <code>€</code> will put the index-character pairs in the wrong order (<a href="https://tio.run/##yy9OTMpM/f/f09NTDwSONB5ugMGgwxsO79WEg9NzMOH//0pKSjm2Oal56SUZ1hp6ZoYWWjmatnX6MXp6WvrWmbaZeSUaKmpAMWuVeNtMPSUFJb3i0qTikiKVeJ1MHUNl3ff79wIR1zAyAxgiAA" rel="nofollow noreferrer">try it online</a>). Removing <code>ā</code> will convert the input to a list of characters due to the <code>€</code>, after which it's joined by spaces (<a href="https://tio.run/##yy9OTMpM/f/f09NTDwQON8Dgo6Y1QYc3HN6rCQen52DC//@VlJRybHNS89JLMqw19MwMLbRyNG3r9GP09LT0rTNtM/NKNFTUgGLWKvG2mXpKCkp6xaVJxSVFKvE6mTqGyrrv9@8FIq5hZAYwRAA" rel="nofollow noreferrer">try it online</a>) - in addition, the <code>.....ÀÀÀÀÀ</code> will be some no-op <code>..</code>, one stack-rotate <code>.À</code>, and some list rotates <code>À</code>, all not changing the result too much. If <code>āÀÀÀÀÀ</code> would all be removed, the lists of the previous results would also be joined by spaces, which won't leave any correct results in the trailing list, hence why the <code>À</code> were added in the first place. Removing all <code>...</code> in front of the <code>ā</code> will result in a loose list of (1-based) indices, which are then joined together by spaces (<a href="https://tio.run/##yy9OTMpM/f/f09PzSOPhBhh81LQm6PCGw3s14eD0HEz4/7@SklKObU5qXnpJhrWGnpmhhVaOpm2dfoyenpa@daZtZl6JhooaUMxaJd42U09JQUmvuDSpuKRIJV4nU8dQWff9/r1AxDWMzACGCAA" rel="nofollow noreferrer">try it online</a>). Removing a <code>I</code> doesn't matter, since I've added two more just in case (it's actually beneficial if some are removed, since the additional <code>I</code> input-strings are trash in the original base program) - removing all three will do an additional enumerate, giving an incorrect list with two indices per string (<a href="https://tio.run/##yy9OTMpM/f/f09NTDwSONB5ugMFHTWuCDm84vBenhCYcnJ6DCf//V1JSyrHNSc1LL8mw1tAzM7TQytG0rdOP0dPT0rfOtM3MK9FQUQOKWavE22bqKSko6RWXJhWXFKnE62TqGCrrvt@/F4i4hpEZwBABAA" rel="nofollow noreferrer">try it online</a>).</li>
<li>And the spaces between the <code>.r</code> and <code>M</code> are no-ops. So removing or keeping those doesn't change anything to the program. They're simply used to fill in the remaining bytes to make the program length 256 (and to somewhat counter the Whitespace program). I've placed them in between those two, since <code>.M</code> if the last <code>r</code> is removed is the most-frequent builtin, which would always give the input-string, but will also take about 25-30 seconds to execute, so we'd like to prevent that with the execution time rule of &lt;1 second.</li>
</ul>
<p>Removing multiple characters in the program simultaneously may result in some undefined behavior. I haven't tested this too much, except for removing <code>āÀÀÀÀÀ</code>, which would probably be one of the worst case scenarios if it's done in the final subprogram of the total 11.</p>
<p>I have no idea how well it will do, since it's still pretty random. But overall it should do reasonably well (I think/hope).</p>
</div>
<div id="pu5" class="pu"><h2>Bastarf Mark III, Python 3 only</h2>
<p>Run with <code>python3 bastarf</code>.</p>
<p>This is a bastard, but my finger slipped.  It is focused on offense targeting the current leaders.</p>
<h3>Mark III</h3>
<p>Implemented @mousetail's suggestion to use <code>exec(&quot;&quot;&quot;</code> to reduce sensitivity to deletions.  Also made print flush as output isn't to a terminal, don't know why this worked with Mark II but maybe it didn't.</p>
<p>Same targets as Mark II but hopefully less fragile.  Some improvements could still be made, like removing nested exec, but there already three versions.</p>
<pre class="lang-python prettyprint-override"><code>#

#

#

#
import os
i=os.sys.stdin.read()
try:
 exec(r&quot;&quot;&quot;
def f(x):
 exec('p=i.find(x)\nif p&gt;=0:print(&quot;%d %c&quot;%(p,i[p]),flush=True);os._exit(0)')
f('=l')
f('xn')
f('_1')
f('&quot;;')
f('\n\t')
f('$(')
f('&gt;+')
f('%c')
f('st')
1//0
&quot;&quot;&quot;)
except:
 print(&quot;9 &quot;+i[9])
</code></pre>
<pre><code>IwoKIwoKIwoKIwppbXBvcnQgb3MKaT1vcy5zeXMuc3RkaW4ucmVhZCgpCnRyeToKIGV4ZWMociIi
IgpkZWYgZih4KToKIGV4ZWMoJ3A9aS5maW5kKHgpXG5pZiBwPj0wOnByaW50KCIlZCAlYyIlKHAs
aVtwXSksZmx1c2g9VHJ1ZSk7b3MuX2V4aXQoMCknKQpmKCc9bCcpCmYoJ3huJykKZignXzEnKQpm
KCciOycpCmYoJ1xuXHQnKQpmKCckKCcpCmYoJz4rJykKZignJWMnKQpmKCdzdCcpCjEvLzAKIiIi
KQpleGNlcHQ6CiBwcmludCgiOSAiK2lbOV0pCg==
</code></pre>
<ul>
<li><code>f('=l')</code> specifically targets Distributed Damage</li>
<li><code>f('xn')</code> tries to target Comment Skipper by attacking the one fatal spot</li>
<li><code>f('_1')</code> tries to target Almost Rare by messing up the 1-base to 0-base conversion hopefully without causing pre-mature exit</li>
<li><code>f('&quot;;')</code> puts Example Python BOt in an unterminated string</li>
<li><code>f('\t\n')</code> attacks Ghost</li>
<li><code>f('$(')</code> will break NÜL Tränslätör, unless the input is actually <code>cat</code></li>
<li><code>f('&gt;+')</code> tries to target The 2nd'er</li>
<li><code>f('%c')</code> will make Example C bot output invalid data</li>
<li><code>f('st')</code> targets <code>stdin</code> in Example Node Bot, MVP and Parenthesis Killer</li>
</ul>
<p>And then it starts getting too big.</p>
<p>Mark I and Mark II are hidden in the edit history.</p>
</div>
<div id="pu6" class="pu"><h2>Tailstrike - Python 3</h2>
<p>I had this laying around, doesn't seem to get immediately killed by the Burrowing Wheel.  Since the last byte is quite likely to be an unnecessary line terminator, the bot actually attacks the 2nd last byte.</p>
<p>It turns out it's near impossible to get Python 3 to NOT use utf-8.
<code>PYTHONIOENCODING</code> only affect the already opened stdin/stdout/stderr, <code>open(0)</code> defaults to utf-8 even with <code>LC_ALL=C.ISO-8859-1</code>.</p>
<p>Using <code>sys.stdin</code> however isn't too horrible, the default error handling is to use surrogate-escape on both stdin and stdout.</p>
<pre class="lang-python prettyprint-override"><code>2
3
5
7



&quot;&quot;&quot;&quot;
11,0
13,0
'(('


import   sys

s=sys.stdin.read();print(&quot;%d &quot;%(len(s)-2)+s[-2])
### &quot;&quot;&quot;&quot;&quot;


&quot;&quot;&quot;&quot;
&quot;%(17,0)&quot;
&quot;%(19,0)&quot;
n=s=sys.stdin.read();print(&quot;%d &quot;%(len(s)-2)+s[-2])
###&quot;&quot;&quot;&quot;&quot;

import  sys

s=sys.stdin.read();print(&quot;%d &quot;%(len(s)-2)+s[-2])
</code></pre>
<h3>base64 for easy copying</h3>
<pre><code>MgozCjUKNwoKCgoiIiIiCjExLDAKMTMsMAonKCgnCgoKaW1wb3J0ICAgc3lzCgpzPXN5cy5zdGRp
bi5yZWFkKCk7cHJpbnQoIiVkICIlKGxlbihzKS0yKStzWy0yXSkKIyMjICIiIiIiCgoKIiIiIgoi
JSgxNywwKSIKIiUoMTksMCkiCm49cz1zeXMuc3RkaW4ucmVhZCgpO3ByaW50KCIlZCAiJShsZW4o
cyktMikrc1stMl0pCiMjIyIiIiIiCgppbXBvcnQgIHN5cwoKcz1zeXMuc3RkaW4ucmVhZCgpO3By
aW50KCIlZCAiJShsZW4ocyktMikrc1stMl0pCg==
</code></pre>
</div>
<div id="pu7" class="pu"><h2>Thief - C (gcc 8.3)</h2>
<p>Sneaks in through the backdoor to steal your rarest most valued characters.</p>
<p>(edited to add two more slashes in the beginning, edited again to add four more nulls at the end)</p>
<pre><code>00000000: 2f2f 2f2f 2f2f 2a2a ff20 2029 7d2e 3031  //////**.  )}.01
00000010: 2b25 2563 2828 ff28 5d2c 702c 6e74 6628  +%%c((.(],p,ntf(
00000020: 2225 6420 2563 222c 505b 635d 2c63 293b  &quot;%d %c&quot;,P[c],c);
00000030: 7d5b 323d 702b 2b3b 7768 696c 6528 6d61  }[2=p++;while(ma
00000040: 696e 2863 297b 750a 0a0a 2f2f 2f2a 2a2f  in(c){u...///**/
00000050: 0a0a 0a00 6766 2c70 713b 3b00 465b 3235  ....gf,pq;;.F[25
00000060: 365d 2c50 5b32 3536 5d2c 702c 663b 6d61  6],P[256],p,f;ma
00000070: 696e 2863 297b 666f 7228 3b28 633d 0020  in(c){for(;(c=. 
00000080: 000a 0020 000a 0020 000a 0020 000a 0000  ... ... ... ....
00000090: 0067 6574 6368 6172 2829 293e 2d31 3b46  .getchar())&gt;-1;F
000000a0: 5b63 5d2b 2b29 505b 635d 3d70 2b2b 3b77  [c]++)P[c]=p++;w
000000b0: 6869 6c65 282b 2b66 3c32 3537 2966 6f72  hile(++f&lt;257)for
000000c0: 2863 3d32 3536 3b2d 2d63 3e2d 313b 2969  (c=256;--c&gt;-1;)i
000000d0: 6628 465b 635d 3d3d 6629 7265 7475 726e  f(F[c]==f)return
000000e0: 2020 7072 696e 7466 2822 2564 2025 6322    printf(&quot;%d %c&quot;
000000f0: 2c50 5b63 5d2c 6329 3b7d 0000 0000 0000  ,P[c],c);}......
</code></pre>
<p>The core of this is this 138 byte long string</p>
<pre class="lang-c prettyprint-override"><code>F[256],P[256],p,f;main(c){for(;(c=getchar())&gt;-1;F[c]++)P[c]=p++;while(++f&lt;257)for(c=256;--c&gt;-1;)if(F[c]==f)return printf(&quot;%d %c&quot;,P[c],c);}
</code></pre>
<h3>How it works</h3>
<p>It searches for the least frequent characters, and of those the last occurrence of the character of the highest value is selected.</p>
<pre class="lang-c prettyprint-override"><code>// Variables are `int` by default.  Global variables are initialized to zero.

F[256],     // Array of frequency for each character value
P[256],     // Array of last position for each character value
p,          // position counter variable
f;          // frequency iterator variable

main(c)     // main function, integer variable for character (argc)
{
    // Read input and count frequency and position
    for(;
        (c = getchar()) &gt; -1;   // Read character in while condition
        F[c]++                  // Update frequency at end of loop
    )
        P[c] = p++;             // Update last position for character

    // Find the least frequent character [1..256]
    while (++f &lt; 257)
        // Find the highest valued character [255..0]
        for (c = 256; --c &gt; -1;)
            // First match is the best match
            if (F[c] == f)
                return printf(&quot;%d %c&quot;,P[c],c);
}
</code></pre>
<h3>Hardening</h3>
<ul>
<li>Many unsuccessful attempts to deceive The Burrowing Wheel</li>
<li>Not much can be done against random targeting bots since the core is so huge.</li>
<li>Lots of padding in the front to handle a variety of bots removing the 1st (many), 1st to 8th (Tapestry), 10th (Bastarf) and 21st (Redun) character. Inside the damage resistant comment there are traps for Key Characters Attack, Bastarf, Parenthesis Killer and Ghost.  Also included are some
invalid UTF-8 bytes and null bytes to hopefully break something before it reaches anything important.</li>
<li>The middle of the program is attacked by the example Python bot</li>
<li>Source code is 7.4% null characters.</li>
</ul>
<h3>base64 (v3)</h3>
<pre><code>Ly8vLy8vKir/ICApfS4wMSslJWMoKP8oXSxwLG50ZigiJWQgJWMiLFBbY10sYyk7fVsyPXArKzt3
aGlsZShtYWluKGMpe3UKCgovLy8qKi8KCgoAZ2YscHE7OwBGWzI1Nl0sUFsyNTZdLHAsZjttYWlu
KGMpe2Zvcig7KGM9ACAACgAgAAoAIAAKACAACgAAAGdldGNoYXIoKSk+LTE7RltjXSsrKVBbY109
cCsrO3doaWxlKCsrZjwyNTcpZm9yKGM9MjU2Oy0tYz4tMTspaWYoRltjXT09ZilyZXR1cm4gIHBy
aW50ZigiJWQgJWMiLFBbY10sYyk7fQAAAAAAAA==
</code></pre>
</div>
<div id="pu8" class="pu"><h1>Python3, Key Characters Attack, 255 bytes</h1>
<p><code> # # # # # # # repetitionrepetitionrepetition=lxn_1&quot;;=lxn_1&quot;;$(&gt;+%cstststststststststststst\n\n\nfrom sys import stdin as s;\ni=s.read();\nfor c in'\\n )}.01+\\n )}.01+'[len(i)%8:][:8]:\n if c in i:print(f'{i.index(c)} {c}');exit();\n\nprint(f'{len(i)-1} {i[-1]}');</code></p>
<p>Which is:</p>
<pre class="lang-python prettyprint-override"><code> # # # # # # # repetitionrepetitionrepetition=lxn_1&quot;;=lxn_1&quot;;$(&gt;+%cstststststststststststst


from sys import stdin as s;
i=s.read();
for c in'\n )}.01+\n )}.01+'[len(i)%8:][:8]:
 if c in i:print(f'{i.index(c)} {c}');exit();

print(f'{len(i)-1} {i[-1]}');
</code></pre>
<p>Base 64:</p>
<p><code>ICMgIyAjICMgIyAjICMgcmVwZXRpdGlvbnJlcGV0aXRpb25yZXBldGl0aW9uPWx4bl8xIjs9bHhuXzEiOyQoPislY3N0c3RzdHN0c3RzdHN0c3RzdHN0c3RzdAoKCmZyb20gc3lzIGltcG9ydCBzdGRpbiBhcyBzOwppPXMucmVhZCgpOwpmb3IgYyBpbidcbiApfS4wMStcbiApfS4wMSsnW2xlbihpKSU4Ol1bOjhdOgogaWYgYyBpbiBpOnByaW50KGYne2kuaW5kZXgoYyl9IHtjfScpO2V4aXQoKTsKCnByaW50KGYne2xlbihpKS0xfSB7aVstMV19Jyk7</code></p>
<p>The repetition was due to <a href="https://codegolf.stackexchange.com/a/251268/111945">this answer</a>.</p>
<p>The next was to target <a href="https://codegolf.stackexchange.com/a/251257/111945">this answer</a>,
and to prevent it from targeting the actual <code>stdin</code>.</p>
<p>The comment up front avoids being target by programs that target the first or second letters, like <a href="https://codegolf.stackexchange.com/a/251190/111945">this answer</a>.</p>
<p>The comment is <code># #</code> instead of <code>#  </code> or <code>###</code> to be robust towards
first letter targetters and <a href="https://codegolf.stackexchange.com/a/251201/111945">this answer</a>, which
targets <code>##</code>.</p>
<p>As in <a href="https://codegolf.stackexchange.com/a/251204/111945">this answer</a>, we target
different things every time. We go through <code>\n</code>, <code> </code>, <code>)</code>, <code>}</code>,
<code>.</code>, <code>0</code>, <code>1</code>, and <code>+</code>, but <code>\n</code> takes priority in the first run,
<code> </code> in the second, et cetera. We decide that newlines, spaces,
closing parenthesis, decimals, numbers, and the plus sign are rarely fake and usually used, while being very vulnerable.</p>
<p>Quick fix: added more comments due to the feedback.</p>
</div>
<div id="pu9" class="pu"><h1>The Newline Killer, 172 Bytes, In response to the new edit in <a href="https://codegolf.stackexchange.com/a/251317/111945">this</a>.</h1>
<pre class="lang-c prettyprint-override"><code>//////
////##
////((
////&gt;&gt;

k,j;main(i){for(j=getchar();i&lt;999;i++){k=getchar();if(k=='\n'||k=='='){printf(&quot;%d %c&quot;,i,k);exit(0);}}printf(&quot;0 %c&quot;,j);}

//////
////##
////((
////&gt;&gt;
</code></pre>
<p>I managed to do this without learning C I am so smart (this is written in C).</p>
<p>Targets the first new line or <code>=</code>. Hopefully there won't be too much irrelevant <code>=</code>s. Else targets the first character. Most of the code has comments which can cause them to break by commenting their own code.</p>
</div>
<div id="pu10" class="pu"><h1>Sorry, <a href="https://soulsphere.org/hacks/smbf/" rel="nofollow noreferrer">Self-modifying Brainfuck</a></h1>
<pre><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;.&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;.&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;,.                                                        00000000000000000000000000000000000000000000000000000000
</code></pre>
<p><a href="https://tio.run/##K85NSvv/3wYP0LMhE5CtUUdPgUxgQCb4/z8RAA" rel="nofollow noreferrer" title="Self-modifying Brainfuck – Try It Online">Try it online!</a></p>
<p>Install (assumes <code>gcc</code> and <code>wget</code>):</p>
<pre><code>wget https://soulsphere.org/hacks/smbf/smbf.c
gcc smbf.c -o smbf
</code></pre>
<p>Run (assumes the source stored as <code>src.smbf</code> in the same folder as <code>smbf</code> executable):</p>
<pre><code>./smbf src.smbf
</code></pre>
<p>Does the most obvious thing, maximizing defense against random deletions and nothing else.</p>
</div>
<div id="pu11" class="pu"><h1>Brainfuck, 168 bytes, &quot;the 2nd'er&quot;</h1>
<pre><code>,#(((((((
&gt;+++++++!
+++++++;/
+++++++//
+++++++/*
+++++++*/
+(+(+(+(+
+#{#+#}#+
!!+++++!!

|v.v|
----|
----v
----|
----v
.&lt;.&lt;/
</code></pre>
<pre><code>LCMoKCgoKCgoCj4rKysrKysrIQorKysrKysrOy8KKysrKysrKy8vCisrKysrKysvKgorKysrKysrKi8KKygrKCsoKygrCisjeyMrI30jKwohISsrKysrISEKCnx2LnZ8Ci0tLS18Ci0tLS12Ci0tLS18Ci0tLS12Ci48Ljwv
</code></pre>
</div>
<div id="pu12" class="pu"><h2>redun - Bash</h2>
<pre class="lang-bash prettyprint-override"><code>#@#,_#

a=&quot;printf '20 ';head -c21|tail -c1;exit&quot;
b=&quot;printf '20 ';head -c21|tail -c1;exit&quot;
[ &quot;$a&quot; == &quot;$b&quot; ]&amp;&amp;[ &quot;$a&quot; == &quot;$b&quot; ]&amp;&amp;eval &quot;$a&quot;

&quot; #&quot;

a=&quot;printf '20 ';head -c21|tail -c1;exit&quot;
b=&quot;printf '20 ';head -c21|tail -c1;exit&quot;
[ &quot;$a&quot; = &quot;$b&quot; ] &amp;&amp; eval &quot;$a&quot;
(
</code></pre>
<p>Survival odds against 1 random deletion: 253/256</p>
<p>Survival odds against 2 random deletions: 31747/32640</p>
<p>Survival time against forward sequential whitespace deletion: 25</p>
<p>Survival time against forward sequential deletions: 10<br />
Don't know why it prints &quot;20 0120  &quot; after 11 deletions when fed its own original source, it start right, but then adds a 1 and runs again.</p>
<pre><code>I0AjLF8jCgphPSJwcmludGYgJzIwICc7aGVhZCAtYzIxfHRhaWwgLWMxO2V4aXQiCmI9InByaW50
ZiAnMjAgJztoZWFkIC1jMjF8dGFpbCAtYzE7ZXhpdCIKWyAiJGEiID09ICIkYiIgXSYmWyAiJGEi
ID09ICIkYiIgXSYmZXZhbCAiJGEiCgoiICMiCgphPSJwcmludGYgJzIwICc7aGVhZCAtYzIxfHRh
aWwgLWMxO2V4aXQiCmI9InByaW50ZiAnMjAgJztoZWFkIC1jMjF8dGFpbCAtYzE7ZXhpdCIKWyAi
JGEiID0gIiRiIiBdICYmIGV2YWwgIiRhIgooCg==
</code></pre>
</div>
<div id="pu13" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="nofollow noreferrer">Jelly</a> with <code>LANG=C.ISO-8859-1</code>, Almost Rare</h1>
<pre><code>““““““⁹ƈ€µTịµṢœ-QŒrṪÐṂFX©⁸ẹX_1⁶®⁸ị`“⁹ƈ€µTịµṢœ-QŒrṪÐṂFX©⁸ẹX_1⁶®⁸ị`“⁹ƈ€µTịµṢœ-QŒrṪÐṂFX©⁸ẹX_1⁶®⁸ị`“⁹ƈ€µTịµṢœ-QŒrṪÐṂFX©⁸ẹX_1⁶®⁸ị`“⁹ƈ€µTịµṢœ-QŒrṪÐṂFX©⁸ẹX_1⁶®⁸ị`“⁹ƈ€µTịµṢœ-QŒrṪÐṂFX©⁸ẹX_1⁶®⁸ị`“⁹ƈ€µTịµṢœ-QŒrṪÐṂFX©⁸ẹX_1⁶®⁸ị`”¹¹LÐṀoo¹¹VVV”¹¹LÐṀoo¹¹VVV”¹¹LÐṀo¹¹VVV
</code></pre>
<p><a href="https://tio.run/##y0rNyan8//9Rwxx01LjzWMejpjWHtoY83N19aOvDnYuOTtYNPDqp6OHOVYcnPNzZ5BZxaOWjxh0Pd@2MiDd81Ljt0DoQb3d3wqjugdA999DOQzt9QKoa8vNB7LCwMGJEoYL//ycmJSanpKalZwAA" rel="nofollow noreferrer" title="Jelly – Try It Online">Try it online!</a></p>
<p>Hexdump (<code>xxd</code> reversible hexdump format, decode with <code>xxd -r</code>):</p>
<pre><code>00000000: fefe fefe fefe 899c 0c09 54d8 09b7 1e2d  ..........T....-
00000010: 5113 72ce 0fb3 4658 0688 d658 5f31 8608  Q.r...FX...X_1..
00000020: 88d8 60fe 899c 0c09 54d8 09b7 1e2d 5113  ..`.....T....-Q.
00000030: 72ce 0fb3 4658 0688 d658 5f31 8608 88d8  r...FX...X_1....
00000040: 60fe 899c 0c09 54d8 09b7 1e2d 5113 72ce  `.....T....-Q.r.
00000050: 0fb3 4658 0688 d658 5f31 8608 88d8 60fe  ..FX...X_1....`.
00000060: 899c 0c09 54d8 09b7 1e2d 5113 72ce 0fb3  ....T....-Q.r...
00000070: 4658 0688 d658 5f31 8608 88d8 60fe 899c  FX...X_1....`...
00000080: 0c09 54d8 09b7 1e2d 5113 72ce 0fb3 4658  ..T....-Q.r...FX
00000090: 0688 d658 5f31 8608 88d8 60fe 899c 0c09  ...X_1....`.....
000000a0: 54d8 09b7 1e2d 5113 72ce 0fb3 4658 0688  T....-Q.r...FX..
000000b0: d658 5f31 8608 88d8 60fe 899c 0c09 54d8  .X_1....`.....T.
000000c0: 09b7 1e2d 5113 72ce 0fb3 4658 0688 d658  ...-Q.r...FX...X
000000d0: 5f31 8608 88d8 60ff 8181 4c0f c86f 6f81  _1....`...L..oo.
000000e0: 8156 5656 ff81 814c 0fc8 6f6f 8181 5656  .VVV...L..oo..VV
000000f0: 56ff 8181 4c0f c86f 8181 5656 56         V...L..o..VVV
</code></pre>
<p>Exits via crashing, so a lot of junk goes to stderr and must be ignored, but stdout should be correct.</p>
<h2>Strategy/algorithm</h2>
<p>This program looks for characters in the input program that appear more than once, but under that restriction, as few times as possible. (So the ideal is to find a character that appears twice.) It picks one of those characters at random, picks a random occurrence of it, and chooses that.</p>
<p>The program is (unless I've missed something) radiation-hardened against any single deletion, and can frequently withstand quite a lot of random deletions (although there are ways to make it fail with only two deletions, it takes some understanding to realise what needs to be deleted).</p>
<p>Unfortunately, Jelly by default has no byte-level I/O at all – any attempt to read invalid UTF-8 (except by shelling out to Python) will cause a crash in the read routines. This is fixable by explicitly disabling Unicode handling when running the program, using <code>LANG=C.ISO-8859-1</code> as a prefix to the command. (This may produce warnings because your OS probably doesn't have non-Unicode locale data files installed nowadays, but Python should still be able to run under these conditions.) Note that the similar <code>LC_ALL</code> doesn't work – using this triggers a special case in Jelly which produces output encoded in Jelly's codepage, rather than the specified encoding.</p>
<h2>Installation</h2>
<ul>
<li>Install python3 and pip3 (on Ubuntu, <code>python3</code> and <code>python3-pip</code>)</li>
<li>You will need to run from an account with a real home directory – if your container is so stripped down that it doesn't have one, create one with, e.g.,
<pre class="lang-bash prettyprint-override"><code>mkdir ./home
export HOME=$(readlink -f ./home)
</code></pre>
</li>
<li>Install Jelly using the instructions at <a href="https://github.com/DennisMitchell/jellylanguage" rel="nofollow noreferrer">https://github.com/DennisMitchell/jellylanguage</a>:
<pre class="lang-bash prettyprint-override"><code>git clone -q https://github.com/DennisMitchell/jellylanguage.git
cd jellylanguage
pip3 install --upgrade --user .
</code></pre>
</li>
</ul>
<p>To run programs: <code>LANG=C.ISO-8859-1 ~/.local/bin/jelly f <em>programfilename</em></code>, where <em>programfilename</em> is the name of the program you're running. Standard input can be piped in or redirected from a file, as normal.</p>
<h2>Explanation</h2>
<p>The program that actually does the work is:</p>
<pre><code>⁹ƈ€µTịµṢœ-QŒrṪÐṂFX©⁸ẹX_1⁶®⁸ị`
 ƈ€                            Read     characters from standard input
⁹                                   256
   µTị                         Remove falsey characters (i.e. past EOF)
      µ                        Assign to ⁸
       Ṣ                       Sort the characters,
        œ-                       and remove
          Q                        one occurence of each character.
           Œr                  Run-length encode,
              ÐṂ                 and take the (char, length) pairs with minimal
             Ṫ                   last component (i.e. length)
                F              Convert into a list of chars, no lengths
                 X             Pick one at random
                  ©              and assign it to ©
                   ⁸ẹ          Find all locations of it within ⁸
                     X         Pick one at random
                      _1       Subtract 1 (to use 0-based indexing)
                        ⁶      {Output the location}, and a space,
                         ®     and ®
                          ⁸ị`  Index the input into itself (i.e. crash)
</code></pre>
<p>This gets repeated many times as elements of a giant list literal, which is then decoded:</p>
<pre><code>¹¹LÐṀoo¹¹VVV
¹¹             no-ops, prevent a crash if the `L` is deleted
   ÐṀ          take the list elements with the maximum
  L              length
     oo¹¹      logical-OR with the list literal (a no-op, usually)
         V     evaluate (running the program and crashing)
          VV   spare Vs in case one gets deleted
</code></pre>
<p>The various deletions from this will generally either do nothing, or represent a program that concatenates the entire list literal into a single program and runs it (so in effect it ends up running the first copy of the program rather than the longest, i.e. least mutated, copy) – it's carefully structured to prevent syntax errors appearing as a result of deletions, e.g. <code>Ðo</code> is a valid command (&quot;apply to odd elements&quot;) and thus won't cause a crash before the evaluation runs.</p>
<p>The decoder is also repeated, but that's mostly irrelevant / chaff to confuse other programs about what we're doing, and matters only if the <code>”</code> that closes the list literal gets deleted (in that case, the second copy of the decoder is used instead).</p>
</div>
<div id="pu14" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="noreferrer">Jelly</a> with <code>LANG=C.ISO-8859-1</code>, The Burrowing Wheel</h1>
<pre><code>⁸

¹¹»¹«
¹
ṛ⁸ẈMị⁸ẈMị⁸ẈMị⁸ẈMị⁸ẈMị⁸ẈMị⁸ẈMị⁸ẈMị

¹

¹ ḷ

¹« »


 ¹




«a

oao

«»«»« »«»«» « »« »

ḷ¹¹ ¹

ṛ
“““““““““““““““““““““““⁹ƈ€µTịµJḟⱮ`ịṙṢṪ€ɗ€JŒgẈNMX©ịṭ®_1¤KȮị““““⁹ƈ€µTịµJḟⱮ`ịṙṢṪ€ɗ€JŒgẈNMX©ịṭ®_1¤KȮị““““⁹ƈ€µTịµJḟⱮ`ịṙṢṪ€ɗ€JŒgẈNMX©ịṭ®_1¤KȮị”µµẈMị¹¹¹⁺VVV⁺
</code></pre>
<p><a href="https://tio.run/##1VLNSsNAEL7PUwxpQxOkYB7Ag@Cp0goiRVDR0NYaCbakARFyMJ4K3ryIqAjiRaMBD8Fsc1tQ9DE2LxJnlxT8AU@9mM3MfvPNP8l@z3WPiiIPUwDO6GQkEUEQ7JJYMRk3RXY6GyRbSEGRvqh2EfIMAFDS9PDIBhjYA4loECU4BTzD0lJJVELOq1JpVMiPr2bwhuxtnJ888mSNxuVJQ6Q3@XO8Q4ZgF4LdCvZA7o9zUo3Xsz7t1Wqu83vlf@LxtsXvlt9jufS/qnrNE56UH0n9BSwPJ@12m3RRVCqGYZggLxPAWagavodY25yvkcYacSPihp5z4O8i6iNErepowWEHsd4h7wZilch63ydlIW4Fwd8JHnmN1cXW0kpTH5llBe97hV8x03Ka3kVNxhMlY7w5S7m/4p@d93p2V/amtGHg244rDQvKxT8B" rel="noreferrer" title="Jelly – Try It Online">Try it online!</a></p>
<p>Exits by crashing, putting junk on standard error, but standard output should be correct.</p>
<p>I don't know how fast the OP's computer is, and it matters for this submission – this program takes around 0.5-0.6 seconds to run on my computer and on TIO, so may go over the time limit if the OP's computer is significantly slower.</p>
<p>Jelly uses a custom code page, so here's a hexdump (<code>xxd</code> format) of what this looks like after encoding:</p>
<pre><code>00000000: 887f 7f81 81fb 81fa 7f81 7fde 88bb 4dd8  ..............M.
00000010: 88bb 4dd8 88bb 4dd8 88bb 4dd8 88bb 4dd8  ..M...M...M...M.
00000020: 88bb 4dd8 88bb 4dd8 88bb 4dd8 7f7f 817f  ..M...M...M.....
00000030: 7f81 20da 7f7f 81fa 20fb 7f7f 7f20 817f  .. ..... .... ..
00000040: 7f7f 7f7f fa61 7f7f 6f61 6f7f 7ffa fbfa  .....a..oao.....
00000050: fbfa 20fb fafb fafb 20fa 20fb fa20 fb7f  .. ..... . .. ..
00000060: 7fda 8181 2081 7f7f de7f fefe fefe fefe  .... ...........
00000070: fefe fefe fefe fefe fefe fefe fefe fefe  ................
00000080: fe89 9c0c 0954 d809 4aeb 9560 d8f3 b7ce  .....T..J..`....
00000090: 0c9d 0c4a 1367 bb4e 4d58 06d8 e008 5f31  ...J.g.NMX...._1
000000a0: 034b cad8 fefe fefe 899c 0c09 54d8 094a  .K..........T..J
000000b0: eb95 60d8 f3b7 ce0c 9d0c 4a13 67bb 4e4d  ..`.......J.g.NM
000000c0: 5806 d8e0 085f 3103 4bca d8fe fefe fe89  X...._1.K.......
000000d0: 9c0c 0954 d809 4aeb 9560 d8f3 b7ce 0c9d  ...T..J..`......
000000e0: 0c4a 1367 bb4e 4d58 06d8 e008 5f31 034b  .J.g.NMX...._1.K
000000f0: cad8 ff09 09bb 4dd8 8181 818a 5656 568a  ......M.....VVV.
</code></pre>
<h2>Strategy/algorithm</h2>
<p>This program checks to see which of the various possible irradiated versions are shortest when compressed, and chooses a byte to delete that produces one of those most-compressible targets.</p>
<p>The idea behind this algorithm is:</p>
<ul>
<li>Repetitive chaff (like <code>///////////////</code>) compresses very well, so the algorithm avoids damaging it (which is generally a useless thing to do, programs with long repeating runs of characters rarely care about the exact number);</li>
<li>Redundant parts of a program (that could survive damage) are often repeated multiple times; the algorithm will tend not to damage those because damaging one copy will make the program less compressible, rather than more;</li>
<li>If one redundant part of a program does have to be damaged (e.g. because the entire program is made of them), the algorithm will then tend to try to damage other parts in the same way;</li>
<li>If a program is formed of some completely random chaff, plus some meaningful code, the algorithm is more likely to target the meaningful code; this is because meaningful code often contains near-repeats (and the algorithm will tend to make them more exact repeats, thus breaking the code), whereas completely random chaff doesn't, and so there's more of a compressibility gain to attacking the meaningful code than the chaff.</li>
</ul>
<p>Jelly doesn't have compression (as opposed to decompression) builtins, so in order to work out what the most compressible irradiated versions are, I had to write my own compressor. The idea is to take a Burrows–Wheeler transform of the input (this is the same general technique that <code>bzip2</code> uses) – take all cyclic permutations of the irradiated program, sort them, and look at the last bytes of each permutation in their sorted order. If a substring appears repeatedly, then imagine the cyclic permutations that split that substring between the start and end of the string; for each copy, the portion that's at the start will be the same, so they'll sort next to each other, and thus the portion at the end (which is also the same) will also sort next to each other, creating runs of the same value in the list of the last bytes.</p>
<p>Burrows–Wheeler-based compression works by run-length-encoding that list of the last bytes, but to work out which irradiated program is the most compressible, there's no actual need to go through with the rest of the compression; it's possible simply to count how many runs there are. This submission does that, looks for the irradiated version with the fewest runs, and outputs whichever byte will produce that particular irradiated version.</p>
<p>Often there'll be more than one possibility, in which case this program picks at random.</p>
<p>The TIO! link above shows this program attacking NÜL tränslätör – there are only two target bytes it will attack, the <code>r</code> of <code>tr</code> and the first <code>&quot;</code> of <code>printf  &quot;%d &quot;</code>. Both of these bytes are fatal to the target, so the algorithm is making good choices there. (The attack on the <code>printf</code> quotes is because the other <code>printf</code>s don't use quotes, so it's trying to make all the <code>printf</code>s the same. I'm not totally sure what causes the attack on <code>tr</code>, but suspect that it's related to most uses of <code>r</code> being in an expression (<code>r+1</code>) or to spell <code>printf</code> – the algorithm has thus correctly identified meaningful code that doesn't have a redundant copy elsewhere in the program.)</p>
<h2>Installation</h2>
<p>There's no change from my other Jelly answer. So that this answer is complete, I'm repeating the instructions here:</p>
<ul>
<li>Install python3 and pip3 (on Ubuntu, <code>python3</code> and <code>python3-pip</code>); also <code>git</code> if you haven't already.</li>
<li>You will need to run from an account with a real home directory – if your container is so stripped down that it doesn't have one, create one with, e.g.,
<pre class="lang-bash prettyprint-override"><code>mkdir ./home
export HOME=$(readlink -f ./home)
</code></pre>
</li>
<li>Install Jelly using the instructions at <a href="https://github.com/DennisMitchell/jellylanguage" rel="noreferrer">https://github.com/DennisMitchell/jellylanguage</a>:
<pre class="lang-bash prettyprint-override"><code>git clone -q https://github.com/DennisMitchell/jellylanguage.git
cd jellylanguage
pip3 install --upgrade --user .
</code></pre>
</li>
</ul>
<p>To run programs: <code>LANG=C.ISO-8859-1 ~/.local/bin/jelly f <em>programfilename</em></code>, where <em>programfilename</em> is the name of the program you're running. Standard input can be piped in or redirected from a file, as normal.</p>
<h2>Explanation</h2>
<h3>Radiation hardening</h3>
<p>The first half of the program is just chaff, intended to create false-positives for most programs that try to aim their attacks, and to take ages to chew through for programs that scan from the start of the program in sequence – it's possible to delete the whole thing and nothing will change. Almost everything here is a) the empty string, or b) a function that always returns one of its arguments literally, so even if some of this code somehow ends up running, it won't do anything. However, Jelly starts execution from the start of the last line of the program, so you need to start deleting newlines in order to even get the code to run.</p>
<p>The radiation hardening is done using three copies of the core program logic – the longest will be run. As an improvement over my previous Jelly submission, I separated them with multiple <code>“</code> marks (which in this context are kind-of like commas) – in order to cause two copies to be combined and become longest, you need to delete all the <code>“</code> marks in that section. Most likely, it's easier to disrupt the program by damaging all three copies separately than by causing two to be combined.</p>
<p>I didn't radiation-harden the code that selects an appropriate copy to run, but it's only four bytes long and one is hardened (as <code>¹</code> is a no-op in most contexts, making it safe to add redundant copies of it), so hard to hit unless aiming at this program in particular:</p>
<pre><code>ẈMị¹
Ẉ     Take the length of each program in the list
 M    Find the indexes of the maximums (i.e. longest programs)
  ị   Index back into
   ¹    the original list
</code></pre>
<p>This gives us a list of the longest programs, which is subsequently evaluated using <code>V</code>. The programs actually get concatenated together by <code>V</code>, so there's an intentional crash to exit before the program runs a second time and produces output again.</p>
<h3>Target selection</h3>
<pre><code>⁹ƈ€µTịµJḟⱮ`ịṙṢṪ€ɗ€JŒgẈNMX©ịṭ®_1¤KȮị
⁹ €                                   Form a list of 256 elements
 ƈ                                      read from standard input
    T                                 Find the truthy elements
   µ i                                  and select them
       J                              Take the indexes of the elements
         Ɱ`                           For each index
        ḟ                               produce a list of indexes that omits it
      µ    ị                          Index back into the input
                ɗ€                    On each of those lists, do:
            ṙ     J                     rotate it by all possible amounts
             Ṣ                          sort the rotated lists
              Ṫ                         take the last element
               €                          of each of the rotated lists
                   Œg                 Group consecutive equals in {each list}
                     Ẉ                Take the length of each list
                      NM              Find all indexes of the minimum value
                        X             Pick one at random
                         ©              and store it in ®
                          ị           Take the {input character} at that index
                           ṭ          Prepend
                            ®_1¤        ® - 1
                                K     separated by a space
                                 Ȯ    Output the result
                                  ị   Index {using a string}, crashes
            
</code></pre>
<p>The <code>ṙ … J</code> is actually slightly buggy – the <code>J</code> is measuring against the length of the original program, not the length of the irradiated version, so one of the rotated lists ends up being added twice. However, this ends up having no impact on the results, because the two identical lists will sort next to each other, and their last elements are the same, thus end up in the same run of consecutive equals and don't change the total number of runs.</p>
</div>
<div id="pu15" class="pu"><h1>Tapestry, <a href="https://esolangs.org/wiki/Fish" rel="nofollow noreferrer">&lt;&gt;&lt;</a></h1>
<p>No good strategy, focuses on being very hardened. Each character is at least 4x redundant.</p>
<pre><code>iiiiiiiivvvvvvv



lllllllllllllll



111111111111111



---------------



nnnnnnnnnnnnnnn



888888888888888



222222222222222



222222222222222



***************



***************



ooooooooooooooo



ooooooooooooooo



;;;;;;;;;;;;;;;
</code></pre>
<h2>Explanation:</h2>
<ol>
<li><code>iiiiiiii</code> push the first 8 characters of our opponent to the stack.</li>
<li><code>v</code> go down</li>
<li><code>l</code> get the length of the stack. In case one of the <code>i</code> was deleted</li>
<li><code>1</code> push one to the stack</li>
<li><code>-</code> subtract 1 to get a 0 based index</li>
<li><code>n</code> print this as a number, this is the index</li>
<li><code>822**</code> push &quot;32&quot; to the stack, the ASCII code for space</li>
<li><code>o</code> print a space</li>
<li><code>o</code> print the original character</li>
<li><code>;</code> end the program</li>
</ol>
<h2>Setup</h2>
<pre class="lang-bash prettyprint-override"><code>if [[ ! -f fish.py ]]
then
            wget https://gist.github.com/anonymous/6392418/raw/3b16018cb47f2f9ad1fa085c155cc5c0dc448b2d/fish.py
fi
</code></pre>
<h2>Run</h2>
<pre class="lang-bash prettyprint-override"><code>python3 fish.py code
</code></pre>
</div>
<div id="pu16" class="pu"><h1><a href="https://github.com/DJMcMayhem/V" rel="nofollow noreferrer">V (vim)</a>, Golf Core</h1>
<pre><code>00000000: 1b1b 1b1b 1b1b 1b1b 1b1b 1b1b 1b1b 1b1b  ................
00000010: 1b1b 1b1b 1b1b 1b1b 1b1b 1b1b 1b1b 1b1b  ................
00000020: 1b1b 1b1b 1b1b 1b1b 1b1b 1b1b 1b1b 1b1b  ................
00000030: 1b1b 1b1b 1b1b 1b1b 1b1b 1b1b 1b1b 1b1b  ................
00000040: 3132 3334 3536 3738 394a 4a4a 4a4a 4a4a  123456789JJJJJJJ
00000050: 4a4a 4a4a 4a4a 4a4a 4a4a 4a4a 4a20 4449  JJJJJJJJJJJJJ DI
00000060: 3020 1b1b 1b1b 1b1b 1b1b 1b1b 1b1b 1b1b  0 ..............
00000070: 1b1b 1b1b 1b1b 1b1b 1b1b 1b1b 1b1b 1b1b  ................
00000080: 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f 6162 6365  ////////////abce
00000090: 6620 6768 696b 6d20 6e6f 7071 7220 7374  f ghikm nopqr st
000000a0: 7576 7720 7879 7a41 4220 4345 4648 4a20  uvw xyzAB CEFHJ
000000b0: 4b4c 4d4e 4f20 5051 5253 5420 5557 5859  KLMNO PQRST UWXY
000000c0: 5a20 2829 5b5d 7b7d 2020 2020 2028 5b5d  Z ()[]{}     ([]
000000d0: 7b7d 2920 285b 7b7d 5d29 20e5 a4a9 e59c  {}) ([{}]) .....
000000e0: b0e7 8e84 e9bb 84e5 ae87 e5ae 99e6 b4aa  ................
000000f0: e88d 920d 0d0d 0d0d 0d0d 0d0d 1b1b 1b1b  ................
</code></pre>
<p><a href="https://tio.run/##K/v/X5q6ICvMPSXHxdNAgRjFVmggMSk5NU0hPSMzO1chL7@gsEihuKS0rFyhorLK0UnB2dXNw0vB28fXz18hIDAoOEQhNDwiMkrB0MjYxFTBzNzCUkEjOra6VhNIVdfGaiocXnpoyaGVQHLOoQ2Hlx/qO9RyeOWh3UBy6aF1h9rB5MzDyw5tObTq8IpDvYcmccEAyG3//wcn5hbkpCp45hWUlnBlFnNlpBalAgA" rel="nofollow noreferrer" title="V (vim) – Try It Online">Try it online!</a></p>
<p>A stupid program which always remove the first character from input. Try to confuse other programs by the unprintable bytes. The only thing that make sense here is <code>89J DI0 &lt;esc&gt;</code>.</p>
<hr />
<p>I'm not sure if this is valid since V doesn't read from stdin but from a file. (I failed to make it read from stdin.)</p>
<p>Starting from Python 3.6 docker container (you may need to mount source code folder into the container so it could be used later)</p>
<pre class="lang-bash prettyprint-override"><code>docker run -it --name=thev python:3.6 /bin/bash
</code></pre>
<p>Download source code and install all dependency</p>
<pre class="lang-bash prettyprint-override"><code>cd ~
pip install docopt neovim trollius
apt update
apt install neovim -y
apt install xterm -y
wget https://github.com/DJMcMayhem/V/archive/refs/heads/master.zip
unzip master.zip
cd V-master
</code></pre>
<p>Place the source code into the container some how</p>
<pre class="lang-bash prettyprint-override"><code>xxd -r &gt; ~/program.v
  (paste the xxd source code in this post)
</code></pre>
<p>Open another terminal, and run the program</p>
<pre class="lang-bash prettyprint-override"><code>docker exec -i thev /bin/bash -c 'cat - &gt; ~/input &amp;&amp; ~/V-master/v ~/program.v -f ~/input'
</code></pre>
</div>
<div id="pu17" class="pu"><h1>NÜL tränslätör - Bash</h1>
<p>Just run it with <code>bash</code>, it should work (TM).</p>
<pre class="lang-bash prettyprint-override"><code>##((()
##(()

i=$(tr  '\0'  ' ')

s=$(printf  %s  &quot;$i&quot;|wc  -c)

[  $s  -gt  -1  ]||s=$(printf  %s  &quot;$i&quot;|wc  -c)

r=$((RANDOM%s))

[  $r  -gt  -1  ]||r=$((RANDOM%s))

printf  &quot;%d &quot;  $r

p=$((r+1))

p=$((r+1))

printf  %s  &quot;$i&quot;|head  -c  $p|tail  -c1
##((()
</code></pre>
<p>It can survive some parts being broken, but unfortunately not syntax errors.
Eg. if <code>$s</code> isn't a valid integer, <code>[</code> will fail and <code>s</code> will be reassigned.</p>
<pre><code>IyMoKCgpCiMjKCgpCgppPSQodHIgICdcMCcgICcgJykKCnM9JChwcmludGYgICVzICAiJGkifHdj
ICAtYykKClsgICRzICAtZ3QgIC0xICBdfHxzPSQocHJpbnRmICAlcyAgIiRpInx3YyAgLWMpCgpy
PSQoKFJBTkRPTSVzKSkKClsgICRyICAtZ3QgIC0xICBdfHxyPSQoKFJBTkRPTSVzKSkKCnByaW50
ZiAgIiVkICIgICRyCgpwPSQoKHIrMSkpCgpwPSQoKHIrMSkpCgpwcmludGYgICVzICAiJGkifGhl
YWQgIC1jICAkcHx0YWlsICAtYzEKIyMoKCgpCg==
</code></pre>
<h2>Non-competing version</h2>
<p>This one can handle NUL bytes, I think.</p>
<pre class="lang-bash prettyprint-override"><code>##()()
##()()

f=ooga

f=ooga

cp  /dev/stdin  $f

s=$(wc  -c &lt; $f)

[  $s  -gt  -1  ]||s=$(wc  -c &lt; $f)

r=$((RANDOM%s))

[  $r  -gt  -1  ]||r=$((RANDOM%s))

printf  &quot;%d &quot;  $r

p=$((r+1))

p=$((r+1))

(head  -c  $p  $f||head  -c  $p  $f)|tail  -c1
##()()
</code></pre>
<p>But it saves input in a temp file violating rule 2.</p>
</div>
<div id="pu18" class="pu"><h1>Natural Radiation - <a href="http://jsoftware.com/" rel="nofollow noreferrer">J</a></h1>
<pre><code>              (       ]                   (      (                    [:        &quot;:           [          ),          ' ',               {      )    ~            [:                  ?         #         )          (1!:1@3              '')                   
</code></pre>
<p><a href="https://tio.run/##y/r/XwEFaEDpWAVMoIGqBAVEW8FYSlbIwgimpg6Cra6groNmQDVUFYiow24yAtjDWcoI85EcaqhoZehgjKpHXV0Ti7v//wcA" rel="nofollow noreferrer" title="J – Try It Online">Try it online!</a> (although TIO won't accept EOF signals/characters for input as far as I'm aware, so it may not work as intended)</p>
<h3>Installation</h3>
<p>(<a href="http://www.jsoftware.com/download/j903/install/j903_linux64.tar.gz" rel="nofollow noreferrer">source</a>)</p>
<p>These instructions assume you are on a x86_64 processor. If you are on armv7/armv8/aarch64, use the Raspberry Pi downloads in the link above.</p>
<p>Prior to installation, you may need to install necessary libraries:</p>
<pre><code>apt-get install libqtgui4 libqt4-svg libqt4-svg libqt4-opengl libqt4-network libqtwebkit4
</code></pre>
<p>Then, save the installation archive (recommended location is the home folder, but can be installed anywhere else with sufficient permissions) with a command similar to</p>
<pre><code>wget http://www.jsoftware.com/download/j903/install/j903_linux64.tar.gz
</code></pre>
<p>Now extract the archive. There should be a folder called <code>j903</code>. Inside the folder, there should be a file called <code>jconsole.sh</code>.</p>
<h3>How to run</h3>
<h4>Option 1</h4>
<pre><code>./jconsole.sh
</code></pre>
<p>Then, paste the source code above in to the console (followed by a newline), or pass it in by script.</p>
<h4>Option 2</h4>
<p>Run the code below. The additional <code>echo</code> is necessary due to the limitations of program output when running directly from script. The <code>echo</code> is generally not counted as part of the source code. In addition, there is an additional character inside the body due to the need to escape the <code>&quot;</code> character.</p>
<pre><code>./jconsole.sh -js &quot;echo               (       ]                   (      (                    [:        \&quot;:           [          ),          ' ',               {      )    ~            [:                  ?         #         )          (1!:1@3              '')                   &quot;
</code></pre>
<h4>Option 3</h4>
<p>Save source code into file and run:</p>
<pre><code>./jconsole.sh code.ijs
</code></pre>
<p>However, there are some caveats. Firstly, <code>echo</code> may need to be added to the beginning of the code to get the output to work correctly (like in Option 2) due to how J is primarily an interpreted language. Also, the appearance of an EOF in stdin may cause extra undesired output to be written to stderr. Finally, I have not tested this on an Ubuntu Linux device as I do not have access to one and am currently unable to access Docker to set one up.</p>
<h3>Explanation</h3>
<p>Just like natural random radiation events, this bot will choose a random character to remove from its target. The bot itself has some basic radiation resistance, but is unable to handle targeted radiation attacks.</p>
</div>
<div id="pu19" class="pu"><h1>MVP - <a href="https://docs.python.org/3/" rel="noreferrer">Python 3</a></h1>

<pre class="lang-python prettyprint-override"><code>import sys
print(&quot;0 &quot;+sys.stdin.read()[:1])
</code></pre>
<p><a href="https://tio.run/##rc/NCoJAFAXgvU9hA@q9KDYWRjTZi0SB@JPXwVHGWSTis08iBD1AZ3fOtzrDZJpeHa2lbui1ccdpdAZNygDjLgvXGo@mJBXrKi8B75fkgdbu/x9HRq3oclJAONe9hjZ7VaZocg0o6HpIU9@Xt4wLCkOc5S/WsAOQfnI64zOAAHHeHtTAvNL1ChZRJFFUbzLAUSzLV/mG7Tp9AA" rel="noreferrer" title="Python 3 – Try It Online">Try it online!</a></p>
<p>MVP - (noun) Minimum Viable Product. This bot meets all the requirements set out in the challenge with 43 bytes. It is unsurprisingly not particularly radiation-resistant.</p>
<h3>Installation</h3>
<pre class="lang-python prettyprint-override"><code>apt-get install python3
</code></pre>
<h3>How to run</h3>
<p>Depending on how you have Python installed:</p>
<pre class="lang-python prettyprint-override"><code>python code.py 
</code></pre>
<p>or</p>
<pre class="lang-python prettyprint-override"><code>python3 code.py
</code></pre>
</div>
<div id="pu20" class="pu"><h1><a href="https://github.com/Vyxal/Vyxal" rel="nofollow noreferrer">Vyxal</a>, The Terrible Bot</h1>
<pre><code>□⁋□⁋###□⁋□⁋
;;}□⁋□⁋□⁋ ėλntt¶ntt=¬;;;Ḋƛ'kwntc¬; λ\#\#\/\#\/JJJJnttc¬;Ẏ;;;Þf℅h :::: □⁋i \   pJ
;;}□⁋□⁋□⁋ ėλntt¶ntt=¬;;;Ḋƛ'kwntc¬; λ\#\#\/\#\/JJJJnttc¬;Ẏ;;;Þf℅h :::: □⁋i \   pJ
;;}□⁋□⁋□⁋ ėλntt¶ntt=¬;;;Ḋƛ'kwntc¬; λ\#\#\/\#\/JJJJnttc¬;Ẏ;;;Þf℅h :::: □⁋i \   pJ
</code></pre>
<p><a href="https://vyxal.pythonanywhere.com/#WyIiLCIiLCLilqHigYvilqHigYsjIyPilqHigYvilqHigYtcbjs7feKWoeKBi+KWoeKBi+KWoeKBiyDEl867bnR0wrZudHQ9wqw7OzvhuIrGmydrd250Y8KsOyDOu1xcI1xcI1xcL1xcI1xcL0pKSkpudHRjwqw74bqOOzs7w55m4oSFaCA6Ojo6IOKWoeKBi2kgXFwgICBwSlxuOzt94pah4oGL4pah4oGL4pah4oGLIMSXzrtudHTCtm50dD3CrDs7O+G4isabJ2t3bnRjwqw7IM67XFwjXFwjXFwvXFwjXFwvSkpKSm50dGPCrDvhuo47OzvDnmbihIVoIDo6Ojog4pah4oGLaSBcXCAgIHBKXG47O33ilqHigYvilqHigYvilqHigYsgxJfOu250dMK2bnR0PcKsOzs74biKxpsna3dudGPCrDsgzrtcXCNcXCNcXC9cXCNcXC9KSkpKbnR0Y8KsO+G6jjs7O8OeZuKEhWggOjo6OiDilqHigYtpIFxcICAgcEoiLCIiLCIgICAgaGVsbG8gYXNkLy9hc2RcbmFzZGFzZGFzZC8vYSJd" rel="nofollow noreferrer">Try it Online!</a></p>
<p>Base64-encoded:</p>
<pre><code>4pah4oGL4pah4oGLIyMj4pah4oGL4pah4oGLCjs7feKWoeKBi+KWoeKBi+KWoeKBiyDEl867bnR0wrZudHQ9wqw7OzvhuIrGmydrd250Y8KsOyDOu1wjXCNcL1wjXC9KSkpKbnR0Y8KsO+G6jjs7O8OeZuKEhWggOjo6OiDilqHigYtpIFwgICBwSgo7O33ilqHigYvilqHigYvilqHigYsgxJfOu250dMK2bnR0PcKsOzs74biKxpsna3dudGPCrDsgzrtcI1wjXC9cI1wvSkpKSm50dGPCrDvhuo47OzvDnmbihIVoIDo6Ojog4pah4oGLaSBcICAgcEoKOzt94pah4oGL4pah4oGL4pah4oGLIMSXzrtudHTCtm50dD3CrDs7O+G4isabJ2t3bnRjwqw7IM67XCNcI1wvXCNcL0pKSkpudHRjwqw74bqOOzs7w55m4oSFaCA6Ojo6IOKWoeKBi2kgXCAgIHBK
</code></pre>
<h3>Installation</h3>
<pre><code>pip install vyxal
</code></pre>
<h3>Running</h3>
<pre><code>vyxal code.vy
</code></pre>
</div>
<div id="pu21" class="pu"><h1><a href="https://esolangs.org/wiki/A_Pear_Tree" rel="noreferrer">A Pear Tree</a>, Distributed Damage</h1>
<p>A Pear Tree isn't actually that good at this challenge as languages go – its general efficiency at <a href="/questions/tagged/radiation-hardening" class="post-tag" title="show questions tagged &#39;radiation-hardening&#39;" rel="tag">radiation-hardening</a> is because it's good at <em>detecting</em> damage, but it has no real way to <em>repair</em> it, so the best you can do is to write the same program several times in a row and hope that at least one copy stays undamaged.</p>
<p>Nonetheless, I'm entering an answer by <a href="https://chat.stackexchange.com/transcript/240?m=61812860#61812860">popular demand</a> :-)</p>
<p>This program contains unprintable characters (thus no TIO link). However, it looks something like this (except that <code>��\n</code> are actually three non-newline nonprintable characters); see below for a hex dump:</p>
<pre class="lang-perl prettyprint-override"><code>l=length;(.618*l)=~/\..*/;i=int($&amp;*l);$_=i.&quot; &quot;.substr$_,i,1#-��
l=length;(.618*l)=~/\..*/;i=int($&amp;*l);$_=i.&quot; &quot;.substr$_,i,1#-��
l=length;(.618*l)=~/\..*/;i=int($&amp;*l);$_=i.&quot; &quot;.substr$_,i,1#-��
l=length;(.618*l)=~/\..*/;i=int($&amp;*l);$_=i.&quot; &quot;.substr$_,i,1#-��
</code></pre>
<h2>Hexdump</h2>
<p>This is the actual submission, as an <code>xxd</code> reversible hex dump.</p>
<pre><code>00000000: 6c3d 6c65 6e67 7468 3b28 2e36 3138 2a6c  l=length;(.618*l
00000010: 293d 7e2f 5c2e 2e2a 2f3b 693d 696e 7428  )=~/\..*/;i=int(
00000020: 2426 2a6c 293b 245f 3d69 2e22 2022 2e73  $&amp;*l);$_=i.&quot; &quot;.s
00000030: 7562 7374 7224 5f2c 692c 3123 2db4 9616  ubstr$_,i,1#-...
00000040: 6c3d 6c65 6e67 7468 3b28 2e36 3138 2a6c  l=length;(.618*l
00000050: 293d 7e2f 5c2e 2e2a 2f3b 693d 696e 7428  )=~/\..*/;i=int(
00000060: 2426 2a6c 293b 245f 3d69 2e22 2022 2e73  $&amp;*l);$_=i.&quot; &quot;.s
00000070: 7562 7374 7224 5f2c 692c 3123 2db4 9616  ubstr$_,i,1#-...
00000080: 6c3d 6c65 6e67 7468 3b28 2e36 3138 2a6c  l=length;(.618*l
00000090: 293d 7e2f 5c2e 2e2a 2f3b 693d 696e 7428  )=~/\..*/;i=int(
000000a0: 2426 2a6c 293b 245f 3d69 2e22 2022 2e73  $&amp;*l);$_=i.&quot; &quot;.s
000000b0: 7562 7374 7224 5f2c 692c 3123 2db4 9616  ubstr$_,i,1#-...
000000c0: 6c3d 6c65 6e67 7468 3b28 2e36 3138 2a6c  l=length;(.618*l
000000d0: 293d 7e2f 5c2e 2e2a 2f3b 693d 696e 7428  )=~/\..*/;i=int(
000000e0: 2426 2a6c 293b 245f 3d69 2e22 2022 2e73  $&amp;*l);$_=i.&quot; &quot;.s
000000f0: 7562 7374 7224 5f2c 692c 3123 2db4 9616  ubstr$_,i,1#-...
</code></pre>
<h3>Strategy/algorithm</h3>
<p>Most of the submissions to this challenge so far use one of two hardening strategies: either the &quot;core and chaff&quot; strategy, in which only a part of the program has any meaning and the rest is just junk to distract the opponents, or a more traditional <a href="/questions/tagged/radiation-hardening" class="post-tag" title="show questions tagged &#39;radiation-hardening&#39;" rel="tag">radiation-hardening</a> approach which has redundant copies of all the important data and will attempt to find and use an undamaged copy.</p>
<p>Distributed Damage works by trying to spread its deletions evenly over the target program; against &quot;core and chaff&quot; this is probably a bit more likely to hit the core than choosing randomly (the <em>first</em> shot is no better than random, but subsequent shots avoid areas that didn't kill the opponent, and are thus more likely to aim for places that could); and against &quot;redundant copies&quot; this is more likely than random to damage every copy and thus prevent the program being repaired.</p>
<p>In order to work out where the program has previously attacked, the attack position is based entirely on the length of the target program (thus, if the program is, e.g., 219 bytes long, it's possible to determine where the previous attack was via knowledge of which byte is attacked in a 220-byte program). The length of the target program is multiplied by (an approximation of) the golden ratio, and the fractional portion of the result is used to give the target to attack – this naturally leads to the attack positions being spread in a distributed way across the target program.</p>
<p>This algorithm was inspired by nature – many plants use the same algorithm to, e.g., place their leaves in such a way that they aren't blocking each others' view of the sun, because it makes it possible to distribute locations approximately evenly even if you don't know in advance how many of them there will be, and the calculation is very simple.</p>
<p>The radiation hardening isn't anything special, just a &quot;redundant copies&quot; approach, with four copies of the 64-byte program (256 bytes in all). The last four bytes of each copy are a checksum; A Pear Tree refuses to run programs unless they have a section that checksums correctly, and will run that section first (thus, if any of the four copies is undamaged, that copy runs). Unfortunately, this means that there's no way to continue if all four copies get damaged, because the program won't parse at all. (It might be possible to put a secondary checksum around the portion from <code>i=</code> onwards so that at least the interpreter would have <em>something</em> to run if every copy got damaged, but that would be unlikely to get extra kills, and I ran out of bytes so there's no room for extra checksums.)</p>
<p>I'm hoping that this answer will do particularly well defending against, and decently at attacking, &quot;tiny core&quot; programs that aim purely for survival rather than kills, and don't have any algorithm for choosing targets – such programs nearly always choose targets near the start, and this program is unlikely to stop working unless all four quarters of it get hit (in particular, the last quarter has to get hit). Programs like Almost Rare that are designed to detect programs consisting of redundant copies and damage them all in the same way are likely to beat this very quickly, though.</p>
<h2>Installation</h2>
<p>Install <code>perl</code> if necessary (it's installed by default on Ubuntu).</p>
<p>Install Digest::CRC (Ubuntu package <code>libdigest-crc-perl</code>).</p>
<p>Download <a href="http://nethack4.org/esolangs/apeartree-v2.pl" rel="noreferrer">http://nethack4.org/esolangs/apeartree-v2.pl</a>.</p>
<p>To run the program, use <code>perl apeartree-v2.pl <em>programfilename</em></code>. A Pear Tree reads in binary (rather than Unicode) by default, so there's no need to worry about changing the default encoding.</p>
<h3>Explanation</h3>
<p>The interpreter for A Pear Tree will rotate an undamaged portion of the program to the start (determined by looking for a valid checksum). If it can't, that's a syntax/checksum error (<code>a partridge</code>).</p>
<p>If it finds an undamaged portion, that portion will do the following:</p>
<pre class="lang-perl prettyprint-override"><code>                       # {implicit input, reading all of stdin into $_}
l=length;              # assign length of {the input} to `l`, as shorthand
(.618*l)               # multiply the length by 0.618
        =~/\..*/;      # regex, matching from `.` to end of string
                         # i.e. this matches the fractional portion
i=int(                 # assign to `i` the value, truncated to integer, of
      $&amp;*l);             # the string matched by the regex, times `l`
$_=i                   # assign the following to $_: `i`, 
    .&quot; &quot;.                # concatenated with &quot; &quot;, concatenated with
         substr$_,       # the substring of the input
                  i,1      # starting at `i`, with length 1
#                      # comment to newline (i.e. end; there is no newline)
                       # {implicit output of $_}
</code></pre>
<p>It's a bit surprising that regexing numbers (i.e. converting them to strings and looking for the decimal point) is the tersest way to extract the fractional portion, but I haven't found anything better.</p>
<p>One change for golfiness, necessary to get this down to 64 bytes: the golden ratio is approximately equal to 1.618, not 0.618, but because we're taking the fractional portion of the result it doesn't matter what the integer portion of the value we're multiplying by is.</p>
</div>
<div id="pu22" class="pu"><h1><a href="https://github.com/catseye/FBBI" rel="noreferrer">Befunge-98 (FBBI)</a>, Comment Skipper</h1>
<p>Note: in the actual submission, the <code>r</code>s are replaced with nonprintable or invalid-UTF-8 bytes; see the hexdump below. I've used <code>r</code> to represent them in this post and in the TIO link, because all unimplemented commands in Befunge-98 have identical semantics to <code>r</code>.</p>
<pre><code>50050050050050050050050050050050050050050xxxxxnnnnn#####;;;;;~~~~~:::::~~~~~-----!!!!!!!!!!;;;;;@@@@@,,,,,.....;;;;;#####\\\\\kkkkkrrrrr'''''#####-----:::::ccccc-----*****#####rrrrr!!!!!;;;;;#####-----aaaaa~~~~~+++++;;;;;#####11111kkkkkrrrrr22222+++++;;;;;
</code></pre>
<p><a href="https://tio.run/##jc69CoMwFIbh3bsoHYRafyoItl28kC41xl9wEAqdeuuR9xs8ax8yJOecfEnr@886@PReh1AVxX/rixVnPPHDA9qlOB000uCKDKop4IUFG2KooRSFOuh4gboatni78Ya@kcC6N9hDJWwkBGac67zvh3GaozwnqHVdRGUH" rel="noreferrer" title="Befunge-98 (FBBI) – Try It Online">Try it online!</a></p>
<h2>Hexdump</h2>
<p>This is the actual submission, as an <code>xxd</code> reversible hex dump.</p>
<pre><code>00000000: 3530 3035 3030 3530 3035 3030 3530 3035  5005005005005005
00000010: 3030 3530 3035 3030 3530 3035 3030 3530  0050050050050050
00000020: 3035 3030 3530 3035 3078 7878 7878 6e6e  050050050xxxxxnn
00000030: 6e6e 6e23 2323 2323 3b3b 3b3b 3b7e 7e7e  nnn#####;;;;;~~~
00000040: 7e7e 3a3a 3a3a 3a7e 7e7e 7e7e 2d2d 2d2d  ~~:::::~~~~~----
00000050: 2d21 2121 2121 2121 2121 213b 3b3b 3b3b  -!!!!!!!!!!;;;;;
00000060: 4040 4040 402c 2c2c 2c2c 2e2e 2e2e 2e3b  @@@@@,,,,,.....;
00000070: 3b3b 3b3b 2323 2323 235c 5c5c 5c5c 6b6b  ;;;;#####\\\\\kk
00000080: 6b6b 6bff ffff ffff 2727 2727 2723 2323  kkk.....'''''###
00000090: 2323 2d2d 2d2d 2d3a 3a3a 3a3a 6363 6363  ##-----:::::cccc
000000a0: 632d 2d2d 2d2d 2a2a 2a2a 2a23 2323 2323  c-----*****#####
000000b0: 0000 0000 0021 2121 2121 3b3b 3b3b 3b23  .....!!!!!;;;;;#
000000c0: 2323 2323 2d2d 2d2d 2d61 6161 6161 7e7e  ####-----aaaaa~~
000000d0: 7e7e 7e2b 2b2b 2b2b 3b3b 3b3b 3b23 2323  ~~~+++++;;;;;###
000000e0: 2323 3131 3131 316b 6b6b 6b6b c1c1 c1c1  ##11111kkkkk....
000000f0: c132 3232 3232 2b2b 2b2b 2b3b 3b3b 3b3b  .22222+++++;;;;;
</code></pre>
<h2>Strategy/algorithm</h2>
<p>Looks at characters in pairs from the start of the program. If they're:</p>
<ul>
<li>not equal, deletes the first character of the pair;</li>
<li>equal but not <code>//</code> nor <code>##</code>, moves onto the next pair;</li>
<li>equal and <code>//</code> or <code>##</code>, moves onto the next line.</li>
</ul>
<p>The idea is that if programs in practical languages are using &quot;hide where my code is&quot; techniques rather than proper radiation-hardening techniques, we should be able to find the start of the real code. If the program starts with a large number of repetitive no-ops, we can skip over those because every consecutive pair in a long string of repeated characters is equal; if it starts with a comment marker consisting of repeated characters, that's in most practical languages probably going to be <code>////… \n</code> or <code>#####… \n</code> and we can skip to the next line; if it starts with a comment/literal marker that doesn't consist of repeated characters (such as <code>/*</code>) we can in most cases simply delete the first character of the marker to uncomment the chaff code, which will also typically break a program because the chaff isn't valid code. (Python also has <code>'''</code> and <code>&quot;&quot;&quot;</code> as literal markers, but these have an odd length so we damage the marker rather than the useless contents inside.) So there's a reasonable chance that the first or second character we delete will end up breaking the program we're attacking.</p>
<h2>Installation</h2>
<p>Install appropriate packages for building C programs (on Ubuntu, this is <code>build-essential</code>), and download <a href="https://catseye.tc/distfiles/fbbi-1.0-2015.0729.zip" rel="noreferrer">https://catseye.tc/distfiles/fbbi-1.0-2015.0729.zip</a>, then:</p>
<pre class="lang-bash prettyprint-override"><code>unzip fbbi-1.0-2015.0729.zip 
cd fbbi-1.0-2015.0729/
(cd src; make)
</code></pre>
<p>Run programs using <code>bin/ffbi <i>programfilename</i></code> (while in the <code>ffbi-1.0-2015.0729/</code> directory created during the install).</p>
<h2>Explanation</h2>
<h3>Radiation hardening</h3>
<p>This is based on a technique discovered by Martin Ender for <a href="https://codegolf.stackexchange.com/a/103555">this answer</a>, which is a little difficult to explain to people who don't know Befunge-98, but I'm going to try anyway.</p>
<p>It works using the <code>x</code> command; you can think of this command as taking a pair of coordinates interpreted as a vector, and creating something line-like (a &quot;Lahey line&quot;) in 2D space by repeatedly moving in the direction of the vector (and the exact opposite direction) starting from itself. For example, if an <code>x</code> is given the coordinates (2,1), it creates the following Lahey line (which is also an actual line) in 2D space (marked with <code>+</code> signs), stretching out to infinity in both directions:</p>
<pre><code>+..........
..+........
....x......
......+....
........+..
..........+
</code></pre>
<p>Unlike actual lines, though, which pass through every point on them, specifying a vector like (2, 0) gives you a Lahey line that only passes through some of the squares along it:</p>
<pre><code>.+.+.+.x.+.+.+.+.
</code></pre>
<p>While the <code>x</code> command is in effect, the Befunge-98 interpreter basically acts as though all the commands that aren't on the Lahey line don't exist. This means that if we can set up an appropriate Lahey line that passes through every fifth character of the program (starting at the first <code>x</code> that remains in the program after radiation damage), and every character from then on (including the <code>x</code>) is repeated five times, any four characters can be deleted from the program and yet it will still have identical behaviour to the original version – in either case, the set of non-hidden characters from the <code>x</code> onwards are identical. (The idea is that before the location of the first deletion, the Lahey line passes through the first character of each set of five; between the first and second deletions, it passes through the second character of each set of five, etc., with the last character of the set being used after the fourth deletion.)</p>
<p>Befunge has a lot of commands that cancel the effect of <code>x</code> (including, most notably, <code>x</code> itself, plus pretty much all the flow control commands). That made this program a fairly awkward <a href="/questions/tagged/restricted-source" class="post-tag" title="show questions tagged &#39;restricted-source&#39;" rel="tag">restricted-source</a> challenge, as I had to write some nontrivial program logic with most of the flow control commands missing. However, the fact that <code>x</code> cancels the old Lahey line before creating a new one is useful in setting up the appropriate Lahey line delta, of (5, 0). The idea is to start by putting a lot of 5s and 0s on the stack in the repetitive <code>050 050 050 …</code> pattern (the stack starts with a zero on it, so the leading 0 can be omitted); each of these patterns (if non-irradiated) will be interpreted as either (5, 0) or (0, 5) depending on its distance from the top of the stack, and the interpretation of two adjacent patterns alternates between (5, 0) or (0, 5) unless radiation hits the upper copy of the pattern. Because there are many more than four copies of the pattern on the stack, there's thus guaranteed to be a (5, 0) pair on the stack somewhere if it's interpreted as pairs from the top. Also, there's nothing but 0s and 5s on the stack, so any pair must be (0, 0), (0, 5), (5, 0), or (5, 5).</p>
<p>Now, consider what happens when the <code>x</code> command gets run. If its argument is (5, 0), it creates the Lahey line that we want, and the program continues in its radiation-hardened way. If it's (0, 0), (0, 5) or (5, 5), then the Lahey line that's created misses our program altogether; (0, 5) and (5, 5) are vertical and diagonal lines that cross our program only at a single point, and the Lahey line (0, 0) is a special case that's inherently a single point. In these cases, therefore, <em>everything in the program</em> apart from the <code>x</code> we just ran gets hidden, so the interpreter has no choice but to run the <code>x</code> again (exiting is always explicit in Befunge), taking the next pair from the stack. Thus, with a one-liner program like this, the behaviour of <code>x</code> inherently looks at pairs of values at a time along the stack until it finds the (5, 0) that must exist, and thus is guaranteed to create a Lahey line that runs along the program in the correct way to radiation-harden it.</p>
<p>(There are many more 050 patterns in this program than are actually required for the radiation hardening to survive four deletions – the idea is to be able to survive for more than four rounds if the opponent is primarily attacking the start of the program, because most damage there is survivable; to eliminate the (5, 0) pattern entirely, a number of deletions equal to the number of 5s is required.)</p>
<h3>How to do flow control</h3>
<p>When writing the main body of the program, because almost all flow control commands cancel the Lahey line, <code>; … ;#</code> and <code>kr</code> are pretty much all I had to work with.</p>
<p><code>; … ;</code> is a jump, and adding <code>#</code>s in various places controls whether the jump is taken or skipped when executing the code in forward and/or reverse order (it also sometimes has the unfortunate side effect of skipping one character beyond the end of the jump, because <code>#</code> is a skip command, but this is easy to work around by repositioning characters; it just makes the program harder to read).</p>
<p><code>kr</code> is a method of creating a conditional without breaking the Lahey line, but it's very quirky (the semantics of <code>k</code> are famously confusing). This combination pops the stack, then does nothing if a 0 was popped, reverses the execution direction if an odd or negative number was popped (for different reasons in the two cases), and its semantics are too complicated to easily describe if an even positive number was popped – this program therefore uses only the arguments 0 and 1, to keep the behaviour of <code>kr</code> easy to understand.</p>
<p><code>r</code> on its own reverses the execution direction unconditionally, which was useful in one place (as <code>#r</code>, which reverses the execution direction only if it's currently going to the left).</p>
<p>As usual for Befunge-98, it's possible to replace <code>r</code> with any invalid command, so I picked NUL, plus two high-bit-set characters that aren't valid UTF-8, in the hope of confusing programs that don't have binary-safe input routines. (FBBI itself is binary-safe if run on a Unix-like system, like the one being used in this challenge.) The command in question is nonetheless written as <code>r</code> in this post, as that's the &quot;official&quot; name for it.</p>
<h3>Doing the actual work</h3>
<p>Once the <code>x</code> command gets hit, here's what the remaining program along hte Lahey line looks like, and how it works (there's also some junk 0s and 5s at the start but they never again get executed):</p>
<pre><code>xn#;~:~-!!;@,.;#\kr'#-:c-*#r!;#-a~+;#1kr2+;
x                                            establish Lahey line
 n                                           clean stack (pop all the 5s)
  #;                                         jump label, no-op right now
</code></pre>
<p>From this point onwards, the element currently on the top of the stack (which at this point is a 0 because the stack has just been cleaned) counts the number of bytes that the program has read.</p>
<pre><code>xn#;~:~-!!;@,.;#\kr'#-:c-*#r!;#-a~+;#1kr2+;
    ~                                        read byte
     :                                       copy it
      ~                                      read another byte
       -                                     subtract
        !!                                   cast to bool (like in C)
          ;   ;#                             jump … to jump label + skip
                 kr                          reverse direction if truthy
</code></pre>
<p>A truthy value at this point means that the two bytes we read were different, so it's time to select the first of the two bytes and exit the program. Top of the stack at this point is the first of the two bytes; the second stack element is its index (because it's still unchanged from the start of the main loop).</p>
<pre><code>xn#;~:~-!!;@,.;#\kr'#-:c-*#r!;#-a~+;#1kr2+;
                \                            swap
               ;#                            jump label, no-op going left
              .                              output integer then space
             ,                               output raw byte
            @                                exit program
</code></pre>
<p>Very convenient that Befunge's &quot;output integer then space&quot; command is usable in this challenge (because it requires a space after the integer)! If the format didn't allow/require a space there, the integer-to-decimal conversion would take up much, much more room and probably reduce the amount of radiation hardening available as a consequence.</p>
<p>If the two bytes the program read are the same, the program continues by checking to see if they're <code>//</code> and/or <code>##</code>, via arithmetic on character codes:</p>
<pre><code>xn#;~:~-!!;@,.;#\kr'#-:c-*#r!;#-a~+;#1kr2+;
                   '#-                       subtract char code of `#`
                      :  *                   multiply by (itself
                       c-                      minus 12)
                          #r                 no-op if going right
                            !                logical not
                             ;     ;#        jump … to jump label + skip
                                      kr     reverse direction if truthy
</code></pre>
<p>The direction reverse here happens if, in C syntax, <code>!(d*(d-12))</code>, where <code>d</code> is the first byte of the pair minus the character code of <code>#</code>; <code>#</code> and <code>/</code> have character codes that differ by 12, so this is true if the byte is <code>#</code> or <code>/</code> (the multiplication <code>*</code> is being used like a logical AND). In this case, the strategy is to skip until finding a newline. The top of the stack at this point is the byte counter, because everything else has been popped, and that gets update while looking for the newline:</p>
<pre><code>xn#;~:~-!!;@,.;#\kr'#-:c-*#r!;#-a~+;#1kr2+;
                                  +  1       add 1 to top of stack
                                   ;#        jump label, no-op going left
                                 ~           read byte
                               -a            subtract 10
                             ;#              jump label, no-op going left
                            !                logical not
                           r                 reverse direction
                            !                logical not again
                             ;     ;#        jump … to jump label + skip
                                      kr     reverse direction if truthy
</code></pre>
<p>In other words, the program adds 1 to the byte counter, then reads the next byte, and continues doing this until a newline was read. (This shares some of the code from the previous case – in that case, the <code>!</code> is executed once, so that the loop is exited/not entered if the character <em>isn't</em> <code>/</code> or <code>#</code>, but in this loop, the same <code>!</code> is executed twice, so that the loop is exited if the character <em>is</em> a newline. In one-line Befunge-98, opportunities like this to use the same character in both directions are rare, but fun when they happen.)</p>
<p>If the byte pair was something other than <code>//</code> or <code>##</code>, or when the newline has been found, the program's main loop continues:</p>
<pre><code>xn#;~:~-!!;@,.;#\kr'#-:c-*#r!;#-a~+;#1kr2+;
                                        2+   add 2 to top of stack
  #;                                      ;  jump … to jump label
</code></pre>
<p>This skips over the <code>xn</code> at the start, and also skips over any of the 0s and 5s that happen to fall on the Lahey line. (In Befunge-98, execution wraps, but it wraps <em>along the Lahey line</em> rather than toroidally around the program, so the same set of characters will be executed after the wrap; the program's length modulo 5 is irrelevant.)</p>
<p>The program &quot;forgot&quot; to add 2 to the byte counter after the pair was checked, so it gets done here; the reason for postponing it is that less stack manipulation is needed to set it here (because there's no need to remember the first character of the pair at this location in order to check whether it's <code>/</code> or <code>#</code>, so the byte counter is the only thing on the stack at this point), and postponing it still produces the correct results because addition is commutative, so it doesn't matter whether we add the 2 before or after adding the 1s. (The skip-to-newline loop doesn't actually inspect the byte counter, just increment it.)</p>
<p>This program doesn't actually work for all inputs – I didn't add any code to handle EOF, rather the hope is that it won't be given input for which the algorithm reaches EOF before reaching a termination condition. I think this is probably a reasonable tradeoff – code to handle EOF given the stringent restrictions on control flow would make the program much longer and thus reduce the amount of radiation it could withstand, as I'd have to use a higher-frequency Lahey line to fit it all into 256 bytes.</p>
</div>
<div id="pu23" class="pu"><h1>Ghost, <a href="https://github.com/wspace/meth0dz-c/blob/889c0ba9f9bcf0844f69071f0d3881a1b6b4da74/whitespace.c" rel="noreferrer">Whitespace</a></h1>
<p>A bot that will remove white-space from other bots, while itself being made of only whitespace.</p>
<h2>Code:</h2>
<pre><code>    
v 
 un 
                0r      
e_
    
    
 
    
                of 
 e
                
r\ 
 }           
y       
        
g 
 i          
e       nc
        
te 
 (s          
no      
        
l 

an      
i(     \w
 
  

        
n 

la 

hr    
t&quot; 
    t(
 
    
l
    
'a 
    .   
             
l=  
  ) 
  ie


uin'o{tts)fa:
</code></pre>
<h2>Base64:</h2>
<pre><code>ICAgIAp2IAogdW4JCgkgCQkJMHIgICAJCmVfCiAgICAKICAgIAogCiAJCgkgCQkJb2YgCiBlCgkJCQkKclwgCiB9ICAgCSAgICAgCnkJICAJCgkgIAkKZyAKIGkgICAJICAJCmUJICAJbmMKCSAgCQp0ZSAKIChzICAgCSAJIApubwkgIAkKCSAgCQpsIAoKYW4gICAJCmkoCSAgIFx3CiAKICAKCiAgCQkKbiAKCmxhIAoKaHIgICAgCnQiIAoJdCgKIAogCQpsCiAgIAkKJ2EgCgkuCQogCSAgIAkgICAgIApsPQkKICApCQogIGllCgoKdWluJ297dHRzKWZhOg==
</code></pre>
<h2>Disassembled</h2>
<pre><code>PUSH 0
DUP
READC ; backup character
RETREIVE
PUSH 1

; START MAIN LOOP
MARK 0  ; main loop


PUSH 0
DUP
READC
; SPACE PART
RETREIVE
DUP
JLT -1
DUP
PUSH ' '
SUB
JEQ 1

; TAB PART
DUP
PUSH 9 ; tab
SUB
JEQ 1
; END TAB PART

; LINE BREAK PART
DUP
PUSH 10
SUB
JEQ 1
POP
; END LINE BREAK PART

PUSH 1
ADD
JMP 0

MARK -1

POP
POP
PUSH 0
SWAP
JMP 1

MARK 1

SWAP
WRITEN
PUSH ' '
WRITEC
WRITEC
EXIT
</code></pre>
<h2>Setup</h2>
<p>I spent a long time finding a whitespace interpreter that allowed me to detect EOF and write logic for it.</p>
<pre class="lang-bash prettyprint-override"><code>apt-get install -y make
apt-get install -y g++
if [[ ! -d pavelshub-cpp ]]
then
    git clone https://github.com/wspace/pavelshub-cpp.git
    cd pavelshub-cpp
    make
    cd ..
fi
</code></pre>
<p>Run:</p>
<pre><code>./pavelshub-cpp/wspace code
</code></pre>
</div>
<div id="pu24" class="pu"><h1>Parentheses Killer - <a href="https://pari.math.u-bordeaux.fr/" rel="noreferrer">PARI/GP</a></h1>
<h3>Code</h3>
<pre><code>/*in&quot;(n1fo]e)itr(s-),)i=nj1sn)io#r]nnsrt()*/print(-1+i=if(a=[i|i&lt;-[1..#s=Vec(strjoin(readstr(&quot;/dev/stdin&quot;/*1e=a1i= o&quot;&quot;sr==s,fia&quot;)[aVtid(ir.iddsr&quot;)i*/)))],s[i]==&quot;(&quot;],a[random(#a)+1],random(#s)+1)&quot; &quot;s[i])\\)i]so)(smirc/=/o&quot;r,tr+)1++[&quot;)=s&quot;[id)nos]
</code></pre>
<h3>Installation</h3>
<p>Just install the <code>pari-gp</code> package on Ubuntu.</p>
<pre class="lang-sh prettyprint-override"><code>apt install -y pari-gp
</code></pre>
<h3>How to run</h3>
<p>Assume that the filename is <code>a.gp</code>:</p>
<pre class="lang-sh prettyprint-override"><code>gp -fq a.gp
</code></pre>
<h3>Explanation</h3>
<p>Removes a random <code>(</code> if there is one. Otherwise removes a random character.</p>
<p>Some random comments are added to make it more resistant to radiation.</p>
<p>PARI/GP doesn't have a built-in to read a string from STDIN, so I have to use <code>readstr(&quot;/dev/stdin&quot;)</code>. This only works on unix-like systems.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/251161/">251161</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




