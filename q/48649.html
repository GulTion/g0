<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::48649</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>034</td><td>Vyxal</td><td>240922T061704Z</td><td><a href="https://codegolf.stackexchange.com/questions/48649/interpreting-fish-no-not-that-fish/275681#275681">emanresu</a></td></tr>
<tr d-ix="1"><td>035</td><td>Jelly</td><td>210220T232839Z</td><td><a href="https://codegolf.stackexchange.com/questions/48649/interpreting-fish-no-not-that-fish/219440#219440">caird co</a></td></tr>
<tr d-ix="2"><td>nan</td><td>Nondeterministic Turing Machine</td><td>150412T140411Z</td><td><a href="https://codegolf.stackexchange.com/questions/48649/interpreting-fish-no-not-that-fish/48762#48762">jazzpi</a></td></tr>
<tr d-ix="3"><td>nan</td><td>Python 3</td><td>180601T212803Z</td><td><a href="https://codegolf.stackexchange.com/questions/48649/interpreting-fish-no-not-that-fish/165969#165969">Alexande</a></td></tr>
<tr d-ix="4"><td>nan</td><td>I wasn't going for size</td><td>150413T143807Z</td><td><a href="https://codegolf.stackexchange.com/questions/48649/interpreting-fish-no-not-that-fish/48810#48810">Kenneth </a></td></tr>
<tr d-ix="5"><td>288</td><td>Java</td><td>150413T093501Z</td><td><a href="https://codegolf.stackexchange.com/questions/48649/interpreting-fish-no-not-that-fish/48806#48806">Landei</a></td></tr>
<tr d-ix="6"><td>299</td><td>Scala</td><td>150412T203206Z</td><td><a href="https://codegolf.stackexchange.com/questions/48649/interpreting-fish-no-not-that-fish/48778#48778">Dave Swa</a></td></tr>
<tr d-ix="7"><td>602</td><td>><></td><td>150412T144119Z</td><td><a href="https://codegolf.stackexchange.com/questions/48649/interpreting-fish-no-not-that-fish/48764#48764">David D</a></td></tr>
<tr d-ix="8"><td>319</td><td>C#</td><td>150409T082815Z</td><td><a href="https://codegolf.stackexchange.com/questions/48649/interpreting-fish-no-not-that-fish/48653#48653">VisualMe</a></td></tr>
<tr d-ix="9"><td>050</td><td>Pyth</td><td>150409T111510Z</td><td><a href="https://codegolf.stackexchange.com/questions/48649/interpreting-fish-no-not-that-fish/48661#48661">isaacg</a></td></tr>
<tr d-ix="10"><td>135</td><td>Javascript 122</td><td>150409T223454Z</td><td><a href="https://codegolf.stackexchange.com/questions/48649/interpreting-fish-no-not-that-fish/48686#48686">Ismael M</a></td></tr>
<tr d-ix="11"><td>177</td><td>Ruby</td><td>150410T124223Z</td><td><a href="https://codegolf.stackexchange.com/questions/48649/interpreting-fish-no-not-that-fish/48702#48702">Heals</a></td></tr>
<tr d-ix="12"><td>811</td><td>Perl</td><td>150409T233704Z</td><td><a href="https://codegolf.stackexchange.com/questions/48649/interpreting-fish-no-not-that-fish/48688#48688">Ilmari K</a></td></tr>
<tr d-ix="13"><td>437</td><td>fish yes</td><td>150410T092551Z</td><td><a href="https://codegolf.stackexchange.com/questions/48649/interpreting-fish-no-not-that-fish/48694#48694">xebtl</a></td></tr>
<tr d-ix="14"><td>164</td><td>JavaScript ES6</td><td>150410T090523Z</td><td><a href="https://codegolf.stackexchange.com/questions/48649/interpreting-fish-no-not-that-fish/48693#48693">edc65</a></td></tr>
<tr d-ix="15"><td>146</td><td>Haskell</td><td>150409T152242Z</td><td><a href="https://codegolf.stackexchange.com/questions/48649/interpreting-fish-no-not-that-fish/48672#48672">Zgarb</a></td></tr>
<tr d-ix="16"><td>156</td><td>Python 3</td><td>150409T095526Z</td><td><a href="https://codegolf.stackexchange.com/questions/48649/interpreting-fish-no-not-that-fish/48656#48656">xnor</a></td></tr>
<tr d-ix="17"><td>nan</td><td></td><td>150409T191822Z</td><td><a href="https://codegolf.stackexchange.com/questions/48649/interpreting-fish-no-not-that-fish/48682#48682">franklyn</a></td></tr>
<tr d-ix="18"><td>9162</td><td>CJam</td><td>150409T124544Z</td><td><a href="https://codegolf.stackexchange.com/questions/48649/interpreting-fish-no-not-that-fish/48667#48667">Optimize</a></td></tr>
<tr d-ix="19"><td>234</td><td>Python 2</td><td>150409T085351Z</td><td><a href="https://codegolf.stackexchange.com/questions/48649/interpreting-fish-no-not-that-fish/48654#48654">Logic Kn</a></td></tr>
<tr d-ix="20"><td>262</td><td>HaskellParsec</td><td>150409T114428Z</td><td><a href="https://codegolf.stackexchange.com/questions/48649/interpreting-fish-no-not-that-fish/48664#48664">swish</a></td></tr>
<tr d-ix="21"><td>142</td><td>Haskell</td><td>150409T110438Z</td><td><a href="https://codegolf.stackexchange.com/questions/48649/interpreting-fish-no-not-that-fish/48659#48659">proud ha</a></td></tr>
<tr d-ix="22"><td>186</td><td>Python 3</td><td>150409T091929Z</td><td><a href="https://codegolf.stackexchange.com/questions/48649/interpreting-fish-no-not-that-fish/48655#48655">Sp3000</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://github.com/Vyxal/Vyxal/tree/version-2" rel="nofollow noreferrer">Vyxal</a>, 34 bytes</h1>
<pre><code>Lƛ»√ĿẆ;»ðøḂτ`,&lt;.`+øṀ⌈↔vṄ;f≬ȧ?=c¤$∨
</code></pre>
<p><a href="https://vyxal.pythonanywhere.com/?v=2&amp;c=1#WyJBIiwiIiwiTMabwrviiJrEv+G6hjvCu8Oww7jhuILPhGAsPC5gK8O44bmA4oyI4oaUduG5hDtm4omsyKc/PWPCpCTiiKgiLCIiLCI8Pjw+XG48Pjw+PD5cbj48Pj48Pj5cbj48Pj48Pj48PD48PD48Pj48PiJd" rel="nofollow noreferrer">Try it Online!</a></p>
<p>I initially attempted to solve this with regex, but it's actually quite tricky, so this is a bruteforcer. Despite technically being <span class="math-container">\$O(9^n)\$</span> in the length of the input, thanks to Vyxal's laziness this will actually terminate within reasonable time for strings containing 5ish fish, although it will take ages for invalid strings. This could be <a href="https://vyxal.pythonanywhere.com/?v=2&amp;c=1#WyJBIiwiIiwiTMabwrviiJrEv+G6hjvCu8Oww7jhuILPhGAsPC5gK8O44bmA4oyI4oaUO2biiaziiJE/PWMiLCIiLCI8Pjw+XG48Pjw+PD5cbj48Pj48Pj5cbj48Pj48Pj48PD48PD48Pj48PiJd" rel="nofollow noreferrer">29 bytes</a> with looser I/O (returning 0 in the fail case, returning a list of fish)</p>
<pre><code>Lƛ                      ;          # Over every integer from 1 to the input length
                     ↔             # Get all combinations of that length of
  »√ĿẆ;»                           # Compressed integer
           τ                       # Converted to custom base
        ðøḂ                        # &quot;&lt; &gt;&quot;, yielding &quot;&gt;&lt;&gt; &gt;&gt;&lt;&gt; &gt;&lt;&gt;&gt; &gt;&lt;&lt;&lt;&gt; &quot;
            `,&lt;.`+                 # Append &quot;,&lt;.&quot; (half a crab)
                  øṀ               # Mirror
                    ⌈              # Split on spaces
                      vṄ           # And join each combination on spaces
                         f    c    # Out of all of those
                          ≬---     # Find one where
                           ȧ       # Removing whitespace
                            ?=     # Yields the input?
                               ¤$∨ # Return nothing otherwise
</code></pre>
</div>
<div id="pu1" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="nofollow noreferrer">Jelly</a>, 35 bytes</h1>
<pre><code>“¦¿Æ×‘B;¬$ị⁾&lt;&gt;“,&lt;..&gt;,”ṭ
J¢ṗẎẎ⁼¥Ƈ⁸ḢK
</code></pre>
<p><a href="https://tio.run/##y0rNyan8//9Rw5xDyw7tP9x2ePqjhhlO1ofWqDzc3f2ocZ@NHVBKx0ZPz07nUcPchzvXcnkdWvRw5/SHu/qA6FHjnkNLj7U/atzxcMci7////yvZ2IGgEgA" rel="nofollow noreferrer" title="Jelly – Try It Online">Try it online!</a></p>
<p>This is <em>brutally</em> inefficient, clocking in at around (I believe) <span class="math-container">\$O(9^{n^2})\$</span>, and times out on TIO for strings of length <span class="math-container">\$7\$</span> or more</p>
<p>Returns <code>0</code> if the input cannot be interpreted as fish</p>
<p>A much faster version is <a href="https://tio.run/##y0rNyan8//9Rw5xDyw7tP9x2ePqjhhlO1ofWqDzc3f2ocZ@NHVBKx0ZPz07nUcPchzvXcvlYGQcdWvRw5/SHu/qA6FHjnkNLj7U/atzxcMci7////9vY2AEhkARTEAQA" rel="nofollow noreferrer">38 bytes</a>, timing out for length <span class="math-container">\$21\$</span> or more</p>
<h2>How it works</h2>
<p>Similar to <a href="https://codegolf.stackexchange.com/a/48661/66833">isaacg's Pyth answer</a>, we generate all possible fish strings, then look for the one(s) equal to the input</p>
<pre><code>“¦¿Æ×‘B;¬$ị⁾&lt;&gt;“,&lt;..&gt;,”ṭ - Helper link. Returns a list of fish
“¦¿Æ×‘                  - [5,11,13,17]
      B                 - Convert to binary; [[1,0,1],[1,0,1,1],[1,1,0,1],[1,0,0,0,1]]
        ¬               - Logical NOT of each bit; [[0,1,0],[0,1,0,0],[0,0,1,0],[0,1,1,1,0]]
       ; $              - Concatenate to the bits; [[1,0,1],[1,0,1,1],...,[0,0,1,0],[0,1,1,1,0]]
          ị⁾&lt;&gt;          - Index into &quot;&lt;&gt;&quot;, replacing 1 with &lt; and 0 with &gt;
              “,&lt;..&gt;,”  - Yield the crab
                      ṭ - Append it to the fish

J¢ṗẎẎ⁼¥Ƈ⁸ḢK - Main link. Takes a fish F of length n on the left
J           - Yield [1, 2, ..., n]
 ¢          - Get the list of fish
  ṗ         - For each i in 1,2,...,n get the i'th Cartesian power of the fish
   Ẏ        - Concatenate into a list of lists
      ¥Ƈ    - Keep those lists for which the following is true:
    Ẏ       -   When concatenated into a flat list of characters,
     ⁼      -   the list equals
        ⁸   -   the input F
         Ḣ  - Take the first list of fish
          K - Join by spaces
    
</code></pre>
</div>
<div id="pu2" class="pu"><h1>Non-deterministic Turing Machine, 20 states, 52 transitions (882 bytes maybe)</h1>
<p>How do you convert this to bytes? I've written the <a href="https://www.dropbox.com/s/hezvu0u1syza2w9/fish-tm.zip?dl=0" rel="nofollow noreferrer">files</a> (absolutely not golfed) to execute this machine with Alex Vinokur's <a href="http://alexvn.freeservers.com/s1/turing.html" rel="nofollow noreferrer">Simulator of a Turing Machine</a><sup>1</sup>. <code>wc -c</code> outputs the following (excluding the description file and the input files):</p>
<pre><code> 12 alphabet
 49 meta
740 rules
 81 states
882 total
</code></pre>
<p>Anyways, I was preparing for my Computer Science A-Levels, so I thought this would be a good exercise (I don't know what I was thinking). So here's the definition:</p>
<p><span class="math-container">$$\begin{align*}
M &amp; = (Q, \Sigma, \iota, \sqcup, A, \delta) \\
Q &amp; = \{q_{0},q_{1},q_{2},q_{3},q_{4},q_{5},q_{6},q_{7},q_{8},q_{9},q_{10},q_{11},q_{12},q_{13},q_{14},q_{15},q_{16},q_{17},q_{18},q_{19}\} \\
\Sigma &amp; = \{&lt; \: ; \: &gt; \: ; \: , \: ; \: . \: ; \: X \: ; \: $\} \\
\iota &amp; = q_0 \\
\sqcup &amp; = $ \\
A &amp; = \{q_0, q_5\}
\end{align*}$$</span></p>
<p><img src="https://i.sstatic.net/pg8Dw.jpg" alt="Transition function" /></p>
<p><sup><em>(the transition function)</em></sup></p>
<p>Excuse the bad image, but I couldn't be bothered with redrawing this thing on a computer. If you actually want to decipher the transition rules, I recommend you read through the rules file I linked above.</p>
<hr>
<p>I've used <code>X</code>s instead of spaces because spaces are hard to visualize here and the simulator doesn't accept spaces in the alphabet.</p>
<p>The concept is fairly simple - q1 to q4 are used to catch right-facing fishes, q11 to q14 are used to catch left-facing fishes, q15 to q19 for crabs and the q5 to q10 blob is simply for inserting a space and moving all following characters one to the right.</p>
<p>If the string is interpretable, it accepts the string and the tape contains the string with spaces inserted. Otherwise it rejects the string (I guess this counts as no output - emptying the tape would be pretty easy but would require lots of transition rules and I don't think it would make the transition function prettier to look at).</p>
<hr>
<p><sub><em><sup>1</sup> Note: It's difficult to compile. I had to edit the <code>src/tape.cpp</code> file and replace <code>LONG_MAX</code> with <code>1&lt;&lt;30</code> and then go to the <code>demo</code> directory, edit the Makefile to replace <code>EXE_BASENAME</code> with <code>turing.exe</code> and execute <code>make</code>. Then go to the directory with the files I've written and execute <code>/path/to/turing/download/src/turing.exe meta</code>.</em></sub></p>
</div>
<div id="pu3" class="pu"><h1>Python 3, <del>166</del> 164 bytes</h1>
<pre><code>def z(s,p=''):[z(s[len(f):],p+' '+s[:len(f)])for f in'&lt;&gt;&lt; &lt;&gt;&lt;&lt; &lt;&lt;&gt;&lt; &lt;&gt;&gt;&gt;&lt; &gt;&lt;&gt; &gt;&gt;&lt;&gt; &gt;&lt;&gt;&gt; &gt;&lt;&lt;&lt;&gt; ,&lt;..&gt;,'.split(' ')if s.startswith(f)]if s else print(p[1:])
z(input())
</code></pre>
<p>Recursive solution. Late to the party, but I thought I'd post it anyway since it beats Sp3000's by <del>20</del> 22 bytes without having to brute-force the answer.</p>
</div>
<div id="pu4" class="pu"><p>I wasn't going for size, but here is an easy to understand way of doing this in Dart.</p>

<pre><code>const List&lt;String&gt; fish = const [
  "&gt;&lt;&gt;",
  "&lt;&gt;&lt;",
  "&gt;&gt;&lt;&gt;",
  "&lt;&gt;&lt;&lt;",
  "&gt;&lt;&gt;&gt;",
  "&lt;&lt;&gt;&lt;",
  "&gt;&lt;&lt;&lt;&gt;",
  "&lt;&gt;&gt;&gt;&lt;",
  ",&lt;..&gt;,"
];

String fishy(String input) {
  var chars = input.split("");
  if (chars.isEmpty || !chars.every((it) =&gt; ["&gt;", "&lt;", ",", "."].contains(it))) {
    throw new Exception("Invalid Input");
  }

  var result = [];
  var i = 0;
  var buff = "";
  while (i &lt; chars.length) {
    buff += chars[i];

    if (fish.contains(buff)) {
      result.add(buff);
      buff = "";
    } else if (chars.length == 6) {
      return "";
    }

    i++;
  }

  return result.join(" ");
}

void main() {
  print(fishy(",&lt;..&gt;,&gt;&lt;&lt;&lt;&gt;,&lt;..&gt;,&gt;&lt;&gt;,&lt;..&gt;,&lt;&gt;&gt;&gt;&lt;,&lt;..&gt;,&gt;&lt;&gt;&gt;,&lt;..&gt;,&lt;&lt;&gt;&lt;,&lt;..&gt;,&lt;&gt;&lt;,&lt;..&gt;,&gt;&gt;&lt;&gt;"));
}
</code></pre>
</div>
<div id="pu5" class="pu"><p><strong>Java, 288 bytes</strong></p>

<pre><code>public class F{public static void main(String[]q){d("",q[0]);}static System y;static void d(String a,String b){if(b.isEmpty()){y.out.println(a);y.exit(0);}for (String s : "&gt;&lt;&gt; &lt;&gt;&lt; &gt;&gt;&lt;&gt; &lt;&gt;&lt;&lt; &gt;&lt;&gt;&gt; &lt;&lt;&gt;&lt; &gt;&lt;&lt;&lt;&gt; &lt;&gt;&gt;&gt;&lt; ,&lt;..&gt;,".split(" "))if(b.startsWith(s))d(a+" "+s,b.substring(s.length()));}}
</code></pre>

<p>Formatted:</p>

<pre><code>public class F {
    public static void main(String[] q) {
        d("", q[0]);
    }

    static System y;

    static void d(String a, String b) {
        if (b.isEmpty()) {
            y.out.println(a);
            y.exit(0);
        }
        for (String s : "&gt;&lt;&gt; &lt;&gt;&lt; &gt;&gt;&lt;&gt; &lt;&gt;&lt;&lt; &gt;&lt;&gt;&gt; &lt;&lt;&gt;&lt; &gt;&lt;&lt;&lt;&gt; &lt;&gt;&gt;&gt;&lt; ,&lt;..&gt;,".split(" "))
            if (b.startsWith(s)) d(a + " " + s, b.substring(s.length()));
    }
}
</code></pre>
</div>
<div id="pu6" class="pu"><h1>Scala, 299 Bytes</h1>

<pre class="lang-scala prettyprint-override"><code>type S=String
type L[T]=List[T]
def c(s:S):L[L[S]]={val f=List("&gt;&lt;&gt;","&lt;&gt;&lt;","&gt;&gt;&lt;&gt;","&lt;&gt;&lt;&lt;","&gt;&lt;&gt;&gt;","&lt;&lt;&gt;&lt;","&gt;&lt;&lt;&lt;&gt;","&lt;&gt;&gt;&gt;&lt;",",&lt;..&gt;,").filter(s.startsWith);if(f.isEmpty)List(List(s)) else f.flatMap(i =&gt; c(s.drop(i.size)).map(i::_))}
def p(s:S)=println(c(s).find(_.last.isEmpty).fold("")(_.mkString(" ")))
</code></pre>

<h1>Test Cases</h1>

<pre class="lang-scala prettyprint-override"><code>val tests = Seq("&gt;&lt;&gt;", "&lt;&gt;&lt;", "&gt;&gt;&lt;&gt;", "&lt;&gt;&lt;&lt;", "&gt;&gt;&lt;&gt;", "&lt;&gt;&lt;&lt;", "&gt;&lt;&lt;&lt;&gt;", "&lt;&gt;&gt;&gt;&lt;", ",&lt;..&gt;,", "&gt;&lt;&gt;&gt;&lt;&gt;", "&gt;&lt;&gt;&lt;&gt;&lt;", ",&lt;..&gt;,&lt;&gt;&lt;", "&lt;&lt;&lt;&gt;&lt;&gt;&lt;&lt;&lt;&gt;&gt;&gt;&lt;&gt;&gt;&lt;&gt;&gt;&lt;&gt;&lt;&gt;&lt;&lt;&gt;&gt;&gt;&lt;&gt;&gt;&lt;&gt;&gt;&gt;&lt;&gt;&gt;&gt;&lt;&gt;&gt;&lt;&gt;&gt;&lt;&lt;&gt;&lt;", "&lt;&lt;&gt;&lt;&gt;&lt;&lt;&lt;&gt;&gt;&gt;&lt;&gt;&gt;&lt;&gt;&gt;&lt;&gt;&lt;&gt;&lt;&lt;&gt;&gt;&gt;&lt;&gt;&gt;&lt;&gt;&gt;&gt;&lt;&gt;&gt;&gt;&lt;&gt;&gt;&lt;&gt;&gt;&lt;&lt;&gt;&lt;")
tests.foreach(p)
</code></pre>

<p>Output</p>

<pre><code>&gt;&lt;&gt; 
&lt;&gt;&lt; 
&gt;&gt;&lt;&gt; 
&lt;&gt;&lt;&lt; 
&gt;&gt;&lt;&gt; 
&lt;&gt;&lt;&lt; 
&gt;&lt;&lt;&lt;&gt; 
&lt;&gt;&gt;&gt;&lt; 
,&lt;..&gt;, 
&gt;&lt;&gt; &gt;&lt;&gt; 
&gt;&lt;&gt; &lt;&gt;&lt; 
,&lt;..&gt;, &lt;&gt;&lt; 

&lt;&lt;&gt;&lt; &gt;&lt;&lt;&lt;&gt; &gt;&gt;&lt;&gt; &gt;&lt;&gt; &gt;&lt;&gt; &lt;&gt;&lt; &lt;&gt;&gt;&gt;&lt; &gt;&gt;&lt;&gt; &gt;&gt;&lt;&gt; &gt;&gt;&lt;&gt; &gt;&lt;&gt;&gt; &lt;&lt;&gt;&lt; 
</code></pre>
</div>
<div id="pu7" class="pu"><h2><strong>>&lt;>, 602 bytes</strong></h2>

<pre><code>0&amp;&gt;i:0)?vr&gt;:5%4-?v}:5%?;}:5%1-?;}:5%1-?;}:5%2-?;}:5%4-?;}&amp;~0&amp; v
  \     /        &gt;:5%2-?v}:5%2-?v}:5%?v}:5%2-?v}              v
 &amp;:?v;&gt;*} ^      v      &lt;       &gt;:5% ?v}:5%?v} :5% ?v}:5%2-?v}v
v&amp;-1&lt; ^48&lt;                                  &gt;: 5%2-?v}:5%2-  ?v&amp;1+&amp;0}}v
&gt;    :?v~^       &gt;:5%?v}:5%?v}:5%2-  ?v}:5%  ?v}              v
^~v?%8:&lt;                    &gt;:5%2-?v}: 5%2-?v} :5%2- ?v}:5%?v}v
^{&lt;        &gt;0&gt;=?;:v                         &gt;: 5%    ?v}:5%  ?v&amp;1+&amp;0}}v
           ^lo~&lt;  &lt;   &gt;            &gt;  &gt;       &gt;     &gt; &gt;     &gt;  02.
          \}*48^?=i:                                          &lt;       &lt;
</code></pre>

<p>A solution in Fish, probably very golfable but it's my first >&lt;> program. It takes its input from the input stack and runs on the online >&lt;> interpreter.</p>

<h2>How it works :</h2>

<p>A loop reads all the input and stacks it, reverse it and put a -1 on the bottom wich will mark that parsing is complete (all characters stay on the stack until the string is deemed parsable).<br>
The parsing uses the fact all characters are different modulo 5, and all patterns are deterministic except &lt;>&lt;&lt; and >&lt;>>. Parsed characters are put on the bottom of the stack.<br>
When a pattern is complete, if -1 is on top, all characters are printed, otherwise a space is added and the program loops.<br>
If &lt;>&lt;&lt; or >&lt;>> are encountered, the register is incremented (0 at the start), and a 0 is placed on the stack before the last character (so that &lt;>&lt; or >&lt;> stays after rollback). If an error appears afterwards during parsing, the register is decreased, all characters after the 0 are put back on top (except spaces thanks to a %8=0 test).<br>
If an error is detected while the register is 0, or inside the crab, the program just ends immediately.<br></p>
</div>
<div id="pu8" class="pu"><h1>C# - 319 bytes</h1>
<p>This solution is shamefully simple, hardly anything to Golf. It's a complete program, takes input as a line from STDIN, and outputs the result to STDOUT.</p>

<pre class="lang-c# prettyprint-override"><code>using C=System.Console;class P{static void Main(){C.Write(S(C.ReadLine()));}static string S(string c){int i=c.LastIndexOf(' ')+1;foreach(var o in&quot;&lt;&gt;&lt; &gt;&lt;&gt; &lt;&lt;&gt;&lt; &gt;&lt;&gt;&gt; &gt;&gt;&lt;&gt; &lt;&gt;&lt;&lt; &gt;&lt;&lt;&lt;&gt; &lt;&gt;&gt;&gt;&lt; ,&lt;..&gt;,&quot;.Split()){string k=c+&quot;\n&quot;,m=c.Substring(i);if(m==o||m.StartsWith(o)&amp;&amp;(k=S(c.Insert(i+o.Length,&quot; &quot;)))!=&quot;&quot;)return k;}return&quot;&quot;;}}
</code></pre>
<p>It simply attempts to match each fish to the first position after a space (or at the start of the string), and matches each type of fish with it. If the fish fits, then it recursively calls the solver after inserting a space after the fish, or simply returns it's input (with a \n for output reasons) if the unmatched string is literally the fish (i.e. we've found a solution).</p>
<p>I haven't made much of an attempt to give the fish string the usual kolmogorov treatment, because it isn't all that long, and I can't find a cheap way to reverse a string in C# (I don't think LINQ will pay), so there may be some opportunity there, but I somewhat doubt it.</p>
<pre class="lang-c# prettyprint-override"><code>using C=System.Console;

class P
{
    static void Main()
    {    
        C.Write(S(C.ReadLine())); // read, solve, write (no \n)
    }
    
    static string S(string c)
    {
        int i=c.LastIndexOf(' ')+1; // find start of un-matched string
        
        // match each fish
        foreach(var o in&quot;&lt;&gt;&lt; &gt;&lt;&gt; &lt;&lt;&gt;&lt; &gt;&lt;&gt;&gt; &gt;&gt;&lt;&gt; &lt;&gt;&lt;&lt; &gt;&lt;&lt;&lt;&gt; &lt;&gt;&gt;&gt;&lt; ,&lt;..&gt;,&quot;.Split())
        {
            string k=c+&quot;\n&quot;, // set up k for return if we have finished
            m=c.Substring(i); // cut off stuff before space
            if(m==o|| // perfect match, return straight away
               m.StartsWith(o)&amp;&amp; // fish matches the start
               (k=S(c.Insert(i+o.Length,&quot; &quot;))) // insert a space after the fish, solve, assign to k
               !=&quot;&quot;) // check the solution isn't empty
                return k;
        }
        
        // no fish match
        return&quot;&quot;;
    }
}
</code></pre>
</div>
<div id="pu9" class="pu"><h1>Pyth, <s>64</s> <s>48</s> 50 bytes</h1>
<pre><code>#jdhfqzsTsm^+msXtjCk2U2&quot;&lt;&gt;&quot;&quot;
\r.1&quot;&quot;,&lt;..&gt;,&quot;dlzB
</code></pre>
<p><a href="https://pyth.herokuapp.com/?code=jdhfqzsTsm%5E%2BmsXtjCk2U2%22%3C%3E%22%22%0A%5Cr%12%14%1B%1D.1%22%22%2C%3C..%3E%2C%22dlz&amp;input=%3C%3E%3C%3E%3C%3E" rel="noreferrer">Test case.</a></p>
<hr />
<p>Version that doesn't take forever (<code>O(9<sup>n/3</sup>)</code>) <a href="https://pyth.herokuapp.com/?code=%23jdhfqzsTsm%5E%2BmsXtjCk2U2%22%3C%3E%22%22%0A%5Cr%12%14%1B%1D.1%22%22%2C%3C..%3E%2C%22dlcz3B&amp;input=%3C%3E%3C%3C%3C%3E%3C&amp;debug=0" rel="noreferrer">here</a>, in 52 bytes.</p>
<hr />
<p>This is the brute force approach, generate all sequences and check whether any sum to the input. Fish diagrams compressed as characters, whose binary representations are the <code>&gt;</code> and <code>&lt;</code>. The whole thing is wrapped in a try-catch block so that no output occurs when no results are found.</p>
<p>This is an <code>O(9<sup>n</sup>)</code> solution.</p>
<p>Some characters are stripped above, because control characters are used. They are reproduced faithfully at the link above.</p>
<p>xxd output:</p>
<pre><code>0000000: 236a 6468 6671 7a73 5473 6d5e 2b6d 7358  #jdhfqzsTsm^+msX
0000010: 746a 436b 3255 3222 3c3e 2222 0a5c 7212  tjCk2U2&quot;&lt;&gt;&quot;&quot;.\r.
0000020: 141b 1d2e 3122 222c 3c2e 2e3e 2c22 646c  ....1&quot;&quot;,&lt;..&gt;,&quot;dl
0000030: 7a42                                     zB
</code></pre>
</div>
<div id="pu10" class="pu"><h1>Javascript (<del>122</del> 135 bytes)</h1>
<p>Not the most golfed here, could be stripped down a little.</p>
<p>This one is regex based, and a tad hard to figure out what is going on.</p>
<pre class="lang-js prettyprint-override"><code>alert(prompt(R=RegExp,r='(&lt;&lt;?&gt;&lt;|&gt;&lt;&gt;&gt;?|,&lt;\.\.&gt;,|&gt;&gt;&lt;&gt;|&gt;&lt;&lt;&lt;&gt;|&lt;&gt;&lt;&lt;|&lt;&gt;&gt;&gt;&lt;)').match(R('^'+r+'+$'))[0].split(R(r+'(?=[&gt;,]|$)','g')).join(' '))
</code></pre>
<p>This one is a one-liner.</p>
<p>Basically, I check the syntax and then I split the string based on the chars and join it together.<br>
It throws an exception when you give it an invalid input.</p>
<p>If it can't throw exceptions (<del>126</del> 139 bytes):</p>
<pre class="lang-js prettyprint-override"><code>(i=prompt(R=RegExp,r='(&lt;&lt;?&gt;&lt;|&gt;&lt;&gt;&gt;?|,&lt;\.\.&gt;,|&gt;&gt;&lt;&gt;|&gt;&lt;&lt;&lt;&gt;|&lt;&gt;&lt;&lt;|&lt;&gt;&gt;&gt;&lt;)')).match(R('^'+r+'+$'))&amp;&amp;alert(i.split(R(r+'(?=[&gt;,]|$)','g')).join(' '))
</code></pre>
<p>Both are one-liners.<br>
Both work the same way.</p>
<hr>
<p>Thank you <a href="https://codegolf.stackexchange.com/users/21348/edc65">@edc65</a> for detecting the edge case that wasn't working well.</p>
<hr>
<p>You can test it here (output will be written to the document).</p>
<p>It is based on the version that throws exceptions when you introduce invalid code.</p>
<p><div class="snippet" data-lang="js" data-hide="true" data-console="false" data-babel="false">
<div class="snippet-code snippet-currently-hidden">
<pre class="snippet-code-js lang-js prettyprint-override"><code>var alert=console.log=function(s){document.write(s)+'&lt;br&gt;';};
try{
alert(prompt(R=RegExp,r='(&lt;&lt;?&gt;&lt;|&gt;&lt;&gt;&gt;?|,&lt;\.\.&gt;,|&gt;&gt;&lt;&gt;|&gt;&lt;&lt;&lt;&gt;|&lt;&gt;&lt;&lt;|&lt;&gt;&gt;&gt;&lt;)').match(R('^'+r+'+\x24'))[0].split(R(r+'(?=[&gt;,]|\x24)','g')).join(' '));
}catch(e){console.log(e);}</code></pre>
</div>
</div>
</p>
<p>(Currently, there's a bug on stack snippets, <del>I've <a href="http://meta.codegolf.stackexchange.com/questions/5055/rr-g-is-converted-to-rr01943df1-b949-454b-b253-e39f9">posted in on meta</a></del> It was already asked yesterday. For it to work, I've replaced <code>$</code> with <code>\x24</code>, which has the same output. You can read about the bug here: <a href="http://meta.codegolf.stackexchange.com/questions/5043/stack-snippets-messing-with-js">http://meta.codegolf.stackexchange.com/questions/5043/stack-snippets-messing-with-js</a>)</p>
</div>
<div id="pu11" class="pu"><h1>Ruby, 177 bytes</h1>
<p>Not the shortest but the first one in ruby:</p>
<pre><code>def r(e,p,m)t='';p.each{|n|t=e.join;return r(e&lt;&lt;n,p,m)if m=~/^#{t+n}/};(m==t)?e:[];end
puts r([],%w(&gt;&lt;&lt;&lt;&gt; &lt;&gt;&gt;&gt;&lt; &gt;&lt;&gt;&gt; &lt;&lt;&gt;&lt; &gt;&gt;&lt;&gt; &lt;&gt;&lt;&lt; &gt;&lt;&gt; &lt;&gt;&lt; ,&lt;..&gt;,),gets.strip).join(' ')
</code></pre>
<p>The attempt here is to recursively extend a regexp and match it against the input.<br />
If a longer match is found r() will recurse, if not it will check if the last match consumes the whole input string and only then output it with added spaces.</p>
</div>
<div id="pu12" class="pu"><h1>Perl, 81 + 1 bytes</h1>

<pre><code>/^((&gt;&gt;&lt;&gt;|&gt;&lt;(|&gt;|&lt;&lt;)&gt;|&lt;&gt;&lt;&lt;|&lt;(|&lt;|&gt;&gt;)&gt;&lt;|,&lt;\.\.&gt;,)(?{local@a=(@a,$2)}))*$(?{say"@a"})/
</code></pre>

<p><a href="http://ideone.com/uLrRX9">Try this code online.</a></p>

<p>This code expects the input in the <code>$_</code> variable; run this with Perl's <code>-n</code> switch (<a href="http://meta.codegolf.stackexchange.com/questions/273/on-interactive-answers-and-other-special-conditions">counted as +1 byte</a>) to apply it to each input line, e.g. like this:</p>

<pre><code>perl -nE '/^((&gt;&gt;&lt;&gt;|&gt;&lt;(|&gt;|&lt;&lt;)&gt;|&lt;&gt;&lt;&lt;|&lt;(|&lt;|&gt;&gt;)&gt;&lt;|,&lt;\.\.&gt;,)(?{local@a=(@a,$2)}))*$(?{say"@a"})/'
</code></pre>

<p>This code uses Perl's regexp engine (and specifically its <a href="http://perldoc.perl.org/perlre.html#%28%3F%7B-code-%7D%29">embedded code execution</a> feature) to perform an efficient backtracking search.  The individual fishes found are collected in the <code>@a</code> array, which is stringified and printed if the match is successful.</p>

<p>This code also uses the Perl 5.10+ <code>say</code> feature, and so must be run with the <code>-E</code> or <code>-M5.010</code> switch (or <code>use 5.010;</code>) to enable such modern features.  <a href="http://meta.codegolf.stackexchange.com/questions/273/on-interactive-answers-and-other-special-conditions">By tradition,</a> such switches used solely to enable a particular version of the language are not included in the byte count. </p>

<p>Alternatively, here's a 87-byte version that requires no special command-line switches at all.  It reads one line from stdin, and prints the result (if any) to stdout, without any trailing linefeed:</p>

<pre><code>&lt;&gt;=~/^((&gt;&gt;&lt;&gt;|&gt;&lt;(|&gt;|&lt;&lt;)&gt;|&lt;&gt;&lt;&lt;|&lt;(|&lt;|&gt;&gt;)&gt;&lt;|,&lt;\.\.&gt;,)(?{local@a=(@a,$2)}))*$(?{print"@a"})/
</code></pre>

<p><strong>Ps.</strong> If printing an extra space at the beginning of the output was allowed, I could trivially save two more bytes with:</p>

<pre><code>/^((&gt;&gt;&lt;&gt;|&gt;&lt;(|&gt;|&lt;&lt;)&gt;|&lt;&gt;&lt;&lt;|&lt;(|&lt;|&gt;&gt;)&gt;&lt;|,&lt;\.\.&gt;,)(?{local$a="$a $2"}))*$(?{say$a})/
</code></pre>
</div>
<div id="pu13" class="pu"><h1>fish (yes, that fish), 437 bytes</h1>

<p>This strikes me as one of those programming tasks where exactly one language is right.</p>

<pre><code>#!/usr/bin/fish

set the_fishes "&gt;&lt;&gt;" "&lt;&gt;&lt;" "&gt;&gt;&lt;&gt;" "&lt;&gt;&lt;&lt;" "&gt;&lt;&gt;&gt;" "&lt;&lt;&gt;&lt;" "&gt;&lt;&lt;&lt;&gt;" "&lt;&gt;&gt;&gt;&lt;" ",&lt;..&gt;,"
set my_fishes

function startswith
        set -l c (echo -n $argv[2]|wc -c)
        echo $argv[1]|cut -c(math $c+1)-
        test $argv[2] = (echo $argv[1]|cut -c-$c)
end

function pickafish
        set -l fix 1
            while true
                if test $fix -gt (count $the_fishes); return 1; end

                if not set rest (startswith $argv[1] $the_fishes[$fix])
                            set fix (math $fix+1)
                        continue
                end    
                set my_fishes $my_fishes $the_fishes[$fix]
                    if test -z $rest
                        echo $my_fishes
                            exit
                    end
                    if not pickafish $rest
                    set my_fishes $my_fishes[(seq (math (count $my_fishes) - 1))]
                    set fix (math $fix+1)
                        continue
                end
        end
end

pickafish $argv[1]
</code></pre>

<p>The following version is still the longest answer to the challenge,</p>

<pre><code>set t "&gt;&lt;&gt;" "&lt;&gt;&lt;" "&gt;&gt;&lt;&gt;" "&lt;&gt;&lt;&lt;" "&gt;&lt;&gt;&gt;" "&lt;&lt;&gt;&lt;" "&gt;&lt;&lt;&lt;&gt;" "&lt;&gt;&gt;&gt;&lt;" ",&lt;..&gt;,";set m;function p;set -l i 1;while true;test $i -gt 9; and return 1;if not set r (begin;set c (echo $t[$i]|wc -c);echo $argv[1]|cut -c$c-;test $t[$i] = (echo $argv[1]|cut -c-(math $c-1));end);set i (math $i+1);continue;end;set m $m $t[$i];if test -z $r;echo $m;exit;end;if not p $r;set m $m[(seq (math (count $m)-1))];set i (math $i+1);continue;end;end;end;p $argv[1]
</code></pre>

<p>but since this was done mostly for the pun (you'll excuse, I hope), better golfing is left as an exercise to the reader.</p>
</div>
<div id="pu14" class="pu"><h1>JavaScript (ES6), 164</h1>
<p>Recursive, depth first scan.<br />
As a program with I/O via popup:</p>

<pre class="lang-javascript prettyprint-override"><code>alert((k=(s,r)=&gt;'&gt;&lt;&gt;0&lt;&gt;&lt;0&gt;&gt;&lt;&gt;0&lt;&gt;&lt;&lt;0&gt;&lt;&gt;&gt;0&lt;&lt;&gt;&lt;0&gt;&lt;&lt;&lt;&gt;0&lt;&gt;&gt;&gt;&lt;0,&lt;..&gt;,'.split(0)
.some(w=&gt;s==w?r=w:s.slice(0,l=w.length)==w&amp;&amp;(t=k(s.slice(l)))?r=w+' '+t:0)?r:'')
(prompt()))
</code></pre>
<p>As a testable function:</p>
<pre class="lang-javascript prettyprint-override"><code>k=(s,r)=&gt;'&gt;&lt;&gt;0&lt;&gt;&lt;0&gt;&gt;&lt;&gt;0&lt;&gt;&lt;&lt;0&gt;&lt;&gt;&gt;0&lt;&lt;&gt;&lt;0&gt;&lt;&lt;&lt;&gt;0&lt;&gt;&gt;&gt;&lt;0,&lt;..&gt;,'.split(0)
.some(w=&gt;s==w?r=w:s.slice(0,l=w.length)==w&amp;&amp;(t=k(s.slice(l)))?r=w+' '+t:0)?r:''
</code></pre>
<p>Test suite (run in Firefox/FireBug console)</p>
<pre class="lang-javascript prettyprint-override"><code>t=['&lt;&gt;&lt;&gt;&lt;&gt;', '&gt;&lt;&gt;&gt;&lt;&gt;&gt;', '&lt;&gt;&lt;&lt;&lt;&gt;&lt;',',&lt;..&gt;,&gt;&lt;&lt;&lt;&gt;,&lt;..&gt;,&gt;&lt;&gt;,&lt;..&gt;,&lt;&gt;&gt;&gt;&lt;,&lt;..&gt;,&gt;&lt;&gt;&gt;,&lt;..&gt;,&lt;&lt;&gt;&lt;,&lt;..&gt;,&lt;&gt;&lt;,&lt;..&gt;,&gt;&gt;&lt;&gt;',
'&lt;&gt;&lt;&gt;',',&lt;..&gt;,&lt;..&gt;,','&gt;&gt;&gt;&lt;&gt;','&gt;&lt;&lt;&lt;&lt;&gt;',',','&gt;&lt;&gt;&lt;&gt;',',&lt;&gt;&lt;&gt;,',
'&lt;&lt;&lt;&gt;&lt;&gt;&lt;&lt;&lt;&gt;&gt;&gt;&lt;&gt;&gt;&lt;&gt;&gt;&lt;&gt;&lt;&gt;&lt;&lt;&gt;&gt;&gt;&lt;&gt;&gt;&lt;&gt;&gt;&gt;&lt;&gt;&gt;&gt;&lt;&gt;&gt;&lt;&gt;&gt;&lt;&lt;&gt;&lt;','&lt;&lt;&gt;&lt;&gt;&lt;&lt;&lt;&gt;&gt;&gt;&lt;&gt;&gt;&lt;&gt;&gt;&lt;&gt;&lt;&gt;&lt;&lt;&gt;&gt;&gt;&lt;&gt;&gt;&lt;&gt;&gt;&gt;&lt;&gt;&gt;&gt;&lt;&gt;&gt;&lt;&gt;&gt;&lt;&lt;&gt;&lt;']

t.forEach(t=&gt;console.log(t + ': ' +k(t)))
</code></pre>
<p><em>Output</em></p>
<pre class="lang-javascript prettyprint-override"><code>&lt;&gt;&lt;&gt;&lt;&gt;: &lt;&gt;&lt; &gt;&lt;&gt;
&gt;&lt;&gt;&gt;&lt;&gt;&gt;: &gt;&lt;&gt; &gt;&lt;&gt;&gt;
&lt;&gt;&lt;&lt;&lt;&gt;&lt;: &lt;&gt;&lt; &lt;&lt;&gt;&lt;
,&lt;..&gt;,&gt;&lt;&lt;&lt;&gt;,&lt;..&gt;,&gt;&lt;&gt;,&lt;..&gt;,&lt;&gt;&gt;&gt;&lt;,&lt;..&gt;,&gt;&lt;&gt;&gt;,&lt;..&gt;,&lt;&lt;&gt;&lt;,&lt;..&gt;,&lt;&gt;&lt;,&lt;..&gt;,&gt;&gt;&lt;&gt;: ,&lt;..&gt;, &gt;&lt;&lt;&lt;&gt; ,&lt;..&gt;, &gt;&lt;&gt; ,&lt;..&gt;, &lt;&gt;&gt;&gt;&lt; ,&lt;..&gt;, &gt;&lt;&gt;&gt; ,&lt;..&gt;, &lt;&lt;&gt;&lt; ,&lt;..&gt;, &lt;&gt;&lt; ,&lt;..&gt;, &gt;&gt;&lt;&gt;
&lt;&gt;&lt;&gt;: 
,&lt;..&gt;,&lt;..&gt;,: 
&gt;&gt;&gt;&lt;&gt;: 
&gt;&lt;&lt;&lt;&lt;&gt;: 
,: 
&gt;&lt;&gt;&lt;&gt;: 
,&lt;&gt;&lt;&gt;,: 
&lt;&lt;&lt;&gt;&lt;&gt;&lt;&lt;&lt;&gt;&gt;&gt;&lt;&gt;&gt;&lt;&gt;&gt;&lt;&gt;&lt;&gt;&lt;&lt;&gt;&gt;&gt;&lt;&gt;&gt;&lt;&gt;&gt;&gt;&lt;&gt;&gt;&gt;&lt;&gt;&gt;&lt;&gt;&gt;&lt;&lt;&gt;&lt;: 
&lt;&lt;&gt;&lt;&gt;&lt;&lt;&lt;&gt;&gt;&gt;&lt;&gt;&gt;&lt;&gt;&gt;&lt;&gt;&lt;&gt;&lt;&lt;&gt;&gt;&gt;&lt;&gt;&gt;&lt;&gt;&gt;&gt;&lt;&gt;&gt;&gt;&lt;&gt;&gt;&lt;&gt;&gt;&lt;&lt;&gt;&lt;: &lt;&lt;&gt;&lt; &gt;&lt;&lt;&lt;&gt; &gt;&gt;&lt;&gt; &gt;&lt;&gt; &gt;&lt;&gt; &lt;&gt;&lt; &lt;&gt;&gt;&gt;&lt; &gt;&gt;&lt;&gt; &gt;&gt;&lt;&gt; &gt;&gt;&lt;&gt; &gt;&lt;&gt;&gt; &lt;&lt;&gt;&lt;
</code></pre>
<p><strong>Ungolfed</strong> just the k function</p>
<pre class="lang-javascript prettyprint-override"><code>function k(s)
{
  var f='&gt;&lt;&gt;0&lt;&gt;&lt;0&gt;&gt;&lt;&gt;0&lt;&gt;&lt;&lt;0&gt;&lt;&gt;&gt;0&lt;&lt;&gt;&lt;0&gt;&lt;&lt;&lt;&gt;0&lt;&gt;&gt;&gt;&lt;0,&lt;..&gt;,'.split(0) 
  var i, w, l, t

  for (w of f)
  {
    if (s == w)
    {
      return w
    } 
    l = w.length
    if (s.slice(0,l) == w &amp;&amp; (t = k(s.slice(l))))
    {
      return w + ' ' + t
    }
  }
  return ''
}
</code></pre>
</div>
<div id="pu15" class="pu"><h1>Haskell, <s>148</s> 146 bytes</h1>

<pre><code>main=mapM_ putStr.take 1.filter(all(`elem`words"&gt;&lt;&gt; &gt;&gt;&lt;&gt; &gt;&lt;&gt;&gt; &gt;&lt;&lt;&lt;&gt; &lt;&gt;&lt; &lt;&gt;&lt;&lt; &lt;&lt;&gt;&lt; &lt;&gt;&gt;&gt;&lt; ,&lt;..&gt;,").words).map concat.mapM(\a-&gt;[[a],a:" "])=&lt;&lt;getLine
</code></pre>

<p>Testing:</p>

<pre><code>$ echo "&gt;&lt;&gt;&gt;&lt;&gt;&gt;&gt;" | runhaskell fishes.hs
</code></pre>

<p>$ echo ">&lt;>>&lt;>>" | runhaskell fishes.hs</p>

<blockquote>
  <p>&lt;> >&lt;>></p>
</blockquote>

<h2>Explanation</h2>

<p>Based on my <a href="https://codegolf.stackexchange.com/a/45498/32014">earlier answer</a> to a similar question.
The algorithm runs in exponential time.</p>

<p>This reads from right to left.</p>

<pre><code>=&lt;&lt;getLine              -- Read a line from STDIN.
mapM(\a-&gt;[[a],a:" "])   -- Replace each letter 'a' by "a" or "a " in
                        -- all possible ways, collect results to a list.
map concat              -- Concatenate those lists-of-strings into strings.
filter(all(...).words)  -- Keep those whose words are correct fish.
take 1                  -- Discard all but the first one.
mapM_ putStr            -- Print each string in that 1- or 0-element list.
main=                   -- That is the main function.
</code></pre>

<p>This will not print a string that ends with a space, even though such strings are generated too, because its no-space counterpart is generated first.</p>
</div>
<div id="pu16" class="pu"><h2>Python 3, 156</h2>

<pre class="lang-python prettyprint-override"><code>*l,s=[],input()
for _ in s:l+=[y+[x]for x in"&gt;&lt;&gt; &gt;&gt;&lt;&gt; &gt;&lt;&gt;&gt; &gt;&lt;&lt;&lt;&gt; &lt;&gt;&lt; &lt;&gt;&lt;&lt; &lt;&lt;&gt;&lt; &lt;&gt;&gt;&gt;&lt; ,&lt;..&gt;,".split()for y in l]
for y in l:
 if"".join(y)==s:print(*y);break
</code></pre>

<p>The strategy is to generate lists of fish and compare their concatenation to the input string.</p>

<p>This takes impossibly long. If you actually want to see an output, replace <code>for _ in s</code> with <code>for _ in [0]*3</code>, where 3 is the upper bound for the number of fish. It works to use <code>s</code> because <code>s</code> contains at most one fish per char.</p>

<p>Thanks to Sp3000 for bugfixes and a char save on input. </p>

<p>Old 165:
</p>

<pre><code>f=lambda s:[[x]+y for x in"&gt;&lt;&gt; &gt;&gt;&lt;&gt; &gt;&lt;&gt;&gt; &gt;&lt;&lt;&lt;&gt; &lt;&gt;&lt; &lt;&gt;&lt;&lt; &lt;&lt;&gt;&lt; &lt;&gt;&gt;&gt;&lt; ,&lt;..&gt;,".split()for y in f(s[len(x):])if s[:len(x)]==x]if s else[[]]
y=f(input())
if y:print(*y[0])
</code></pre>
</div>
<div id="pu17" class="pu"><pre class="lang-python prettyprint-override"><code>import sys

def unfish(msg,dict,start):
    if(len(msg[start:])&lt;3):
        return "";
    for i in range(3,6):
        if (msg[start:start+i] in dict):
            if(start+i==len(msg)):
                return msg[start:start+i];
            else:
                ret = unfish(msg,dict,start+i);
                if ret != "":
                    return msg[start:start+i]+" "+ret;
    return ""

dict = {'&gt;&lt;&gt;':1,'&lt;&gt;&lt;':1,'&gt;&gt;&lt;&gt;':1,'&lt;&gt;&lt;&lt;':1,'&gt;&lt;&gt;&gt;':1,'&lt;&lt;&gt;&lt;':1,'&gt;&lt;&lt;&lt;&gt;':1,'&lt;&gt;&gt;&gt;&lt;':1,',&lt;..&gt;,':1};

print unfish(sys.argv[1],dict,0);
</code></pre>

<p>im a bit of a python noob so ignore the weirdness :P</p>
</div>
<div id="pu18" class="pu"><h1>CJam, <s>111 96</s> 91 (or 62 bytes)</h1>

<p>An iterative greedy approach to keep figuring out what all fish combinations are possible as you iterate. Really not golfed right now.</p>

<pre><code>q_aa\,{{" È÷®µãÑø"255b5b" &gt;&lt;,."f=S/\f{)_3$#{;;;}{2$,&gt;:P@a\a++}?PR+!{S:R*W&lt;o}*}~}%}*];
</code></pre>

<p>The code contains some unprintable characters, so use the link below for reference.</p>

<p><em>Update</em> Encoded the string</p>

<p>Will add explanation once done golfing</p>

<p><a href="http://cjam.aditsu.net/#code=q_aa%5C%2C%7B%7B%22%02%20%C3%88%C3%B7%C2%AE%C2%B5%17%C3%A3%06%C3%91%1B%C3%B8%C2%97%1C%22255b5b%22%20%3E%3C%2C.%22f%3DS%2F%5Cf%7B)_3%24%23%7B%3B%3B%3B%7D%7B2%24%2C%3E%3AP%40a%5Ca%2B%2B%7D%3FPR%2B!%7BS%3AR*W%3Co%7D*%7D~%7D%25%7D*%5D%3B&amp;input=%3C%3C%3E%3C%3E%3C%3C%3C%3E%3E%3E%3C%3E%3E%3C%3E%3E%3C%3E%3C%3E%3C%3C%3E%3E%3E%3C%3E%3E%3C%3E%3E%3E%3C%3E%3E%3E%3C%3E%3E%3C%3E%3E" rel="nofollow">Try it online here</a></p>

<hr>

<h1>62 bytes</h1>

<p>Super slow version. This basically creates all the combinations and checks which are equal to the input.</p>

<pre><code>L"¬ééãLù:9$"255b6b5," &gt;&lt;,."erS/aq:Q,*{m*}*{sQ=}=`"[]\""-
</code></pre>

<p>This also contains unprintable characters, so rely on the below link.</p>

<p><a href="http://cjam.aditsu.net/#code=L%22%C2%AC%C3%A9%C2%9D%C3%A9%C3%A3%10L%1F%C3%B9%3A9%C2%97%1B%24%C2%87%22255b6b5%2C%22%20%3E%3C%2C.%22erS%2Faq%3AQ%2C*%7Bm*%7D*%7BsQ%3D%7D%3D%60%22%5B%5D%5C%22%22-&amp;input=%3E%3C%3E%3E%3C%3E%3E%3E%3C%3E" rel="nofollow">Try it online here</a></p>
</div>
<div id="pu19" class="pu"><h1>Python 2, 234 bytes</h1>

<p>I tried a Python regex solution first, but there seems to be no way to extract the groups after a match on multiple patterns. The following is a recursive search which seems to do well on the test cases.</p>



<pre class="lang-python prettyprint-override"><code>a='&gt;&lt;&gt; &gt;&gt;&lt;&gt; &gt;&lt;&gt;&gt; &gt;&lt;&lt;&lt;&gt; &lt;&gt;&lt; &lt;&gt;&lt;&lt; &lt;&lt;&gt;&lt; &lt;&gt;&gt;&gt;&lt; ,&lt;..&gt;,'.split()
def d(t,p=0):
 if p&lt;len(t):
  for e in a:
   z=p+len(e)
   if e==t[p:z]:
    if z==len(t):return[e]
    c=d(t,z)
    if c:return[e]+c
c=d(raw_input())
if c:
 print' '.join(c)
</code></pre>

<p>An example test:</p>

<pre class="lang-python prettyprint-override"><code>$ echo ",&lt;..&gt;,&gt;&lt;&lt;&lt;&gt;,&lt;..&gt;,&gt;&lt;&gt;,&lt;..&gt;,&lt;&gt;&gt;&gt;&lt;,&lt;..&gt;,&gt;&lt;&gt;&gt;,&lt;..&gt;,&lt;&lt;&gt;&lt;,&lt;..&gt;,&lt;&gt;&lt;,&lt;..&gt;,&gt;&gt;&lt;&gt;" | python soln.py 
,&lt;..&gt;, &gt;&lt;&lt;&lt;&gt; ,&lt;..&gt;, &gt;&lt;&gt; ,&lt;..&gt;, &lt;&gt;&gt;&gt;&lt; ,&lt;..&gt;, &gt;&lt;&gt;&gt; ,&lt;..&gt;, &lt;&lt;&gt;&lt; ,&lt;..&gt;, &lt;&gt;&lt; ,&lt;..&gt;, &gt;&gt;&lt;&gt;
</code></pre>

<p>And the ungolfed version:</p>

<pre class="lang-python prettyprint-override"><code>fishtypes = '&gt;&lt;&gt; &gt;&gt;&lt;&gt; &gt;&lt;&gt;&gt; &gt;&lt;&lt;&lt;&gt; &lt;&gt;&lt; &lt;&gt;&lt;&lt; &lt;&lt;&gt;&lt; &lt;&gt;&gt;&gt;&lt; ,&lt;..&gt;,'.split()

def getfish(t, p=0):
    if p &lt; len(t):
        for afish in fishtypes:
            z = p+len(afish)
            if afish == t[p:z]:
                if z == len(t) :
                    return [afish]
                fishlist = getfish(t, z)
                if fishlist :
                    return [afish]+fishlist

fishlist = getfish(raw_input())
if fishlist:
    print ' '.join(fishlist)
</code></pre>
</div>
<div id="pu20" class="pu"><h1>Haskell(Parsec) - 262</h1>
<pre><code>import Text.Parsec
c=words&quot;&gt;&lt;&gt; &gt;&gt;&lt;&gt; &gt;&lt;&gt;&gt; &gt;&lt;&lt;&lt;&gt; &lt;&gt;&lt; &lt;&gt;&lt;&lt; &lt;&lt;&gt;&lt; &lt;&gt;&gt;&gt;&lt; ,&lt;..&gt;,&quot;
p c d=choice[eof&gt;&gt;return[],lookAhead(choice$map(try.string)d)&gt;&gt;=(\s-&gt;try(string s&gt;&gt;p c c&gt;&gt;=(\ss-&gt;return$s:ss))&lt;|&gt;p c(filter(/=s)c))]
main=interact$either show unwords.runParser(p c c)()&quot;&quot;
</code></pre>
</div>
<div id="pu21" class="pu"><h1>Haskell, <s>148</s> 142</h1>

<pre><code>p[]=[[]]
p s=[i:j|i&lt;-words"&gt;&lt;&gt; &gt;&gt;&lt;&gt; &gt;&lt;&gt;&gt; &gt;&lt;&lt;&lt;&gt; &lt;&gt;&lt; &lt;&gt;&lt;&lt; &lt;&lt;&gt;&lt; &lt;&gt;&gt;&gt;&lt; ,&lt;..&gt;,",i==map fst(zip s i),j&lt;-p$drop(length i)s]
    g s=unwords$head$p s++p[]
</code></pre>

<p>this uses list comprehensions to iterate over the fish, pick the ones who match the start and continue recursively.</p>
</div>
<div id="pu22" class="pu"><h1>Python 3, <s>196</s> 186 bytes</h1>

<pre class="lang-py prettyprint-override"><code>F="&gt;&lt;&gt; &gt;&gt;&lt;&gt; &gt;&lt;&gt;&gt; &gt;&lt;&lt;&lt;&gt; &lt;&gt;&lt; &lt;&gt;&lt;&lt; &lt;&lt;&gt;&lt; &lt;&gt;&gt;&gt;&lt; ,&lt;..&gt;,".split()
def g(s):
 if s in F:return[s]
 for f in F:
  i=len(f)
  if f==s[:i]and g(s[i:]):return[f]+g(s[i:])
R=g(input())
if R:print(*R)
</code></pre>

<p>Simple recursion. <code>g</code> either returns a list of parsed fish, or <code>None</code> if the input string is unparseable.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/48649/">48649</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




