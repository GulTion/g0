<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::110485</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>023</td><td>Swift 5.10 with C interop</td><td>240403T155047Z</td><td><a href="https://codegolf.stackexchange.com/questions/110485/leak-memory-in-as-few-bytes-as-possible/272294#272294">macOSist</a></td></tr>
<tr d-ix="1"><td>000</td><td>Bash 4.4.20</td><td>200701T184923Z</td><td><a href="https://codegolf.stackexchange.com/questions/110485/leak-memory-in-as-few-bytes-as-possible/206643#206643">Sapphire</a></td></tr>
<tr d-ix="2"><td>038</td><td>Swift</td><td>200609T213737Z</td><td><a href="https://codegolf.stackexchange.com/questions/110485/leak-memory-in-as-few-bytes-as-possible/205864#205864">Sapphire</a></td></tr>
<tr d-ix="3"><td>046</td><td>C/C++</td><td>190302T190242Z</td><td><a href="https://codegolf.stackexchange.com/questions/110485/leak-memory-in-as-few-bytes-as-possible/180774#180774">Ed The &</a></td></tr>
<tr d-ix="4"><td>023</td><td>Python <3.6.5</td><td>170218T230133Z</td><td><a href="https://codegolf.stackexchange.com/questions/110485/leak-memory-in-as-few-bytes-as-possible/110520#110520">user2357</a></td></tr>
<tr d-ix="5"><td>002</td><td>Batch</td><td>180803T123845Z</td><td><a href="https://codegolf.stackexchange.com/questions/110485/leak-memory-in-as-few-bytes-as-possible/169922#169922">Engineer</a></td></tr>
<tr d-ix="6"><td>034</td><td>C#</td><td>170219T133910Z</td><td><a href="https://codegolf.stackexchange.com/questions/110485/leak-memory-in-as-few-bytes-as-possible/110562#110562">MrPaulch</a></td></tr>
<tr d-ix="7"><td>008</td><td>SmileBASIC</td><td>180407T111346Z</td><td><a href="https://codegolf.stackexchange.com/questions/110485/leak-memory-in-as-few-bytes-as-possible/161532#161532">12Me21</a></td></tr>
<tr d-ix="8"><td>023</td><td>Java 1.3</td><td>170220T115532Z</td><td><a href="https://codegolf.stackexchange.com/questions/110485/leak-memory-in-as-few-bytes-as-possible/110628#110628">Olivier </a></td></tr>
<tr d-ix="9"><td>2826</td><td>Common Lisp SBCL only</td><td>170219T062806Z</td><td><a href="https://codegolf.stackexchange.com/questions/110485/leak-memory-in-as-few-bytes-as-possible/110543#110543">coredump</a></td></tr>
<tr d-ix="10"><td>056</td><td>Julia</td><td>171129T233535Z</td><td><a href="https://codegolf.stackexchange.com/questions/110485/leak-memory-in-as-few-bytes-as-possible/149526#149526">eaglgene</a></td></tr>
<tr d-ix="11"><td>029</td><td>Haskell</td><td>171128T205526Z</td><td><a href="https://codegolf.stackexchange.com/questions/110485/leak-memory-in-as-few-bytes-as-possible/149395#149395">Hjulle</a></td></tr>
<tr d-ix="12"><td>035</td><td>Plain English</td><td>170225T235438Z</td><td><a href="https://codegolf.stackexchange.com/questions/110485/leak-memory-in-as-few-bytes-as-possible/111291#111291">Jasper</a></td></tr>
<tr d-ix="13"><td>109</td><td>C#</td><td>170307T120231Z</td><td><a href="https://codegolf.stackexchange.com/questions/110485/leak-memory-in-as-few-bytes-as-possible/112228#112228">TheLetha</a></td></tr>
<tr d-ix="14"><td>009</td><td>c</td><td>170226T040342Z</td><td><a href="https://codegolf.stackexchange.com/questions/110485/leak-memory-in-as-few-bytes-as-possible/111303#111303">Moonchil</a></td></tr>
<tr d-ix="15"><td>220</td><td>Java OpenJDK 9</td><td>170220T095848Z</td><td><a href="https://codegolf.stackexchange.com/questions/110485/leak-memory-in-as-few-bytes-as-possible/110619#110619">Serverfr</a></td></tr>
<tr d-ix="16"><td>109</td><td>Solution 1 C Mac OS X x86_64</td><td>170223T135822Z</td><td><a href="https://codegolf.stackexchange.com/questions/110485/leak-memory-in-as-few-bytes-as-possible/111042#111042">ScrimpyC</a></td></tr>
<tr d-ix="17"><td>002</td><td>ZX Spectrum BASIC</td><td>170223T132451Z</td><td><a href="https://codegolf.stackexchange.com/questions/110485/leak-memory-in-as-few-bytes-as-possible/111037#111037">Radovan </a></td></tr>
<tr d-ix="18"><td>012</td><td>Swift</td><td>170223T062838Z</td><td><a href="https://codegolf.stackexchange.com/questions/110485/leak-memory-in-as-few-bytes-as-possible/111013#111013">Alexande</a></td></tr>
<tr d-ix="19"><td>022</td><td>C</td><td>170218T190452Z</td><td><a href="https://codegolf.stackexchange.com/questions/110485/leak-memory-in-as-few-bytes-as-possible/110499#110499">Riley</a></td></tr>
<tr d-ix="20"><td>032</td><td>PHP</td><td>170222T111006Z</td><td><a href="https://codegolf.stackexchange.com/questions/110485/leak-memory-in-as-few-bytes-as-possible/110909#110909">aross</a></td></tr>
<tr d-ix="21"><td>001</td><td>x86 ASM</td><td>170220T211823Z</td><td><a href="https://codegolf.stackexchange.com/questions/110485/leak-memory-in-as-few-bytes-as-possible/110691#110691">Joshua</a></td></tr>
<tr d-ix="22"><td>076</td><td>Dart</td><td>170220T225923Z</td><td><a href="https://codegolf.stackexchange.com/questions/110485/leak-memory-in-as-few-bytes-as-possible/110702#110702">Dwayne S</a></td></tr>
<tr d-ix="23"><td>013</td><td>Factor</td><td>170219T224534Z</td><td><a href="https://codegolf.stackexchange.com/questions/110485/leak-memory-in-as-few-bytes-as-possible/110579#110579">fede s.</a></td></tr>
<tr d-ix="24"><td>038</td><td>Swift 3</td><td>170218T202308Z</td><td><a href="https://codegolf.stackexchange.com/questions/110485/leak-memory-in-as-few-bytes-as-possible/110509#110509">Daniel</a></td></tr>
<tr d-ix="25"><td>030</td><td>C</td><td>170220T155058Z</td><td><a href="https://codegolf.stackexchange.com/questions/110485/leak-memory-in-as-few-bytes-as-possible/110656#110656">Abel Tom</a></td></tr>
<tr d-ix="26"><td>016</td><td>C++</td><td>170220T154946Z</td><td><a href="https://codegolf.stackexchange.com/questions/110485/leak-memory-in-as-few-bytes-as-possible/110655#110655">matovitc</a></td></tr>
<tr d-ix="27"><td>003</td><td>8086 ASM</td><td>170220T130138Z</td><td><a href="https://codegolf.stackexchange.com/questions/110485/leak-memory-in-as-few-bytes-as-possible/110637#110637">FUZxxl</a></td></tr>
<tr d-ix="28"><td>045</td><td>go</td><td>170220T001445Z</td><td><a href="https://codegolf.stackexchange.com/questions/110485/leak-memory-in-as-few-bytes-as-possible/110580#110580">don brig</a></td></tr>
<tr d-ix="29"><td>010</td><td>Java</td><td>170219T083124Z</td><td><a href="https://codegolf.stackexchange.com/questions/110485/leak-memory-in-as-few-bytes-as-possible/110549#110549">zeppelin</a></td></tr>
<tr d-ix="30"><td>084</td><td>C#  84bytes</td><td>170218T222440Z</td><td><a href="https://codegolf.stackexchange.com/questions/110485/leak-memory-in-as-few-bytes-as-possible/110518#110518">VisualMe</a></td></tr>
<tr d-ix="31"><td>003</td><td>Javascript</td><td>170219T055600Z</td><td><a href="https://codegolf.stackexchange.com/questions/110485/leak-memory-in-as-few-bytes-as-possible/110540#110540">Ismael M</a></td></tr>
<tr d-ix="32"><td>000</td><td>Perl 5.22.2</td><td>170219T010020Z</td><td><a href="https://codegolf.stackexchange.com/questions/110485/leak-memory-in-as-few-bytes-as-possible/110525#110525">user6213</a></td></tr>
<tr d-ix="33"><td>001</td><td>Befunge fungi</td><td>170218T233633Z</td><td><a href="https://codegolf.stackexchange.com/questions/110485/leak-memory-in-as-few-bytes-as-possible/110522#110522">James Ho</a></td></tr>
<tr d-ix="34"><td>006</td><td>Forth</td><td>170218T201121Z</td><td><a href="https://codegolf.stackexchange.com/questions/110485/leak-memory-in-as-few-bytes-as-possible/110508#110508">zeppelin</a></td></tr>
<tr d-ix="35"><td>014</td><td>Javascript</td><td>170218T215525Z</td><td><a href="https://codegolf.stackexchange.com/questions/110485/leak-memory-in-as-few-bytes-as-possible/110516#110516">zeppelin</a></td></tr>
<tr d-ix="36"><td>033</td><td>Delphi Object Pascal</td><td>170218T210209Z</td><td><a href="https://codegolf.stackexchange.com/questions/110485/leak-memory-in-as-few-bytes-as-possible/110513#110513">R-D</a></td></tr>
<tr d-ix="37"><td>012</td><td>TIBasic</td><td>170218T192310Z</td><td><a href="https://codegolf.stackexchange.com/questions/110485/leak-memory-in-as-few-bytes-as-possible/110503#110503">Timtech</a></td></tr>
<tr d-ix="38"><td>052</td><td>Rust</td><td>170218T191741Z</td><td><a href="https://codegolf.stackexchange.com/questions/110485/leak-memory-in-as-few-bytes-as-possible/110502#110502">kennytm</a></td></tr>
<tr d-ix="39"><td>001</td><td>Unlambda crefcnt/unlambda</td><td>170218T181700Z</td><td><a href="https://codegolf.stackexchange.com/questions/110485/leak-memory-in-as-few-bytes-as-possible/110490#110490">user6213</a></td></tr>
<tr d-ix="40"><td>015</td><td>C gcc</td><td>170218T180826Z</td><td><a href="https://codegolf.stackexchange.com/questions/110485/leak-memory-in-as-few-bytes-as-possible/110489#110489">Dennis</a></td></tr>
<tr d-ix="41"><td>039</td><td>AutoIt</td><td>170218T174545Z</td><td><a href="https://codegolf.stackexchange.com/questions/110485/leak-memory-in-as-few-bytes-as-possible/110487#110487">user4264</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>Swift 5.10 (with C interop), 23 bytes</h1>
<p>Well of <em>course</em> the C-interop solution would be the shortest, I don't know what I expected.</p>
<pre class="lang-swift prettyprint-override"><code>import Darwin
malloc(1)
</code></pre>
<blockquote>
<p>If you're on a Linux box, you'll need to replace <code>Darwin</code> with <code>Glibc</code>. (Incidentally, this saves a byte.)</p>
</blockquote>
<h2>Swift 5.10 (pure), 42 bytes</h2>
<pre class="lang-swift prettyprint-override"><code>({UnsafeMutablePointer&lt;()&gt;.allocate})()(1)
</code></pre>
<p>This is basically a direct Swift port of the <code>malloc(_:)</code> call above.</p>
</div>
<div id="pu1" class="pu"><h1>Bash (4.4.20), 0 bytes</h1>
<pre><code></code></pre>
<h3>Verification</h3>
<pre><code>$ valgrind bash main.sh
==1172== Memcheck, a memory error detector
==1172== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==1172== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info
==1172== Command: bash main.sh
==1172== 
==1172== 
==1172== HEAP SUMMARY:
==1172==     in use at exit: 33,849 bytes in 379 blocks
==1172==   total heap usage: 514 allocs, 135 frees, 54,210 bytes allocated
==1172== 
==1172== LEAK SUMMARY:
==1172==    definitely lost: 12 bytes in 1 blocks
==1172==    indirectly lost: 0 bytes in 0 blocks
==1172==      possibly lost: 0 bytes in 0 blocks
==1172==    still reachable: 33,837 bytes in 378 blocks
==1172==         suppressed: 0 bytes in 0 blocks
==1172== Rerun with --leak-check=full to see details of leaked memory
==1172== 
==1172== For counts of detected and suppressed errors, rerun with: -v
==1172== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
</code></pre>
</div>
<div id="pu2" class="pu"><h1>Swift, <s>42</s> 38 bytes</h1>

<pre><code>class a{var b: a};var b:a?=a();b!.b=b;b=nil
</code></pre>

<h3>Explanation</h3>

<p>Swift uses automatic reference counting (ARC) for garbage collection. It works by keeping a count of the number of references to an object, and deallocates it right before the reference count diminishes to zero.<br>
Take a look at the following pseudocode:  </p>

<pre><code>let x be an address of allocated memory
allocate 16 bytes, then store the address of those 16 bytes in x
</code></pre>

<p>One of the worst things to do is...  </p>

<pre><code>set x to NULL
</code></pre>

<p>Because now we no longer know where those 16 bytes are located.  </p>

<p>ARC prevents (most) objects from being made inaccessible. However, what ARC doesn't help with is <em>cycles</em>, or reference loops.<br>
For example, <span class="math-container">\$a\$</span> has a reference to <span class="math-container">\$b\$</span>, and <span class="math-container">\$b\$</span> has a reference to <span class="math-container">\$a\$</span>. The problem is that they rely on each other to keep a non-zero reference count.
Recall that the above code looks like </p>

<pre><code>class a{var b: a!};do{var b:a?=a();b!.b=b;b=nil}
</code></pre>

<p>The first part...</p>

<pre><code>class a {
   var b: a!
}
</code></pre>

<p>...lays the foundation for a reference cycle.  </p>

<pre><code>var b: a? = a();
</code></pre>

<p>Sets <code>b</code> to to a new <code>a</code>, and <code>b</code> allowed to be <code>nil</code>. Right now, the reference count is <code>1</code>.  </p>

<pre><code>b!.b = b
</code></pre>

<p>Assert that b is not <code>nil</code> (because it's allowed to be, as it will be later), set property <code>b</code> of <code>b</code> to <code>b</code>.
This creates a cycle; <code>b</code> has a reference to <code>b</code>. Right now, the reference count is <code>2</code>, but only one of those references come from an accessible source, namely <code>b</code>.  </p>

<pre><code>b = nil
</code></pre>

<p>Whoops. The reference count is <code>1</code>, because <code>b</code> has a reference to <code>b</code>, but now, nothing else has a reference to <code>b</code>, creating a memory leak.</p>
</div>
<div id="pu3" class="pu"><h2>C/C++, GCC; 46 bytes</h2>

<pre><code>int main(){while(1){int* x=new int;}return 0;}
</code></pre>

<p>What does it do?</p>

<pre><code>int main()
{
    // Start an infinite loop:
    while (1)
    {
        // Create a variable `x` and point to a new integer:
      int* x = new int;
    }

    return 0;
}
</code></pre>

<p>The code above uses an infinite loop to point to a new address that is not deleted.</p>
</div>
<div id="pu4" class="pu"><h2>Python &lt;3.6.5, 23 bytes</h2>
<pre><code>property([]).__init__()
</code></pre>
<p><code>property.__init__</code> leaks references to the property's old <code>fget</code>, <code>fset</code>, <code>fdel</code>, and <code>__doc__</code> if you call it on an already-initialized <code>property</code> instance. This is a bug, eventually reported as part of CPython <a href="https://bugs.python.org/issue31787" rel="noreferrer">issue 31787</a> and fixed in <a href="https://github.com/python/cpython/commit/47316342417146f62653bc3c3dd505bfacc5e956" rel="noreferrer">Python 3.6.5</a> and <a href="https://github.com/python/cpython/commit/ef20abed7f2ae0ba54b1d287f5fe601be80c1128" rel="noreferrer">Python 3.7.0</a>. (Also, yes, <code>property([])</code> is a thing you can do.)</p>
</div>
<div id="pu5" class="pu"><h1>Batch, 2 bytes</h1>

<pre><code>a^
</code></pre>

<p>This is based on my favorite <a href="https://web.archive.org/web/20170814061717/https://stackoverflow.com/questions/23284131/cmd-exe-parsing-bug-leads-to-other-exploits" rel="nofollow noreferrer">StackOverflow post</a> of all time. (Wayback link since the original is <a href="https://stackoverflow.com/q/23284131">removed</a>.) I'll copy the explanation directly from there:</p>

<blockquote>
  <p><strong>The Bug Explained</strong></p>
  
  <p>The bug is that when a caret is detected, the next character is read
  from the file (to be 'escaped'). If the caret is the last character of
  the file, this results in a logic error, as when a call to
  <code>get_next_char</code> is made, the file pointer is incremented by one; in this
  case that puts it passed the <code>EOF</code>. Since the <code>EOF</code> is effectively ignored
  when the command parser continues to read the next input, it
  essentially 'resets' its file pointer due to the <code>EOF+1</code> error. In this
  case, putting the file pointer to <code>EOF+1</code> causes the pointer to be at
  some large negative number, and since file's can't go below 0, it's
  file pointer is basically reset to 0 and the parsing continues from
  the beginning of the file.</p>
</blockquote>

<p>It should be noted that, based on my own testing, the issue seems to be resolved in Windows 10.</p>
</div>
<div id="pu6" class="pu"><h1>C#, 34 bytes</h1>
<pre><code>class L{~L(){for(;;)new L();}}
</code></pre>
<p>This <em>solution</em> does not require the Heap.
It just needs a real hard working GC (<a href="https://www.google.de/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=12&amp;cad=rja&amp;uact=8&amp;ved=0ahUKEwjaqvXGqZzSAhXMXhQKHYlpDakQFghIMAs&amp;url=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FGarbage_collection_(computer_science)&amp;usg=AFQjCNHMuYt1SQmqd0Z2AE27JpDAP5rBfg&amp;sig2=KvQoRPh3_BaQ0qFp86YodQ&amp;bvm=bv.147448319,d.bGs" rel="noreferrer">Garbage Collector</a>).</p>
<p>Essentially it turns the GC into its own enemy.</p>
<h1>Explanation</h1>
<p>Whenever the <em>destructor</em> is called, It creates new instances of this evil class as long as the timeout runs out and tells the GC to just ditch that object without waiting for the destructor to finish. By then thousands of new instances have been created.</p>
<p>The &quot;evilness&quot; of this is, the harder the GC is working, the more this will blow up in your face.</p>
<p><em>Disclaimer</em>: Your GC may be smarter than mine. Other circumstances in the program may cause the GC to ignore the first object or its destructor. In these cases this will not blow up. But in many variations it <em>will</em>. Adding a few bytes here and there might ensure a leak for every possible circumstances. Well except for the power switch maybe.</p>
<h1>Test</h1>
<p>Here is a test <em>suite</em>:</p>
<pre><code>using System;
using System.Threading;
using System.Diagnostics;
class LeakTest {
    public static void Main() {
        SpawnLeakage();
        Console.WriteLine(&quot;{0}-: Objects may be freed now&quot;, DateTime.Now);
        // any managed object created in SpawbLeakage 
        //  is no longer accessible
        // The GC should take care of them
        
        // Now let's see
        MonitorGC();
    }
    public static void SpawnLeakage() {
        Console.WriteLine(&quot;{0}-: Creating 'leakage' object&quot;, DateTime.Now);
        L l = new L();
    }
    public static void MonitorGC() {
        while(true) {
            int top = Console.CursorTop;
            int left = Console.CursorLeft;
            Console.WriteLine(
                &quot;{0}-: Total managed memory: {1} bytes&quot;,
                DateTime.Now,
                GC.GetTotalMemory(false)
            );
            Console.SetCursorPosition(left, top);
        }
    }
}
</code></pre>
<p>Output after 10 minutes:</p>
<pre><code>2/19/2017 2:12:18 PM-: Creating 'leakage' object
2/19/2017 2:12:18 PM-: Objects may be freed now
2/19/2017 2:22:36 PM-: Total managed memory: 2684476624 bytes
</code></pre>
<p>That's 2 684 476 624 bytes.
The Total <code>WorkingSet</code> of the process was about 4.8 GB</p>
<p>This answer has been inspired by Eric Lippert's wonderful article: <a href="https://ericlippert.com/2015/05/18/when-everything-you-know-is-wrong-part-one/" rel="noreferrer">When everything you know is wrong</a>.</p>
</div>
<div id="pu7" class="pu"><h1>SmileBASIC, 8 bytes</h1>
<pre><code>?POP(@L)
</code></pre>
<p>Due to a bug, using POP on a string literal will use up memory, which can't be freed without restarting the system.</p>
</div>
<div id="pu8" class="pu"><h1>Java 1.3, 23 bytes</h1>

<pre><code>void l(){new Thread();}
</code></pre>

<p>Creating a thread but not starting it. The thread is registered in the internal thread pool, but will never be started, so never ended and therefore never be a candidate for the GC. It is an unretrievable object, stuck in Java limbos.</p>

<p><a href="https://bugs.java.com/view_bug.do?bug_id=4410846" rel="nofollow noreferrer">It's a bug in Java until 1.3 included</a> as it was fixed afterwards.</p>

<h2>Testing</h2>

<p>The following program makes sure to pollute the memory with new thread objects and show a decreasing free memory space. For the sake of leaks testing, I intensively makes the GC run.</p>

<pre><code>public class Pcg110485 {

    static
    void l(){new Thread();}

    public static void main(String[] args) {

        while(true){
            l();
            System.gc();
            System.out.println(Runtime.getRuntime().freeMemory());
        }
    }
}
</code></pre>
</div>
<div id="pu9" class="pu"><h2>Common Lisp (SBCL only), <del>28</del> 26 bytes</h2>

<pre><code>sb-alien::(make-alien int)
</code></pre>

<p>You run it like so: <code>sbcl --eval 'sb-alien::(make-alien int)'</code>; nothing is printed nor returned, but the memory allocation happens. If I wrap the form inside a <code>(print ...)</code>, the pointer is displayed in the REPL.</p>

<ol>
<li><p><code>package::(form)</code> is a special notation in SBCL for temporarily binding the current package while reading a form. This is used here to avoid prefixing both <code>make-alien</code> and <code>int</code> with <code>sb-alien</code>. I think it would be cheating to assume the current package is set to this one, because that's not the case at startup.</p></li>
<li><p><code>make-alien</code> allocates memory for a given type and an optional size (using malloc).</p></li>
<li><p>When executing this in the REPL, add <code>0</code> after the allocation so that the REPL does not return the pointer, but that value instead. Otherwise, that would no be a real leak because the REPL remembers the last three returned values (See <a href="http://www.lispworks.com/documentation/HyperSpec/Body/v__stst_.htm" rel="nofollow noreferrer"><code>*</code>, <code>**</code>, <code>***</code></a>) and we could still have a chance to free the allocated memory.</p></li>
</ol>

<p>2 bytes removed thanks to PrzemysławP, thanks!</p>
</div>
<div id="pu10" class="pu"><h1>Julia, <s>60</s> 56 bytes</h1>

<pre><code>addprocs();!a=while 1&gt;0 s=convert(SharedArray,a)end;![9]
</code></pre>

<p>This entry is based on the bug <a href="https://github.com/JuliaLang/julia/issues/20424" rel="nofollow noreferrer">https://github.com/JuliaLang/julia/issues/20424</a> , and is very likely to be invalidated by a future update. </p>

<p>It can be done with less code, but the loop nails it down that it's an actual leak, caused by a bug, and not just the GC waiting its merry time before it starts collecting garbage. Also, GC will probably be alerted and start cleaning everything up if you start putting any significant amount of <em>other</em> garbage onto the heap, so I want to get the OOM error up before anyone starts cluttering the heap with other garbage. </p>

<p>Explained (as far as I can tell):</p>

<pre><code>#Spawn some child processes
addprocs();

#Iterative subroutine that does nothing but generate and then immediately forget shared arrays en masse
!a=while 1&gt;0 s=convert(SharedArray,a)end;

#Let it rip
#For whatever reason, GC never gets around to cleaning the shared arrays up
#The OutOfMemoryError should pop up soon enough
![9]
</code></pre>
</div>
<div id="pu11" class="pu"><h1>Haskell, 29 bytes</h1>
<p>Yet another &quot;malloc and forget&quot; answer:</p>
<pre class="lang-hs prettyprint-override"><code>import Foreign
main=()&lt;$new 0
</code></pre>
<p>This time it is in Haskell, which is normally a garbage collected language, but the <a href="https://wiki.haskell.org/Foreign_Function_Interface" rel="nofollow noreferrer">Foreign Function Interface</a> gives access to raw <a href="https://hackage.haskell.org/package/base-4.9.1.0/docs/Foreign-Marshal-Alloc.html#v:malloc" rel="nofollow noreferrer"><code>malloc</code></a> operations.</p>
<h2>Explanation</h2>
<p>The function <a href="https://hackage.haskell.org/package/base-4.9.1.0/docs/Foreign-Marshal-Utils.html#v:new" rel="nofollow noreferrer"><code>new</code></a> allocates a new block of memory, stores a copy of the argument at that location and returns a pointer to it. In this case, we store the value <code>0 :: Double</code>. Then, we ignore the pointer by using <a href="https://hackage.haskell.org/package/base-4.9.1.0/docs/Control-Applicative.html#v:-60--36-" rel="nofollow noreferrer"><code>(&lt;$) :: a -&gt; IO (Ptr Double) -&gt; IO a</code></a> to replace the return value with the unit (<code>()</code>).</p>
</div>
<div id="pu12" class="pu"><h1><a href="https://github.com/Folds/english" rel="nofollow noreferrer">Plain English</a>, <s>71</s> <s>70</s> <s>58</s> 35 bytes</h1>
<p>Removed 1 byte by deleting a blank line.  Removed 12 bytes by eliminating the &quot;bogon&quot; type definition, and using the parent &quot;thing&quot; type instead of the &quot;bogon&quot; subtype.  Removed 23 bytes by switching from a complete program, to just a routine that leaks memory.</p>
<p>Golfed version:</p>
<pre><code>To x:
Allocate memory for a thing.
</code></pre>
<p>Ungolfed version that is a complete program, uses a subtype definition, and does not leak memory:</p>
<pre><code>A bogon is a thing.

To do something:
  Allocate memory for a bogon.
  Destroy the bogon.

To run:
  Start up.
  Do something.
  Shut down.
</code></pre>
<p>If the golfed version of &quot;x&quot; is called, it will leak memory in proportion to the number of times &quot;x&quot; is called.  In the golfed version, &quot;Deallocate the thing.&quot; would fix the memory leak.</p>
<p>Plain English checks for memory leaks by default.  When the version that leaks memory is run, a dialog box will appear just before the program shuts down.  The dialog box has a title of &quot;debug&quot;, a message of &quot;1 drip&quot;, and an &quot;OK&quot; button.  The more times the leaking function is called, the larger the number of &quot;drips&quot; in the message. When the version that does not leak memory is run, the dialog box does not appear.</p>
<p>In Plain English, a &quot;thing&quot; is a pointer to an item in a doubly-linked list.  &quot;Thing&quot;, &quot;to start up&quot;, and &quot;to shut down&quot; are defined in a module called &quot;the noodle&quot;, which needs to be copied in (usually as a separate file) into each project.  &quot;A&quot;, &quot;the&quot;, &quot;to&quot;, &quot;to allocate memory&quot;, and &quot;to destroy&quot; are defined in the compiler.</p>
</div>
<div id="pu13" class="pu"><h2>C#, 109 bytes</h2>
<pre><code>public class P{static void Main({for(;;)System.Xml.Serialization.XmlSerializer.FromTypes(new[]{typeof(P)});}}
</code></pre>
<p>We found the idea behind this leak in production code and researching it leads to <a href="https://blogs.msdn.microsoft.com/tess/2006/02/15/net-memory-leak-xmlserializing-your-way-to-a-memory-leak/" rel="nofollow noreferrer">this article.</a> The main problem is in this long quote from the article (read it for more info):</p>
<blockquote>
<p>Searching my code for <code>PurchaseOrde</code>r, I find this line of code in <code>page_load</code> of one of my pages <code>XmlSerializer serializer = new XmlSerializer(typeof(PurchaseOrder), new XmlRootAttribute(“”));</code></p>
<p>This would seem like a pretty innocent piece of code. We create an <code>XMLSerializer</code> for <code>PurchaseOrder</code>. But what happens under the covers?</p>
<p>If we take a look at the <code>XmlSerializer</code> constructor with Reflector we find that it calls <code>this.tempAssembly = XmlSerializer.GenerateTempAssembly(this.mapping, type, defaultNamespace, location, evidence);</code> which generates a temp (dynamic) assembly. So every time this code runs (i.e. every time the page is hit) it will generate a new assembly.</p>
<p>The reason it generates an assembly is that it needs to generate functions for serializing and deserializing and these need to reside somewhere.</p>
<p>Ok, fine… it creates an assembly, so what? When we’re done with it, it should just disappear right?</p>
<p>Well… an assembly is not an object on the GC Heap, the GC is really unaware of assemblies, so it won’t get garbage collected. The only way to get rid of assemblies in 1.0 and 1.1 is to unload the app domain in which it resides.</p>
<p>And therein lies the problem Dr Watson.</p>
</blockquote>
<p>Running from the compiler in Visual Studio 2015 and using the Diagnostic Tools Window shows the following results after about 38 seconds. Note the Process memory is steadily climbing and the Garbage Collector (GC) keeps running but can't collect anything.</p>
<p><a href="https://i.stack.imgur.com/2xuNb.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/2xuNb.png" alt="Diagnostic Tools Window" /></a></p>
</div>
<div id="pu14" class="pu"><h1>c, 9 bytes</h1>

<pre><code>main(){}
</code></pre>

<p>Proof:</p>

<pre><code>localhost/home/elronnd-10061: cat t.c
main(){}
localhost/home/elronnd-10062: valgrind gcc t.c
==10092== Memcheck, a memory error detector
==10092== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al.
==10092== Using Valgrind-3.12.0 and LibVEX; rerun with -h for copyright info
==10092== Command: gcc t.c
==10092==
t.c:1:1: warning: return type defaults to ‘int’ [-Wimplicit-int]
 main(){}
 ^~~~
==10092==
==10092== HEAP SUMMARY:
==10092==     in use at exit: 178,518 bytes in 73 blocks
==10092==   total heap usage: 362 allocs, 289 frees, 230,415 bytes allocated
==10092==
==10092== LEAK SUMMARY:
==10092==    definitely lost: 4,659 bytes in 8 blocks
==10092==    indirectly lost: 82 bytes in 5 blocks
==10092==      possibly lost: 0 bytes in 0 blocks
==10092==    still reachable: 173,777 bytes in 60 blocks
==10092==         suppressed: 0 bytes in 0 blocks
==10092== Rerun with --leak-check=full to see details of leaked memory
==10092==
==10092== For counts of detected and suppressed errors, rerun with: -v
==10092== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
</code></pre>
</div>
<div id="pu15" class="pu"><h1><a href="http://openjdk.java.net/projects/jdk9/" rel="nofollow noreferrer">Java (OpenJDK 9)</a>, <strike>322</strike> 220 bytes</h1>



<pre class="lang-java prettyprint-override"><code>import sun.misc.*;class Main{static void main(String[]a)throws Exception{java.lang.reflect.Field f=Unsafe.class.getDeclaredField("theUnsafe");f.setAccessible‌​(1&lt;2);((Unsafe)f.get‌​(1)).allocateMemory(‌​1);}}
</code></pre>

<p><a href="https://tio.run/nexus/java-openjdk9#NYy7asNAEEV/ZVG1m2LAaWUXgSSdK5MquBivZuUJq12zM/EDY1DvfKV@RFEs0l3uOZyRu0MuauQ7Qcfi4an2EUXMGjldRVHZm2PmxnTTYTdaOLWfW3S6L/kk5u3s6aCc0/ULjwgRUwuFQiSv8M4UGxNWH0kwEDy60JK@0jQLNQ9uK93TbFSuDiCkL96TCO8iDf3P0N/tYvnsamtny4W/xj9xDjDG7FFpTV0uFzuThatvt3H8BQ" rel="nofollow noreferrer" title="Java (OpenJDK 9) – TIO Nexus">Try it online!</a></p>

<p>This is a other Memory leak that don't use the String Cache. It Allocates half of your RAM and you can't do anything with it.</p>

<p>Thanks to zeppelin for saving all the bytes</p>
</div>
<div id="pu16" class="pu"><h1>Solution 1: C (Mac OS X x86_64), 109 bytes</h1>

<p>The source for golf_sol1.c</p>

<pre><code>main[]={142510920,2336753547,3505849471,284148040,2370322315,2314740852,1351437506,1208291319,914962059,195};
</code></pre>

<p>The above program needs to be compiled with execution access on the __DATA segment.</p>

<pre><code>clang golf_sol1.c -o golf_sol1 -Xlinker -segprot -Xlinker __DATA -Xlinker rwx -Xlinker rwx
</code></pre>

<p>Then to execute the program run the following:</p>

<pre><code>./golf_sol1 $(ruby -e 'puts "\xf5\xff\xff\xfe\xff\xff\x44\x82\x57\x7d\xff\x7f"')
</code></pre>

<h2>Results:</h2>

<p>Unfortunately Valgrind does not watch for memory allocated from system calls, so I can't show a nice detected leak.</p>

<p>However we can look at vmmap to see the large chunk of allocated memory (MALLOC metadata).</p>

<pre><code>                                VIRTUAL   REGION 
REGION TYPE                        SIZE    COUNT (non-coalesced) 
===========                     =======  ======= 
Kernel Alloc Once                    4K        2 
MALLOC guard page                   16K        4 
MALLOC metadata                   16.2M        7 
MALLOC_SMALL                      8192K        2         see MALLOC ZONE table below
MALLOC_TINY                       1024K        2         see MALLOC ZONE table below
STACK GUARD                       56.0M        2 
Stack                             8192K        3 
VM_ALLOCATE (reserved)             520K        3         reserved VM address space (unallocated)
__DATA                             684K       42 
__LINKEDIT                        70.8M        4 
__TEXT                            5960K       44 
shared memory                        8K        3 
===========                     =======  ======= 
TOTAL                            167.0M      106 
TOTAL, minus reserved VM space   166.5M      106 
</code></pre>

<h2>Explanation</h2>

<p>So I think I need to describe what's actually going on here, before moving onto the improved solution.</p>

<p>This main function is abusing C's missing type declaration (so it defaults to int without us needing to waste characters writing it), as well how symbols work. The linker only cares about whether of not it can find a symbol called <code>main</code> to call to. So here we're making main an array of int's which we're initializing with our shellcode that will be executed. Because of this, main will not be added to the __TEXT segment but rather the __DATA segment, reason we need to compile the program with an executable __DATA segment.</p>

<p>The shellcode found in main is the following:</p>

<pre><code>movq 8(%rsi), %rdi
movl (%rdi), %eax
movq 4(%rdi), %rdi
notl %eax
shrq $16, %rdi
movl (%rdi), %edi
leaq -0x8(%rsp), %rsi
movl %eax, %edx
leaq -9(%rax), %r10
syscall
movq (%rsi), %rsi
movl %esi, (%rsi)
ret
</code></pre>

<p>What this is doing is calling the syscall function to allocate a page of memory (the syscall mach_vm_allocate uses internally). RAX should equal 0x100000a (tells the syscall which function we want), while RDI holds the target for the allocation (in our case we want this to be mach_task_self()), RSI should hold the address to write the pointer to the newly created memory (so we are just pointing it to a section on the stack), RDX holds the size of the allocation (we're just passing in RAX or 0x100000a just to save on bytes), R10 holds the flags (we're indicating it can be allocated anywhere).</p>

<p>Now it's not plainly obvious where RAX and RDI are getting their values from. We know RAX needs to be 0x100000a, and RDI needs to be the value mach_task_self() returns. Luckily mach_task_self() is actually a macro for a variable (mach_task_self_), which is at the same memory address every time (should change on reboot however). In my particular instance mach_task_self_ happens to be located at 0x00007fff7d578244. So to cut down on instructions, we'll instead be passing in this data from argv. This is why we run the program with this expression <code>$(ruby -e 'puts "\xf5\xff\xff\xfe\xff\xff\x44\x82\x57\x7d\xff\x7f"')</code> for the first argument. The string is the two values combined, where the RAX value (0x100000a) is only 32 bits and has had a one's complement applied to it (so there's no null bytes; we just NOT the value to get the original), the next value is the RDI (0x00007fff7d578244) which has been shifted to the left with 2 extra junk bytes added to the end (again to exclude the null bytes, we just shift it back to the right to get it back to the original).</p>

<p>After the syscall we're writing to our newly allocated memory. The reason for this is because memory allocated using mach_vm_allocate (or this syscall) are actually VM pages, and are not automatically paged into memory. Rather they are reserved until data is written to them, and then those pages are mapped into memory. Wasn't sure if it would meet the requirements if it was only reserved.</p>

<p>For the next solution we'll be taking advantage of the fact that our shellcode has no null bytes, and so can move it outside of our program's code to reduce the size.</p>

<h1>Solution 2: C (Mac OS X x86_64), 44 bytes</h1>

<p>The source for golf_sol2.c</p>

<pre><code>main[]={141986632,10937,1032669184,2,42227};
</code></pre>

<p>The above program needs to be compiled with execution access on the __DATA segment.</p>

<pre><code>clang golf_sol2.c -o golf_sol2 -Xlinker -segprot -Xlinker __DATA -Xlinker rwx -Xlinker rwx
</code></pre>

<p>Then to execute the program run the following:</p>

<pre><code>./golf_sol2 $(ruby -e 'puts "\xb8\xf5\xff\xff\xfe\xf7\xd0\x48\xbf\xff\xff\x44\x82\x57\x7d\xff\x7f\x48\xc1\xef\x10\x8b\x3f\x48\x8d\x74\x24\xf8\x89\xc2\x4c\x8d\x50\xf7\x0f\x05\x48\x8b\x36\x89\x36\xc3"')
</code></pre>

<p>The result should be the same as before, as we're making an allocation of the same size.</p>

<h2>Explanation</h2>

<p>Follows much the same concept as solution 1, with the exception that we've moved the chunk of our leaking code outside of the program.</p>

<p>The shellcode found in main is now the following:</p>

<pre><code>movq 8(%rsi), %rsi
movl $42, %ecx
leaq 2(%rip), %rdi
rep movsb (%rsi), (%rdi)
</code></pre>

<p>This basically copies the shellcode we pass in argv to be after this code (so after it has copied it, it will run the inserted shellcode). What works to our favour is that the __DATA segment will be at least a page size, so even if our code isn't that big we can still "safely" write more. The downside is the ideal solution here, wouldn't even need the copy, instead it would just call and execute the shellcode in argv directly. But unfortunately, this memory does not have execution rights. We could change the rights of this memory, however it would require more code than simply copying it. An alternative strategy would be to change the rights from an external program (but more on that later).</p>

<p>The shellcode we pass to argv is the following:</p>

<pre><code>movl $0xfefffff5, %eax
notl %eax
movq $0x7fff7d578244ffff, %rdi
shrq $16, %rdi
movl (%rdi), %edi
leaq -0x8(%rsp), %rsi
movl %eax, %edx
leaq -9(%rax), %r10
syscall
movq (%rsi), %rsi
movl %esi, (%rsi)
ret
</code></pre>

<p>This is much the same as our previous code, only difference being we're including the values for EAX and RDI directly.</p>

<h1>Possible Solution 1: C (Mac OS X x86_64), 11 bytes</h1>

<p>The idea of modifying the program externally, gives us the possible solution of moving the leaker to an external program. Where our actual program (submission) is just a dummy program, and the leaker program will allocate some memory in our target program. Now I wasn't certain if this would fall within the rules for this challenge, but sharing it nonetheless.</p>

<p>So if we were to use mach_vm_allocate in an external program with the target set to our challenge program, that could mean our challenge program would only need to be something along the lines of:</p>

<pre><code>main=65259;
</code></pre>

<p>Where that shellcode is simply a short jump to itself (infinite jump/loop), so the program stays open and we can reference it from an external program.</p>

<h1>Possible Solution 2: C (Mac OS X x86_64), 8 bytes</h1>

<p>Funnily enough when I was looking at valgrind output, I saw that at least according to valgrind, dyld leaks memory. So effectively every program is leaking some memory. With this being the case, we could actually just make a program that does nothing (simply exits), and that will actually be leaking memory.</p>

<p>Source:</p>

<pre><code>main(){}


==55263== LEAK SUMMARY:
==55263==    definitely lost: 696 bytes in 17 blocks
==55263==    indirectly lost: 17,722 bytes in 128 blocks
==55263==      possibly lost: 0 bytes in 0 blocks
==55263==    still reachable: 0 bytes in 0 blocks
==55263==         suppressed: 16,316 bytes in 272 blocks
</code></pre>
</div>
<div id="pu17" class="pu"><h1>ZX Spectrum BASIC, 2 bytes</h1>

<pre><code>GO SUB PI
</code></pre>

<p>Explanation: both <code>GO SUB</code> and <code>PI</code> are single tokens taking one byte. <code>GO SUB</code> will actually jump to line nr. 3, but the number <code>3</code> would take 5 bytes whereas <code>PI</code> takes only one.</p>

<p>ZX Spectrum BASIC has no memory management, so the return address on the stack remains until you re-initialize BASIC with <code>NEW</code> or <code>CLEAR</code> or <code>RUN</code> a program or until you use the <code>RETURN</code> command. If used as a part of a stored BASIC program, the memory would remain leaked even after the program terminates (and if you repeat the <code>GO SUB PI</code> enough times, the machine will run out of memory).</p>
</div>
<div id="pu18" class="pu"><h1>Swift, 12 bytes</h1>

<pre><code>[3,5][0...0]
</code></pre>

<h2>Explanation:</h2>

<p>This is a de-facto memory leak that can occur in any language, regardless if the language uses memory manual management, automated reference counting (ARC, like Swift), or even sweeping garbage collection.</p>

<p><code>[3,5]</code> is just an array literal. This array allocates enough memory for at least these those 2 elements. The <code>3</code> and <code>5</code> are just arbitrary.</p>

<p>Subscripting (indexing) an <code>Array&lt;T&gt;</code> produces an <code>ArraySlice&lt;T&gt;</code>. An <code>ArraySlice&lt;T&gt;</code> is a view into the memory of the Array it was created from.</p>

<p><code>[3,5][0...0]</code> produces an <code>ArraySlice&lt;Int&gt;</code>, whose value is <code>[3]</code>. Note that the <code>3</code> in this slice is the same <code>3</code> element as the <code>3</code> in the original <code>Array</code> shown above, <em>not</em> a copy.</p>

<p>The resulting slice can then be stored into a variable and used. The original array is no longer referenced, so you would think it could be deallocated. However, it cannot.</p>

<p>Since the slice exposes a view onto the memory of the array it came from, the original array must be kept alive as long as the slice lives. So of the original <code>2</code> element-sizes worth of memory that were allocated, only first element-size worth of memory is being used, with the other the one being required to exist so as to not allocate the first. The second element-size of memory is de-factor leaked.</p>

<p>The solution to this problem is to not keep alive small slices of large arrays for long. If you need to persist the slice contents, then promote it to an Array, which will trigger the memory to be copied, thus removing the dependancy on the original array's memory:</p>

<pre><code>Array([3,5][0...0])
</code></pre>
</div>
<div id="pu19" class="pu"><h1>C, <s>48 31</s> 22 bytes</h1>

<p>Warning: Don't run this too many times.</p>

<p>Thanks to <a href="https://codegolf.stackexchange.com/users/12012/dennis">Dennis</a> for lots of help/ideas!</p>

<pre><code>f(k){shmget(k,1,512);}
</code></pre>

<p>This goes one step further. <code>shmget</code> allocates shared memory that  isn't deallocated when the program ends. It uses a key to identify the memory, so we use an uninitialized int. This is technically undefined behaviour, but practically it means that we use the value that is just above the top of the stack when this is called. This will get written over the next time that anything is added to the stack, so we will lose the key.</p>

<hr>

<p>The only case that this doesn't work is if you can figure out what was on the stack before. For an extra 19 bytes you can avoid this problem:</p>

<pre><code>f(){srand(time(0));shmget(rand(),1,512);}
</code></pre>

<hr>

<p>Or, for 26 bytes:</p>

<pre><code>main(k){shmget(&amp;k,1,512);}
</code></pre>

<p>But with this one, the memory is leaked after the program exits. While running the program has access to the memory which is against the rules, but after the program terminates we lose access to the key and the memory is still allocated.&nbsp;
This requires address space layout randomisation (ASLR), otherwise <code>&amp;k</code> will always be the same. Nowadays ASLR is typically on by default. </p>

<hr>

<p><strong>Verification:</strong></p>

<p>You can use <code>ipcs -m</code> to see what shared memory exists on your system. I removed pre-existing entries for clarity: </p>

<pre><code>$ cat leakMem.c 
f(k){shmget(k,1,512);}
int main(){f();}     
$ gcc leakMem.c -o leakMem
leakMem.c:1:1: warning: return type defaults to ‘int’ [-Wimplicit-int]
 f(k){shmget(k,1,512);}
 ^
leakMem.c: In function ‘f’:
leakMem.c:1:1: warning: type of ‘k’ defaults to ‘int’ [-Wimplicit-int]
leakMem.c:1:6: warning: implicit declaration of function ‘shmget’ [-Wimplicit-function-declaration]
 f(k){shmget(k,1,512);}
ppcg:ipcs -m

------ Shared Memory Segments --------
key        shmid      owner      perms      bytes      nattch     status      


$ ./leakMem 

$ ipcs -m

------ Shared Memory Segments --------
key        shmid      owner      perms      bytes      nattch     status      

0x0000007b 3375157    Riley      0          1          0  
</code></pre>
</div>
<div id="pu20" class="pu"><h1>PHP, 32 bytes</h1>

<pre><code>gc_disable();$x[]=&amp;$x;unset($x);
</code></pre>

<p>Run like this:</p>

<pre><code>php -r 'gc_disable();$x[]=&amp;$x;unset($x);'
</code></pre>

<h1>Explanation</h1>

<p>This causes a circular reference, which can only be caught (and freed) by the circular reference collector (which I disabled). Test to see memory leak effects:</p>

<pre><code># Without disabling circular ref collector.
php -nr 'for(;$a++&lt;100000;){$x[]=&amp;$x;unset($x);}echo memory_get_usage()."\n";'
&gt; 353944
# Circular ref collector disabled.
php -nr 'gc_disable();for(;$a++&lt;100000;){$x[]=&amp;$x;unset($x);}echo memory_get_usage()."\n";'
&gt; 40354096
</code></pre>
</div>
<div id="pu21" class="pu"><h1>x86 ASM, 1 byte, assumes a certain kind of stack frame</h1>

<pre><code>push AX
</code></pre>

<p>Some kinds of stack frames free this at <code>mov SP, BP</code>, some don't. The kinds that don't probably crash but you can avoid that by not returning. For some reason this code golf challenge does not require placing the leak inside a loop as it ought to.</p>
</div>
<div id="pu22" class="pu"><h2>Dart, 76 bytes</h2>

<pre><code>import'dart:async';main()=&gt;new Stream.periodic(Duration.ZERO).listen((_){});
</code></pre>

<p>A bit like the JavaScript answer. When you call <code>.listen</code> on a Dart stream object you are given back a StreamSubscription, which allows you to disconnect from the stream. However, if you throw that away, you can never unsubscribe from the stream, causing a leak. The only way the leak can be fixed is if the Stream itself gets collected, but its still referenced internally by a StreamController+Timer combo.</p>

<p>Unfortunately, Dart is too smart for the other stuff I've tried. <code>()async=&gt;await new Completer().future</code> doesn't work because using await is the same as doing <code>new Completer().future.then(&lt;continuation&gt;)</code>, which allows the closure itself to be destroyed the second Completer isn't referenced (Completer holds a reference to the Future from <code>.future</code>, Future holds a reference to the continuation as a closure).</p>

<p>Also, Isolates (aka threads) are cleaned up by GC, so spawning yourself in a new thread and immediately pausing it (<code>import'dart:isolate';main(_)=&gt;Isolate.spawn(main,0,paused:true);</code>) doesn't work. Even spawning an Isolate with an infinite loop (<code>import'dart:isolate';f(_){while(true){print('x');}}main()=&gt;Isolate.spawn(f,0);</code>) kills the Isolate and exits the program.</p>

<p>Oh well.</p>
</div>
<div id="pu23" class="pu"><h1><a href="http://factorcode.org" rel="nofollow noreferrer">Factor</a>, 13 bytes</h1>

<p>Factor has automatic memory management, but also gives access to some libc functionality:</p>

<pre><code>1 malloc drop
</code></pre>

<p>Manually allocates 1 byte of memory, returns it's address, and drops it.</p>

<p><code>malloc</code> actually registers a copy to keep track of memory leaks adn double frees, but identifying the one you leaked is not an easy task.</p>

<p>If you prefer to make sure you really lose that reference:</p>

<pre><code>1 (malloc) drop
</code></pre>

<p>Testing leaks with <code>[ 1 malloc drop ] leaks.</code> says:</p>

<pre><code>| Disposable class | Instances |                    |
| malloc-ptr       | 1         | [ List instances ] |
</code></pre>

<p>Testing leaks with <code>[ 1 (malloc) drop ] leaks.</code> says:</p>

<pre><code>| Disposable class | Instances | |
</code></pre>

<p>Oh no! Poor factor, it's got Alzheimer now! D:</p>
</div>
<div id="pu24" class="pu"><h2>Swift 3, 38 bytes</h2>

<p>New version:</p>

<pre><code>class X{var x: X!};do{let x=X();x.x=x}
</code></pre>

<p><code>x</code> has a strong reference to itself, so it will not be deallocated, leading to a memory leak. </p>

<p>Old version:</p>

<pre><code>class X{var y:Y!}
class Y{var x:X!}
do{let x=X();let y=Y();x.y=y;y.x=x}
</code></pre>

<p><code>x</code> contains a strong reference to <code>y</code>, and vice versa. Thus, neither will be deallocated, leading to a memory leak. </p>
</div>
<div id="pu25" class="pu"><h2>C 30 bytes</h2>

<pre><code>f(){int *i=malloc(sizeof(4));}
</code></pre>

<h2>Valgrind Results:</h2>

<pre><code>         ==26311== HEAP SUMMARY:
         ==26311==     in use at exit: 4 bytes in 1 blocks
         ==26311==   total heap usage: 1 allocs, 0 frees, 4 bytes allocated
         ==26311== 
         ==26311== LEAK SUMMARY:
         ==26311==    definitely lost: 4 bytes in 1 blocks
         ==26311==    indirectly lost: 0 bytes in 0 blocks
         ==26311==      possibly lost: 0 bytes in 0 blocks
         ==26311==    still reachable: 0 bytes in 0 blocks
         ==26311==         suppressed: 0 bytes in 0 blocks
         ==26311== Rerun with --leak-check=full to see details of leaked memory
</code></pre>
</div>
<div id="pu26" class="pu"><h2>C++, 16 bytes</h2>

<pre><code>main(){new int;}
</code></pre>

<p><s>I don't have valgrind to check it leaks, but pretty sure it should.</s> Otherwise I would try:</p>

<pre><code>main(){[]{new int;}();}
</code></pre>

<h1>Valgrind result</h1>

<p>(It does leak indeed)</p>

<pre><code>==708== LEAK SUMMARY:
==708==    definitely lost: 4 bytes in 1 blocks
</code></pre>
</div>
<div id="pu27" class="pu"><h2>8086 ASM, 3 bytes</h2>

<p>This examples assumes that a C runtime is linked in.</p>

<pre><code>jmp _malloc
</code></pre>

<p>this assembles to <code>e9 XX XX</code> where <code>XX XX</code> is the relative address of <code>_malloc</code></p>

<p>This invokes <code>malloc</code> to allocate an unpredictable amount of memory and then immediately returns, terminating the processes. On some operating systems like DOS, the memory might not be reclaimable at all until the system is rebooted!</p>
</div>
<div id="pu28" class="pu"><h1>go 45 bytes</h1>
<pre><code>package main
func main(){go func(){for{}}()}
</code></pre>
<p>this creates an anonymous goroutine with an infinite loop inside of it. the program can continue to run as normal, as starting the goroutine is kind of like spawning a concurrently running small thread, but the program has no way to reclaim the memory that was allocated for the goroutine. the garbage collector will never collect it either since it is still running. some people call this 'leaking a goroutine'</p>
</div>
<div id="pu29" class="pu"><h1>Java, 10 bytes</h1>
<p>Finally, a competitive answer in Java !</p>
<p><strong>Golfed</strong></p>
<pre class="lang-java prettyprint-override"><code>&quot;. &quot;::trim
</code></pre>
<p>This is a method reference (against a string constant), which can be used like that:</p>
<pre class="lang-java prettyprint-override"><code>Supplier&lt;String&gt; r = &quot;. &quot;::trim
</code></pre>
<p>A literal string <code>&quot;. &quot;</code> will be automatically added to the global <em>interned</em> strings pool, as maintained by the <code>java.lang.String</code> class,
and as we immediatelly trim it, the reference to it can not be reused further in the code (unless you declare exactly the same string again).</p>
<blockquote>
<p>...</p>
<p>A pool of strings, initially empty, is maintained privately by the class String.</p>
<p>All literal strings and string-valued constant expressions are interned. String literals are defined in section 3.10.5 of the The Java™ Language Specification.</p>
<p>...</p>
</blockquote>
<p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#intern--" rel="noreferrer">https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#intern--</a></p>
<p>You can turn this in a &quot;production grade&quot; memory leak, by adding the string to itself and then invoking the <em>intern()</em> method explicitly, in a loop.</p>
</div>
<div id="pu30" class="pu"><h1>C# - 84bytes</h1>

<pre class="lang-c# prettyprint-override"><code>class P{static void Main(){System.Runtime.InteropServices.Marshal.AllocHGlobal(1);}}
</code></pre>

<p>This allocates exactly 1 byte of unmanaged memory, and then loses the <code>IntPtr</code>, which I believe is the only way to get at or free it. You can test it by stuffing it in a loop, and waiting for the application to crash (might want to add a few zeros to speed things up).</p>

<p>I considered <code>System.IO.File.Create("a");</code> and such, but I'm not convinced that these are necessarily memory leaks, as the application itself <em>will</em> collect the memory, it's the OS underneath that <em>might</em> leak (because <code>Close</code> or <code>Dispose</code> were not called). File access stuff also requires file system permissions, and no one wants to rely on those. <em>And it turns out this won't leak anyway, because there is nothing stopping the finaliser being called (which does free the underlying resources is possible), which the framework includes to mitigate these sorts of error of judgement (to some degree), and to confuse programmers with seemingly non-deterministic file locking (if you're a cynic). Thanks to Jon Hanna for putting me straight on this.</em></p>

<p>I am a tad disappointed that I can't find a shorter way. The .NET GC works, I can't think of any <code>IDisposables</code> in mscorlib that will definitely leak <em>(and indeed they all seem to have finalisers, how annoying)</em>, I'm not aware of any other way to allocate unmanaged memory (short of PInvoke), and reflection ensures anything with a reference to it (regardless of language semantics (e.g. private members or classes with no accessors)) <em>can</em> be found.</p>
</div>
<div id="pu31" class="pu"><h1>Javascript, 3 bytes</h1>
<p>Every string in Javascript is re-created in memory, since they are immutable.</p>
<p>If you allocate a string with something, it will take (at least) 2 bytes (UTF-16).</p>
<pre><code>&quot;1&quot;
</code></pre>
<p>Running something like <code>for(var i = 0; i &lt; 1000000; i++)&quot;1&quot;;</code>, on Google Chrome, you can see the memory increasing (using the built-in task manager).<br />
It climbs by 10-20kb, using the example code.</p>
</div>
<div id="pu32" class="pu"><h1><a href="https://www.perl.org/" rel="noreferrer">Perl</a> (5.22.2), 0 bytes</h1>



<pre class="lang-perl prettyprint-override"><code></code></pre>

<p><a href="https://tio.run/nexus/perl" rel="noreferrer" title="Perl – TIO Nexus">Try it online!</a></p>

<p>I knew there'd be some language out there that leaked memory on an empty program. I was expecting it to be an esolang, but turns out that <code>perl</code> leaks memory on any program. (I'm assuming that this is intentional, because freeing memory if you know you're going to exit anyway just wastes time; as such, the common recommendation nowadays is to just leak any remaining memory once you're in your program's exit routines.)</p>

<h2>Verification</h2>

<pre class="lang-perl prettyprint-override"><code>$ echo -n | valgrind perl
…snip…
==18517== 
==18517== LEAK SUMMARY:
==18517==    definitely lost: 8,134 bytes in 15 blocks
==18517==    indirectly lost: 154,523 bytes in 713 blocks
==18517==      possibly lost: 0 bytes in 0 blocks
==18517==    still reachable: 0 bytes in 0 blocks
==18517==         suppressed: 0 bytes in 0 blocks
==18517== 
==18517== For counts of detected and suppressed errors, rerun with: -v
==18517== ERROR SUMMARY: 15 errors from 15 contexts (suppressed: 0 from 0)
</code></pre>
</div>
<div id="pu33" class="pu"><h1>Befunge (<a href="https://hackage.haskell.org/package/Fungi-1.0.4" rel="noreferrer">fungi</a>), 1 byte</h1>
<pre><code>$
</code></pre>
<p>This may be platform dependent and version dependent (I've only tested with version 1.0.4 on Windows), but <em>fungi</em> has historically been a very leaky interpreter. The <code>$</code> (drop) command shouldn't do anything on an empty stack, but looping over this code somehow manages to leak a lot of memory very quickly. Within a matter of seconds it will have used up a couple of gigs and will crash with an &quot;out of memory&quot; error.</p>
<p>Note that it doesn't necessarily have to be a <code>$</code> command - just about anything would do. It won't work with a blank source file though. There's got to be at least one operation.</p>
</div>
<div id="pu34" class="pu"><h1>Forth, 6 bytes</h1>
<p><strong>Golfed</strong></p>
<pre><code>s&quot; &quot; *
</code></pre>
<p>Allocates an empty string with <code>s&quot; &quot;</code>, leaving it's address and length (0) on the stack, then multiplies them (resulting in a memory address being lost).</p>
<p><strong>Valgrind</strong></p>
<pre><code>%valgrind --leak-check=full gforth -e 's&quot; &quot; * bye'
...
==12788== HEAP SUMMARY:
==12788==     in use at exit: 223,855 bytes in 3,129 blocks
==12788==   total heap usage: 7,289 allocs, 4,160 frees, 552,500 bytes allocated
==12788== 
==12788== 1 bytes in 1 blocks are definitely lost in loss record 1 of 22
==12788==    at 0x4C2AB80: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==12788==    by 0x406E39: gforth_engine (in /usr/bin/gforth-0.7.0)
==12788==    by 0x41156A: gforth_go (in /usr/bin/gforth-0.7.0)
==12788==    by 0x403F9A: main (in /usr/bin/gforth-0.7.0)
==12788== 
...
==12818== LEAK SUMMARY:
==12818==    definitely lost: 1 bytes in 1 blocks
==12818==    indirectly lost: 0 bytes in 0 blocks
</code></pre>
</div>
<div id="pu35" class="pu"><h1>Javascript, 14 bytes</h1>
<p><strong>Golfed</strong></p>
<pre class="lang-js prettyprint-override"><code>setInterval(0)
</code></pre>
<p>Registers an empty interval handler with a default delay, discarding the resulting timer id (making it impossible to cancel).</p>
<p><a href="https://i.stack.imgur.com/v5YRe.png" rel="noreferrer"><img src="https://i.stack.imgur.com/v5YRe.png" alt="enter image description here" /></a></p>
<p>I've used a non-default interval, to create several million timers, to illustrate the leak, as using a default interval eats CPU like mad.</p>
</div>
<div id="pu36" class="pu"><h1>Delphi (Object Pascal) - 33 bytes</h1>
<p>Creating an object without a variable, full console program:</p>
<pre><code>program;begin TObject.Create;end.
</code></pre>
<p>Enabling FastMM4 in the project will show the memory leak:</p>
<p><a href="https://i.stack.imgur.com/Iy90o.png" rel="noreferrer"><img src="https://i.stack.imgur.com/Iy90o.png" alt="enter image description here" /></a></p>
</div>
<div id="pu37" class="pu"><h1>TI-Basic, 12 bytes</h1>
<pre><code>While 1
Goto A
End
Lbl A
Pause 
</code></pre>
<p>&quot;... a memory leak is where you use a Goto/Lbl within a loop or If conditional (anything that has an End command) to jump out of that control structure before the End command is reached... &quot; <a href="http://tibasicdev.wikidot.com/memory-leaks" rel="noreferrer">(more)</a></p>
</div>
<div id="pu38" class="pu"><h1>Rust, 52 bytes</h1>

<pre><code>extern{fn malloc(_:u8);}fn main(){unsafe{malloc(9)}}
</code></pre>

<p>Allocates some bytes with the system malloc. This assumes the wrong ABI is acceptable.</p>

<hr>

<h1><del>Rust (in theory), 38 bytes</del></h1>

<pre><code>fn main(){Box::into_raw(Box::new(1));}
</code></pre>

<p>We allocate memory on the heap, extract a raw pointer, and then just ignore it, effectively leaking it. (<code>Box::into_raw</code> is shorter then <code>std::mem::forget</code>). </p>

<p>However, Rust by default uses jemalloc, <a href="https://github.com/rust-lang/rust/issues/28224" rel="noreferrer">which valgrind can't detect any leakage</a>. We could switch to the system allocator but that <a href="https://doc.rust-lang.org/book/custom-allocators.html#switching-allocators" rel="noreferrer">adds 50 bytes</a> and requires nightly. Thanks so much for memory safety.</p>

<hr>

<p>Output of the first program:</p>

<pre><code>==10228== Memcheck, a memory error detector
==10228== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al.
==10228== Using Valgrind-3.12.0.SVN and LibVEX; rerun with -h for copyright info
==10228== Command: ./1
==10228== 
==10228== 
==10228== HEAP SUMMARY:
==10228==     in use at exit: 9 bytes in 1 blocks
==10228==   total heap usage: 7 allocs, 6 frees, 2,009 bytes allocated
==10228== 
==10228== LEAK SUMMARY:
==10228==    definitely lost: 9 bytes in 1 blocks
==10228==    indirectly lost: 0 bytes in 0 blocks
==10228==      possibly lost: 0 bytes in 0 blocks
==10228==    still reachable: 0 bytes in 0 blocks
==10228==         suppressed: 0 bytes in 0 blocks
==10228== Rerun with --leak-check=full to see details of leaked memory
==10228== 
==10228== For counts of detected and suppressed errors, rerun with: -v
==10228== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
</code></pre>
</div>
<div id="pu39" class="pu"><h1><a href="http://www.madore.org/~david/programs/unlambda/" rel="noreferrer">Unlambda</a> (<code>c-refcnt/unlambda</code>), 1 byte</h1>

<pre><code>i
</code></pre>

<p><a href="https://tio.run/nexus/unlambda#@5/5/z8A" rel="noreferrer" title="Unlambda – TIO Nexus">Try it online!</a></p>

<p>This is really a challenge about finding a pre-existing interpreter which leaks memory on very simple programs. In this case, I used Unlambda. There's more than one official Unlambda interpreter, but <code>c-refcnt</code> is one of the easiest to build, and it has the useful property here that it leaks memory when a program runs successfully. So all I needed to give here was the simplest possible legal Unlambda program, a no-op. (Note that the empty program doesn't work here; the memory is still reachable at the time the interpreter crashes.)</p>

<h2>Verification</h2>

<pre>
$ wget ftp://ftp.madore.org/pub/madore/unlambda/unlambda-2.0.0.tar.gz
…snip…
2017-02-18 18:11:08 (975 KB/s) - ‘unlambda-2.0.0.tar.gz’ saved [492894]
$ tar xf unlambda-2.0.0.tar.gz 
$ cd unlambda-2.0.0/c-refcnt/
$ gcc unlambda.c
$ echo -n i | valgrind ./a.out /dev/stdin
…snip…
==3417== LEAK SUMMARY:
==3417==    definitely lost: 40 bytes in 1 blocks
==3417==    indirectly lost: 0 bytes in 0 blocks
==3417==      possibly lost: 0 bytes in 0 blocks
==3417==    still reachable: 0 bytes in 0 blocks
==3417==         suppressed: 0 bytes in 0 blocks
==3417== 
==3417== For counts of detected and suppressed errors, rerun with: -v
==3417== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)
</pre>
</div>
<div id="pu40" class="pu"><h1><a href="https://gcc.gnu.org/" rel="noreferrer">C (gcc)</a>, 15 bytes</h1>

<pre class="lang-c prettyprint-override"><code>f(){malloc(1);}
</code></pre>

<h3>Verification</h3>

<pre><code>$ cat leak.c
f(){malloc(1);}
main(){f();}
$ gcc -g -o leak leak.c
leak.c: In function ‘f’:
leak.c:1:5: warning: incompatible implicit declaration of built-in function ‘malloc’ [enabled by default]
 f(){malloc(1);}
     ^
$ valgrind --leak-check=full ./leak
==32091== Memcheck, a memory error detector
==32091== Copyright (C) 2002-2013, and GNU GPL'd, by Julian Seward et al.
==32091== Using Valgrind-3.10.0 and LibVEX; rerun with -h for copyright info
==32091== Command: ./leak
==32091==
==32091==
==32091== HEAP SUMMARY:
==32091==     in use at exit: 1 bytes in 1 blocks
==32091==   total heap usage: 1 allocs, 0 frees, 1 bytes allocated
==32091==
==32091== 1 bytes in 1 blocks are definitely lost in loss record 1 of 1
==32091==    at 0x4C29110: malloc (in /usr/lib64/valgrind/vgpreload_memcheck-amd64-linux.so)
==32091==    by 0x40056A: f (leak.c:1)
==32091==    by 0x40057A: main (leak.c:2)
==32091==
==32091== LEAK SUMMARY:
==32091==    definitely lost: 1 bytes in 1 blocks
==32091==    indirectly lost: 0 bytes in 0 blocks
==32091==      possibly lost: 0 bytes in 0 blocks
==32091==    still reachable: 0 bytes in 0 blocks
==32091==         suppressed: 0 bytes in 0 blocks
==32091==
==32091== For counts of detected and suppressed errors, rerun with: -v
==32091== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)
</code></pre>
</div>
<div id="pu41" class="pu"><h1><a href="https://autoitscript.com" rel="nofollow noreferrer">AutoIt</a>, 39 bytes</h1>

<pre><code>#include&lt;Memory.au3&gt;
_MemGlobalAlloc(1)
</code></pre>

<p>Allocates one byte from the heap. Since the handle returned by <code>_MemGlobalAlloc</code> is discarded, there is no way to explicitly free that allocation.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/110485/">110485</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




