<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::18129</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>027</td><td>Juby</td><td>240321T160123Z</td><td><a href="https://codegolf.stackexchange.com/questions/18129/reciprocal-fibonacci-constant/272013#272013">Jordan</a></td></tr>
<tr d-ix="1"><td>011</td><td>cQuents</td><td>181126T030724Z</td><td><a href="https://codegolf.stackexchange.com/questions/18129/reciprocal-fibonacci-constant/176562#176562">Stephen</a></td></tr>
<tr d-ix="2"><td>005</td><td>Jelly</td><td>181126T041034Z</td><td><a href="https://codegolf.stackexchange.com/questions/18129/reciprocal-fibonacci-constant/176565#176565">Bubbler</a></td></tr>
<tr d-ix="3"><td>007</td><td>JAEL</td><td>181107T201112Z</td><td><a href="https://codegolf.stackexchange.com/questions/18129/reciprocal-fibonacci-constant/175471#175471">Eduardo </a></td></tr>
<tr d-ix="4"><td>050</td><td>RPL HP 49G/G+/50g</td><td>181107T152349Z</td><td><a href="https://codegolf.stackexchange.com/questions/18129/reciprocal-fibonacci-constant/175458#175458">G. W. Ba</a></td></tr>
<tr d-ix="5"><td>066</td><td>C# .NET Core</td><td>181108T154757Z</td><td><a href="https://codegolf.stackexchange.com/questions/18129/reciprocal-fibonacci-constant/175531#175531">Meerkat</a></td></tr>
<tr d-ix="6"><td>027</td><td>Perl 6</td><td>181108T061859Z</td><td><a href="https://codegolf.stackexchange.com/questions/18129/reciprocal-fibonacci-constant/175483#175483">Jo King</a></td></tr>
<tr d-ix="7"><td>006</td><td>Japt mx</td><td>181107T174249Z</td><td><a href="https://codegolf.stackexchange.com/questions/18129/reciprocal-fibonacci-constant/175466#175466">Shaggy</a></td></tr>
<tr d-ix="8"><td>021</td><td>APL</td><td>140111T223003Z</td><td><a href="https://codegolf.stackexchange.com/questions/18129/reciprocal-fibonacci-constant/18272#18272">Tobia</a></td></tr>
<tr d-ix="9"><td>021</td><td>Kona</td><td>140110T031927Z</td><td><a href="https://codegolf.stackexchange.com/questions/18129/reciprocal-fibonacci-constant/18154#18154">Kyle Kan</a></td></tr>
<tr d-ix="10"><td>051</td><td>Python</td><td>140113T125022Z</td><td><a href="https://codegolf.stackexchange.com/questions/18129/reciprocal-fibonacci-constant/18379#18379">jur</a></td></tr>
<tr d-ix="11"><td>019</td><td>K</td><td>140111T165851Z</td><td><a href="https://codegolf.stackexchange.com/questions/18129/reciprocal-fibonacci-constant/18256#18256">Joachim </a></td></tr>
<tr d-ix="12"><td>035</td><td>Perl</td><td>140111T111352Z</td><td><a href="https://codegolf.stackexchange.com/questions/18129/reciprocal-fibonacci-constant/18241#18241">primo</a></td></tr>
<tr d-ix="13"><td>022</td><td>K</td><td>140112T214435Z</td><td><a href="https://codegolf.stackexchange.com/questions/18129/reciprocal-fibonacci-constant/18327#18327">tmartin</a></td></tr>
<tr d-ix="14"><td>064</td><td>Forth</td><td>140110T220327Z</td><td><a href="https://codegolf.stackexchange.com/questions/18129/reciprocal-fibonacci-constant/18218#18218">Darren S</a></td></tr>
<tr d-ix="15"><td>033</td><td>Javascript</td><td>140110T112906Z</td><td><a href="https://codegolf.stackexchange.com/questions/18129/reciprocal-fibonacci-constant/18176#18176">Ant&#243</a></td></tr>
<tr d-ix="16"><td>043</td><td>PERL</td><td>140110T010636Z</td><td><a href="https://codegolf.stackexchange.com/questions/18129/reciprocal-fibonacci-constant/18147#18147">Ant&#243</a></td></tr>
<tr d-ix="17"><td>116</td><td>BC</td><td>140110T032009Z</td><td><a href="https://codegolf.stackexchange.com/questions/18129/reciprocal-fibonacci-constant/18155#18155">Tyzoid</a></td></tr>
<tr d-ix="18"><td>032</td><td>Mathematica</td><td>140110T012647Z</td><td><a href="https://codegolf.stackexchange.com/questions/18129/reciprocal-fibonacci-constant/18148#18148">ybeltuko</a></td></tr>
<tr d-ix="19"><td>035</td><td>GTB</td><td>140110T000911Z</td><td><a href="https://codegolf.stackexchange.com/questions/18129/reciprocal-fibonacci-constant/18143#18143">Timtech</a></td></tr>
<tr d-ix="20"><td>024</td><td>Mathematica</td><td>140110T004722Z</td><td><a href="https://codegolf.stackexchange.com/questions/18129/reciprocal-fibonacci-constant/18146#18146">DavidC</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://github.com/cyoce/J-uby" rel="nofollow noreferrer">J-uby</a>, 27 bytes</h1>
<pre class="lang-ruby prettyprint-override"><code>:+|:*&amp;(:++[0,1]|:/&amp;1r)|:sum
</code></pre>
<p>Returns a fraction. If a floating point number is necessary, change <code>1r</code> to <code>1.0</code> for +1 byte.</p>
<p><a href="https://ato.pxeger.com/run?1=m700K740qXLBIjfbpaUlaboWu620a6y01DSstLWjDXQMY2us9NUMizRrrIpLcyEqVhaUlhQruEWbxkL4CxZAaAA" rel="nofollow noreferrer">Attempt This Online!</a></p>
<h2>Explanation</h2>
<p>J-uby's <code>+</code> operator, when called with a function and initial array like <code>fn + arr</code>, returns a function that, when called with an integer <code>n</code> (like <code>(fn + arr).(n)</code>), applies <code>fn</code> to the last <code>arr.size</code> items in <code>arr</code> <code>n</code> times, making it very handy for Fibonacci and similar sequences.</p>
<pre><code>:+ | :* &amp; (:+ + [0,1] | :/ &amp; 1r) | :sum
:+ |                                      # Range 1..input, then
     :* &amp; (                    )          # map with...
           :+ + [0,1] |                   #   nth fibonacci number, then
                        :/ &amp; 1r           #   reciprocal
                                 | :sum   # then sum
</code></pre>
</div>
<div id="pu1" class="pu"><h1><a href="https://github.com/stestoltz/cQuents/tree/cquents-0" rel="nofollow noreferrer">cQuents</a>, <s>13</s> 11 bytes</h1>
<pre><code>;/b$
=1:Z+Y
</code></pre>
<p><a href="https://tio.run/##Sy4sTc0rKf7/31o/SYXL1tAqSjvy/39DAwMDAA" rel="nofollow noreferrer" title="cQuents – Try It Online">Try it online!</a></p>
<h2>Explanation</h2>
<pre><code>;          The sum of the first n terms of the sequence
 /         which are 1 divided by
  b$       the nth term in the sequence on the second line

=1:Z+Y     Fibonacci with starting indexes 1,1
</code></pre>
</div>
<div id="pu2" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="nofollow noreferrer">Jelly</a>, 5 bytes</h1>

<pre><code>RÆḞİS
</code></pre>

<p><a href="https://tio.run/##y0rNyan8/z/ocNvDHfOObAj@//@/KQA" rel="nofollow noreferrer" title="Jelly – Try It Online">Try it online!</a></p>

<h3>How it works</h3>

<pre><code>RÆḞİS    Main link (monad). Input: integer
R        Range
 ÆḞ      nth Fibonacci number
   İ     Reciprocal
    S    Sum
</code></pre>
</div>
<div id="pu3" class="pu"><h1>JAEL, <s>9</s> 7 bytes</h1>

<p>Changing the diacritics from one character to another gave me 1 byte</p>

<p>Still working on SBCS encoding.</p>

<pre><code>#`&amp;@uȦ
</code></pre>

<h3>Explanation (generated automatically):</h3>

<pre><code>./jael -u explain '#`&amp;@uȦ'

ORIGINAL CODE:
#`&amp;@uȦ

EXPANDING EXPLANATION:
Ȧ =&gt; .a!

EXPANDED CODE:
#`&amp;@u.a!

COMPLETED CODE:
#`&amp;@u.a!,


#       ,               repeat (p1) times:
 `                              stack 1
  &amp;                             push number of iterations of this loop
   @                            push nth fibonacci number
    u                           push p2 / p1
     .                          push the value under the tape head
      a                         push p1 + p2
       !                        write p1 to the tapehead
         ␄              print machine state
</code></pre>
</div>
<div id="pu4" class="pu"><p><strong>RPL (HP 49G/G+/50g), 50 bytes</strong></p>

<pre><code>« 0. 1. DUP2 5. ROLL
  START SWAP OVER + ROT OVER INV + UNROT
  NEXT DROP2
»
</code></pre>

<p>Examples:</p>

<p>10 -> 3.33046904076</p>

<p>11 -> 3.34170499582</p>

<p>30 -> 3.35988372158</p>

<p>55 -> 3.35988566622</p>

<p>In theory, the sum of the first 55 digits would give 12 correct digits. The last digit should be '4' instead of '2'. This should be fixed by adding up the terms backwards, but the code would be slightly longer.</p>

<p>If the constant were to be computed to 1000 decimal places using the definition  the sum should be carried out to at least the first 4790 terms, which would take too much time on the HP 50g, if possible at all. For this task a more efficient method is required, like the one used in the following RPL program (464 bytes, checksum # 207Eh) whose argument is the desired number of decimal places: </p>

<pre><code>%%HP: T(3)A(R)F(.);
\&lt;&lt; PUSH RAD -105 CF -3 CF R\-&gt;I DUP 1 + 2 INV SWAP 100 LN * 5 LN + OVER ASINH / \v/ * CEIL DUP 2 MOD + DUP 0 ROT
[[ 1 1 ]
 [ 1 0 ]] SWAP DUP2 ^ 3 GETI UNROT GET 4 ROLLD 4 ROLLD DUP + ^ 1 GETI UNROT GET 1 + 0 1 8 ROLL 2 /
  START PICK3 + DUP PICK3 * NEG 6 PICK SQ + / 4 PICK SQ * EXPAND ROT PICK3 - ROT OVER - ROT 6 ROLL 6 ROLL 6 ROLL + LASTARG * LASTARG 5 ROLLD 5 ROLLD / + ROT PICK3 - ROT OVER - 6 ROLL 6 ROLL 6 ROLL
  NEXT ROT + INV 5 ROLL + EXPAND 4 ROLLD 3 DROPN FXND PICK3 ALOG OVER - PICK3 * SWAP IQUOT + \-&gt;STR DUP HEAD -51 FC? { "." } { "," } IFTE + SWAP TAIL + 1 ROT 2 + SUB POP
\&gt;&gt;

'RFC' STO
</code></pre>

<p>1000 RFC --></p>

<p>3.3598856662431775531720113029189271796889051337319684864955538153251303189966833836154162164567900872970453429288539133041367890171008836795913517330771190785803335503325077531875998504871797778970060395645092153758927752656733540240331694417992939346109926262579646476518686594497102165589843608814726932495910794738736733785233268774997627277579468536769185419814676687429987673820969139012177220244052081510942649349513745416672789553444707777758478025963407690748474155579104200675015203410705335285129792635242062267537568055761955669720848843854407983324292851368070827522662579751188646464096737461572387236295562053612203024635409252678424224347036310363201466298040249015578724456176000319551987905969942029178866949174808096746523682654086938399069873211752166957063859411814553647364268782462926166650100098903804823359519893146150108288726392887669917149304053057745574321561167298985617729731395370735291966884327898022165047585028091806291002444277017460241040417786069190065037142835294</p>

<p>(22 min 23 sec, on the real HP 50g)</p>

<hr>

<p>For one thousand digits the first 50 terms of the series plus another 50 terms of a continued fraction are evaluated, two at a time in only 25 iterations (48 terms of each would have sufficed, though). An equivalent DECIMAL BASIC program takes just 10 milliseconds on my computer (Intel(R) Core(TM) Duo CPU E4700 @ 2.6 GHz).</p>
</div>
<div id="pu5" class="pu"><h1><a href="https://www.microsoft.com/net/core/platform" rel="nofollow noreferrer">C# (.NET Core)</a>, 66 bytes</h1>



<pre class="lang-cs prettyprint-override"><code>a=&gt;{double r=1,x=1,y=1,i=0;for(;++i&lt;a;y+=x,x=y-x)r+=1/y;return r;}
</code></pre>

<p><a href="https://tio.run/##NY3LCsIwFETX9ivuMqX1Ud0IaQQRBEE3KriO6a0EagI3qTSUfnsNlA4chsMsRrmlsoRj67T5wCM4j18OqpHOwRH6xHnptYJza1RZ2fbdYA5TH6AGMUpx6CcHEkXeRUJEiw2vLTGeZbqUPGSii1tYdillolgHTuhbMkB8GPl88rO6gpvUhqV9sjhZ42yDqxdpj6xm0X9IfvW0F@N3Wzbvd5TVVRtkaQxPhmHc/wE" rel="nofollow noreferrer" title="C# (.NET Core) – Try It Online">Try it online!</a></p>

<p>Can't use floats because of imprecision.</p>

<p>Example where input = 8:</p>

<ul>
<li>double: 3.28287545787546 (rounds to 3.282875)</li>
<li>float:  3.282876 (off by 0.000001)</li>
</ul>

<p>Ungolfed:</p>

<pre class="lang-cs prettyprint-override"><code>a =&gt; {
    double r = 1,                       // initialize r (sum of reciprocals) - start at 1 to save one byte in for loop
            x = 1, y = 1,                   // initialize x (2nd largest Fibonacci) and y (largest Fibonacci)
            i = 0;                          // initialize i (loop counter)
    for(; ++i &lt; a; y += x, x = y - x)   // from 1 to a, while incrementing the Fibonacci numbers
        r += 1 / y;                         // increment the reciprocal Fibonacci
    return r;                           // return the reciprocal Fibonacci
}
</code></pre>
</div>
<div id="pu6" class="pu"><h1><a href="https://github.com/nxadm/rakudo-pkg" rel="nofollow noreferrer">Perl 6</a>, 27 bytes</h1>



<pre class="lang-perl6 prettyprint-override"><code>{sum 1 X/(1,&amp;[+]...*)[^$_]}
</code></pre>

<p><a href="https://tio.run/##K0gtyjH7n1upoJamYKvwv7q4NFfBUCFCX8NQRy1aO1ZPT09LMzpOJT629n9xYqVCmoahgYGBpvV/AA" rel="nofollow noreferrer" title="Perl 6 – Try It Online">Try it online!</a></p>

<p>Alternatively</p>



<pre class="lang-perl6 prettyprint-override"><code>{sum 1 xx$_ Z/(1,&amp;[+]...*)}
</code></pre>

<p><a href="https://tio.run/##K0gtyjH7n1upoJamYKvwv7q4NFfBUKGiQiVeIUpfw1BHLVo7Vk9PT0uz9n9xYqVCmoahgYGBpvV/AA" rel="nofollow noreferrer" title="Perl 6 – Try It Online">Try it online!</a></p>
</div>
<div id="pu7" class="pu"><h1>Japt <code>-mx</code>, 6 bytes</h1>
<pre><code>1/MgUÄ
</code></pre>
<p><a href="https://ethproductions.github.io/japt/?v=1.4.6&amp;code=MS9NZ1XE&amp;input=MTAwMAotbXg=" rel="nofollow noreferrer">Try it</a></p>
</div>
<div id="pu8" class="pu"><h1>APL, 21 chars/bytes*</h1>

<pre><code>{+/÷{↑+\∘⌽⍣⍵⊢0 1}¨⍳⍵}
</code></pre>

<p><strong>Example</strong></p>

<pre><code>      {+/÷{↑+\∘⌽⍣⍵⊢0 1}¨⍳⍵} 10
3.330469041
      ⍪{+/÷{↑+\∘⌽⍣⍵⊢0 1}¨⍳⍵}¨⍳10
1          
2          
2.5        
2.833333333
3.033333333
3.158333333
3.23525641 
3.282875458
3.312287223
3.330469041
      {+/÷{↑+\∘⌽⍣⍵⊢0 1}¨⍳⍵} 100
3.359885666
</code></pre>

<p>⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯<br>
<sup>*: APL can be written in its own (legacy) single-byte charset that maps APL symbols to the upper 128 byte values. Therefore, for the purpose of scoring, a program of N chars <em>that only uses ASCII characters and APL symbols</em> can be considered to be N bytes long.</sup></p>
</div>
<div id="pu9" class="pu"><h2>Kona (<strike>25</strike> 21)</h2>

<pre><code>{+/%(x(|+\)\1 1)[;1]}
</code></pre>

<p>Probably could be made smaller by experts, but I am still learning the language.</p>

<pre><code>  f 10
3.341705
  f 3
2.8333
  f 25
3.359872
  f 400
3.359886
</code></pre>

<p>The last one didn't actually take any more time than the others.</p>
</div>
<div id="pu10" class="pu"><h2>Python (<s>55</s> 51)</h2>

<p><s></p>

<pre><code>i,r=p=1,1
while i&lt;n+1:r+=1./p[-1];p=p[1],sum(p);i+=1
r
</code></pre>

<p></s></p>

<pre><code>i,r,a,b=[1]*4
while i&lt;n+1:r+=1./b;a,b=b,b+a;i+=1
r
</code></pre>

<p>In interactive mode:</p>

<pre><code>n=10
3.341704995819338

n=100
</code></pre>

<p><s></p>

<pre><code>3.3598856429940778
</code></pre>

<p></s></p>

<pre><code>3.359885666243178

n=400
</code></pre>

<p><s></p>

<pre><code>3.3598855578800064
</code></pre>

<p></s></p>

<pre><code>3.359885666243178
</code></pre>
</div>
<div id="pu11" class="pu"><p><b>K (19)</b></p>

<p>(or 17 if you skip defining it as a function)</p>

<pre><code>f:{+/*+%x(|+\)\|!2}
</code></pre>

<p>Tested on Kona.</p>

<p>Basically, it generates the first x values of the fibonacci sequence into an array (without using builtins), divides 1 by each value of the entire array, transposes and sums it up.</p>

<p>(thanks to @tmartin for the better sum method)</p>
</div>
<div id="pu12" class="pu"><h2>Perl - 35 bytes</h2>
<pre><code>print!map$\-=1/($%+=$.=$%-$.),0..&lt;&gt;
</code></pre>
<p>Sample usage:</p>
<pre><code>$ echo 10 | perl inv-fib-sum.pl
3.34170499581934
</code></pre>
<hr />
<h2>Further Analysis</h2>
<p>It's interesting to note that the sum</p>
<p><img src="https://chart.googleapis.com/chart?cht=tx&amp;chl=f%3D%5Csum%5Climits_%7Bi%3D0%7D%5E%5Cinfty%7B%5Cfrac%7B1%7D%7BF_i%7D%7D%3D%5Cfrac%7B1%7D%7B1%7D%2B%5Cfrac%7B1%7D%7B1%7D%2B%5Cfrac%7B1%7D%7B2%7D%2B%5Cfrac%7B1%7D%7B3%7D%2B%5Cfrac%7B1%7D%7B5%7D%2B%5Cfrac%7B1%7D%7B8%7D%2B%5Cfrac%7B1%7D%7B13%7D%2B%5Cfrac%7B1%7D%7B21%7D%2B%5Cfrac%7B1%7D%7B34%7D%2B%5Cdots" alt="" /></p>
<p>is convergent. Supposing we wanted to calculate a few thousand digits or so, the naïve approach is almost sufficient. The convergence is quite slow at first, but speeds up rapidly, so that <em>1000</em> digits only takes about <em>4800</em> terms. A sample Python implementation might be:</p>
<pre><code>a=[1,1]
for i in range(4800):a=[a[0]+a[1]]+a
z=10**1000
print sum(map(lambda i:z/i,a))
</code></pre>
<p>which after a second or so outputs:</p>
<pre><code>33598856662431775531720113029189271796889051337319684864955538153251303189966833836154162164567900872970453429288539133041367890171008836795913517330771190785803335503325077531875998504871797778970060395645092153758927752656733540240331694417992939346109926262579646476518686594497102165589843608814726932495910794738736733785233268774997627277579468536769185419814676687429987673820969139012177220244052081510942649349513745416672789553444707777758478025963407690748474155579104200675015203410705335285129792635242062267537568055761955669720848843854407983324292851368070827522662579751188646464096737461572387236295562053612203024635409252678424224347036310363201466298040249015578724456176000319551987905969942029178866949174808096746523682654086938399069873211752166957063859411814553647364268782462926166650100098903804823359519893146150108288726392887669917149304053057745574321561167298985617729731395370735291966884327898022165047585028091806291002444277017460241040417786069190065037142832933
</code></pre>
<p>(The last four digits don't quite converge, but we'll ignore that for now.)</p>
<p>Let's try to speed up the convergence a bit. A standard trick is to use <a href="http://en.wikipedia.org/wiki/Series_acceleration#Euler.27s_transform" rel="nofollow noreferrer">Euler's Transform</a>. After expansion and simplification, this produces a nicer result:</p>
<p><img src="https://chart.googleapis.com/chart?cht=tx&amp;chl=f%3D3%2B%5Csum%5Climits_%7Bi%3D0%7D%5E%5Cinfty%7B%28-1%29%5Ei%5Cfrac%7B1%7D%7BF_i%5Ccdot+F_%7Bi%2B1%7D%5Ccdot+F_%7Bi%2B2%7D%7D%7D%3D%5Cfrac%7B1%7D%7B1%5Ccdot+1%5Ccdot+2%7D-%5Cfrac%7B1%7D%7B1%5Ccdot+2%5Ccdot+3%7D%2B%5Cfrac%7B1%7D%7B2%5Ccdot+3%5Ccdot+5%7D-%5Cfrac%7B1%7D%7B3%5Ccdot+5%5Ccdot+8%7D%2B%5Cdots" alt="" /></p>
<p>It should be fairly apparent why this converges more quickly; each term has 3 terms in the denominator rather than just one. Calculating <em>1000</em> digits takes only <em>1600</em> (one third as many) terms:</p>
<pre><code>a=[1,1]
for i in range(1601):a=[a[0]+a[1]]+a
z=10**1000
print sum(map(lambda i:(-1)**i*z/(a[i]*a[i+1]*a[i+2]),range(1601)))
</code></pre>
<p>Output:</p>
<pre><code>3598856662431775531720113029189271796889051337319684864955538153251303189966833836154162164567900872970453429288539133041367890171008836795913517330771190785803335503325077531875998504871797778970060395645092153758927752656733540240331694417992939346109926262579646476518686594497102165589843608814726932495910794738736733785233268774997627277579468536769185419814676687429987673820969139012177220244052081510942649349513745416672789553444707777758478025963407690748474155579104200675015203410705335285129792635242062267537568055761955669720848843854407983324292851368070827522662579751188646464096737461572387236295562053612203024635409252678424224347036310363201466298040249015578724456176000319551987905969942029178866949174808096746523682654086938399069873211752166957063859411814553647364268782462926166650100098903804823359519893146150108288726392887669917149304053057745574321561167298985617729731395370735291966884327898022165047585028091806291002444277017460241040417786069190065037142834500
</code></pre>
<p>(Here again, the last 4 digits don't converge.)</p>
<p>We're not quite done yet. If we combine adjacent terms, we end up with the following:</p>
<p><img src="https://chart.googleapis.com/chart?cht=tx&amp;chl=f%3D3%2B%5Cfrac%7B2%7D%7B1%5Ccdot+2%5Ccdot+3%7D%2B%5Cfrac%7B2%7D%7B2%5Ccdot+5%5Ccdot+8%7D%2B%5Cfrac%7B2%7D%7B5%5Ccdot+13%5Ccdot+21%7D%2B%5Cfrac%7B2%7D%7B13%5Ccdot+34%5Ccdot+55%7D%2B%5Cfrac%7B2%7D%7B34%5Ccdot+89%5Ccdot+144%7D%2B%5Cdots%2B%5Cfrac%7B2%7D%7BF_n%5Ccdot+F_%7Bn%2B2%7D%5Ccdot+F_%7Bn%2B3%7D%7D%2B%5Cdots" alt="" /></p>
<p>Factoring out each term from the remainder of the summation gives the nested expression:</p>
<p><img src="https://chart.googleapis.com/chart?cht=tx&amp;chl=f%3D3%2B%5Cfrac%7B2%7D%7B2%5Ccdot+3%7D%281%2B%5Cfrac%7B3%7D%7B5%5Ccdot+8%7D%281%2B%5Cfrac%7B2%5Ccdot+8%7D%7B13%5Ccdot+21%7D%281%2B%5Cfrac%7B5%5Ccdot+21%7D%7B34%5Ccdot+55%7D%281%2B%5Cfrac%7B13%5Ccdot+55%7D%7B89%5Ccdot+144%7D%28%5Cdots%2B%5Cfrac%7BF_%7B2n%7DF_%7B2n%2B3%7D%7D%7BF_%7B2n%2B4%7DF_%7B2n%2B5%7D%7D%28%5Cdots%29%29%29%29%29%29" alt="" /></p>
<p>Now we're getting somewhere. Notice that the numerators of follow <a href="http://oeis.org/A206351" rel="nofollow noreferrer">OEIS A206351</a> (with the exception of the first term, which is doubled):</p>
<p><img src="https://chart.googleapis.com/chart?cht=tx&amp;chl=b%3D%5B2%2C%5C+3%2C%5C+16%2C%5C+105%2C%5C+715%2C%5C+4896%2C%5C+%5Cldots%5D" alt="" /></p>
<p>and the denominators follow <a href="http://oeis.org/A081016" rel="nofollow noreferrer">OEIS A081016</a> (shifted by one term):</p>
<p><img src="https://chart.googleapis.com/chart?cht=tx&amp;chl=c%3D%5B6%2C%5C+40%2C%5C+273%2C%5C+1870%2C%5C+12816%2C%5C+%5Cldots%5D" alt="" /></p>
<p>Each of these have very simple recurrence relations, namely:</p>
<p><img src="https://chart.googleapis.com/chart?cht=tx&amp;chl=b_n%3D7b_%7Bn-1%7D-b_%7Bn-2%7D-4%5Cqquad+where%5Cqquad+b_0%3D1%2C%5C+b_1%3D3" alt="" /></p>
<p>and</p>
<p><img src="https://chart.googleapis.com/chart?cht=tx&amp;chl=c_n%3D7c_%7Bn-1%7D-c_%7Bn-2%7D-1%5Cqquad+where%5Cqquad+c_0%3D1%2C%5C+c_1%3D6" alt="" /></p>
<p>respectively. Putting it all together, we find that we need only <em>800</em> iterations for <em>1000</em> digits:</p>
<pre><code>b,c=[16,3,1],[273,40,3]
for i in range(800):b,c=[7*b[0]-b[1]-4]+b,[7*c[0]-c[1]-1]+c
s=z=10**1000
for x,y in zip(b,c):s=(z+s)*x/y
print s
</code></pre>
<p>which outputs:</p>
<pre><code>3598856662431775531720113029189271796889051337319684864955538153251303189966833836154162164567900872970453429288539133041367890171008836795913517330771190785803335503325077531875998504871797778970060395645092153758927752656733540240331694417992939346109926262579646476518686594497102165589843608814726932495910794738736733785233268774997627277579468536769185419814676687429987673820969139012177220244052081510942649349513745416672789553444707777758478025963407690748474155579104200675015203410705335285129792635242062267537568055761955669720848843854407983324292851368070827522662579751188646464096737461572387236295562053612203024635409252678424224347036310363201466298040249015578724456176000319551987905969942029178866949174808096746523682654086938399069873211752166957063859411814553647364268782462926166650100098903804823359519893146150108288726392887669917149304053057745574321561167298985617729731395370735291966884327898022165047585028091806291002444277017460241040417786069190065037142835294
</code></pre>
<p>(Here, finally, the last 4 digits converge correctly.)</p>
<p>But that's still not quite everything. If we observe the intermediate values for <em>s</em>, we find that it converges to a different value entirely before converging on the actual convergence point. The reason for this is the following:</p>
<p><img src="https://chart.googleapis.com/chart?cht=tx&amp;chl=%5Clim_%7Bn%5Cto%5Cinfty%7D%5Cfrac%7BF_%7B2n%7DF_%7B2n%2B3%7D%7D%7BF_%7B2n%2B4%7DF_%7B2n%2B5%7D%7D%3D%5Cfrac%7B1%7D%7B%5Cvarphi%5E6%7D" alt="" /></p>
<p>Solving for a stable <em>s</em>, we find that:</p>
<p><img src="https://chart.googleapis.com/chart?cht=tx&amp;chl=s%3D%5Cfrac%7B1%7D%7B4%7D%28%5Csqrt%7B5%7D-2%29" alt="" /></p>
<p>Because this is a simple root, we can use <a href="http://mathworld.wolfram.com/NewtonsMethod.html" rel="nofollow noreferrer">Newton's Method</a> to get us most of the way there, and then jump in at a much later point in the iteration. Only about <em>400</em> digits of precision are necessary (as the <em>b</em> and <em>c</em> values aren't any larger than that anyway), which can be achieved with just <em>7</em> iterations, while saving <em>320</em> iterations of the main loop:</p>
<pre><code>b,c=[16,3,1],[273,40,3]
for i in range(480):b,c=[7*b[0]-b[1]-4]+b,[7*c[0]-c[1]-1]+c
z=10**1000;s=z/17
for i in range(7):s-=(s*s+s*z-z*z/16)/(2*s+z)
for x,y in zip(b,c):s=(z+s)*x/y
print s
</code></pre>
<p>Output is identical to the previous, runtime is about 0.02s on my system using PyPy v2.1. Even though it needs one tenth the number of iterations as the original, it's significantly faster than 10x due to multiplying and dividing by much smaller terms. I don't think much more can be tweaked out of it, although I'd be happy to be shown wrong.</p>
</div>
<div id="pu13" class="pu"><h1>K, 22</h1>

<p>...</p>

<pre><code>{+/%x#x{x,+/-2#x}/1 1}
</code></pre>
</div>
<div id="pu14" class="pu"><h2>Forth, 64</h2>

<pre><code>: r 1 1 rot 1e 0 do 2dup - nip tuck + dup s&gt;f 1/f f+ swap loop ;
</code></pre>

<p>usage:</p>

<pre><code>10 r f. 3.34170499581934  ok
100 r f. 3.35988566624318  ok
1000 r f. 3.35988566624318  ok
</code></pre>
</div>
<div id="pu15" class="pu"><h1>Javascript, 33</h1>

<p><em>Input:</em> <code>n = 10</code></p>

<pre><code>s=f=t=1;for(;n--;)t+=1/(s+=f=s-f)
</code></pre>

<p>Based in my first post in Perl, here is the result directly from the <em>Google Chrome Console</em>.</p>

<p><img src="https://i.stack.imgur.com/OOZIq.png" alt="enter image description here"></p>
</div>
<div id="pu16" class="pu"><h1>PERL, <s>62</s> 43</h1>

<p><s></p>

<pre><code>$s=$t=1;$t+=1/($a=$f+$s),$f=$s,$s=$a,for 0..&lt;&gt;;say $t
</code></pre>

<p></s></p>

<p><strong>Edit:</strong></p>

<p>After some more time looking at my code I was able to save 19 chars:</p>

<pre><code>$s=1;$t+=1/($s+=$f=$s-$f)for 0..&lt;&gt;;say $t+2
</code></pre>

<blockquote>
  <p>input: 10<br>
  > 3.35294128575734</p>
</blockquote>
</div>
<div id="pu17" class="pu"><h1>BC - 116</h1>
<pre><code>define f(n){if(n &lt; 2){return n;}else{return f(n-1)+f(n-2);}}
define r(n){for(i=1;i&lt;n;++i){m=m+(1/f(i));};return m;}
</code></pre>
<p>call r(n) with n to solve. The precision can be set arbitrarily, so this is the most accurate solution.</p>
</div>
<div id="pu18" class="pu"><h1>Mathematica (32 characters without built-in Fibonacci)</h1>
<pre><code>Tr[1/⌈(.5+√5/2)^Range@#/√5-.5⌉]&amp;
</code></pre>
<p><img src="https://i.stack.imgur.com/yWv3U.png" alt="enter image description here" /></p>
<p>Here I used the rounding formula for Fibonacci numbers</p>
<p><img src="https://i.stack.imgur.com/lHbH6.png" alt="enter image description here" /></p>
<p>where <code>φ</code> is the golden ratio.</p>
</div>
<div id="pu19" class="pu"><h2><a href="http://timtechsoftware.com/?page_id=1309" rel="nofollow" title="GTB">GTB</a>, 35</h2>

<p><em>Runs on a TI-84 calculator</em></p>

<pre><code>1→Y:0→X`N4;N,1,N~1/X:Y→Z:X+Y→Y:Z→X&amp;
</code></pre>

<ul>
<li>Store <code>1</code> in <code>Y</code> and <code>0</code> in <code>X</code></li>
<li>Take <code>N</code> as input</li>
<li>Initialize a <code>For</code> loop</li>
<li>Display <code>X</code></li>
<li>Store <code>Y</code> in <code>Z</code> and <code>X+Y</code> in <code>Y</code></li>
<li>Store <code>Z</code> in <code>X</code></li>
<li>End the <code>For</code> loop</li>
</ul>
</div>
<div id="pu20" class="pu"><h1>Mathematica <s>30</s>  24</h1>
<p>With 6 characters saved thanks to ybeltukov.</p>
<pre><code> Tr[1/Fibonacci@Range@#]&amp;
</code></pre>
<hr />
<p>Before adding the terms:</p>
<pre><code>1/Fibonacci@Range@#&amp;[20]
</code></pre>
<p><img src="https://i.stack.imgur.com/4hwt3.png" alt="image1" /></p>
<hr />
<p>With addition included:</p>
<pre><code> Tr[1/Fibonacci@Range@#]&amp;[20]
</code></pre>
<p><img src="https://i.stack.imgur.com/XWsgt.png" alt="image2" /></p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/18129/">18129</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




