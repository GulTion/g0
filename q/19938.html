<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::19938</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>nan</td><td></td><td>140206T132510Z</td><td><a href="https://codegolf.stackexchange.com/questions/19938/down-the-drain-it-goes/20208#20208">Timwi</a></td></tr>
<tr d-ix="1"><td>nan</td><td></td><td>140203T173148Z</td><td><a href="https://codegolf.stackexchange.com/questions/19938/down-the-drain-it-goes/19944#19944">DavidC</a></td></tr>
<tr d-ix="2"><td>311</td><td>Groovy</td><td>140204T210648Z</td><td><a href="https://codegolf.stackexchange.com/questions/19938/down-the-drain-it-goes/20036#20036">krs</a></td></tr>
<tr d-ix="3"><td>nan</td><td></td><td>140205T004935Z</td><td><a href="https://codegolf.stackexchange.com/questions/19938/down-the-drain-it-goes/20060#20060">MT0</a></td></tr>
<tr d-ix="4"><td>nan</td><td></td><td>140204T045521Z</td><td><a href="https://codegolf.stackexchange.com/questions/19938/down-the-drain-it-goes/19976#19976">Hand-E-F</a></td></tr>
<tr d-ix="5"><td>nan</td><td></td><td>140203T211125Z</td><td><a href="https://codegolf.stackexchange.com/questions/19938/down-the-drain-it-goes/19959#19959">jimbobmc</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="http://esolangs.org/wiki/Funciton" rel="nofollow noreferrer">Funciton</a></h1>
<p>As if Funciton wasn’t already among the most pointless languages in the world, this is certainly the most useless program I’ve written in it so far.</p>
<p>Since Funciton doesn’t have a random number generator, I decided to let you enter the pipe pattern. Since the pattern encoding is unobvious, banging the digit keys on your keyboard randomly is as good as a random number generator.</p>
<p>The input is expected to be three decimal numbers separated by spaces. The first number is the width (one less than the number of vertical pipes); the second is the index of the starting pipe, and the last is any number that encodes the horizontal pipe pattern; you can make it as large as you want. If the width is negative or the pipe index is out of range, the output is <code>Impossiburu.</code></p>
<p>The program automatically ensures that there are never two horizontal pipes next to each other, which could cause ambiguous turns.</p>
<pre><code>                            ┌───╖
               ┌────────────┤ ♯ ╟───────────┬───────────────┐
     ╔════╗  ┌─┴─╖  ┌────╖  ╘═══╝  ╔═══╗  ┌─┴─╖  ╔════╗     │
     ║ 21 ║  │ × ╟──┤ &gt;&gt; ╟─────────╢   ╟──┤ ʘ ╟──╢ 32 ║     │
     ╚═╤══╝  ╘═╤═╝  ╘═╤══╝         ╚═══╝  ╘═══╝  ╚════╝     │
       └───────┘  ┌───┴───┐                                 │
   ╔════╗  ┌───╖  │   ┌───┴──────────────────┐              │
   ║ 32 ╟──┤ ʘ ╟──┘   │          ╔═══╗       │              │
   ╚════╝  ╘═╤═╝    ┌─┴─╖        ║ 0 ╟───┐   │              │
     ┌───────┴──────┤ · ╟────┐   ╚═══╝ ┌─┴─╖ │              │
     │              ╘═╤═╝    └─────────┤ ʃ ╟─┘              │
     │     ┌──────────┘                ╘═╤═╝                │
   ┌─┴─╖ ┌─┴──╖  ┌─────────╖        ┌────┴────╖             │
   │ ♯ ║ │ &gt;&gt; ╟──┤ str→int ╟────┐   │ str→int ║             │
   ╘═╤═╝ ╘═╤══╝  ╘═════════╝  ┌─┴─╖ ╘════╤════╝           ┌─┴─╖
     │   ┌─┴─╖ ╔════╗         │ ░ ║   ┌──┴────────────────┤ · ╟────────────┐
     └───┤ × ╟─╢ 21 ║         ╘═╤═╝ ┌─┴─╖                 ╘═╤═╝            │
         ╘═══╝ ╚════╝┌─────┐    └───┤ ▒ ╟───┐ ┌─────────╖ ┌─┴─╖            │
      ┌─────────╖  ┌─┴─╖   │        ╘═╤═╝   ├─┤ str→int ╟─┤ ʃ ╟─┐          │
   ┌──┤ int→str ╟──┤ · ╟─┐ └──────────┘     │ ╘═════════╝ ╘═╤═╝ │          │
   │  ╘═════════╝  ╘═╤═╝ │ ╔══════════════╗ │ ╔═══╗  ┌──────┘   │          │
   │ ╔══════════╗  ┌─┴─╖ │ ║ 158740358500 ║ │ ║   ╟──┘ ┌───╖  ╔═╧═╗  ┌───╖ │
   │ ║ 20971533 ╟──┤   ╟─┘ ║ 305622435610 ║ │ ╚═══╝  ┌─┤ ≤ ╟──╢ 0 ╟──┤ ≥ ╟─┴─┐
   │ ╚════╤═════╝  └─┬─╜   ║ 491689778976 ║ └────────┤ ╘═╤═╝  ╚═══╝  ╘═╤═╝   │
   │    ┌─┴─╖  ┌───╖ │     ║ 886507240727 ║          │   └──────┬──────┘     │
   │    │ ‼ ╟──┤ ‼ ╟─┘     ║ 896192890374 ║          │         ┌┴┐           │
   │    ╘═╤═╝  ╘═╤═╝       ║ 899130957897 ╟───┐      │         └┬┘           │
   └──────┘    ┌─┴─╖       ╚══════════════╝ ┌─┴─╖  ┌─┴─╖        │            │
               │ ‼ ╟────────────────────────┤ ? ╟──┤ · ╟────────┤            │
               ╘═╤═╝                        ╘═╤═╝  ╘═╤═╝      ┌─┴─╖          │
 ╔═══════════════╧════════════════════════╗   │      └────────┤ ≥ ╟──────────┘
 ║ 83139057126481738391428729850811584337 ║       ┌────╖      ╘═══╝
 ║ 75842912478026089564602018574355013746 ║  ┌────┤ &gt;&gt; ╟──┐
 ║ 85373033606532129933858395805642598753 ║  │    ╘══╤═╝  │
 ║ 19381927245726769973108298347355345088 ║  │     ┌─┴─╖  │       ╓───╖
 ║ 84932603219463911206052446527634696060 ║  │     │ ░ ║  │       ║ ░ ║
 ║ 230797436494578049782495796264992      ║  │     ╘═╤═╝  │       ╙─┬─╜
 ╚════════════════════════════════════════╝  │    ┌──┴──┐ └─────────┴────────┐
                                             │    │   ┌─┴──╖ ┌┐   ┌┐         │
                                             │    │   │ &lt;&lt; ╟─┤├─┬─┤├─────┐   │
   ┌────╖  ╔═══╗                             │    │   ╘═╤══╝ └┘ │ └┘   ╔═╧═╗ │
 ┌─┤ &lt;&lt; ╟──╢ 1 ║                             │    │   ╔═╧═╗     │      ║ 1 ║ │
 │ ╘═╤══╝  ╚═══╝      ┌───────────────────┐  │    │   ║ 2 ║     │      ╚═╤═╝ │
 │   └─────┬──────────┴─────────┐         │  │ ┌──┴─╖ ╚═══╝   ┌─┴─╖ ┌┐   │   │
 │         │           ┌───┐  ┌─┴─╖       │  │ │ &lt;&lt; ╟─────────┤ ? ╟─┤├───┤   │
 │         │           │   ├──┤ · ╟─┐     │  │ ╘══╤═╝         ╘═╤═╝ └┘   ├───┘
 │ ┌───┐ ┌─┴─╖ ┌───╖   └─┬─┘  ╘═╤═╝ ├───┐ │  │  ╔═╧═╗  ╔═══╗  ┌─┴─╖      │
 ├─┤   ├─┤ · ╟─┤ ♯ ╟─────┘    ┌─┴─╖ │   │ │  └──╢ 1 ║  ║ 0 ╟──┤ ? ╟──────┘
 │ └───┘ ╘═╤═╝ ╘═══╝  ┌───────┤ · ╟─┴─┐ │ │     ╚═══╝  ╚═══╝  ╘═╤═╝
 │       ┌─┴─╖      ┌─┴─╖     ╘═╤═╝   │ │ └─────────────────┐   │
 │  ┌────┤ · ╟──────┤ · ╟──┐    │     │ └────────┐          │
 │  │    ╘═╤═╝      ╘═╤═╝  │    │     └────┐     │          │
 │  └───┬──┴──┐       │    │    │        ┌─┴──╖  │          │
 │      │    ┌┴┐      │    │    └─────┬──┤ &lt;&lt; ║  │          │
 │      │    └┬┘      │    │         ┌┴┐ ╘═╤══╝  │          │
 │    ┌─┴─╖ ┌─┴─╖   ┌─┴─╖  │         └┬┘ ╔═╧═╗   │          │
 └────┤ · ╟─┤ ? ╟─┐ │ ♯ ║  ├──────────┤  ║ 1 ║   │          │
      ╘═╤═╝ ╘═╤═╝ │ ╘═╤═╝ ┌┴┐         │  ╚═══╝   │          │
        │     │   │ ┌─┴─╖ └┬┘         │          │          │
        │     │   └─┤ ? ╟──┘        ┌─┴─╖        │          │
        │     │     ╘═╤═╝     ┌─────┤ &gt; ╟─────┬──┘          │
        │     │     ┌─┴─╖   ┌─┴─╖   ╘═══╝     ├─────────┐   │
      ┌─┴─╖   └─────┤ · ╟───┤ · ╟─────────────┘         │   │
    ┌─┤ · ╟─────┐   ╘═╤═╝   ╘═╤═╝                       │   │
    │ ╘═╤═╝  ┌──┴─╖ ┌─┴─╖     │                         │   │
    │   │    │ &gt;&gt; ╟─┤ ▒ ╟──┐  ├─────────────┐         ┌─┴─╖ │
    │   │    ╘══╤═╝ ╘═╤═╝  ├──┘             │ ╓───╖ ┌─┤ · ╟─┤
    │   │       │   ┌─┴─╖  │                ├─╢ ▒ ╟─┤ ╘═╤═╝ │
    │   │       └───┤ · ╟──┘                │ ╙─┬─╜ │   │   │
    │   │           ╘═╤═╝                   │   │ ┌─┴─╖ │   │
    │   │           ┌─┴─╖                   │   └─┤ · ╟─┤   │
    │   │        ┌──┤   ╟────────────┐      │     ╘═╤═╝ │   │
    │   │        │  └─┬─╜  ┌───╖   ┌─┴─╖  ┌─┴─╖   ┌─┴─╖ │   │
    │   └──────┐ │    └────┤ ‼ ╟───┤ · ╟──┤ · ╟───┤ ▓ ╟─┘   │
    │          │ │         ╘═╤═╝   ╘═╤═╝  ╘═╤═╝   ╘═╤═╝     │
    │          │ │  ╔═══╗  ┌─┴─╖     │      └───────┘       │
    │          │ └──╢ 0 ╟──┤ ? ╟─┐   │                      │
    │          │    ╚═══╝  ╘═╤═╝ │ ┌─┴─╖                    │
    │ ╔═══╗    │           ┌─┴─╖ ├─┤ · ╟─┐                  │
    │ ║ 2 ║    │      ┌────┤ · ╟─┘ ╘═╤═╝ ├──────────────────┘
    │ ╚═╤═╝    │      │    ╘═╤═╝     │   │
    │ ┌─┴─╖  ┌─┴─╖  ┌─┴─╖  ╔═╧═╕ ┌─┐ │   │
    │ │ + ╟──┤ ? ╟──┤ ? ╟──╢   ├─┴─┘ │   │
    │ ╘═╤═╝  ╘═╤═╝  ╘═╤═╝  ╚═╤═╛     │   │
    │   └──┬───┘    ╔═╧═╗    │       │   │
    │      │        ║ 0 ║            │   │
    │      │        ╚═══╝            │   │
    │      └─────────────────────────┘   │
    └────────────────────────────────────┘        ╓┬──╖
 ┌────────────────────────────────────────────────╫┘▓ ╟────────────┐
 │ ╔═══════════╗        ╔════════════════════╗    ╙─┬─╜            │
 │ ║ 387759291 ║        ║ 385690484238253342 ║      │              │
 │ ║ 565251600 ║    ┌───╢ 839653020379129116 ║      │    ┌────┐    │
 │ ║ 199735775 ║  ┌─┴─╖ ╚════════════════════╝      │    │   ┌┴┐   │
 │ ║ 904933210 ╟──┤ ? ╟────────────────┐            │    │   └┬┘   │
 │ ╚═══════════╝  ╘═╤═╝    ┌──────┐    ├────────────┴────┘  ┌─┴─╖  │
 │ ╔═══════════╗  ┌─┴─╖  ┌─┴─╖  ╔═╧═╗  │  ╔════╗    ╔═══╗   │ ♯ ║  │
 │ ║ 388002680 ╟──┤ ? ╟──┤ ≠ ║  ║ 1 ║  │  ║ 21 ║  ┌─╢ 1 ║   ╘═╤═╝  │
 │ ║ 480495420 ║  ╘═╤═╝  ╘═╤═╝  ╚═══╝  │  ╚═╤══╝  │ ╚═══╝    ┌┴┐   │
 │ ║ 244823142 ║    │      ├───────────┘    │     │          └┬┘   │
 │ ║ 920365396 ║    │    ┌─┴─╖  ┌───╖     ┌─┴──╖  │ ┌────╖  ┌─┴─╖  │
 │ ╚═══════════╝    └────┤ · ╟──┤ ‡ ╟─────┤ &gt;&gt; ║  └─┤ &gt;&gt; ╟──┤ · ╟──┴─┐
 │ ╔═══════════╗ ┌───┐   ╘═╤═╝  ╘═╤═╝     ╘═╤══╝    ╘═╤══╝  ╘═╤═╝    │
 │ ║ 618970314 ╟─┘ ┌─┴─╖ ┌─┘      │         │       ┌─┴─╖     │      │
 │ ║ 790736054 ║ ┌─┤ ? ╟─┴─┐      │         ├───────┤ ▓ ╟─────┘      │
 │ ║ 357861634 ║ │ ╘═╤═╝   │      │     ┌───┘       ╘═╤═╝            │
 │ ╚═══════════╝ │ ┌─┴─╖ ┌─┴─╖  ┌─┴─╖ ┌─┴─╖         ┌─┴─╖     ╔═══╗  │
 │ ╔═══════════╗ │ │ ‼ ╟─┤ · ╟──┤ ? ╟─┤ · ╟─────────┤ · ╟──┐  ║ 1 ║  │
 │ ║ 618970314 ╟─┘ ╘═╤═╝ ╘═╤═╝  ╘═╤═╝ ╘═╤═╝         ╘═╤═╝  │  ╚═╤═╝  │
 │ ║ 790736054 ║     │   ┌─┴─╖  ┌─┴─╖   │   ╓┬──╖    ┌┴┐  ┌┴┐   │    │
 │ ║ 357861713 ║     └───┤ · ╟──┤ · ╟───┘ ┌─╫┘‡ ╟─┐  └┬┘  └┬┘   │    │
 │ ╚═══════════╝         ╘═╤═╝  ╘═╤═╝     │ ╙───╜ │ ┌─┴─╖  └────┤    │
 │ ╔════════════════╗    ┌─┴─╖  ┌─┴─╖     │ ┌───╖ │ │ ♯ ║       └────┘
 │ ║ 43980492383490 ╟────┤ ? ╟──┤ ? ╟───┐ └─┤ ‼ ╟─┘ ╘═╤═╝
 │ ╚════════════════╝    ╘═╤═╝  ╘═╤═╝   │   ╘═╤═╝    ┌┴┐
 │ ╔════════════════╗      │      │     │     │      └┬┘
 │ ║ 43980492383569 ╟──────┘            └──────┬──────┘
 │ ╚════════════════╝                          │
 └─────────────────────────────────────────────┘
</code></pre>
<h2>Explanation</h2>
<ul>
<li><p>The main program finds the first two spaces and splits out the numbers. It runs the third (the pipe pattern) through <code>░</code> and then calls <code>▒</code> with the result, which returns the output as well as the number of turns taken. It then adds the text <code>n turns were taken to get to the end.</code>, where <code>n</code> is the number of turns calculated by <code>▒</code>.</p>
</li>
<li><p><code>░</code> takes a number and inserts a <code>0</code>-bit after every <code>1</code>-bit, thus ensuring there are never two horizontal pipes in succession.</p>
</li>
<li><p><code>▒</code> generates the output by successively calling <code>▓</code> and then shifting out the right number of bits from the pipe pattern until it is zero. It also increments or decrements the “current pipe” appropriately.</p>
</li>
<li><p><code>▓</code> generates one line of the output. In each iteration, it shifts out one bit from the pipe pattern and then decides whether to output <code>│</code> (+ 4 spaces), <code>║</code> (+ 4 spaces), <code>├────┤</code>, <code>╔════╝</code> or <code>╚════╗</code>; in the latter three cases, it removes the first character from the next iteration. The last iteration generates <code>│\r\n</code> or <code>║\r\n</code> as appropriate.</p>
</li>
</ul>
<h2>Example output</h2>
<p>Input:</p>
<blockquote>
<p><code>6 3 73497529294753</code></p>
</blockquote>
<p>Output:</p>
<pre><code>├────┤    │    ║    │    │    │
├────┤    │    ╚════╗    ├────┤
│    ├────┤    ╔════╝    ├────┤
│    ├────┤    ║    │    │    │
│    │    │    ║    │    ├────┤
│    │    │    ║    ├────┤    │
│    ├────┤    ╚════╗    ├────┤
│    ├────┤    │    ║    │    │
│    ├────┤    ╔════╝    │    │
├────┤    ╔════╝    │    ├────┤
│    │    ║    │    │    ├────┤

10 turns were taken to get to the end.
</code></pre>
<p>Input:</p>
<blockquote>
<p><code>3 0 65536</code></p>
</blockquote>
<p>Output:</p>
<pre><code>║    │    │    │
║    │    │    │
║    │    ├────┤

0 turns were taken to get to the end.
</code></pre>
<p>Input:</p>
<blockquote>
<p><code>3 7 75203587360867</code> (pipe index out of range)</p>
</blockquote>
<p>Output:</p>
<pre><code>Impossiburu.
</code></pre>
</div>
<div id="pu1" class="pu"><h1>Mathematica</h1>
<p>The 2D code generates a graph showing the path of the water. I displayed the vertex numbers for convenient cross-checking with the 3D display.  Normally the vertex numbers would be hidden.</p>
<p>Input:</p>
<pre><code>r=10;c=7;
result=flow2D[{r,c},3]
</code></pre>
<p>Actually, the result contains multiple objects. The first object, <code>result[[1]]</code>, is the 2D graph shown here.</p>
<p><img src="https://i.sstatic.net/MT1jd.png" alt="2D" /></p>
<hr />
<p>The 3 dimensional pipes are <code>Tube</code>'s  (3D lines) plotted in 3 space.  The coordinates computed based on the vertices of the 2D graph along a 3rd coordinate that was randomly generated (This allows the pipes to assume different positions along y each time the code is run.)</p>
<p>The axes are displayed to help the reader convince herself that the 3D rendering is indeed based on the 2D rendering.</p>
<p>The 3D input of interest here is:</p>
<pre><code>Graphics3D[{CapForm[None],verticalPipes,allRungs,Darker@Red,connections},
ImageSize-&gt;600,Axes-&gt; True,Ticks-&gt;{Range[1,2 r,2],Range[c],Range[10]},ViewPoint-&gt;{0,-2,1.5}]
</code></pre>
<p>The number or rows, columns and entry column are taken from the 2D code.  They do not have to be re-entered.</p>
<p><img src="https://i.sstatic.net/Km7lU.png" alt="3D" /></p>
<h2>2D Code</h2>
<p>In the coming days I will document and tidy up the code for 2D and 3D.</p>
<pre><code>flow2D[{rows_,columns_},startColumn_]:=
Module[{r=rows,c=columns,g,j,h,ends,middle,midcuts,direction=&quot;down&quot;,turns=0,path,rungs},

   (*complete gridgraph*)
g=GridGraph[{r,c},VertexSize-&gt; Medium,GraphStyle-&gt;&quot;Prototype&quot;,EdgeStyle-&gt;&quot;Thick&quot;,
  VertexLabels-&gt;&quot;Name&quot;,ImagePadding-&gt; 30,ImageSize-&gt;470];

(*horizontal pipes that must be removed*)
ends=Table[r(c1-1)+r1\[UndirectedEdge] r(c1)+r1,{c1,1,c-1},{r1,{1,r}}];

(*horizontal pipes to consider removing *)
middle=Table[r(c1-1)+r1\[UndirectedEdge] r(c1)+r1,{c1,1,c-1},{r1,2,r-1}];
midcuts=RandomSample[#,RandomInteger[Round[{r/15,2r/5}]]]&amp;/@middle;

rungs=Flatten[midcuts(*Join[ends,midcuts]*)];

j=EdgeDelete[g,Flatten[Join[ends,midcuts]]];

h[path_]:= Module[{start=path[[-1]],right,left,up,down,newnodes}, 
     {v=NeighborhoodGraph[j,start,1,(*VertexLabels\[Rule]&quot;Name&quot;,*)ImagePadding-&gt;25],
     VertexList[v]};newnodes=Complement[VertexList[v],path];
     If[newnodes=={},path,  
     h[Append[path,
  Switch[direction,
   &quot;down&quot;,Which[
     MemberQ[newnodes,start+r],(turns++;direction=&quot;right&quot;;start+r),
     MemberQ[newnodes,start-r],(turns++;direction=&quot;left&quot;;start-r),
     MemberQ[newnodes,start-1],start-1],
   &quot;right&quot;,Which[
     MemberQ[newnodes,start-1],(turns++;direction=&quot;down&quot;;start-1),
     MemberQ[newnodes,start+r],start+r],  
   &quot;left&quot;,Which[
     MemberQ[newnodes,start-1],(turns++;direction=&quot;down&quot;;start-1),
     MemberQ[newnodes,start-r],start-r]
    ]]]]];
{HighlightGraph[j,path=h[{r*startColumn}],ImageSize-&gt;300],path,rungs,ends,midcuts}]

convert[node_,r_,c_]:=Append[footing[[Quotient[node-1,r]+1]],Mod[node-1,r]+1(*Mod[node,r]*)]
connect[a_\[UndirectedEdge]b_,r_,c_]:=Tube[Line[{convert[a,r,c],convert[b,r,c]}],0.2]
</code></pre>
<h1>3D Code and results</h1>
<pre><code>r=10;c=7;
result=flow2D[{r,c},3];
g2D=result[[1]];
path2D=result[[2]];
\[AliasDelimiter]
xScale=2;
footing = {#, RandomInteger[{1, 6}]} &amp; /@ Range[1,xScale c, xScale];
verticalPipes=Tube[Line[{Append[#,1],Append[#,r]}],.19]&amp;/@footing;
Graphics3D[{CapForm[None],verticalPipes},ImageSize-&gt;600,Axes-&gt;True,AxesEdge-&gt;Automatic,ViewPoint-&gt;{0,-2,1.5},
Ticks-&gt;{Range[1,2 r,2],Range[c],Range[10]}];

path3D=UndirectedEdge@@@Partition[Riffle[stops=path2D,Rest@stops],2];
allRungs=connect[#,r,c]&amp;/@rungs;
connections=connect[#,r,c]&amp;/@path3D;

path2D;
g2D
Graphics3D[{CapForm[None],verticalPipes,allRungs,Darker@Red,connections},
ImageSize-&gt;600,Axes-&gt; True,Ticks-&gt;{Range[1,2 r,2],Range[c],Range[10]},ViewPoint-&gt;{0,-2,1.5}]
</code></pre>
</div>
<div id="pu2" class="pu"><h1>Groovy, 311</h1>

<pre><code>t=System.in.text.collect{it.collect{it}};s=t.size();d=0;c=0;y=0;x=t[0].indexOf('|');println' '*x+'V'
while(y&lt;s){t[y][x]=t[y][x]=='|'?':':'='
if(d){x+=d}else y++
if(y&lt;s)if(d){if(t[y][x]=='|'){d=0;c++}}else if(t[y][x+1]=='-'){d=1;c++} else if(t[y][x-1]=='-'){d=-1;c++}}
t.each{println it.join()}println' '*x+'^'+c
</code></pre>

<ul>
<li>line 1: setup and find first |</li>
<li>line 2: swap out replacement : or =</li>
<li>line 3: move x/y to next pos (d=0=down,d=-1=left,d=1=right)</li>
<li>line 4: find next direction</li>
<li>line 5: print out results</li>
</ul>

<p>Here it is formatted:</p>

<pre><code>t=System.in.text.split('\n').collect{it.collect{it}}; s=t.size()
d=0; c=0; y=0; x=t[0].indexOf('|')
println ' '*x + 'V'
while (y&lt;s) { 
    t[y][x] = t[y][x] == '|' ? ':' : '='
    if (d) {x += d} else y++
    if (y&lt;s) 
        if (d) {if (t[y][x]=='|') {d = 0; c++}} 
        else if(t[y][x+1]=='-') {d = 1; c++}
        else if(t[y][x-1]=='-') {d = -1; c++}
}
t.each {println it.join()}
println ' '*x + '^'+c
</code></pre>

<p>Output from the sample:</p>

<pre><code>V
:       |       |-------|  
:=======:       |-------|  
|       :=======:       |  
|-------|-------:=======:  
|       |-------|       :  
|-------|       :=======:  
|-------|       :=======:  
|       |-------|       :
                        ^10
</code></pre>

<p>Other output:</p>

<pre><code>V
:       |       |-------|       |
:=======:       |-------|       |
|       :=======:       |-------|  
|-------|-------:=======:       |
|       |-------|       :=======:
|-------|       |-------|       :
|-------|       |-------|       :
|       |-------|       :=======:
|       |-------|       :       |
|       |       :=======:       |
|-------|       :       |       |
|       :=======:       |       |
|       :       |-------|       |
|       :=======:       |       |
                ^16
</code></pre>

<p>(I know I did code-golf instead of popularity, but that's just my style)</p>
</div>
<div id="pu3" class="pu"><p><strong>JavaScript</strong></p>

<p>The HTML canvas listens for click events and finds the nearest row of pipes and uses that for the starting point. Output is drawn on the canvas and there is also a textarea containing the ASCII output defined by the OP.</p>

<p>The algorithm will ensure that there are never two connecting horizontal pipes. Other than that restriction, a probability is defined in the initial variables and that is used to randomly determine whether a horizontal pipe should occur or not.</p>

<p><a href="http://jsfiddle.net/pqx8S/1/" rel="nofollow noreferrer">JSFIDDLE</a></p>

<pre><code>&lt;html&gt;
&lt;head&gt;
&lt;script type="text/javascript"&gt;
var     WIDTH       = 20,
        HEIGHT      = 15,
        JUNCTIONS   = [],
        PROBABILITY = 0.2,
        COLOR1      = '#00DD00',
        COLOR2      = '#DD0000',
        RADIUS      = 4,
        SPACING     = 20,
        turns       = 0,
        pipe        = 10,
        canvas,
        context;

function Junction( x, y ){
    this.x = x;
    this.y = y;
    this.l = null;
    this.r = null;

    if ( y == 0 )
        JUNCTIONS[x] = [];

    JUNCTIONS[x][y] = this;

    var l = this.left();
    if ( x &gt; 0 &amp;&amp; l.l == null &amp;&amp; Math.random() &lt;= PROBABILITY )
    {
        this.l = l;
        l.r = this;
    }
}

Junction.prototype.left = function(){
    return this.x == 0?null:JUNCTIONS[this.x-1][this.y];
}
Junction.prototype.right= function(){
    return this.x == WIDTH-1?null:JUNCTIONS[this.x+1][this.y];
}
Junction.prototype.down = function(){
    return this.y == HEIGHT-1?null:JUNCTIONS[this.x][this.y+1];
}
Junction.prototype.reset = function(){
    this.entry = null;
    this.exit = null;
}

Junction.prototype.followPipe = function( prev ){
    this.entry = prev;
    if ( prev === this.l || prev === this.r ) {
        this.exit = this.down() || true;
        turns++;
    } else if ( this.l !== null ) {
        this.exit = this.l;
        turns++;
    } else if ( this.r !== null ) {
        this.exit = this.r;
        turns++;
    } else
        this.exit = this.down() || true;
    console.log( this.exit );
    if ( this.exit !== true )
        this.exit.followPipe( this );
}

Junction.prototype.toString = function(){
    if ( this.entry === null ){
        if ( this.r === null )  return '|  ';
                                        return '|--';
    } else {
        if ( this.r === null )  return ':  ';
                                        return ':==';
    }
}

function init(){
    for ( var x = 0; x &lt; WIDTH; ++x )
        for ( var y = 0; y &lt; HEIGHT; ++y )
            new Junction( x, y );

    canvas  = document.getElementById('canvas');
    context = canvas.getContext('2d');

    canvas.addEventListener('click', draw );

    draw();
}

function draw( evt ){
    for ( var x = 0; x &lt; WIDTH; ++x )
        for ( var y = 0; y &lt; HEIGHT; ++y )
            JUNCTIONS[x][y].reset();

    if ( evt ){ 
        pipe = Math.round((evt.clientX - canvas.getBoundingClientRect().left)/SPACING)-1;
        if ( pipe &lt; 0 )     pipe = 0;
        if ( pipe &gt;= WIDTH )    pipe = WIDTH - 1;
    }

    turns = 0;
    JUNCTIONS[pipe][0].followPipe( true );

    context.clearRect(0, 0, canvas.width, canvas.height);
    context.lineWidth = 2;

    for ( var y = 0; y &lt; HEIGHT; ++y ) {
        for ( var x = 0; x &lt; WIDTH; ++x ) {
            var j = JUNCTIONS[x][y];
                    e = j.entry;

            if ( j.r !== null ){
                context.beginPath();
                context.strokeStyle = e===null?COLOR1:COLOR2;
                context.moveTo(SPACING*(x+1), SPACING*(y+1));
                context.lineTo(SPACING*(x+2), SPACING*(y+1));
                context.stroke();
            }

            if ( y &gt; 0 ){
                context.beginPath();
                context.strokeStyle = (e===JUNCTIONS[x][y-1])?COLOR2:COLOR1;
                context.moveTo(SPACING*(x+1), SPACING*(y));
                context.lineTo(SPACING*(x+1), SPACING*(y+1));
                context.stroke();
            }
        }
    }

    for ( var y = 0; y &lt; HEIGHT; ++y ) {
        for ( var x = 0; x &lt; WIDTH; ++x ) {
            context.beginPath();
            context.arc(SPACING*(x+1), SPACING*(y+1), RADIUS, 0, 2*Math.PI, false);
            context.fillStyle = JUNCTIONS[x][y].entry===null?COLOR1:COLOR2;
            context.fill();
        }
    }

    var h = [];
    for ( var x = 0; x &lt; WIDTH; ++x )
        h.push( x!=pipe?'   ':'v  ' );
    h.push( '\n' );
    for ( var y = 0; y &lt; HEIGHT; ++y ) {
        for ( var x = 0; x &lt; WIDTH; ++x )
            h.push( JUNCTIONS[x][y].toString() )
        h.push( '\n' );
    }
    for ( var x = 0; x &lt; WIDTH; ++x )
        h.push( JUNCTIONS[x][HEIGHT-1].exit!==true?'   ':'^  ' );
    h.push( '\n' );
    h.push( turns + ' turns were taken to get to the end.' );
    document.getElementById( 'output' ).value = h.join( '' );
}

window.onload   = init;
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;p&gt;Click on a row to show the path&lt;/p&gt;
&lt;canvas id="canvas" width="450" height="350"&gt;&lt;/canvas&gt;
&lt;textarea id="output" style="width:100%; height:24em;"&gt;&lt;/textarea&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p><strong>Output</strong></p>

<p><img src="https://i.sstatic.net/OoUQV.png" alt="http://imageshack.com/a/img600/9241/94wh.png"></p>
</div>
<div id="pu4" class="pu"><h2>C#</h2>

<p>Fun times!  :-)</p>

<p>This code ensures there is at least some straight pipe at either end of each pipe.  It also ensures there are no ambiguous turns.</p>

<pre><code>using System;

namespace Experiment.DownTheDrain
{
    class Program
    {
        static void Main(string[] args)
        {
            var program = new Program();
            program.Width = 19;
            program.Height = 17;
            program.SpanCount = program.Width * program.Height / 4;
            program.Spacing = 3;
            program.Run();
        }

        public int Width { get; set; }
        public int Height { get; set; }
        public int SpanCount { get; set; }
        public int Spacing { get; set; }
        public bool[,] Spans { get; private set; }

        public void Run()
        {
            GenerateSpans();
            DrawPipes();
            var pipe = ReadStartPipe();
            var turns = DrawPath(pipe);
            WriteTurns(turns);
            Console.ReadLine();
        }

        private void GenerateSpans()
        {
            Random random = new Random();
            Spans = new bool[Width, Height];

            int x, y;
            for (int i = 0; i &lt; SpanCount; i++)
            {
                do
                {
                    x = random.Next(Width);
                    y = random.Next(Height);
                }
                while (SpanAt(x - 1, y) || SpanAt(x, y) || SpanAt(x + 1, y));
                Spans[x, y] = true;
            }
        }

        private void DrawPipes()
        {
            const string Junction = "│┤├┼";

            Console.CursorLeft = 0;
            Console.CursorTop = 0;
            DrawLabels();
            for (int y = -1; y &lt;= Height; y++)
            {
                for (int x = 0; x &lt;= Width; x++)
                {
                    Console.Write(Junction[(SpanAt(x-1,y) ? 1 : 0) + (SpanAt(x,y) ? 2 : 0)]);
                    Console.Write(x == Width ? Environment.NewLine : new string(SpanAt(x, y) ? '─' : ' ', Spacing));
                }
            }
            DrawLabels();
        }

        private void DrawLabels()
        {
            for (int x = 0; x &lt;= Width; x++)
                Console.Write("{0}{1}",
                    (char)(x + 65),
                    x == Width ? Environment.NewLine : new string(' ', Spacing)
                );
        }

        private int ReadStartPipe()
        {
            Console.WriteLine();
            Console.Write("Please select a start pipe: ");
            int pipe;
            do
            {
                var key = Console.ReadKey(true);
                pipe = (int)char.ToUpper(key.KeyChar) - 65;
            }
            while (pipe &lt; 0 || pipe &gt; Width);
            Console.WriteLine((char)(pipe + 65));
            return pipe;
        }

        private int DrawPath(int x)
        {
            int turns = 0;
            Console.CursorTop = 1;
            for (int y = -1; y &lt;= Height; y++)
            {
                if (SpanAt(x - 1, y))
                {
                    x--;
                    Console.CursorLeft = x * (Spacing + 1);
                    Console.WriteLine("╔{0}╝", new string('═', Spacing));
                    turns += 2;
                }
                else if (SpanAt(x, y))
                {
                    Console.CursorLeft = x * (Spacing + 1);
                    Console.WriteLine("╚{0}╗", new string('═', Spacing));
                    x++;
                    turns += 2;
                }
                else
                {
                    Console.CursorLeft = x * (Spacing + 1);
                    Console.WriteLine("║");
                }
            }

            return turns;
        }

        private void WriteTurns(int turns)
        {
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine("{0} turns taken to reach the bottom.", turns);
        }

        private bool SpanAt(int x, int y)
        {
            return x &gt;= 0
                &amp;&amp; x &lt; Width
                &amp;&amp; y &gt;= 0
                &amp;&amp; y &lt; Height
                &amp;&amp; Spans[x, y];
        }
    }
}
</code></pre>

<p>Output:</p>

<p><img src="https://i.sstatic.net/qoTUQ.png" alt="Down The Drain"></p>
</div>
<div id="pu5" class="pu"><h1>C#</h1>

<p><em>(via LINQPad, in "C# Program" mode; )</em></p>

<p>Going to have to apply Equitable Stroke Control, as far as any golfing might go, but this is my approach in C# <em>(well, LINQPad, but who wants all the boilerplate that goes into making a full C# app work?)</em>.</p>

<p>Grid definitions are variable, with a number of vertical pipes and height of overall structure, and are repeatably-random by passing a seed (see the <code>PipeGrid</code> constructor).</p>

<p>In the absence of a definitive answer as to which way the object would flow if either direction was possible, I have allowed you to specify a behaviour from a number of options (see <code>SolveBehavior</code> enumeration / <code>PipeSolver</code> constructor).</p>

<p>Starting vertical is definable (see <code>PipeSolver.Solve</code>).</p>

<p>I have assumed that the horizontal pipes are always between two <em>adjacent</em> vertical pipes, i.e. no horizontal can bypass a horizontal pipe.</p>

<pre><code>///&lt;summary&gt;Entry point&lt;/summary&gt;
void Main()
{
    var grid = new PipeGrid(vertical:10, height:10, seed:5);
    var solver = new PipeSolver(grid, SolveBehavior.FlipFlop);
    solver.Solve(start:2);
}

///&lt;summary&gt;Represents the direction the object is travelling&lt;/summary&gt;
enum Direction
{
    Down = 0,
    Left = 1,
    Right = 2
}

///&lt;summary&gt;Determines the route to take if a junction yields both horizontal directions&lt;/summary&gt;
enum SolveBehavior
{
    ///&lt;summary&gt;Throws an &lt;see cref="InvalidOperationException" /&gt;&lt;/summary&gt;
    Fail = 0,

    ///&lt;summary&gt;Prefers the left-most direction (screen-relative)&lt;/summary&gt;
    FavorLeft = 1,

    ///&lt;summary&gt;Prefers the right-most direction (screen-relative)&lt;/summary&gt;
    FavorRight = 2,

    ///&lt;summary&gt;Alternates preferred direction, based on the number of turns&lt;/summary&gt;
    FlipFlop = 3,

    ///&lt;summary&gt;Prefers the same direction the object travelled, on its last horizontal movement&lt;/summary&gt;
    SameDirection = 4,

    ///&lt;summary&gt;Prefers the opposite direction the object travelled, on its last horizontal movement&lt;/summary&gt;
    Uturn = 5
}

///&lt;summary&gt;Provides the logic for solving a &lt;see cref="PipeGrid" /&gt;&lt;/summmary&gt;
class PipeSolver
{
    ///&lt;summary&gt;Creates a new &lt;see cref="PipeSolver" /&gt; for the supplied &lt;paramref name="grid" /&gt;,
    ///with the given &lt;paramref name="behavior" /&gt; used to resolve junctions with both horizontal 
    ///paths&lt;/summary&gt;
    public PipeSolver(PipeGrid grid, SolveBehavior behavior = SolveBehavior.FlipFlop)
    {       
        if (grid == null) throw new ArgumentNullException("grid");
        _grid = grid;
        _behavior = behavior;
    }

    private readonly PipeGrid _grid;
    private readonly SolveBehavior _behavior;

    ///&lt;summary&gt;Simulate the dropping of an object to run through the grid, at the top of a
    ///given &lt;paramref name="start" /&gt; vertical pipe&lt;/summary&gt;
    public void Solve(int start = 1, bool dumpFrames = false, string tag = "Result")
    {
        if (start &lt; 1) start = 1;
        if (start &gt; _grid.Verticals) start = _grid.Verticals;

        int x, y;

        Direction?[,] path = new Direction?[_grid.Width, _grid.Height];

        x = (start - 1) * 2;
        y = 0;
        Direction dir = Direction.Down, lastDir = Direction.Down;

        int turns = 0;      
        do
        {
            path[x, y] = dir;       // we moved through this pipe

            // rule 1: when moving through horizontal pipe, object will go down when possible
            if ((dir == Direction.Left || dir == Direction.Right) &amp;&amp; (x % 2 == 0))
            {
                lastDir = dir;
                dir = Direction.Down;
                ++turns;
            }
            // rule 2: when moving through start pipe, object will turn into horizontal pipe when possible
            else if (dir == Direction.Down)
            {
                bool hasLeft  = (x &gt; 0 &amp;&amp; _grid[x - 1, y]);
                bool hasRight = (x &lt; _grid.Width - 1 &amp;&amp; _grid[x + 1, y]);

                if (hasLeft &amp;&amp; hasRight)
                {
                    switch (_behavior)
                    {
                        case SolveBehavior.FavorLeft: 
                            hasRight = false;       // "forget" about right pipe
                            break;
                        case SolveBehavior.FavorRight:
                            hasLeft = false;        // "forget" about left pipe
                            break;
                        case SolveBehavior.FlipFlop:
                            if (turns % 2 == 0) hasLeft = false;
                            else hasRight = false;  // "forget" about left on the even moves, or right on the odd moves
                            break;
                        case SolveBehavior.SameDirection:   // force staying in the same direction
                            if (lastDir == Direction.Left)       hasRight = false;
                            else if (lastDir == Direction.Right) hasLeft = false;
                            else goto case SolveBehavior.FlipFlop;  // use the flip-flop behaviour to determine first turn
                            break;
                        case SolveBehavior.Uturn:   // force turning back on itself
                            if (lastDir == Direction.Left)       hasLeft = false;
                            else if (lastDir == Direction.Right) hasRight = false;
                            else goto case SolveBehavior.FlipFlop;  // use the flip-flop behaviour to determine first turn
                            break;
                        default: throw new InvalidOperationException(
                            "Failed to find distinct path, with no resolving behavior defined"
                        );
                    }
                }

                if (hasLeft)        dir = Direction.Left;
                else if (hasRight)  dir = Direction.Right;

                if (hasLeft || hasRight) ++turns;
            }

            switch (dir)    // update position, based on current direction
            {
                case Direction.Left:  if (x &gt; 0) --x; break;
                case Direction.Right: if (x &lt; _grid.Width - 1) ++x; break;
                default: ++y; break;
            }
            if (dumpFrames) 
            {
                DumpFrame(path, start, tag:string.Concat("Frame #", turns, " (", _grid.Seed, ")"));
                DrawFrame(path, start, tag:string.Concat("Frame #", turns));
            }
        } 
        while (y &lt; _grid.Height);

        int end = (x / 2) + 1;
        DumpFrame(path, start, end, turns, tag);
        DrawFrame(path, start, end, turns, tag);
    }

    ///&lt;summary&gt;Internal method for drawing a given frame&lt;/summary&gt;
    private void DumpFrame(Direction?[,] path, int start, int? end = null, int? turns = null, string tag = null)
    {
        var builder = new StringBuilder();

        builder.Append(' ', --start * 5).AppendLine("v");
        for (int y = 0; y &lt; _grid.Height; y++)
        {
            for (int x = 0; x &lt; _grid.Width; x++)
            {
                builder.Append(
                    (x % 2 == 0) 
                        ? path[x, y].HasValue ? ":"    : _grid[x, y] ? "|"    : " "
                        : path[x, y].HasValue ? "====" : _grid[x, y] ? "----" : "    "
                );
            }
            builder.AppendLine();
        }
        if (end.HasValue)   builder.Append(' ', (end.Value - 1) * 5).AppendLine("^");

        if (turns.HasValue) builder.Append(turns.Value)
                                   .Append(" turns were taken to get to ")
                                   .AppendLine(end.HasValue ? "the end." : "this point.");

        builder.ToString().Dump(string.IsNullOrWhiteSpace(tag) ? "Frame" : tag);
    }

    ///&lt;summary&gt;Internal method for rendering a frame as a bitmap&lt;/summary&gt;
    private void DrawFrame(Direction?[,] path, int start, int? end = null, int? turns = null, string tag = null)
    {
        using (var sprites = new Sprites())
        using (var canvas = new Bitmap(16 * _grid.Width, 16 * (_grid.Height + 3)))
        using (var graphics = Graphics.FromImage(canvas))
        {
            graphics.FillRectangle(Brushes.Green, 0, 16, 16 * _grid.Width, 16 * _grid.Height);
            _grid.Draw(graphics, sprites, offsetX:0, offsetY:16);

            // draw the start position
            start = (start - 1) * 32;
            graphics.DrawImageUnscaled(sprites.RoadVertical, start, 0);
            graphics.DrawImageUnscaled(sprites.CarVertical,  start, 0);
            graphics.DrawImageUnscaled(sprites.StartFlag,    start, 0);

            // draw the path
            for (int y = 0; y &lt; _grid.Height; y++)
            for (int x = 0; x &lt; _grid.Width;  x++)
            {
                if (path[x, y].HasValue)
                {
                    Image car;

                    switch (path[x, y])
                    {
                        case Direction.Left:
                            // if even, then on a vertical, so turning left; otherwise travelling left
                            car = (x % 2 == 0) ? sprites.CarTurnLeft : sprites.CarLeft;
                            break;
                        case Direction.Right:
                            // if even, then on a vertical, so turning right; otherwise travelling right
                            car = (x % 2 == 0) ? sprites.CarTurnRight: sprites.CarRight;
                            break;
                        default:
                            car = sprites.CarVertical;
                            if (x == 0 &amp;&amp; path[x + 1, y].HasValue)                            // far-left and will move right = turn-right
                                car = sprites.CarTurnRight;
                            else if (x == _grid.Width - 1 &amp;&amp; path[x - 1, y].HasValue)         // far-right and will move left = turn-left
                                car = sprites.CarTurnLeft;
                            else if (x &gt; 0 &amp;&amp; x &lt; _grid.Width - 1)
                            {
                                car = sprites.CarVertical;                                    // if not right or left, then down
                                if (path[x + 1, y].HasValue &amp;&amp; !path[x - 1, y].HasValue)      // if came from the left, then turn right
                                    car = sprites.CarTurnRight;
                                else if (path[x - 1, y].HasValue &amp;&amp; !path[x + 1, y].HasValue) // if came from the right, then turn left
                                    car = sprites.CarTurnLeft;
                            }
                            break;
                    }

                    graphics.DrawImageUnscaled(car, 16 * x, 16 * (y + 1));
                }
            }

            // draw the end position, if we are at the end
            if (end.HasValue)
            {
                end = (end - 1) * 32;
                graphics.DrawImageUnscaled(sprites.RoadVertical, end.Value, 16 * (_grid.Height + 1));
                graphics.DrawImageUnscaled(sprites.CarVertical,  end.Value, 16 * (_grid.Height + 1));
                graphics.DrawImageUnscaled(sprites.EndFlag,      end.Value, 16 * (_grid.Height + 1));
            }

            if (turns.HasValue) 
            {
                string s = string.Concat(turns.Value, " turns were taken to get to ", 
                                         end.HasValue ? "the end." : "this point.");

                graphics.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAliasGridFit;
                graphics.DrawString(s, SystemFonts.DefaultFont, Brushes.Black, 0, 16 * (_grid.Height + 2));
            }

            canvas.Dump(tag ?? "Bonus");
        }       
    }
}

///&lt;summary&gt;Represents a configuration of pipes&lt;/summary&gt;
class PipeGrid
{
    ///&lt;summary&gt;Creates a new &lt;see cref="PipeGrid" /&gt;, of a given &lt;paramref name="height" /&gt;
    ///with the given number of &lt;paramref name="vertical" /&gt; pipes, and randomly distributes 
    ///horizontal pipes between them, based on a repeatable &lt;paramref name="seed" /&gt;.&lt;/summary&gt;
    public PipeGrid(int vertical = 4, int height = 8, int? seed = null)
    {
        if (vertical &lt; 2) vertical = 2;
        if (height &lt; 2) height = 2;

        Width = (2 * vertical) - 1;
        Height = height;
        Verticals = vertical;

        Seed = seed ?? Environment.TickCount;
        var rnd = new Random(Seed);

        _nodes = new bool[Width,Height];
        for (int x = 0, xw = Width; x &lt; xw; x++) 
        for (int y = 0; y &lt; height; y++)
        {
            // place verticals in every even column, and randomly place horizontals in odd columns
            if (x % 2 == 0 || rnd.Next(0, 2) == 1)
                _nodes[x, y] = true;
        }
    }

    private readonly bool[,] _nodes;

    public int Width { get; private set; }
    public int Height { get; private set; }
    public int Verticals { get; private set; }
    public int Seed { get; private set; }

    public bool this[int x, int y] { get { return _nodes[x, y]; } }

    ///&lt;summary&gt;Renders the grid to the LINQPad results pane, for inspection&lt;/summary&gt;
    public PipeGrid Dump(string tag = null)
    {
        var builder = new StringBuilder();

        for (int y = 0; y &lt; Height; y++)
        {
            for (int x = 0; x &lt; Width; x++)
            {
                builder.Append(
                    (x % 2 == 0)
                        ? _nodes[x, y] ? "|"    : " "
                        : _nodes[x, y] ? "----" : "    "
                );
            }
            builder.AppendLine();
        }

        builder.ToString().Dump(string.IsNullOrWhiteSpace(tag) ? "Grid" : tag);
        return this;
    }

    ///&lt;summary&gt;Render the grid as a bitmap image&lt;/summary&gt;
    public void Draw(Graphics g, Sprites s, int offsetX = 0, int offsetY = 0)
    {           
        for (int y = 0; y &lt; Height; y++)
        {
            for (int x = 0; x &lt; Width; x++)
            {
                if (_nodes[x, y])
                {   
                    Image sprite = sprite = s.RoadVertical;

                    if (x % 2 != 0) 
                        sprite = s.RoadHorizontal;
                    else if (x == 0 &amp;&amp; _nodes[1, y])
                        sprite = s.JunctionTeeRight;
                    else if (x == Width - 1 &amp;&amp; _nodes[x - 1, y])
                        sprite = s.JunctionTeeLeft;
                    else if (x &gt; 0 &amp;&amp; x &lt; Width - 1)
                    {
                        if (_nodes[x - 1, y] &amp;&amp; _nodes[x + 1, y])
                            sprite = s.JunctionCross;
                        else if (_nodes[x + 1, y] &amp;&amp; !_nodes[x - 1, y])
                            sprite = s.JunctionTeeRight;
                        else if (_nodes[x - 1, y] &amp;&amp; !_nodes[x + 1, y])
                            sprite = s.JunctionTeeLeft;
                    }

                    g.DrawImageUnscaled(sprite, 
                                        x:(16 * x) + offsetX, 
                                        y:(16 * y) + offsetY);
                }
            }
        }
    }

    ///&lt;summary&gt;Creates a &lt;see cref="PipeGrid" /&gt; with horizontal pipes at all possible positions&lt;/summary&gt;
    public static PipeGrid CreateAllOpen(int verticals = 4, int height = 8)
    {
        var grid = new PipeGrid(verticals, height, 0);
        for (int y = 0; y &lt; height; y++)
        for (int x = 0, xw = grid.Width; x &lt; xw; x++)
            grid._nodes[x, y] = true;

        return grid;
    }
}

///&lt;summary&gt;Store tile sprites, to be used in the graphical rendering of the result&lt;/summary&gt;
class Sprites : IDisposable
{
    public Sprites()
    {
        byte[,] car = new byte[,] {
            { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
            { 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0 },
            { 0, 0, 0, 1, 3, 3, 3, 3, 3, 3, 3, 3, 1, 0, 0, 0 },
            { 0, 0, 0, 1, 3, 1, 1, 1, 1, 1, 1, 3, 1, 0, 0, 0 },
            { 0, 0, 0, 1, 3, 1, 1, 1, 1, 1, 1, 3, 1, 0, 0, 0 },
            { 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0 },
            { 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0 },
            { 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0 },
            { 0, 0, 0, 0, 3, 1, 1, 1, 1, 1, 1, 3, 0, 0, 0, 0 },
            { 0, 0, 0, 0, 3, 1, 1, 1, 1, 1, 1, 3, 0, 0, 0, 0 },
            { 0, 0, 0, 1, 3, 1, 1, 1, 1, 1, 1, 3, 1, 0, 0, 0 },
            { 0, 0, 0, 1, 3, 3, 3, 3, 3, 3, 3, 3, 1, 0, 0, 0 },
            { 0, 0, 0, 1, 3, 3, 3, 3, 3, 3, 3, 3, 1, 0, 0, 0 },
            { 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0 },
            { 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0 },
            { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
        };
        byte[,] road = new byte[,] {
            { 0, 6, 2, 2, 2, 2, 2, 6, 6, 2, 2, 2, 2, 2, 6, 0 },
            { 0, 6, 2, 2, 2, 2, 2, 6, 6, 2, 2, 2, 2, 2, 6, 0 },
            { 0, 6, 2, 2, 2, 2, 2, 6, 6, 2, 2, 2, 2, 2, 6, 0 },
            { 0, 6, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 6, 0 },
            { 0, 6, 2, 2, 2, 2, 2, 6, 6, 2, 2, 2, 2, 2, 6, 0 },
            { 0, 6, 2, 2, 2, 2, 2, 6, 6, 2, 2, 2, 2, 2, 6, 0 },
            { 0, 6, 2, 2, 2, 2, 2, 6, 6, 2, 2, 2, 2, 2, 6, 0 },
            { 0, 6, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 6, 0 },
            { 0, 6, 2, 2, 2, 2, 2, 6, 6, 2, 2, 2, 2, 2, 6, 0 },
            { 0, 6, 2, 2, 2, 2, 2, 6, 6, 2, 2, 2, 2, 2, 6, 0 },
            { 0, 6, 2, 2, 2, 2, 2, 6, 6, 2, 2, 2, 2, 2, 6, 0 },
            { 0, 6, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 6, 0 },
            { 0, 6, 2, 2, 2, 2, 2, 6, 6, 2, 2, 2, 2, 2, 6, 0 },
            { 0, 6, 2, 2, 2, 2, 2, 6, 6, 2, 2, 2, 2, 2, 6, 0 },
            { 0, 6, 2, 2, 2, 2, 2, 6, 6, 2, 2, 2, 2, 2, 6, 0 },
            { 0, 6, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 6, 0 },
        };
        byte[,] roadNESW = new byte[,] {
            { 0, 6, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 6, 0 },
            { 6, 6, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 6, 6 },
            { 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2 },
            { 2, 2, 2, 5, 2, 2, 5, 2, 2, 5, 2, 2, 5, 2, 2, 2 },
            { 2, 2, 2, 2, 5, 5, 2, 5, 5, 2, 5, 5, 2, 2, 2, 2 },
            { 2, 2, 2, 2, 5, 5, 2, 5, 5, 2, 5, 5, 2, 2, 2, 2 },
            { 2, 2, 2, 5, 2, 2, 5, 2, 2, 5, 2, 2, 5, 2, 2, 2 },
            { 2, 2, 2, 2, 5, 5, 2, 5, 5, 2, 5, 5, 2, 2, 2, 2 },
            { 2, 2, 2, 2, 5, 5, 2, 5, 5, 2, 5, 5, 2, 2, 2, 2 },
            { 2, 2, 2, 5, 2, 2, 5, 2, 2, 5, 2, 2, 5, 2, 2, 2 },
            { 2, 2, 2, 2, 5, 5, 2, 5, 5, 2, 5, 5, 2, 2, 2, 2 },
            { 2, 2, 2, 2, 5, 5, 2, 5, 5, 2, 5, 5, 2, 2, 2, 2 },
            { 2, 2, 2, 5, 2, 2, 5, 2, 2, 5, 2, 2, 5, 2, 2, 2 },
            { 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2 },
            { 6, 6, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 6, 6 },
            { 0, 6, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 6, 0 },
        };
        byte[,] roadNES = new byte[,] {
            { 0, 6, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 6, 0 },
            { 0, 6, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 6, 6 },
            { 0, 6, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2 },
            { 0, 6, 2, 5, 2, 2, 5, 2, 2, 5, 2, 2, 5, 2, 2, 2 },
            { 0, 6, 2, 2, 5, 5, 2, 5, 5, 2, 5, 5, 2, 2, 2, 2 },
            { 0, 6, 2, 2, 5, 5, 2, 5, 5, 2, 5, 5, 2, 2, 2, 2 },
            { 0, 6, 2, 5, 2, 2, 5, 2, 2, 5, 2, 2, 5, 2, 2, 2 },
            { 0, 6, 2, 2, 5, 5, 2, 5, 5, 2, 5, 5, 2, 2, 2, 2 },
            { 0, 6, 2, 2, 5, 5, 2, 5, 5, 2, 5, 5, 2, 2, 2, 2 },
            { 0, 6, 2, 5, 2, 2, 5, 2, 2, 5, 2, 2, 5, 2, 2, 2 },
            { 0, 6, 2, 2, 5, 5, 2, 5, 5, 2, 5, 5, 2, 2, 2, 2 },
            { 0, 6, 2, 2, 5, 5, 2, 5, 5, 2, 5, 5, 2, 2, 2, 2 },
            { 0, 6, 2, 5, 2, 2, 5, 2, 2, 5, 2, 2, 5, 2, 2, 2 },
            { 0, 6, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2 },
            { 0, 6, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 6, 6 },
            { 0, 6, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 6, 0 },
        };
        byte[,] start = new byte[,] {
            { 0, 0, 1, 1, 1, 0, 4, 4, 4, 0, 0, 0, 4, 0, 0, 0 },
            { 0, 0, 1, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0 },
            { 0, 0, 1, 1, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0 },
            { 0, 0, 1, 1, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0 },
            { 0, 0, 1, 1, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0 },
            { 0, 0, 1, 1, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0 },
            { 0, 0, 1, 1, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0 },
            { 0, 0, 1, 1, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0 },
            { 0, 0, 1, 4, 4, 4, 0, 0, 0, 4, 4, 4, 0, 0, 0, 0 },
            { 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
            { 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
            { 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
            { 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
            { 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
            { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
            { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
        };
        byte[,] end = new byte[,] {
            { 0, 0, 1, 1, 1, 0, 1, 1, 6, 0, 0, 0, 6, 0, 0, 0 },
            { 0, 0, 1, 6, 6, 6, 1, 1, 6, 6, 1, 1, 6, 0, 0, 0 },
            { 0, 0, 1, 1, 6, 6, 6, 6, 1, 6, 1, 1, 1, 0, 0, 0 },
            { 0, 0, 1, 1, 1, 1, 6, 6, 1, 1, 6, 6, 1, 0, 0, 0 },
            { 0, 0, 1, 1, 1, 1, 1, 1, 6, 1, 6, 6, 0, 0, 0, 0 },
            { 0, 0, 1, 1, 6, 6, 1, 1, 6, 6, 1, 1, 0, 0, 0, 0 },
            { 0, 0, 1, 1, 6, 6, 6, 6, 1, 6, 1, 1, 0, 0, 0, 0 },
            { 0, 0, 1, 1, 1, 1, 6, 6, 1, 1, 6, 6, 0, 0, 0, 0 },
            { 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 6, 6, 0, 0, 0, 0 },
            { 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
            { 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
            { 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
            { 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
            { 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
            { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
            { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
        };

        RoadVertical     = Sprite(road);
        RoadHorizontal   = RotateSprite(RoadVertical, 90);
        JunctionCross    = Sprite(roadNESW);
        JunctionTeeRight = Sprite(roadNES);
        JunctionTeeLeft  = FlipSprite(JunctionTeeRight, horizontal:true);
        CarVertical      = Sprite(car);
        CarLeft          = RotateSprite(CarVertical,  90);
        CarRight         = FlipSprite(CarLeft, horizontal:true);
        CarTurnLeft      = RotateSprite(CarVertical,  45);
        CarTurnRight     = FlipSprite(CarTurnLeft, horizontal:true);
        StartFlag        = Sprite(start);
        EndFlag          = Sprite(end);
    }

    public Image RoadVertical     { get; private set; }
    public Image RoadHorizontal   { get; private set; }
    public Image JunctionCross    { get; private set; }
    public Image JunctionTeeLeft  { get; private set; }
    public Image JunctionTeeRight { get; private set; }
    public Image CarVertical      { get; private set; }
    public Image CarLeft          { get; private set; }
    public Image CarRight         { get; private set; }
    public Image CarTurnLeft      { get; private set; }
    public Image CarTurnRight     { get; private set; }
    public Image StartFlag        { get; private set; }
    public Image EndFlag          { get; private set; }

    ///&lt;summary&gt;Create a sprite from the byte data&lt;/summary&gt;
    private Image Sprite(byte[,] data) 
    {
        int width = data.GetLength(0);
        int height = data.GetLength(1);

        var image = new Bitmap(width, height);

        for (int y = 0; y &lt; height; y++)
        for (int x = 0; x &lt; width; x++)
        {
            Color c;
            switch (data[y,x])
            {
                case 1: c = Color.Black; break;
                case 2: c = Color.DarkGray; break;
                case 3: c = Color.Red; break;
                case 4: c = Color.LimeGreen; break;
                case 5: c = Color.Yellow; break;
                case 6: c = Color.White; break;
                default: continue;
            }

            image.SetPixel(x, y, c);
        }

        return image;
    }

    ///&lt;summary&gt;Rotate an image by a number of &lt;paramref name="degrees" /&gt; around the centre&lt;/summary&gt;
    private Image RotateSprite(Image source, float deg)
    {
        var b = new Bitmap(source.Width, source.Height);

        using (var g = Graphics.FromImage(b))
        {
            float tx = (float)source.Width / 2.0f;
            float ty = (float)source.Height / 2.0f;

            g.TranslateTransform(tx, ty);
            g.RotateTransform(deg);
            g.TranslateTransform(-tx, -ty);
            g.DrawImageUnscaled(source, 0, 0);
        }

        return b;
    }

    ///&lt;summary&gt;Flip an image about its centre&lt;/summary&gt;
    private Image FlipSprite(Image source, bool horizontal = false, bool vertical = false)
    {
        var b = new Bitmap(source);

        RotateFlipType rft = ( horizontal &amp;&amp;  vertical) ? RotateFlipType.RotateNoneFlipXY
                           : ( horizontal &amp;&amp; !vertical) ? RotateFlipType.RotateNoneFlipX
                           : (!horizontal &amp;&amp;  vertical) ? RotateFlipType.RotateNoneFlipY
                           : RotateFlipType.RotateNoneFlipNone;

        b.RotateFlip(rft);
        return b;
    }

    #region IDisposable implementation
    public void Dispose() { Dispose(true); }
    ~Sprites() { Dispose(false); }
    protected void Dispose(bool disposing)
    {
        if (disposing)
        {
            GC.SuppressFinalize(this);
            using (RoadVertical) { }    
            using (RoadHorizontal) { }
            using (JunctionCross) { }
            using (JunctionTeeLeft) { }
            using (JunctionTeeRight) { }
            using (CarVertical) { }
            using (CarLeft) { }
            using (CarRight) { }
            using (CarTurnLeft) { }
            using (CarTurnRight) { }
            using (StartFlag) { }
            using (EndFlag) { };
        }
        RoadVertical = null;
        RoadHorizontal = null;
        JunctionCross = null;
        JunctionTeeLeft = null;
        JunctionTeeRight = null;
        CarVertical = null;
        CarLeft = null;
        CarRight = null;
        CarTurnLeft = null;
        CarTurnRight = null;
        StartFlag = null;
        EndFlag = null;
    }
    #endregion
}
</code></pre>

<h2>Update:</h2>

<p>Fearing my plain old text output might be a little drab for this popularity context, I offer up an extended version that <em>also</em> draws the path taken as an image.  I've modelled it as car, driving through a horrible road network, trying to get to the bottom, but with the world's-worst GPS that forces you to make a turn at every junction.</p>

<p>As a bonus, this also makes it clearer to see the 'turns'.</p>

<p>Enjoy -- <em>vroom vroom!!</em></p>

<h2>Example results:</h2>

<p><em>(verticals: 10, height: 10, random seed:5, start pipe: 2, solve behaviour: FlipFlop})</em>
<img src="https://i.sstatic.net/dT4Xo.png" alt="Example results, as seen in LINQPad results page, for {vertical:10,height:10,seed:5,start:2,behaviour:FlipFlop}"></p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/19938/">19938</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




