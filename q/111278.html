<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::111278</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>2010</td><td>Vim</td><td>240125T005611Z</td><td><a href="https://codegolf.stackexchange.com/questions/111278/turing-complete-language-interpreter/269538#269538">Aaroneou</a></td></tr>
<tr d-ix="1"><td>232</td><td>Turing machine finitely initialized</td><td>230927T204326Z</td><td><a href="https://codegolf.stackexchange.com/questions/111278/turing-complete-language-interpreter/265539#265539">ais523 -</a></td></tr>
<tr d-ix="2"><td>034</td><td>Jelly → Couplet 2C variant</td><td>230913T115239Z</td><td><a href="https://codegolf.stackexchange.com/questions/111278/turing-complete-language-interpreter/265198#265198">ais523</a></td></tr>
<tr d-ix="3"><td>001</td><td>Vyxal interpreting Thue variant</td><td>230822T025350Z</td><td><a href="https://codegolf.stackexchange.com/questions/111278/turing-complete-language-interpreter/264467#264467">emanresu</a></td></tr>
<tr d-ix="4"><td>003</td><td>Jelly → Addition Automaton with b = 10</td><td>230821T000214Z</td><td><a href="https://codegolf.stackexchange.com/questions/111278/turing-complete-language-interpreter/264429#264429">ais523</a></td></tr>
<tr d-ix="5"><td>087</td><td>Python 3 interpreting I/D machine</td><td>221215T025224Z</td><td><a href="https://codegolf.stackexchange.com/questions/111278/turing-complete-language-interpreter/255506#255506">Fmbalbue</a></td></tr>
<tr d-ix="6"><td>050</td><td>Haskell</td><td>220813T202307Z</td><td><a href="https://codegolf.stackexchange.com/questions/111278/turing-complete-language-interpreter/251064#251064">Benji</a></td></tr>
<tr d-ix="7"><td>004</td><td>Vyxal implementing "add minimum to transpose"</td><td>220606T103741Z</td><td><a href="https://codegolf.stackexchange.com/questions/111278/turing-complete-language-interpreter/248276#248276">emanresu</a></td></tr>
<tr d-ix="8"><td>004</td><td>><> interpreting "Craw><>"</td><td>220219T064407Z</td><td><a href="https://codegolf.stackexchange.com/questions/111278/turing-complete-language-interpreter/243067#243067">Twilight</a></td></tr>
<tr d-ix="9"><td>084</td><td>Headass interpreting BCT</td><td>220204T051625Z</td><td><a href="https://codegolf.stackexchange.com/questions/111278/turing-complete-language-interpreter/242335#242335">thejonym</a></td></tr>
<tr d-ix="10"><td>138</td><td>Nim Three Star Programmer</td><td>211013T072622Z</td><td><a href="https://codegolf.stackexchange.com/questions/111278/turing-complete-language-interpreter/236240#236240">Qaziquza</a></td></tr>
<tr d-ix="11"><td>182</td><td>C clang interpreting Brainfuck</td><td>170508T071401Z</td><td><a href="https://codegolf.stackexchange.com/questions/111278/turing-complete-language-interpreter/119524#119524">jdt</a></td></tr>
<tr d-ix="12"><td>114</td><td>JavaScript Lambda Calculus</td><td>190409T145342Z</td><td><a href="https://codegolf.stackexchange.com/questions/111278/turing-complete-language-interpreter/182909#182909">SYZYGY-D</a></td></tr>
<tr d-ix="13"><td>004</td><td>M → Tip</td><td>180712T130716Z</td><td><a href="https://codegolf.stackexchange.com/questions/111278/turing-complete-language-interpreter/168471#168471">ais523</a></td></tr>
<tr d-ix="14"><td>015</td><td>APL Dyalog → Fractran variant</td><td>180426T124028Z</td><td><a href="https://codegolf.stackexchange.com/questions/111278/turing-complete-language-interpreter/163444#163444">user4180</a></td></tr>
<tr d-ix="15"><td>031</td><td>C implementing the 2</td><td>170507T002605Z</td><td><a href="https://codegolf.stackexchange.com/questions/111278/turing-complete-language-interpreter/119342#119342">a52</a></td></tr>
<tr d-ix="16"><td>015</td><td>APL Dyalog Unicode</td><td>180416T090128Z</td><td><a href="https://codegolf.stackexchange.com/questions/111278/turing-complete-language-interpreter/162381#162381">Ad&#225;</a></td></tr>
<tr d-ix="17"><td>024</td><td>Perl a → I/D machine</td><td>180318T031349Z</td><td><a href="https://codegolf.stackexchange.com/questions/111278/turing-complete-language-interpreter/159493#159493">ais523</a></td></tr>
<tr d-ix="18"><td>2127</td><td>x86 assembly Intel syntax/MASMBrainfuck</td><td>170510T155959Z</td><td><a href="https://codegolf.stackexchange.com/questions/111278/turing-complete-language-interpreter/119941#119941">user6318</a></td></tr>
<tr d-ix="19"><td>013</td><td>CJam → ResPlicate Variant</td><td>170516T223009Z</td><td><a href="https://codegolf.stackexchange.com/questions/111278/turing-complete-language-interpreter/120967#120967">Esolangi</a></td></tr>
<tr d-ix="20"><td>004</td><td>Jelly → "Add minimum to transpose"</td><td>170611T081643Z</td><td><a href="https://codegolf.stackexchange.com/questions/111278/turing-complete-language-interpreter/125815#125815">user6213</a></td></tr>
<tr d-ix="21"><td>009</td><td>Brachylog 2 → Post correspondence problem</td><td>170517T005322Z</td><td><a href="https://codegolf.stackexchange.com/questions/111278/turing-complete-language-interpreter/120979#120979">user6213</a></td></tr>
<tr d-ix="22"><td>075</td><td>Clojure</td><td>170507T144009Z</td><td><a href="https://codegolf.stackexchange.com/questions/111278/turing-complete-language-interpreter/119410#119410">NikoNyrh</a></td></tr>
<tr d-ix="23"><td>nan</td><td>Chip</td><td>170511T221503Z</td><td><a href="https://codegolf.stackexchange.com/questions/111278/turing-complete-language-interpreter/120155#120155">Phlarx</a></td></tr>
<tr d-ix="24"><td>081</td><td>Clojure</td><td>170506T111716Z</td><td><a href="https://codegolf.stackexchange.com/questions/111278/turing-complete-language-interpreter/119246#119246">NikoNyrh</a></td></tr>
<tr d-ix="25"><td>467</td><td>Lua interpreting Brainf***</td><td>170508T180249Z</td><td><a href="https://codegolf.stackexchange.com/questions/111278/turing-complete-language-interpreter/119607#119607">Blab</a></td></tr>
<tr d-ix="26"><td>nan</td><td>Clojure</td><td>170508T153102Z</td><td><a href="https://codegolf.stackexchange.com/questions/111278/turing-complete-language-interpreter/119586#119586">NikoNyrh</a></td></tr>
<tr d-ix="27"><td>842</td><td>BF/P" implemented in a Turing Machine</td><td>170507T064220Z</td><td><a href="https://codegolf.stackexchange.com/questions/111278/turing-complete-language-interpreter/119362#119362">a52</a></td></tr>
<tr d-ix="28"><td>008</td><td>Jelly → 2Tag system</td><td>170508T044708Z</td><td><a href="https://codegolf.stackexchange.com/questions/111278/turing-complete-language-interpreter/119513#119513">user6213</a></td></tr>
<tr d-ix="29"><td>046</td><td>Iterated Generalized Collatz Functions > Python 2</td><td>170508T014155Z</td><td><a href="https://codegolf.stackexchange.com/questions/111278/turing-complete-language-interpreter/119506#119506">quintopi</a></td></tr>
<tr d-ix="30"><td>047</td><td>ResPlicate variant > Python 2</td><td>170508T010943Z</td><td><a href="https://codegolf.stackexchange.com/questions/111278/turing-complete-language-interpreter/119502#119502">quintopi</a></td></tr>
<tr d-ix="31"><td>106</td><td>Röda implementing Fractran</td><td>170506T125011Z</td><td><a href="https://codegolf.stackexchange.com/questions/111278/turing-complete-language-interpreter/119252#119252">user4180</a></td></tr>
<tr d-ix="32"><td>nan</td><td>JavaScript interpreting Rule 110</td><td>170228T222554Z</td><td><a href="https://codegolf.stackexchange.com/questions/111278/turing-complete-language-interpreter/111732#111732">Jens Ren</a></td></tr>
<tr d-ix="33"><td>nan</td><td>Perl → Three Star Programmer variant</td><td>170227T082621Z</td><td><a href="https://codegolf.stackexchange.com/questions/111278/turing-complete-language-interpreter/111479#111479">user6213</a></td></tr>
<tr d-ix="34"><td>016</td><td>Pip interpreting cyclic tag systems</td><td>170227T074315Z</td><td><a href="https://codegolf.stackexchange.com/questions/111278/turing-complete-language-interpreter/111469#111469">DLosc</a></td></tr>
<tr d-ix="35"><td>064</td><td>Mathematica interpreting Conway's Game of Life</td><td>170227T030027Z</td><td><a href="https://codegolf.stackexchange.com/questions/111278/turing-complete-language-interpreter/111454#111454">Greg Mar</a></td></tr>
<tr d-ix="36"><td>049</td><td>Turtlèd interpreting CT</td><td>170226T015135Z</td><td><a href="https://codegolf.stackexchange.com/questions/111278/turing-complete-language-interpreter/111297#111297">Destruct</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://www.vim.org/" rel="nofollow noreferrer">Vim</a>, interpreting <a href="https://esolangs.org/wiki/Malbolge_Unshackled" rel="nofollow noreferrer">Malbolge Unshackled</a>, 2010 bytes</h1>
<pre><code>o/rd&lt;C-V&gt;
@g^Wy$/rc&lt;C-V&gt;
WD&quot;0p&lt;ESC&gt;^&quot;iC/ra&lt;C-V&gt;
@f^WylWD&quot;xp`o&lt;C-V&gt;&lt;DEL&gt;:if@0.@-[len(@-)-1]==21&lt;C-V&gt;
norm o&lt;C-V&gt;
el&lt;C-V&gt;
norm A&lt;C-V&gt;&lt;C-R&gt;=nr2char(@-,1)&lt;C-V&gt;
&lt;C-V&gt;
en&lt;C-V&gt;
&lt;ESC&gt;^&quot;aC`i+x/ra&lt;C-V&gt;
Wr0WD&quot;=char2nr(@-,1)&lt;C-V&gt;
p&lt;ESC&gt;^&quot;bC/rw&lt;C-V&gt;
W&quot;yy$-@g^W&quot;xylWy$:if@y&gt;len(@&quot;)&lt;C-V&gt;
norm A&lt;C-V&gt;&lt;C-R&gt;=repeat(@x,@y-len(@&quot;))&lt;C-V&gt;
&lt;C-V&gt;
en&lt;C-V&gt;
^WWx$p^Wy$/ra&lt;C-V&gt;
WD&quot;0p&lt;ESC&gt;^&quot;cC/rd&lt;C-V&gt;
@g^Wy$/rd&lt;C-V&gt;
WD&quot;0p@u&lt;ESC&gt;^&quot;jC/ra&lt;C-V&gt;
Wyl$p^WW&quot;ny$++@g^Wyl$p^WW&quot;my$@o^WWD&quot;mpx^WR&lt;C-V&gt;&lt;C-R&gt;&quot;&lt;C-V&gt;&lt;ESC&gt;y$/ra&lt;C-V&gt;
WD&quot;0p&lt;ESC&gt;^&quot;pC^WWD:wh@&quot;&gt;2&lt;C-V&gt;
norm&quot;=&lt;C-V&gt;&lt;C-V&gt;&lt;C-V&gt;&lt;C-R&gt;&quot;%3&lt;C-V&gt;&lt;C-V&gt;&lt;C-V&gt;
p&lt;C-V&gt;
let@&quot;=@&quot;/3&lt;C-V&gt;
endw&lt;C-V&gt;
p&lt;ESC&gt;^&quot;tC^WWD:let@x=@-|let@&quot;=join(map(split(@&quot;,'\zs'),{a,b-&gt;b*float2nr(pow(3,a))}),'+')&lt;C-V&gt;
&quot;=&lt;C-V&gt;&lt;C-R&gt;&quot;&lt;C-V&gt;
p&lt;ESC&gt;^&quot;fCmg@wgg/m&lt;C-V&gt;&lt;C-R&gt;- \|m!&lt;C-V&gt;
WWy$:let@s=@-|if@&quot;==-1&lt;C-V&gt;
norm`g^WxPWyll&lt;C-V&gt;
let@x=4*@-+@&quot;+6-@-&lt;C-V&gt;
norm y$&lt;C-V&gt;
for_ in split(@&quot;,'\zs')&lt;C-V&gt;
let@x=(@x+3*(_+6-@-))%6&lt;C-V&gt;
endfo&lt;C-V&gt;
let@x=@x+1&lt;C-V&gt;
norm`n@xjy$2Gom&lt;C-V&gt;&lt;C-R&gt;s &lt;C-V&gt;&lt;C-V&gt;&lt;C-V&gt;&lt;C-R&gt;&quot;&lt;C-V&gt;
en&lt;C-V&gt;
@f^WWD&quot;xp:let@&quot;=@x&lt;C-V&gt;
&lt;ESC&gt;^&quot;gC@f@t@f&lt;C-V&gt;&lt;C-A&gt;@t^WWy$:if len(@0)!=len(@x)&lt;C-V&gt;
norm$x^Wx&quot;=@-%2&lt;C-V&gt;&lt;C-V&gt;&lt;C-V&gt;
P$&quot;=(@-+1)%3&lt;C-V&gt;&lt;C-V&gt;&lt;C-V&gt;
p&lt;C-V&gt;
en&lt;C-V&gt;
&lt;ESC&gt;^&quot;vC:let@&quot;=len(@n)-len(@m)|if@&quot;&gt;0&lt;C-V&gt;
let@m=@m.repeat(@m[len(@m)-1],@&quot;)&lt;C-V&gt;
elsei@&quot;&lt;0&lt;C-V&gt;
let@n=@n.repeat(@n[len(@n)-1],-@&quot;)&lt;C-V&gt;
en|let@m=join(map(split(@n,'\zs'),{a,b-&gt;((float2nr(pow(b+(@m[a]*512)+8,2))%82)%3)}),'')&lt;C-V&gt;
&lt;ESC&gt;^&quot;oC&amp;&amp;&lt;C-V&gt;&lt;C-V&gt;&lt;C-V&gt;&lt;C-R&gt;=&lt;C-V&gt;&lt;C-V&gt;&lt;C-V&gt;
!=&lt;ESC&gt;^&quot;zCgg&quot;zx/ra&lt;C-V&gt;
^WWD&quot;=_&lt;C-V&gt;
p@t@wggjom&lt;C-V&gt;&lt;C-R&gt;- 0 &lt;C-V&gt;&lt;C-R&gt;=char2nr(@z,1)&lt;C-V&gt;
&lt;C-V&gt;&lt;ESC&gt;@t&lt;ESC&gt;^&quot;dC/rc&lt;C-V&gt;
@g^Wyl:if@&quot;&lt;1&lt;C-V&gt;
let@&quot;=@-&lt;C-V&gt;
en|if@&quot;&gt;32&amp;&amp;@&quot;&lt;127&lt;C-V&gt;
let@&quot;=nr2char(@&quot;)&lt;C-V&gt;
if@&quot;==&quot;/&quot;&lt;C-V&gt;
let@&quot;='\/'&lt;C-V&gt;
en&lt;C-V&gt;
norm`x/\V&lt;C-V&gt;&lt;C-V&gt;&lt;C-V&gt;&lt;C-R&gt;&quot;&lt;C-V&gt;&lt;C-V&gt;&lt;C-V&gt;
j&quot;zyl/rc&lt;C-V&gt;&lt;C-V&gt;&lt;C-V&gt;
@g^WWC&lt;C-V&gt;&lt;C-V&gt;&lt;C-V&gt;&lt;C-R&gt;=char2nr(@z)&lt;C-V&gt;&lt;C-V&gt;&lt;C-V&gt;
&lt;C-V&gt;&lt;C-V&gt;&lt;C-V&gt;&lt;ESC&gt;@t&lt;C-V&gt;
en&lt;C-V&gt;
&lt;ESC&gt;^&quot;eC^WxPWy$:s/&lt;C-V&gt;&lt;C-R&gt;-*$/&lt;C-V&gt;&lt;C-R&gt;-&lt;C-V&gt;
^WWD&quot;0p&lt;ESC&gt;^&quot;wC/rd&lt;C-V&gt;
WylW&quot;yy$:s/&lt;C-V&gt;&lt;C-R&gt;0*$&lt;C-V&gt;
$&quot;0p^WW&quot;zy$+Wy$:if@&quot;/2&lt;(len(@z)-1)&lt;C-V&gt;
let@0=len(@z)+5&lt;C-V&gt;
norm ^WD&quot;0p/rd&lt;C-V&gt;&lt;C-V&gt;&lt;C-V&gt;
WWD&quot;yp&lt;C-V&gt;
en&lt;C-V&gt;
&lt;ESC&gt;^&quot;uC/rc&lt;C-V&gt;
@f^WWD&quot;xp:let@z=@-&lt;C-V&gt;
@g:let@z=(@-+@z)%94&lt;C-V&gt;
&lt;ESC&gt;^&quot;hDddggo!
m! -1 -1
@
ra 0 0
rc 0 0
rd 0 0
rw 10
&lt;ESC&gt;mx:for_ in range(32,126)
norm A&lt;C-V&gt;&lt;C-R&gt;=nr2char(_)&lt;C-V&gt;

endfo
o 5z]&amp;gqtyfr$(we4{WP)H-Zn,[%\3dL+Q;&gt;U!pJS72FhOA1CB6v^=I_0/8|jsb9m&lt;.TVac`uY*MK'X~xDl}REokN:#?G&quot;i@
#&lt;ESC&gt;miGo
&lt;C-O&gt;mo$
&lt;C-O&gt;mn%&lt;ESC&gt;gg&quot;xy$:for_ in range(len(@x))
norm @d
endfo
/ra
^WWDA0&lt;ESC&gt;/m&lt;C-R&gt;&quot;
^W&quot;zD&quot;zpj^Wy$`no&lt;ESC&gt;&quot;0p^2x$pxo&lt;ESC&gt;&quot;zp^2x$px:norm&lt;C-R&gt;=repeat(&quot;-\&quot;my$+\&quot;ny$@oo&lt;C-V&gt;&lt;ESC&gt;\&quot;mp&quot;,18-((len(@x)%6)))

G5-d`nO%&lt;ESC&gt;mnj:g/^\d/norm$x^Pa 
:wh1
norm@h
if@z==4
norm@i
elsei@z==5
norm@a
elsei@z==23
norm@b
elsei@z==39
norm@c
elsei@z==40
norm@j
elsei@z==62
norm@p
elsei@z==81
brea
en
norm @e/rc&lt;C-V&gt;
@vj@v
endw

</code></pre>
<p>...I'm so tired. This took a solid two months of work. The specification for Malbolge Unshackled is so vague in some places that I had to learn C, just so I could read the reference implementation and copy that. I LEARNED C FOR A VIM PROGRAM.</p>
<p>In all seriousness, this is something that I've wanted to do for a few years now, and having left the site for about a year and a half, I figured I should come back with something big, you know? I call it: Vim Unshackled.</p>
<p><a href="https://gist.github.com/AMiller42/96daeb2ccf32f88cc0df212a5dba59b8" rel="nofollow noreferrer">Gist containing full code explanation</a></p>
<p><a href="https://tio.run/##ZVVLc@JGEK7cUnNJlQ@6cBGzwkhIsh7YrE0sZxyROO91NsmSxBgjQMgQ9IjARtJ689edngcQb6oAjbp7ur/u/rp5fH5OrXwqIRIN@6Vi5RMJ9XvYzmpDPPetPADNDDRLEBbZKJU@7c5nxD4i5s0yTFRiaqZz63muI6EkzWM5lVC4FOdL6cBLcndyH@RgaDiahECbSAh8B/5orhfMfz@3wblHzdxkZ0kBjAHABgxwWSomBYgLAFIqFEJ5weJj7T/B8jALg7VKCoOUplDvgg77/ULJeJLBPsmJ/yL9qdCQB9AteAEge3qxj5NS0XVmKQRxqZAUDj0cZ8Ww/1Y6wFLtowCZTw26m3uCL1wOFnuSBKaNNjxQJqFluCbYI9hqU6jTDc9@zS9SZeER84lbLdJ5osZBpq6y5RxyxUZzUK2amvE@MMbmxbg1W6bBmhYySzdq2wg07YNmNPUmFALiAkDmfObHEdlEkRVLB6Y8eIrrgJiWlkZZ0XBQY@x5pmjsCLIuriHxJYdbeMctYuoE6x2TmKIHpSKhWZrfyfNE/gje9hY0R2@31Dt2TdMaHZbxLN3qQb2NmJBiUSruVQoQVzKrGO8kJSSjY1cUrmCUinwyI2sykz4h62Gf00RmLLC1uscOhWCLAs0q4KLZcGkLrhUMwEzd0XYtETR99EUMdj3ROKtijVXnwuaoY4/ER1vuxTfCBObCYPQMl6twTvC5sE48kuysk5utY7A2uXnyxJ1@3OnkZadV9UWnxzqNHdy2ThxX008NF4p76kJCrP20AZBO6h8e0kJS/qG6B5LKjyJc8UFkVfXuIH8oI3BjkTJy2DJc2E1nxee4RtZwe@qzhcFHgk4lPnd2dDZZLqxQbffwkOrc11vtbi/QlDnVsIW32ubAavIeMCYU1uAd7z/AXuCqXNKwEg/c91lGe4Aa1cAXIO76GPqcvkp3ZUFOLYX@iozZlG74GqCLjm4bZma3gM8K6OmoVzD7YvVgyz1XWd8q6Jugtu0JiX4ipmHIfFO3Ep2tHi73vHoQhXvB5IrVjETihTIS/DXOjtmV@950GkVpHcV12XTggwjKA@iOjfIJf0z5YyM7NqrFRXc7i3mQRKHadg3H7Wj/3813kAKfQpTKJ9XtYfT3upzliroJj9/3r7VvzD8T46YxaE9/0H/@/OK3evbdL6/dr@/fXDr@l53HofftnW2dPi1W47P4/OjXd8Fk9PBH68fvm7//U/SWH95@lf71U/fVF1d4TtCrWjy/StFncarAT9KoAf0KKOtLqGJYBVYyFeiApaxll3bNig8wnHHVw1W2oLt7lKQ12isXtnwBx0ocu9TH7r8BmwO6tfUBXeYkTaUavGfYcE5NdRu20dEgNLo6Maej5E2jFieLbmQNB1NL7I7rQEaw0B0Gj9xT/laed8xf52LgQXLCJcFe4ra5aLwXtc@4aLIXHdtctNiLOi4XZXvRqYPGeQjOE1GmkHPqcUEe2d8Ien7@Fw" rel="nofollow noreferrer" title="V (vim) – Try It Online">Copy+paste it online!</a> <br />
(Running &quot;Hello, world!&quot; takes something like half an hour, which is slightly longer than TIO's 60 second limit, so you'll have to run it on your own machine if you wanna do that)</p>
</div>
<div id="pu1" class="pu"><h1><a href="https://en.wikipedia.org/wiki/Turing_machine" rel="noreferrer">Turing machine</a> (finitely initialized, halts) implementing an encoding of <a href="https://esolangs.org/wiki/Grill_Tag" rel="noreferrer">Grill Tag</a>, 2 states, 14 symbols, 232 bytes</h1>
<p>We've had a few answers implementing Turing machines in various languages. Time to go the other way, and implement a language in a Turing machine. (A lot of time… I started working on this problem in 2019, and only proved Grill Tag, the implemented language, to be Turing-complete just now.)</p>
<pre><code>0 e e r 1
0 P p l 0
1 P p r 1
0 p P l 0
1 p q r 0
0 q P r 1
* &gt; &lt; r *
0 &lt; &gt; l 0
1 &lt; &lt; l 0
0 i a r 0
1 i &lt; l 1
0 I A r 0
1 I &lt; r 0
0 a x l 0
1 a i l 1
0 A X l 0
1 A I l 1
* X a r *
* x A r *
0 _ o l 0
1 _ _ l halt
0 o _ l 1
1 o A r 0
</code></pre>
<p><a href="http://morphett.info/turing/turing.html?a2b2c66cbda6a5b2ddce0476ac390bf3" rel="noreferrer">Try this program in an online simulator</a></p>
<p>Something that needs to be made clear, because the details can make a <em>huge</em> difference to the size of a universal Turing machine: the problem I'm solving here is the problem of creating a universal Turing machine where the program to implement is specified using a finitely initialized tape (i.e. all but finitely many cells are blank), and for which the Turing machine halts when the implemented program halts. It is possible for a Turing machine to be much smaller if, e.g., you allow for an infinite repeating pattern on the tape, and work out whether the program &quot;should have halted&quot; by inspecting the tape rather than by using a halt state, but that is effectively an entirely different problem (and both are interesting).</p>
<p>As far as I can tell, the previous record for a 2-state Turing machine was 18 symbols, so unless there's been some development I've missed since, this is a huge proportion golfed off a very long-standing mathematical problem.</p>
<p>You can encode a Grill Tag program and initial string into an initial tape for this Turing machine using <a href="https://tio.run/##LU@7CsJAEOzzFVOkkhRZtTsfYCEKFvYxdhaGFFpaCEFSmU5BVBQRLa2sjBaBmPgflx85706bYWZnmN31Rr4/E6IItvxxBfFnBM@xLbJsF0wTcgEwMoEsIrQUmuDPs8TPHUgTZdvgcWikMZCvOpLvhwMJnyXep2JxQ1tHe3UyZU3ToCyRmR0hX/P4ora48HQF0ltZmyH4KyqCQ39SBMefjjeQfMTA5HxaqjWkMn6p7ljxSpawapbMhRD/y4VD6hVLo/sF" rel="noreferrer" title="Jelly – Try It Online">this Jelly program</a> (the last line of output is the initial tape, the other lines are debug output). The program is specified in the RLE syntax, and its initial queue in JSON (with the head at the start of the array).</p>
<h2>Explanations</h2>
<h3>The implemented language</h3>
<h4>Grill Tag</h4>
<p><a href="https://esolangs.org/wiki/Grill_Tag" rel="noreferrer">Grill Tag</a> is a variant of <a href="https://en.wikipedia.org/wiki/Tag_system#Cyclic_tag_systems" rel="noreferrer">cyclic tag</a> in which all productions have an odd length, start and end with 0, and alternate between 0 and 1. In other words, the only valid productions are <code>0</code>, <code>010</code>, <code>01010</code>, <code>0101010</code>, and longer strings that follow the same pattern.</p>
<p>In case you don't know what cyclic tag is, the language works like this: there is a queue of bits, which handles all the data storage for the program; and a program, which runs in an infinite loop forever until/unless the queue becomes empty. Each program command, known as a &quot;production&quot;, dequeues a bit from the front of the queue, then enqueues either something (if a 1 bit was dequeued) or nothing (if a 0 bit was dequeued) to the back of the queue – the only freedom you have when writing the program is in specifying what exactly it is that gets enqueued. In the full version of cyclic tag, you can enqueue any arbitrary sequence of bits, but Grill Tag is restricted to using <code>010…010</code>-style sequences (&quot;grills&quot;) only.</p>
<p>Grill Tag is something that I've been looking at as a potential target for interpreter golf for several years now. However, back in 2019 when I created it, I wasn't able to determine whether or not it was Turing-complete; the language has a fundamental issue that make it very hard to program in (the number of 0s minus the number of 1s in any given string is equal to the number of 1s in the string that produced it, which means that programming in it requires controlling both the length and the 0/1 ratio of everything you use in order to keep control of which productions the 1s will expand).</p>
<p>I have very recently <a href="https://esolangs.org/wiki/Grill_Tag#Computational_class" rel="noreferrer">proven it Turing-complete</a>, via creating a Turing-complete language (<a href="https://esolangs.org/wiki/Genera_Tag" rel="noreferrer">Genera Tag</a>) in which you can write programs where every symbol expands in a very regimented way: every symbol always expands into two symbols in the next generation, each of those expands into another two symbols, and so on. Unfortunately, this construction tends to cause a useless explosion of no-ops (one no-op expands into two, then four, then eight, etc.) and makes programs run very slowly, but that is not an obstacle to Turing-completeness (and is <em>probably</em> not inherent in the language, but just trying to find anything that works was hard enough – I'm not immediately planning to go looking for something more efficient, even though it probably exists).</p>
<h4>A decomposition of Grill Tag</h4>
<p>As described above, Grill Tag has some fairly complex commands (&quot;pop, and conditionally append <code>…</code> if a 1 bit was popped&quot;). However, it is possible to break it down into smaller pieces, in a way that's quite suitable for a simple language like a Turing machine to handle.</p>
<p>The first observation (which is a standard transformation which I learned from <a href="https://esolangs.org/wiki/Bitwise_Cyclic_Tag" rel="noreferrer">Bitwise Cyclic Tag</a>) is that instead of appending to the end of the queue all in one go, it is instead possible to split it up and push bit by bit: &quot;dequeue a bit, and if it was a 0 bit, ignore any commands that would enqueue to the queue until the next bit is dequeued&quot;, &quot;enqueue a 0 bit&quot;, &quot;enqueue a 1 bit&quot;. The existence of the first command here effectively leads to two global states, which I think of as &quot;blocked&quot; and &quot;extending&quot;; in a blocked state, enqueuing commands do nothing, and in an extending state, they enqueue onto the back of the queue. This is still 3 commands, though, which is not ideal for implementing in a 2-state Turing machine (it's <em>possible</em>, but you need to add a lot of extra symbols to remember the half-command that you've seen already).</p>
<p>The second observation is that, in order to reach the far end of the queue, a Turing machine has to move its head over the entire queue as it does so (and generally speaking it's terser to have the &quot;growing&quot; end of the queue – the tail – at the opposite end from where the program is stored, so that it doesn't end up crashing into the program or forcing you to move the program out of the way). That gives it an opportunity to make simple changes as it goes, like, say, inverting the queue by flipping every bit in it. So instead of &quot;dequeue and possibly block&quot;, &quot;enqueue 0&quot;, &quot;enqueue 1&quot;, it's possible instead to use &quot;dequeue and possibly block&quot;, &quot;enqueue 1&quot;, &quot;invert the queue&quot; (with an enqueuing of 0 implemented as an invert, enqueueing of 1, and another invert).</p>
<p>Look at what happens when using this decomposition on grills, rather than arbitrary strings:</p>
<ul>
<li><code>0</code>: dequeue/block; invert; enqueue 1; invert</li>
<li><code>010</code>: dequeue/block; invert; enqueue 1; invert; enqueue 1; invert; enqueue 1; invert</li>
<li><code>01010</code>: dequeue/block; invert; enqueue 1; invert; enqueue 1; invert; enqueue 1; invert; enqueue 1; invert; enqueue 1; invert</li>
<li>etc.</li>
</ul>
<p>Every second command is an <code>invert</code> command, so they can be paired with the preceding (or subsequent) commands in order to create a language that has only two commands, rather than three. I chose to pair them with the subsequent commands, meaning that Grill Tag can be implemented using only two commands:</p>
<ul>
<li>invert, then dequeue/block</li>
<li>invert, then enqueue 1</li>
</ul>
<p>(These commands actually give you a little more power than Grill Tag has – I made a catalogue of &quot;languages that might be good to implement in low-powered languages and might be Turing-complete&quot; back in 2019, and codenamed the full version of this language <a href="https://esolangs.org/wiki/BIX_Queue_Subset#a_vd_vt" rel="noreferrer"><code>a vd vt</code></a>. The extra power of <code>a vd vt</code> is not needed, though, with Grill Tag being Turing-complete on its own.)</p>
<p>Now that there are only two commands, it is possible for the Turing machine to remember which command it is executing via using its two states – it no longer needs to store a &quot;half-command&quot; onto the tape to remember what it's doing.</p>
<p>In the next section, I discuss how <code>a vd vt</code> (thus Grill Tag) is implemented in the Turing machine.</p>
<h3>How the Turing machine works</h3>
<p>This is a program of two halves, each of which does something sensible in isolation: the &quot;left half&quot; that uses the four symbols <code>epPq</code>, and the &quot;right half&quot; that uses the other ten symbols (including the &quot;blank tape&quot; symbol). The left half stores the program; the right half stores the queue, and implements the logic of Grill Tag.</p>
<h4>Right half</h4>
<p>Let's look at the right half of the program first. This is an implementation of all of Grill Tag other than the routines for determining what the next Grill Tag command is (which are implemented by the left half of the program).</p>
<p>The part of the tape used by this half of the program consists of a section of <code>&lt;</code> and <code>&gt;</code> symbols, followed by the tape, and possibly an <code>o</code> at the end (and beyond that is blank tape forever). The queue is encoded very directly: the head of the queue is towards the left-hand side of the tape (with the tail being at the right-hand side), and uses states represented by capital letters to encode 1 bits and states represented by lowercase letters to encode 0 bits. This part of the program is, in effect, a state machine; it remembers which state it is in by using different pairs of symbols to represent the queue (either <code>iI</code>, <code>xX</code>, or <code>aA</code>).</p>
<p>The only requirement that the right half of the program makes on the left half is that it can ask for commands. To ask for a command, it moves the tape head to the left out of its own section of the program, in state 0. The left half of the program responds with a command, returning the tape head in state 1 for an &quot;invert and enqueue&quot; command, or state 0 for an &quot;invert and dequeue&quot; command. There are a couple of quirks:</p>
<ul>
<li>After a returning a 0 command, the next &quot;ask for a command&quot; must, instead of returning the next command in the program, unconditionally return in state 1.</li>
<li>Every second 0 command is implemented as unconditionally blocking the queue, rather than inverting and dequeuing a bit. This can be worked around by adding a sequence of dummy commands after each original 0 command: arbitrarily many 1 commands in the program, followed by one 0 command (to unblock the queue and dequeue the bit that should have been dequeued by the original 0 command).</li>
</ul>
<p>These quirks are present because they allow the Turing machine to be smaller, and the workarounds don't hurt its universality. (In fact, each of the quirks has positive (or at least simplifying) impacts on both halves of the Turing machine, which is something of an amazing coincidence.) The reasoning behind them, and the way that they benefit the construction, will be explained in the appropriate sections below.</p>
<p>Apart from storing the queue, the right half of the Turing machine is effectively just one state machine, with a few hardcoded states.</p>
<p>Below, I take a look at every state. If you'd prefer to read the description in Jelly rather than English (maybe to have something to compare the Turing machine to), I have <a href="https://tio.run/##rZPPahsxEMbv@xRz8MGBbfCaEEJy6KmUlt6SWylEXk3WirXSVtImMSXgQ299gkILoec@QE0PBUMexHkRd0a7rtf500vLsqy0mvn0@0ajc9R6ulrdzb4kJ2PloXK2cKIEGgp4X2ONIOpgSxGsgTAWAbwqay0CenjplNZwIgroCyOhtA6hQINOkCacCriQcBFOd1JQhbFOmQLwAt0UPOaWElxtwJ5BbsuS8j30tZogbYLQH6aQ7e3ASR2zSpGPlUGQFv3ObvKCpuADMXA6x98HJXqHlUOPJqAEwWZes1OQUyFVDlqZyW7yKnjQeBZAuKIuKZYTWW9dhaibArtTFOtUMe4Ec6QUoa3TbpIcR6bh7eywJSI5JTUegbNx6RHtylbx95lyPgBqjNKtr416AzFywpD3YFv7e7czsA4O6CPy3DpJ1dLTlP/hlSI792WYCMsqTO9mX5Pl/HPWg5jNQsv5x@WPb71reA6QLm7e0CDhvjheb9VxJW090vhspG0@QXn4pD@oTVCaqj@IZxKjJPNzJBqZ8sA88LV/O@sANp/B8uenHix@Aa92wPa3wP4z0Ujkkw3W8K9Ywy2sA8YqhZt0G5SKfxVoEzomFsoGWyk87Vj5E3oIytC9CQ9a4umuih4Ku0HPhk2rZHzSEqtGGeiuXPKlvhSP1aJjNubH5Gj4AzXJ4vt1Fz62/SXCeU193ACz2CNd3OX1Yup5R1ExEo9UiDIGG5R2QUDWLK4Vor3t4@H6MfJivrjhMRxlvS3EvX9C9IGuaoNDpTvaKm/bsNyZCRVitVq9zdIsHbRv8zyctaN3m2ie/QY" rel="noreferrer" title="Jelly – Try It Online">a Jelly implementation of the state machine</a> available (which implements the program queue itself rather than asking the left half of the tape).</p>
<h5>Idle</h5>
<pre><code>[head] &gt;&gt;&gt;…&gt;&gt;&gt;iIIii…Iii
</code></pre>
<p>The <strong>idle</strong> state happens a) at the start of the program, b) immediately after a 0 command. In this state, the right half of the Turing machine consists of an arbitrary number <code>&gt;</code> symbols, followed by the queue written with <code>iI</code> (which could be any combination of lowercase <code>i</code> and capital <code>I</code>, reflecting the 0 and 1 bits that make up the queue).</p>
<p>In this implementation, a 0 command does not actually dequeue the first bit of the queue immediately. Instead, it sets the state to <strong>idle</strong>, and then allows the implementation of the idle state to handle dequeuing the bit of the queue.</p>
<p>The <strong>idle</strong> state is intended to run immediately after a 0 command, at a time when the left half of the tape is unconditionally returning control in state 1 (rather than reading a command from the program); the Jelly implementation unconditionally rotates the program to emulate this. That means that the idle state will be entered in state 1 (and this is the reason why the &quot;always 1 after 0&quot; quirk is helpful to the right-hand half – it ensures that the <strong>idle</strong> state is entered with the Turing machine in the correct state, necessary because the <strong>idle</strong> state wouldn't work properly in Turing machine state 0).</p>
<p>The Turing machine proceeds to move along the row of <code>&gt;</code>, changing them to <code>&lt;</code> and remaining in state 1 (per the rules for <code>&gt;</code>). When it reaches the end of the row of <code>&gt;</code>, one of three things happens:</p>
<ul>
<li><p>The next symbol could be <code>i</code>. In this case, the <code>i</code> becomes <code>&lt;</code> and the head moves left, remaining in state 1. It will move to a <code>&lt;</code>, which remains as <code>&lt;</code>, moves the tape head to the left and changes to state 0. In state 0, the machine will change all the remaining <code>&lt;</code> back to <code>&gt;</code> and pass control to the left half in state 0.</p>
<p>The machine has dequeued a 0 from the queue (a lowercase letter became a filler symbol <code>&lt;</code>), and entered a <strong>double-blocked</strong> state (<code>&gt;&gt;&gt;…&gt;&gt;&gt;&lt;&lt;</code>). This dequeues a symbol (as required), and blocks the queue (also as required when a 0 bit is dequeued).</p>
</li>
<li><p>The next symbol could be <code>I</code>. In this case, the <code>I</code> becomes <code>&lt;</code>, the head moves to the right, and the Turing machine enters state 0. In state 0, <code>I</code> becomes <code>A</code> and <code>i</code> becomes <code>a</code>, with the head moving to the right over the entire queue; the queue is becoming active. When it reaches the end of the queue, the Turing machine is in <strong>mark as extending</strong> state. This dequeues a symbol (as required), and does not block the queue (as required when a 1 bit is dequeued). The <strong>mark as extending</strong> state will handle marking the queue as extending.</p>
</li>
<li><p>The queue could be empty – there might be no next symbol. In this case, beyond the last <code>&gt;</code> will be an empty portion of the tape. The rule for empty tape is to <strong>halt</strong> in state 1, and we will be in state 1, so this correctly emulates a halt; Grill Tag halts when the queue is empty, and so does the Turing machine.</p>
</li>
</ul>
<h5>Blocked and double-blocked</h5>
<pre><code>Blocked:
[head] &gt;&gt;&gt;…&gt;&gt;&gt;&gt;&lt;iIIii…Iii

Double-blocked:
[head] &gt;&gt;&gt;…&gt;&gt;&gt;&lt;&lt;iIIii…Iii
</code></pre>
<p>The <strong>blocked</strong> and <strong>double-blocked</strong> states are very similar to each other. They handle situations where enqueue commands should be ignored, either because a 0 was dequeued, or due to the quirk where every second 0 command unconditionally blocks the queue.</p>
<p>A <strong>double-blocked</strong> state effectively says &quot;the last 0 command blocked the queue, and the next 0 command should block the queue as well&quot; – this is used to remember the fact that after a &quot;regular&quot; block of the queue when a 0 command dequeues a 0 bit in <strong>idle</strong> state, a &quot;quirky&quot; block is required on the next 0. A <strong>blocked</strong> state is one in which the last 0 command blocked the queue, but the next 0 command should be processed normally. As such, a 0 command changes the state from <strong>double-blocked</strong> to <strong>blocked</strong> or <strong>blocked</strong> to <strong>idle</strong>. 1 commands are entirely ignored in this state, because its entire purpose is to discard inverts and enqueues.</p>
<p>The <strong>blocked</strong> and <strong>double-blocked</strong> states read commands from the program – they are entered from the left half of the program. When either state is initially entered, it will be after a 0 command was read, so there will be a spurious 1 command arriving – but that quirk is irrelevant here, because the states discard 1 commands anyway. So all they actually have to do is to wait for a 0 command, and then remove one blockage upon receiving it.</p>
<p>There are two possibilities for what could happen, because the left half of the program could give this half control in either state 0 or state 1. In either state, the machine moves along the row of <code>&gt;</code>, changing them to <code>&lt;</code>, while remaining in the same state. When it reaches the <code>&lt;</code>, there are two possibilities.</p>
<ul>
<li>In state 1, with a 1 command (or spurious-1-after-0) having been read from the program, the <code>&lt;</code> remains unchanged and moves the head back to the left in state 0 (as per the rules for <code>&lt;</code>). The rest of the row of <code>&gt;</code> will be flipped back to <code>&lt;</code>, and control will move to the left half of the program in state 0 (asking for a new program command). In other words, nothing changes other than a new command is being requested; in particular, the row of <code>&gt;</code> and <code>&lt;</code> ends up exactly as it started, so the machine will remain in <strong>blocked</strong> or <strong>double-blocked</strong> state (whichever it was in previously).</li>
<li>In state 0, with a 0 command having been read from the program, everything is <em>almost</em> the same as in state 1; however, the rule for <code>&lt;</code> in state 0 is to change to <code>&gt;</code> and remain in state 0 (rather than remaining as <code>&lt;</code> and changing to state 0). Thus, everything ends up the same, except that the machine has changed from <strong>double-blocked</strong> to <strong>blocked</strong> or <strong>blocked</strong> to <strong>idle</strong> state (because the only difference between the representation of those states is the number of <code>&lt;</code> at the rightmost end of the <code>&gt;</code>).</li>
</ul>
<h5>Mark as extending</h5>
<pre><code>&lt;&lt;&lt;…&lt;&lt;&lt;aAAaa…Aaa [head]
</code></pre>
<p>The <strong>mark as extending</strong> state is used to produce the correct representation of the queue for <strong>extending</strong> state. It is entered with the Turing machine in state 0, with the tape head in the blank space to the right of the tape.</p>
<p>This one works very simply: the rule for blank space (<code>_</code> in the notation used by the interpreter I chose) in state 0 is to write an <code>o</code>, then move the head to the left in state 0. <code>&lt;aA</code>'s rules for state 0 all move the head to the left, with <code>&lt;</code> becoming <code>&gt;</code>, <code>a</code> becoming <code>x</code>, and <code>A</code> becoming <code>X</code>. The content of the queue has remained unchanged, the head has moved to the left in state 0 (reading the next command) and now the machine is in <strong>extending</strong> state.</p>
<h5>Extending</h5>
<pre><code>[head] &gt;&gt;&gt;…&gt;&gt;&gt;xXXxx…Xxxo
</code></pre>
<p>The <strong>extending</strong> state is used to handle the &quot;invert&quot; half of commands, in cases where the queue is not blocked.</p>
<p>The <strong>extending</strong> state can be entered with the Turing machine in either state 0 or state 1 – a command has just been read from the program. The rules for <code>&gt;</code>, <code>x</code>, and <code>X</code> are basically the same between the two states: they leave the Turing machine in the same state, but otherwise the state doesn't matter (it's just remembered so that the <code>o</code> at the end of the tape knows which command to implement the second half of).</p>
<p><code>&gt;</code>, <code>x</code> and <code>X</code> all move the head to the right, in both state 0 and state 1. <code>&gt;</code> becomes <code>&lt;</code>; <code>x</code> becomes <code>A</code>; and <code>X</code> becomes <code>a</code>. This mapping of lowercase to capital and capital to lowercase letters is inverting the sense of the queue; 0 bits become 1 bits and vice versa. The machine is now in <strong>enqueue</strong> or <strong>stop extending</strong> state.</p>
<h5>Enqueue</h5>
<pre><code>&lt;&lt;&lt;…&lt;&lt;&lt;aAAaa…Aaao[head] in state 1
</code></pre>
<p>The <strong>enqueue</strong> state is entered from <strong>extending</strong> when a 1 command was read (and thus the Turing machine is in state 1), with the head over the <code>o</code> at the end of the tape. This is the simplest state in the entire machine, implemented by a single Turing machine transition: the <code>o</code> becomes an <code>A</code> (writing a capital letter at the end of the queue and thus enqueueing a 1 onto it), and the head moves to the right, onto the blank space beyond the queue. The Turing machine is now in <strong>mark as extending</strong> state, which will set the tape back to the format it was in before the &quot;invert and enqueue&quot; command ran – but the tape has now been inverted (because <strong>extending</strong> inverts the queue but <strong>mark as extending</strong> does not invert it back), and then an <code>A</code> (which becomes an <code>X</code> during <strong>mark as extending</strong>) was appended to the end.</p>
<h5>Stop extending</h5>
<pre><code>&lt;&lt;&lt;…&lt;&lt;&lt;aAAaa…Aaao[head] in state 0
</code></pre>
<p>The <strong>stop extending</strong> state has an identical tape to <strong>enqueue</strong>, and the head is likewise over the <code>o</code>, but the Turing machine is in a different state. The purpose of this state is to bridge between the &quot;invert&quot; and &quot;dequeue&quot; halves of an &quot;invert and dequeue&quot; command – the &quot;invert&quot; half leaves the head at the rightmost end of the tape, but the &quot;dequeue&quot; command needs the head at the left, so the <strong>stop extending</strong> state is used to move the head into the correct location and appropriately re-encode the queue as it goes.</p>
<p>First, the <code>o</code> at the end of the queue deletes itself (which is what the rules for <code>o</code> do in state 0), switching to state 1 and moving the head back onto the last <code>a</code>/<code>A</code>.</p>
<p>Then, the head moves back leftwards over the queue, remaining in state 1 (<code>a</code> and <code>A</code> leave the state the same), with <code>a</code> becoming <code>i</code> and <code>A</code> becoming <code>I</code> – the queue encoding is going back to the encoding used for <strong>idle</strong>.</p>
<p>When the head moves back to the <code>&lt;</code>, the logical thing to do (and the obvious thing to try to implement) would be to change the <code>&lt;</code> back to <code>&gt;</code>, and enter <strong>idle</strong> state (which implements the &quot;dequeue&quot; half of an &quot;invert and dequeue&quot; command). Unfortunately, golfing the Turing machine down to only 14 symbols ended up making the logical and obvious behaviour impossible to fit in, so the machine does something else instead; <code>&lt;</code> in state 1 remains <code>&lt;</code> and moves to the left, changing to state 0. The remaining <code>&lt;</code> do change back to <code>&gt;</code>, though (now that the machine is in state 0), so the resulting queue state consists of arbitrarily many <code>&gt;</code>, an <code>&lt;</code>, and the queue encoded with <code>iI</code> – in other words, this is <strong>blocked</strong> state!</p>
<p>This explains the quirk in which every second 0 command unconditionally blocks the queue, rather than doing an invert-and-dequeue like it's supposed to. If a 0 command runs when the queue is unblocked, then <strong>stop extending</strong> will end up inverting and then blocking the queue – it's the <em>next</em> 0 command that will actually do the dequeue (so the invert happens when it's supposed to, but the dequeue is delayed until the next 0 command). I couldn't find a terse way to avoid this behaviour. However, it was trivial to change the behaviour of a 0 command that blocks the queue to match (by making it double-block the queue rather than merely blocking it), in order to produce a construction in which every second block of 111…1110 in the program is consistently ignored (a quirk that is trivial to work around if you know it exists, simply by adding dummy commands).</p>
<p>That concludes the entire functionality of the right hand half of the program: enqueuing, dequeuing, inverting and halting. Apart from the weirdness of <strong>stop extending</strong> becoming <strong>blocked</strong> rather than <strong>idle</strong> (requiring a <strong>double-blocked</strong> state to compensate), everything is fairly straightforward and intuitive, and you can generally immediately understand what it's doing in the simulator.</p>
<p>Unfortunately, the left half will be a whole lot weirder and harder to understand – unlike the right half, it wasn't constructed, but rather discovered. Let's take a look at how it works.</p>
<h4>Left half</h4>
<h5>Low-level behaviour</h5>
<p>The left half of the program uses only 4 of the 14 symbols (<code>e</code>, <code>p</code>, <code>P</code>, <code>q</code>), and in fact only 6 of the 8 transitions are used (the other two do not have a rule defined because they never occur). Its purpose is to store the program, which it does by producing a specific, endlessly repeating stream of &quot;state 0&quot; and &quot;state 1&quot; signals; whenever the tape head enters it from the right (in state 0 – the right half always sets the state to 0 when giving the left half control), it will return the tape head to the right in either state 0 or state 1, whichever is the next element in the sequence.</p>
<p>First, let's take a look at what the rules actually do. The structure of the left half of the tape, when the tape head is outside it, is always of one of the following two forms (where <code>p</code> and <code>P</code> can be arbitrarily mixed):</p>
<pre><code>eppPp…PPpp
eppPp…PPpq
</code></pre>
<p>Let's consider the first of these forms, and what happens when the tape head enters it in state 0. While moving to the left, the behaviour is fairly simple; <code>p</code> becomes <code>P</code>, and vice versa, with the machine remaining in state 0. When it reaches the <code>e</code>, it changes to state 1 and moves back to the right.</p>
<p>When moving rightwards, things are more complex. A <code>P</code> becomes a <code>p</code>, moves to the right, and remains in state 1; in other words, it undoes the inversion that was done when moving to the left, restoring the symbol to its original state. However, a <code>p</code> has a much weirder rule: it becomes a <code>q</code> and moves to the right, while switching to state 0. This has the effect of inverting the symbol to the right (because both <code>p</code> and <code>P</code>, when encountered in state 0, invert), and moving back to the left, onto the <code>q</code>. The <code>q</code> then becomes <code>P</code> and moves to the right in state 1, as &quot;normal&quot;.</p>
<p>In other words, when moving to the right, <code>P</code> becomes <code>p</code>, and <code>p</code> inverts the symbol to the right and then becomes <code>P</code>. The result of this is that each cell, when the head leaves it, becomes set equal to the cumulative/running XOR of the original states (i.e. before they were inverted while moving to the left) of all the cells so far. This can be seen inductively. The base case is that the first cell starts out as the inversion of its original value, i.e. the XOR of all the cells so far, i.e. itself. For the inductive case, immediately before a cell changes to <code>P</code> (i.e. asserting that the XOR of all the cells so far was odd), it inverts the cell to its right, so it ends up being inverted three times and flipping (i.e. it was set to its original value XOR 1 = its previous value XOR that of all the cells to its left), whereas if a cell changes to <code>p</code>, the cell to its right is inverted only twice (leaving it at its original value, which must be the XOR of all the cells seen so far because the cells to its left XOR to 0).</p>
<p>People familiar with small Turing machines may be familiar with this general algorithm, of using a running XOR to store data. I learned about this pattern from <a href="https://en.wikipedia.org/wiki/Wolfram%27s_2-state_3-symbol_Turing_machine" rel="noreferrer">Wolfram's (2,3) Turing machine</a>, which is capable of doing a running-XOR and which uses this mechanism as its primary data storage. In fact, the rules used in this Turing machine were based on those from the (2,3) Turing machine, with all the relevant states and transitions being the same and used for the same purpose (the only difference is the addition of an <code>e</code> symbol to reflect the tape head, which is required because both transitions of the blank symbol are both being used for other purposes).</p>
<p>One quirk of this method of doing things is the way in which output is produced. When the last symbol becomes a <code>p</code> (i.e. all the symbols XOR to 0), the output uses a sensible protocol: it just reports the 1 via transferring control to the right half in state 1 (the state numbering is inverted, so a 1 command has to be stored as a 0 and vice versa, but this is not a significant issue because you can just invert the commands before encoding them). When the last symbol becomes a <code>P</code> (i.e. all the symbols XOR to 1), the head does indeed move to the right half in state 0, informing the right half of a 0 command – but this happens during the &quot;invert the next cell&quot; attempt, when the scan over the program storage has not yet finished. As a consequence, there is a <code>q</code> at the end of the program storage rather than a <code>P</code>. The next time control is transferred to the left half, it will finish the scan, changing to a <code>P</code> and transferring control to the right half in state 1 (which is the state that it would normally use to scan its next cell). The consequence is that each 0 is necessarily followed by a spurious 1. Fortunately, this quirk turned out to be easy to work around in the right-hand half of the program (and it actually simplifies the <strong>idle</strong> state a little, whilst not having negative consequences on anything else).</p>
<h5>Encoding a running-XOR storage</h5>
<p>Only one question remains: is it possible to encode a running-XOR storage such that iterating the running-XOR operation will produce any desired sequence of 0s and 1s?</p>
<p>The answer is &quot;not <em>any</em> sequence: there's a restriction&quot;. It turns out that the period of a running-XOR storage will always be a power of 2. However, it is possible to construct a running-XOR storage that outputs 0s and 1s in any arbitrary pattern whose period is any arbitrary power of 2. Fortunately, this is a trivial restriction to obey: a quirk in the right half of the program means that every second block of <code>0111…111</code> in the output gets entirely ignored, and it is possible to pad out any of these blocks by inserting extra 1s until the length of the program becomes a power-of-2 number of commands.</p>
<p>As for encoding the actual sequence, the encoding algorithm is a fairly simple recursive algorithm:</p>
<ul>
<li>The sequence [0] encodes as [0];</li>
<li>The sequence [1] encodes as [1];</li>
<li>Otherwise, split the sequence into two equal-length halves A and B, and concatenate (the encoding of A pointwise-xor B) with (the encoding of B).</li>
</ul>
<p>Proving that this works is a somewhat interesting induction, as the inductive hypothesis needs to include both the encoding rule itself, and the behaviour of a length-2<sup><em>n</em></sup> running-XOR memory if you invert all the storage cells (this causes the running-XOR memory to output the same period-2<sup><em>n</em></sup> sequence except that the last element in the sequence gets inverted). It is most intuitive to think of a running-XOR memory as a length-2<sup><em>n</em></sup> queue whose output is XORed with its input; when entering the memory normally, the last element is dequeued, and both output and enqueued back onto the queue; when entering the memory &quot;inverted&quot; (i.e. with the cells to its left XORing to 1), the last element is dequeued, inverted, and the inverted value is both output and enqueued back onto the queue. If you concatentate two such queues of length 2<sup><em>n</em></sup> together, then for 2<sup><em>n</em></sup> cycles, you get the XOR of the values dequeued from both queues, and after those cycles the later of the original queues has pointwise-XORed itself with the earlier (because the values it output were enqueued back onto it), whilst the earlier has its original values. The next 2<sup><em>n</em></sup> cycles will then output the XOR of the new values of the queues, i.e. the original value of the earlier queue XOR (the original value of the earlier queue XOR the original value of the later queue), which is just the original value of the later queue. Thus, concatenating a running-XOR memory representing A and a running-XOR memory of the same power-of-2 width representing B will output the sequence (A pointwise-XOR B) concatenate B (which is why the recursive encoding algorithm works).</p>
<h2>Conclusions</h2>
<p>This is a 2-state, 14-symbol strongly universal Turing machine (i.e. it starts from a finitely initialized tape and implements halting correctly). Finding small universal Turing machines is effectively a code golf problem, so it makes sense to post it on a code golf site.</p>
<p>Most of the machine actually functions fairly intuitively. The only confusing part is the running-XOR storage used for the program, but that can easily be encoded mechanically (and there is <a href="https://tio.run/##LU@7CsJAEOzzFVOkkhRZtTsfYCEKFvYxdhaGFFpaCEFSmU5BVBQRLa2sjBaBmPgflx85706bYWZnmN31Rr4/E6IItvxxBfFnBM@xLbJsF0wTcgEwMoEsIrQUmuDPs8TPHUgTZdvgcWikMZCvOpLvhwMJnyXep2JxQ1tHe3UyZU3ToCyRmR0hX/P4ora48HQF0ltZmyH4KyqCQ39SBMefjjeQfMTA5HxaqjWkMn6p7ljxSpawapbMhRD/y4VD6hVLo/sF" rel="noreferrer" title="Jelly – Try It Online">a program</a> to do it) – it's generally considered that as long as the encoding algorithm can be proven to always halt and produce a finite result, it counts. (I prefer for the encoding algorithms to be primitive recursive, so that you can easily tell how long the encoding to take, but this one is (and in fact runs in O(<em>n</em> log <em>n</em>) time, so is even pretty fast.)</p>
<p>There is still quite a bit of slack in this construction; I ended up not needing to use 2 of the 28 transitions that were available, and it seems likely that many small variations of this machine are also going to be strongly universal. In 2019, I catalogued a range of small programming languages that could be encoded into 2-state 14-symbol Turing machines (the &quot;Core <a href="https://esolangs.org/wiki/BIX_Queue_Subset" rel="noreferrer">BIX Queue Subsets</a>&quot;), although I didn't at the time mention what my motivation for selecting that particular set of languages was. <code>a vd vt</code> is not the only Core BIX Queue Subset that seems promising for Turing-completeness (although it did seem like the easiest to prove, and given that it took me almost 4 years, I have not been particularly inspired to try to work on one of the harder ones…); this Turing machine can easily be adapted to interpret any of the others.</p>
<p>I'd be interested to know whether anyone else has been trying to golf universal Turing machines recently (either strongly universal Turing machines like this one, or one of the less restrictive categories of universality). A quick search didn't turn up anything better for 2 states than 18 symbols, but it's quite possible that this sort of result would be in some obscure corner of the Internet that might be hard to find.</p>
</div>
<div id="pu2" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="noreferrer">Jelly</a> → <a href="https://esolangs.org/wiki/2C#Couplet_2C" rel="noreferrer">Couplet 2C</a> variant, 3 bytes (infinite loop) or 4 bytes (halting)</h1>
<pre><code>ṃVß
ṃV¥Ƭ
</code></pre>
<p><a href="https://tio.run/##y0rNyan8///hzuawQ0uPrfl/eHnk//9GRoaGIAwCRkYG/6MNdAwNdQzQIFDIyAhDFCiERe0ggrEA" rel="noreferrer" title="Jelly – Try It Online">Try it online!</a></p>
<p>Takes the initial string from the left-hand argument, and the replacement table from the right-hand argument (this is a map from numbers to strings encoded as a Jelly array, i.e. the element at index 1 is the key for value 1, and so on). Replacement strings are encoded as numbers in big-endian base <em>n</em>, where <em>n</em> is the size of the alphabet (which must be a power of 10).</p>
<p>The language implemented by this program is fairly powerful, and doesn't seem to <em>exactly</em> correspond to any of the existing languages, but is powerful enough to almost directly implement <a href="https://esolangs.org/wiki/2C#Couplet_2C" rel="noreferrer">Couplet 2C</a> via using replacement strings that consist of two copies of the same symbol (except at the end of the string, where they have an odd length), and using only symbols that have no leading zeroes. As such, it is trivially Turing-complete. The halt state is a &quot;trivial infinite loop&quot; (i.e. repeating a previous state) rather than having a separate halt symbol.</p>
<h2>Explanation</h2>
<pre><code>ṃVß   ṃV¥Ƭ
ṃ     ṃ      Convert {the left argument} into digits
               in base (element count of {the right argument}),
               then map them using {the right argument} as the map
 V     V     Concatenate the digits of the result
  ß          Recursive call to the main function
         Ƭ   Loop until a previous result is repeated
        ¥      over the previous two commands
</code></pre>
<p>Jelly's <code>ṃ</code> is powerful enough that there's more than one way to combine it with a single other built-in, and a loop, in order to create a Turing-complete language. In an earlier answer, I used <code>Ḍ</code>, which created a very powerful language but had trouble halting. Using <code>V</code> creates a different very powerful language which finds halting much easier.</p>
<p>The basic idea is that when the size of the replacement table is a power of 10, <code>ṃ</code> is effectively splitting a number into substrings of a given length, and mapping those substrings through the replacement table; then <code>V</code> concatenates the resulting substrings. This operation is pretty similar to that done by a tag system, but doesn't implement tag systems directly because it doesn't remember the length of the string across iterations (whereas in, say, 2-tag, a common programming technique is to create a string that's either an odd or an even number of characters long to change which commands run in the next iteration). You can implement Couplet 2C pretty easily, though, by using two copies of the same symbol and rebracketing them:</p>
<pre><code>xxyyzz0         string looks like this
x xy yz z0      using ṃ to convert into digits in base 100^n
aa bb cc dd0    using ṃ to map via a replacement table
aabbccdd0       using V to concatenate digits
</code></pre>
<p>The halt state of <code>Ƭ</code> – a repeat of a previous state – is a little tricky to achieve (and different from Couplet 2C's &quot;natural&quot; halt state), but by varying the behaviour of the end of the string it is possible to make it work. (One possible way to make the halt state work: compile a Turing machine into a cellular automaton into full 2C into Couplet 2C, and have the ends of the tape stay in a stable place by alternating between growing and shrinking, except when the tape head is there. This will quickly cause a halt of the Turing machine to enter a repeat of a previous state in the 2C program.)</p>
<p>One potential controversy with this answer: <code>V</code> in Jelly is overloaded: when acting on a list of numbers, it concatenates their digits; but when acting on a string, it is an <code>eval</code> function. It isn't being used as an <code>eval</code> function here, but it is still a little uncomfortable to use a builtin that is represented by the same character as the <code>eval</code> builtin (and I think internally Jelly implements it by concatenating the string representations of the numbers and then using an <code>eval</code> to convert the number from its string format to an actual number). I assume the question was intending to ban the use of <code>eval</code> to evaluate code, as opposed to parsing integers from strings, but it is possible that it ends up inadvertently disallowing this style of answer.</p>
</div>
<div id="pu3" class="pu"><h1><a href="https://github.com/Vyxal/Vyxal" rel="noreferrer">Vyxal</a> interpreting <a href="https://esolangs.org/wiki/Thue" rel="noreferrer">Thue</a> variant, 1 byte</h1>
<pre><code>¢
</code></pre>
<p><a href="https://vyxal.pythonanywhere.com/?v=2#WyIiLCIiLCLCoiIsIiIsIltcIjAqXCIgLCBcIjAqKlwiICwgXCJeXCJdXG5bXCIxXCIgICwgXCIqMFwiICAsIFwiXjBcIl1cblwiXjEwMTFcIiJd" rel="noreferrer">Try it Online!</a></p>
<p><code>¢</code> is a builtin that performs infinite replacement. When given a string <span class="math-container">\$s\$</span>, a list of targets <span class="math-container">\$[t_1, t_2 ... t_n] \$</span>, and a list of replacements <span class="math-container">\$[r_1, r_2 ... r_n]\$</span> it replaces <span class="math-container">\$t_1\$</span> with <span class="math-container">\$r_1\$</span>, <span class="math-container">\$t_2\$</span> with <span class="math-container">\$r_2\$</span> and so on, repeatedly, until no more replacements can be performed.</p>
<p>As it turns out, this is sufficient for Turing-Completeness as it can interpret a variant of <a href="https://esolangs.org/wiki/Thue" rel="noreferrer">Thue</a>. A Thue program consists of a series of replacement rules, which replace one string with another, and an initial string to which the replacements are performed.</p>
<p>The only difference between this language and Thue is that, while the Thue spec mandates a single replacement be performed at a time, this language performs as many replacements as possible in parallel. This turns out to be equivalent, though, as it can be treated as performing a series of replacements.</p>
<p>This language takes input as a list of replacement strings, a list of target strings, and the initial string on which replacements are to be performed. The TIO link contains a binary-to-unary converter.</p>
</div>
<div id="pu4" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="noreferrer">Jelly</a> → <a href="https://esolangs.org/wiki/Addition_Automaton" rel="noreferrer">Addition Automaton</a> with <em>b</em> = 10, 3 bytes</h1>
<pre><code>ṃḌç
</code></pre>
<p><a href="https://tio.run/##y0rNyan8///hzuaHO3oe7mw5vPz///9GBkZGRgYWRgYgYPY/2hBE6xjpQARMgGwgzwACgRwzEDYy0DGEMQxiAQ" rel="noreferrer" title="Jelly – Try It Online">Try it online!</a> (contains added <code>Ṅ</code> so that you can see the program being interpreted)</p>
<p>Me in 2018:</p>
<blockquote>
<p>Is three bytes possible? [...] at this point it surely seems like it'd be possible somehow, as there are so many ways to do it in four and so many Turing-complete languages you could implement.</p>
</blockquote>
<p>Five years later, I finally figured it out.</p>
<p>This program's first argument is the Addition Automaton initial value, and its second argument is the transition table (which is a map). Jelly uses 1-based indexing, so the entry for <em>d</em>=0 actually has to be at the end of the table rather than the start, but otherwise the map is just being specified directly by giving all the mapped-to values in order of the digits being mapped.</p>
<h2>Explanation</h2>
<pre><code>ṃḌç
ṃ    Convert {the left argument} into digits
       in base (element count of {the right argument}),
       then map them using {the right argument} as the map
 Ḍ   1 × the least significant digit, plus
       10 × the second-least significant digit, plus
       100 × the third-least significant digit, etc.
  ç  Recursive call, where the left argument is {the result of Ḋ}
       and the right argument is {this function's right argument}
</code></pre>
<p>Somehow it is not too much of a surprise that the three-byte breakthrough involved using <code>ṃ</code>, a built-in which a) has a very complicated effect and b) for which part of that effect involves indexing into a map/table. Being able to index into a table is the hardest part of implementing many Turing tarpits (not because it's hard, but because the other parts of implementing them are even easier), so finding this answer was a case of looking at what <code>ṃ</code> did and trying to find another builtin that would combine with it to produce a Turing-complete language. (And yes, Addition Automaton was originally discovered by trying to work out what <code>ṃḌ</code> did, although luckily the language as a whole has rather sensible behaviour that can be defined without having to resort to Jelly.)</p>
<p>Addition Automaton is basically defined as &quot;a find-and-replace on the digits of a number, but the replacements can be multiple digits long, and carry into the more significant digits as a consequence&quot;. This is actually a <em>very</em> powerful operation; if you allow bases <em>b</em> above 10, it is possible to implement Turing machines pretty much directly. However, the definition requires the two base conversions (into digits to do the mapping, and then back into a single number to handle the carry) to use the same base, whereas thus Jelly program uses the size of the map to do the first conversion and hardcodes the second base conversion to base 10. As such, the program only actually works when <em>b</em>=10; but fortunately, <em>b</em>=10 turns out to be just enough for Addition Automaton to be Turing-complete (it can implement <a href="https://esolangs.org/wiki/Echo_Tag" rel="noreferrer">Echo Tag</a> with arbitrary <em>n</em>, which is enough to implement arbitrary tag systems, and from there you can reach Turing machines).</p>
<p>The next challenge in writing very short interpreters in Jelly is likely to try to get them to halt. The effective halt state for this interpreter is &quot;the internal value repeats an older value times a power of 10&quot; – this is something that can be objectively defined, but would take quite a bit of code to implement in Jelly. In Addition Automaton, you have some amount of ability to trade simple halt states for small values of <em>b</em>; <em>b</em>=10 is enough to do things like <a href="https://tio.run/##y0rNyan8///hzuaHO6c93NFzcvqxNf///zcyAIL/0YYGOoYmOiZAygiIzQyAXAMdC5CohY6RjkEsAA" rel="noreferrer" title="Jelly – Try It Online">run 4-state 2-symbol busy beavers</a>, but the &quot;the value multiplies itself by <em>b</em> every cycle&quot; halt state used there is probably not achievable for arbitrary programs with a <em>b</em> as small as 10, and this program has a tendency to collapse into &quot;the binary builtins aren't chaining the way I want them to&quot; hell as soon as you start trying to use custom bases rather than sticking to decimal. So there's a lot of scope for creative solutions there, and Addition Automaton may well not be the best language for the &quot;exit when the implemented language halts&quot; version of the challenge.</p>
</div>
<div id="pu5" class="pu"><h1><a href="https://docs.python.org/3/" rel="nofollow noreferrer">Python 3</a> interpreting <a href="https://esolangs.org/wiki/I/D_machine" rel="nofollow noreferrer">I/D machine</a>, <s>88</s> 87 bytes</h1>

<pre class="lang-python prettyprint-override"><code>x=input()
l=[]
p=0
while 1:
&#9;for i in x:l+=[0];a=i=="I";print(l);l[p]+=1*a;p=l[p]*(a&lt;1)
</code></pre>
<p><a href="https://tio.run/##FcYxDoQgEAXQWk5BrEAbyXayv9uGMxAKCo2TTHBiMLqnx/iqJ/@67eXT2g0qclZjFSMmJZjUtREv2s2qW/dDk6ai75lHxCn5DAL60Hs5qFTD1nOUNMIN2QveDyZ/nW0t/MID" rel="nofollow noreferrer" title="Python 3 – Try It Online">Try it online!</a></p>

<p>This code probably can be golfed.</p>
<p>See <a href="https://codegolf.stackexchange.com/a/159493/106959">ais523's answer</a> for an explanation of how I/D machine works and why is it turing-complete.</p>
<h2>Ungolfed</h2>
<pre class="lang-python prettyprint-override"><code>x = input()
l = []
p = 0
while 1:
    for i in x:
        l += [0]
        a = i == &quot;I&quot;
        print(l)
        l[p] += 1 * a
        p = l[p] * (a &lt; 1)
</code></pre>
</div>
<div id="pu6" class="pu"><h1><a href="https://www.haskell.org/" rel="nofollow noreferrer">Haskell</a>, 50 bytes</h1>

<pre class="lang-hs prettyprint-override"><code>p#r=([p#(n*r`div`d)|(n,d)&lt;-p,n*r`mod`d&lt;1]++[r])!!0
</code></pre>
<p><a href="https://tio.run/##y0gszk7Nyfn/v0C5yFYjukBZI0@rKCElsywhRbNGI08nRdNGt0AHJJabn5KQYmMYq60dXRSrqaho8D83MTPPtqAoM69EQUUhWsNYx0gzVtlM4T8A" rel="nofollow noreferrer" title="Haskell – Try It Online">Try it online!</a></p>
<p>Implements <a href="https://wikipedia.org/wiki/fractran" rel="nofollow noreferrer">FRACTRAN</a>. Function (#) takes two arguments; a list of tuples containing the (numerator, denominator) pairs that specify a fractran program, and the input number</p>
</div>
<div id="pu7" class="pu"><h1><a href="https://github.com/Vyxal/Vyxal" rel="nofollow noreferrer">Vyxal</a> implementing &quot;add minimum to transpose&quot;, 4 bytes</h1>
<pre><code>{:g+
</code></pre>
<p><a href="https://vyxal.pythonanywhere.com/#WyIiLCIiLCJ7OmcrIiwi4oCmIiwiW1sxLDIsM10sWzE1LDEwLDVdLFsxMDAsMjAwLDMwMF1dIl0=" rel="nofollow noreferrer">Try it Online!</a> (prints each iteration)</p>
<pre><code>{    # Forever
   + # Add to each
 :g  # Corresponding element of minimum row
</code></pre>
<p>See <a href="https://codegolf.stackexchange.com/a/125815/100664">this answer</a> for a better explanation of why this is turing-complete.</p>
</div>
<div id="pu8" class="pu"><h1><a href="https://esolangs.org/wiki/Fish" rel="noreferrer">&gt;&lt;&gt;</a> interpreting &quot;Craw&gt;&lt;&gt;&quot;, 4 bytes</h1>
<pre><code>iiip
</code></pre>
<p><a href="https://tio.run/##S8sszvj/PzMzs@D/fwA" rel="noreferrer" title="&gt;&lt;&gt; – Try It Online">Try it online!</a></p>
<p>Craw&gt;&lt;&gt; is a language I just made up defined by the above implementation. It's almost obvious that you can translate all &gt;&lt;&gt; programs into Craw&gt;&lt;&gt;. Pretty sure someone had this idea before me.</p>
</div>
<div id="pu9" class="pu"><h1><a href="https://esolangs.org/wiki/Headass" rel="nofollow noreferrer">Headass</a> interpreting <a href="https://esolangs.org/wiki/Bitwise_Cyclic_Tag" rel="nofollow noreferrer">BCT</a>, 84 bytes</h1>
<pre><code>U[{U+)]ORO:RO};N-)-E:{UON)}:]+E.{UO+):};UP{N)UO}:E.U[{U+)]ORO:RO};UO^{N)UO}:D)E:]O[E
</code></pre>
<p><a href="https://replit.com/@thejonymyster/HA23" rel="nofollow noreferrer">Try it here!</a> Code will need to be copied, and executed like this:</p>
<pre><code>srun(&quot;U[{U+)]ORO:RO};N-)-E:{UON)}:]+E.{UO+):};UP{N)UO}:E.U[{U+)]ORO:RO};UO^{N)UO}:D)E:]O[E&quot;,&lt;your bct program here&gt;)
</code></pre>
<p>where the program is formatted as individual bits delimited by comma, and the code separated from the datastring by a -1. for example, the bct program <code>111000|111</code> would be executed like this:</p>
<pre><code>srun(&quot;U[{U+)]ORO:RO};N-)-E:{UON)}:]+E.{UO+):};UP{N)UO}:E.U[{U+)]ORO:RO};UO^{N)UO}:D)E:]O[E&quot;,1,1,1,0,0,0,-1,1,1,1)
</code></pre>
<p>The program prints bits deleted by the <code>0</code> command, but this can be disabled for -1 byte by removing the <code>P</code> in the program. Halts by throwing a Headass error.</p>
<p>I chose classic Headass over it's younger, ascii-based brother <a href="https://esolangs.org/wiki/Headass#Headascii" rel="nofollow noreferrer">Headascii</a> because it allowed me to take -1s as inputs, which is conveniently close to 0, as is 1.</p>
<p>Before I get into the explanation I just want to say that if I were allowed to choose a TC subset of this lang I'd be golden, having to validate the input cost me like 5 bytes T_T</p>
<h3>Code breakdown:</h3>
<pre><code>U[{U+)]ORO:RO};N-)-E:{UON)}:]+E     Block 0

U[                                  Store the first command
  {          }                      Loop
   U+)                              If the next number in the program is -1,
      ]O                              Push the stored command to the end of the
                                       program string
        RO                            Push the -1 to the end of the program string
          :   ;                       And then leave the loop
                                    Else
           RO                         Leave it alone and continue
               N-)                  If the data string is empty
                  -E                  Go to block -1 (exit with error)
                    :               Else
                     {UON)}:          Ready the rest of the data for the next block
                            ]+E       Then go to either block 1 or 2 based on if
                                       the stored command was 0 or 1 respectively

.{UO+):};UP{N)UO}:E                 Block 1 (handles 0)

.                                   Block separator
 {UO+):};                           Read through the numbers until after the -1 delimiter
         UP                         Print and discard the first bit of the data string
           {N)UO}:                  Ready the rest of the data for the next block
                  E                 Go to block 0

.U[{U+)]ORO:RO};UO^{N)UO}:D)E:]O[E  Block 2 (handles 1)

.                                   Block separator
 U[{U+)]ORO:RO};                    Same as in block 0
                UO^                 Store the first bit of the data string
                   {N)UO}:          Ready the rest of the data for the next block
                          D)        If the first bit of the data string is 0
                            E         Then go to block 0
                             :      Else
                              ]O      Push the stored bit from the command string
                                       to the end of the data string
                                [E    Go to block 0
</code></pre>
<p>My heftiest explanation yet. Whew!</p>
</div>
<div id="pu10" class="pu"><h1>Nim: <a href="https://esolangs.org/wiki/Three_Star_Programmer" rel="nofollow noreferrer">Three Star Programmer</a>, 138 bytes</h1>
<pre><code>import strutils
var
  r:array[100,int]
  p=readFile(readLine(stdin)).split('\n')
while 1&lt;0:
  for i in 0..&lt;p.len:r[r[r[p[i].parseInt]]]+=1
</code></pre>
<p>A simple implementation, with 100 memory locations, enough for demonstration purposes.</p>
</div>
<div id="pu11" class="pu"><h2>C (clang) interpreting Brainfuck, <s>187</s> 182 bytes</h2>

<pre class="lang-c prettyprint-override"><code>t[99],*p=t,c,i,l;f(*t){for(i=0;c=t[i];i++){c^62?c^60?c^43?c^45?c^46?c^44?c^91:(*p=getchar()):putchar(*p):--*p:++*p:--p:++p;if(c==93&amp;&amp;*p)for(l=1;l&gt;0;)c=t[--i],c==91?l--:c==93?l++:0;}}
</code></pre>
<p><a href="https://tio.run/##VY3RasQgEEWfm8/Yh0WjI0l3uxCN5gf6ByGFIDUV7Fa2lj6E/HpTJw0tveDxMFccCzaM12ldU980Ay@jTtxyz4NypEx0dm834nWlrE69H5RnjM726XLfZVQZ5xPiAXFBnDOaWpL80fSc7Mt4I5TK@PGjZaQSoIySsQwAlKi8I1br5nQ85h4XBl2rYCpFcSuAHzj2dRcA5PayC4zJSi3L@jr6K6HFXNw58nhgv@nNLuZvZrbT5sCQXRgm9kagCJy1LfsfYbYOtuxXFoPFgapiWb@sC@P0vsLnNw" rel="nofollow noreferrer" title="C (clang) – Try It Online">Try it online!</a></p>
</div>
<div id="pu12" class="pu"><h1>JavaScript: Lambda Calculus (<s>123</s> 114)</h1>

<p>Represented using Debruijn Indicies in Duples.</p>

<pre><code>V=function b(c,d){if(!isNaN(c)){for(;--c;)d=d[1];return d[0]}return 0==c[0]?e=&gt;b(c[1],[e,d]):b(c[0],d)(b(c[1],d))}
</code></pre>

<p>The S combinator is <code>[0, [0, [0, [[3, 1], [2, 1]]]]]</code></p>

<p>K is <code>[0, [0, 2]]</code></p>

<p>I is <code>[0, 1]</code></p>

<p>Edit: Shaved 9 bytes by replacing <code>"number"==typeof c</code> with <code>!isNaN(c)</code></p>
</div>
<div id="pu13" class="pu"><h1><a href="https://github.com/DennisMitchell/m" rel="noreferrer">M</a> → <a href="https://esolangs.org/wiki/Tip" rel="noreferrer">Tip</a>, 4 bytes</h1>

<pre><code>Ṅ×ịß
</code></pre>

<p><a href="https://tio.run/##y/3//@HOlsPTH@7uPjz/v6GlmZmBhbWhmfWRjdbGINrw8HaTQ0sUgGoUDi93UDD8DwA" rel="noreferrer" title="M – Try It Online">Try it online!</a></p>

<p>The TIO link adds a footer to call the function with the example Tip program shown on the Esolang page (M's "automatic wrapper" to call functions as though they were programs can't handle rational or fixed-point numbers, or at least I haven't figured out how to tell it how, so I need to make the function into a full program by hand to be able to run it.)</p>

<p>This actually prints useful debug output; the program can't be written in 3 bytes in M because a program consisting of exactly three dyads triggers a special case in the parser, so I had to add an extra command to avoid the special case. Making it <code>Ṅ</code> (print with newline) at least gives it a useful purpose.</p>

<p>Function submission, taking two arguments: the initial IP on the left, the program on the right. The program is 1-indexed (i.e. command 1 is the first command; M uses 1-indexing by default); goto commands are represented as M rationals, and the halt command as <code>ı</code> (i.e. the imaginary unit, \$i=\sqrt{-1}\$). </p>

<p>Does not implement I/O (other than halt/no-halt). I/O is an extension to Tip (not part of the language itself), and not required for Turing-completeness.</p>

<h2>Explanation/background</h2>

<pre><code>Ṅ×ịß
Ṅ     Print {the left argument} and a newline; also resolves a parser ambiguity
  ị   {The left argument}th element of {the right argument}, wrapping on OoB
 ×    Multiply {the left argument} by {the chosen element}
   ß  Recursive call; arguments: {the product} and {the same right argument}
</code></pre>

<p>I was reading through the answers to this entry and realised that iterated <a href="https://esolangs.org/wiki/Collatz_function" rel="noreferrer">Collatz functions</a>, which were used in <a href="https://codegolf.stackexchange.com/a/119506">quintopia's earlier answer</a>, would be fairly short to represent in golfing languages in which list indexing wraps by default (i.e. the fifth element of <code>[1,2,3]</code> is 2, because the list is being treated as <code>[1,2,3,1,<b>2</b>,3,1,2,3,…]</code>). So it's easy to extract a particular Collatz operation from a list in very few characters. Can we implement the Collatz operation easily? Well, a Collatz operation is \$rx+s\$, which is a polynomial, and the "base conversion" builtin that many golfing languages have is actually a general-purpose polynomial evaluator in disguise. So all we have to do is index into a list of lists of digits, base-convert them, and we're done, right?</p>

<p>Unfortunately, it's not that simple. The first problem is that although Collatz functions can be defined entirely in terms of integers, that requires a divmod to extract the new value of \$x\$ (the definition where \$x\$ is the same value that's used to index into the list of Collatz operations requires rationals). Well, we just need a golfing language that supports rationals, right? <a href="https://github.com/DennisMitchell/m" rel="noreferrer">M</a> is a Jelly derivative that supports many types of arbitrary-precision arithmetic, and arithmetic on the rationals is part of its arsenal of mathematical operators.</p>

<p>Then we get to the second problem: M's base-conversion builtin <code>ḅ</code> takes its arguments in the wrong order (it wants the list of digits to appear before the base). The problem with this is that M's default method of chaining together two binary operators given two arguments is \$x\oplus(x\otimes y)\$, and yet we'd want the Collatz operation (which can only fit the \$x\otimes y\$ part of this structure, as it's obtained by an index) to be on the <em>left</em> of the \${\oplus}\$. Sure, we could override the chaining behaviour to pretty much anything we want, but that would cost a whole byte, and the golfing language entries to this question are getting so short that a byte is a lot.</p>

<p>So I looked back and re-evaluated a bit. Are there any operations we could use instead of polynomial evaluation? Ideally, ones that are commutative, so we don't have to worry about argument order? Soon after that, I realised that Collatz functions are more complex than they need to be.</p>

<p>As a result, I created <a href="https://esolangs.org/wiki/Tip" rel="noreferrer">Tip</a>, a simplification/tarpit-ification of iterated Collatz functions in which \$s\$ is always 0, meaning that instead of a polynomial evaluation, we can perform the various operations via a simple multiplication. The language is more complex to prove Turing-complete than Collatz functions are, but it still has enough power to implement any program; there's a proof on the Esolang page.</p>

<p>And of course, unlike base conversion (<code>ḅ</code>), multiplication (<code>×</code>) is commutative, and thus it doesn't matter what order the arguments are placed in. So all we need to write is <code>×ị</code>, and then place the program into an infinite recursion with <code>ß</code>, and we have a Turing-complete language. Right?</p>

<p>Unfortunately, we run into a new problem. If a program starts with three binary operations, M engages in a special case that chains them as \$(x\odot y)\oplus(x\otimes y)\$ which is the worst possible structure for us, as it doesn't have the three nested function calls we'd need (index, multiply, and recursive call). So no matter what, we're going to need a fourth byte to disambiguate. <code>¹×ịß</code> (adding the identity function <code>¹</code> as a no-op so that the program doesn't <em>start with</em> three binary operators) does exactly what we'd need, causing them to nest inside each other in the way we want. We can use other operations in place of <code>¹</code>; <code>Ṅ</code> is a good choice because it produces useful debug output.</p>

<p>Is three bytes possible? Unless I'm missing something, not with this specific choice of implementing and implemented language, but at this point it surely seems like it'd be possible somehow, as there are so many ways to do it in four and so many Turing-complete languages you could implement.</p>
</div>
<div id="pu14" class="pu"><h1><a href="https://www.dyalog.com/" rel="nofollow noreferrer">APL (Dyalog)</a> → <a href="https://esolangs.org/wiki/Fractran" rel="nofollow noreferrer">Fractran</a> variant, 15 bytes</h1>



<pre class="lang-apl prettyprint-override"><code>(⊃0~⍨××0=1|×)⍣≡
</code></pre>

<p><a href="https://tio.run/##dY5BCsIwEEX3OcVftqDQJA1pFx6mIHVTULITxI0gKBS661rceAMPkJvkInEmqbhyMRnyZ@b93x2G9fbYDftdjH24TkW4X6pzGF9@9nO1kSc/l2F8htsjRkdzaQHbALIFlKaibklrTe4SVPRImkmTyxjh/JuOWxo0LFDXBNELgEEMZHg6ZEBNOsOEW7GvcCj@hFMllBCcrjYmX6cc0MD3uyRgx2SRZcsLKq3@bHpY9QE" rel="nofollow noreferrer" title="APL (Dyalog Unicode) – Try It Online">Try it online!</a></p>

<p>The function takes in the rationals as a list of numbers rather than two lists containing the numerator and the denominator, and outputs the result if the program ends. This implements a variant of Fractran that has the rational 1/1 (= 1) at the end of the program. The 1 has no effect on the Turing-completeness (as far as I understand) because the input to the program only lands on the 1 when none of the other rationals work, and when it does, the input is not changed. This is only used so that the function knows when to end.</p>

<p>The TIO link runs the function for 2 iterations (so that you can see the output as the program does not end) on the first input, and runs the second input until completion, after which it returns the output.</p>

<p><code>(⊃0~⍨××0=1|×)⍣≡</code> takes the list of rationals as the left argument, to be referred to as ⊣, and the input as the right argument, to be referred to as ⊢</p>

<p><code>(⊃0~⍨××0=1|×)</code> function train</p>

<ul>
<li><p><code>1|×</code> get the part after the decimal point (modulo 1) of the product <code>×</code> of ⊣ and ⊢</p></li>
<li><p><code>0=</code> does it equal 0?</p></li>
<li><p><code>××</code> multiply this result with ⊣ × ⊢, wherever the rational × ⊢ is not an integer, it is replaced with 0</p></li>
<li><p><code>0~⍨</code> remove all 0s</p></li>
<li><p><code>⊃</code> get the first element</p></li>
</ul>

<p><code>⍣</code> loop until <code>≡</code> input does not change, note that the result of <code>(⊃0~⍨××0=1|×)</code> is reused as the input, so if it stops changing (as a result of the 1 at the end) the program stops</p>
</div>
<div id="pu15" class="pu"><h1>C implementing the <a href="https://en.wikipedia.org/wiki/Wolfram%27s_2-state_3-symbol_Turing_machine" rel="nofollow noreferrer">(2,3) Turing Machine</a>, <s>236</s> 205 bytes (<s>46</s> 31 less if you don't care about awkward inputs)</h1>

<p>Thanks to Appleshell for -11 bytes, VisualMelon for -12 bytes, and Johan du Toit for -7 bytes.</p>

<p><em>CeilingCat made a version that uses only 144 bytes, see <a href="https://tio.run/##DY1LCsIwFADP0kUhnxdoY6vREDxIqVCSWC22hr7nSjx7zHYYZryavc/ZP6ZdJEAIg@5PIyx2nZ4bI/4NA9L@ihubIyFb44qRWIDOgO6PnPPRdcbe3ztLLshWGyvlYsmJpIoikmNaoSIuSKLszpCkY3irCtCqBXR4pVpfKqoPkD5lUBqc21/OTdP8AQ" rel="nofollow noreferrer">here</a>.</em> </p>

<p>(I've added a few line breaks here so you don't have to scroll, but normally most of those would be deleted)
</p>

<pre class="lang-c prettyprint-override"><code>#define c char
j;i;k;c s,d[256];c main(){c*p=d+128;gets(d);
for(;k&lt;256&amp;&amp;d[k];)d[k++]-=48;for(;++j&lt;256;)
{c t=*p;*p=-t*t+(2-s)*t+1+s;p+=(s^t==0)*2-1;s=s?t%2:!t%3;
for(i=0;++i&lt;256;)printf("%d",d[i]);puts("");}}
</code></pre>

<p><a href="https://tio.run/nexus/c-gcc#JY7NDoIwEITvPgViIC21Sak/Ia6ND0IwIS1oJUJD68nw2J5xlcvOJjPzZeaNaVrbN5GO9L0eVw@w0IGO/NaU8nCs8H3Wtif0rTOnDMtlAbcmeGIotMNIoDtjLE1N2VVA8TJWcbUvFpOxx88GbEdBZQ6QwUMWGJHcU9SceXBMEX8NSgmaSZ6DV/4SEnlah2T3x1glkGQXkhttH1oSJybGibai4F44J44pTNM8CyHmTz9wXet78wU" rel="nofollow noreferrer" title="C (gcc) – TIO Nexus">Try it online!</a></p>

<p>To use: Input a string of up to 256 ones, zeros, and twos to initialize the the tape. Any uninitialized values will be zero. (Values other than 0, 1, and 2 may cause undefined behavior.) The program will iterate over 256 steps. The number of steps it iterates over can be increased by modifying the code, but obviously that requires more characters.</p>

<p>It's a pretty long entry, but this is my first time doing one of these and I didn't use a dedicated golfing language. I had a lot of fun, even if it turned out longer than I expected. </p>

<p>A lot of the bytes are from dealing with input and output, and I lost a whole 42 bytes by making it accept 0, 1, and 2 instead of NUL, SOH, STX. (To change that, delete <code>k;</code> from the front and <code>for(;k&lt;256&amp;&amp;d[k];)d[k++]-=48;</code> from the second line.) </p>

<p>The transistion table, especially the line <code>*p=-t*t+(2-s)*t+1+s;</code> (which sets the values on the tape) could probably be compressed more as well.</p>
</div>
<div id="pu16" class="pu"><h1><a href="https://www.dyalog.com/" rel="nofollow noreferrer">APL (Dyalog Unicode)</a>, 15 <a href="https://codegolf.meta.stackexchange.com/a/9429/43319" title="When can APL characters be counted as 1 byte each?">bytes</a><sup><a href="https://github.com/abrudz/SBCS" rel="nofollow noreferrer" title=".dyalog files using a single byte character set">SBCS</a></sup></h1>



<p>Full program which implements a generalised one-dimensional cellular automaton executor. This includes <a href="https://en.wikipedia.org/wiki/Rule_110" rel="nofollow noreferrer">Rule 110</a> which is Turing complete. Prompts stdin for initial state, number of iterations (or <code>≡</code> to continue until stable or <code>{⍵≡⎕←⍺}</code> to display all intermediate values until stable), and rule-set.</p>

<pre class="lang-apl prettyprint-override"><code>⎕∊⍨∘(⊢∘⊂⌺3)⍣⎕⊢⎕
</code></pre>

<p><a href="https://tio.run/##SyzI0U2pTMzJT///qKM97f@jvqmPOroe9a541DFD41HXIiD1qKvpUc8uY81HvYtBskCxvqkgxf8VwCCNy0ABBg2hGEQawlkIHpjmMuHSAEtoKmiApYE0WCmUNgTTIHEA" rel="nofollow noreferrer" title="APL (Dyalog Unicode) – Try It Online">Try it online!</a> (4 iterations of Rule 110)</p>

<p><code>⎕</code> prompt for initial state and </p>

<p><code>⊢</code> yield that (separates the state from the number of iterations)</p>

<p><code>⍣⎕</code> prompt for number of iterations and apply the following function that many times:</p>

<p> <code>(</code>…<code>)</code> apply the following tacit function:</p>

<p>  <code>⌺3</code> get all length-3 neighbourhoods (with info on whether they are at the edge) and apply the following tacit function to each pair:</p>

<p>   <code>⊂</code> enclose the neighbourhood</p>

<p>   <code>∘</code> and</p>

<p>   <code>⊢</code> yield that (discarding the info about being at the edge)</p>

<p> <code>∘</code> then</p>

<p> <code>∊⍨</code> check if they are members of</p>

<p> <code>⎕</code> prompt for list of neighbourhoods leading to being on in the next iteration</p>
</div>
<div id="pu17" class="pu"><h1><a href="https://www.perl.org/" rel="noreferrer">Perl</a> <code>-a</code> → <a href="https://esolangs.org/wiki/I/D_machine" rel="noreferrer">I/D machine</a>, 24 bytes</h1>

<pre class="lang-perl prettyprint-override"><code>$p=$a[$p]+=$_ for@F;redo
</code></pre>
<p><a href="https://tio.run/##K0gtyjH9r6Jjq6SjoGRdnFjpkGitUqGtbWdooKaWWpFZYv1fpcBWJTFapSBW21YlXiEtv8jBzbooNSX//39jBSMFYwVTBQMwNAOx/uUXlGTm5xX/1030NdUzMDQAAA" rel="noreferrer" title="Perl 5 – Try It Online">Try it online!</a> (contains a header that prints the internal state and halts after 10 iterations, so that the behaviour is observable)</p>
<h2>About the language</h2>
<p>I've spent the past couple of days working on the <a href="https://esolangs.org/wiki/I/D_machine" rel="noreferrer">I/D machine</a>, one of my latest ideas for very simple programming languages. It works as follows: the data storage consists of an unbounded RAM, initially all zeros. Each element can store an unbounded integer (although in practice, most I/D machine programs will only store small integers in most of them, and make use of the unbounded integers only as a way of addressing cells with large addresses). There's also a data pointer, which points to a cell (i.e. holds the address as a cell); it's initially also zero.</p>
<p>There are only two commands:</p>
<ul>
<li><strong><code>I</code></strong>: Increment the cell the data pointer points to. (The data pointer itself remains unchanged.)</li>
<li><strong><code>D</code></strong>: Dereference the data pointer, i.e. read the value of the cell that the data pointer points to. Then store the resulting value that you read back into the data pointer.</li>
</ul>
<p>Execution simply runs the program in a loop repeatedly, forever.</p>
<p>It's fairly surprising that a language this simple is Turing-complete, so I've been working on proving that. <a href="https://esolangs.org/wiki/I/D_machine_Turing-completeness_proof" rel="noreferrer">Here's the proof</a>. It's pretty similar to (but simpler than) the proof for Three Star Programmer, a very similar language (and in fact, this submission uses the same basic OISC &quot;shell&quot; around the program, differing only in the actual instruction implemented).</p>
<h2>About the program</h2>
<h3>Usage</h3>
<p>The input should be given on standard input, and is an I/D machine program without comments, and using the RLE/OISC syntax. (The I/D machine has two different, equivalent syntaxes, but for golfiness this program only supports one of them.) In this syntax, a program is a sequence of numbers in decimal, representing the lengths of runs of <code>I</code> commands between <code>D</code> commands. (You can specify two or more consecutive <code>D</code> commands via placing a &quot;run of 0 <code>I</code> commands&quot; between them, so the syntax is fully general.)</p>
<h3>Explanation</h3>
<p>As can be seen from the program, this isn't implementing the <code>I</code> and <code>D</code> commands individually. In fact, it's a (very slightly) optimising interpreter (purely because it's shorter to write this way). The key is to see that a run of <em>n</em> increment commands increment the data pointer's target <em>n</em> times, i.e. add <em>n</em> to it; and a run of 0 increment commands can also be implemented this way, as adding 0 to memory has no effect. So the operation we actually implement is to alternate between implementing a run-of-<code>I</code>s and a <code>D</code>. Or in other words, &quot;add <em>n</em> to the value pointed to by the data pointer (storing it back in the value pointed to by the data pointer), then read the value pointed to by the data pointer and store it in the data pointer&quot;. That's clearly more verbose than it needs to be, and we can further simplify this to &quot;add <em>n</em> to the value pointed to by the data pointer, then store that value both in the data pointer's target and the data pointer itself&quot;.</p>
<p>So that makes for the core of our program. We're using an array <code>$a</code> to store the RAM, and <code>$p</code> as the data pointer (indexing into the array):</p>
<pre class="lang-perl prettyprint-override"><code>$p=$a[$p]+=$_
         + $_  add {the run length}
   $a[$p]      to the element of $a pointed to by $p
   $a[$p] =    storing the result back into that element
$p=            and also in the pointer itself
</code></pre>
<p>Conveniently, Perl interprets uninitialised array elements as 0 when they're treated like numbers, so the array will be lazily initialised to zeroes for us without any explicit code for that being needed. (One potential issue is numerical accuracy when the numbers get large; however, that'll only happen if the amount of the array being used exceeds the machine's address space (Perl integers are large enough to hold pointers), something that can't happen on an idealised machine.)</p>
<p>Finally, all we need to do is to place this program into a couple of loops. The <code>for@F</code> loop, combined with the <code>-a</code> command line option, will loop over the fields of standard input (the default definition of &quot;field&quot; here will split on whitespace). The <code>redo</code> loop will place the entire program in an implicit loop (other than, conveniently, the reading of standard input), which will cause the program to run in a loop repeatedly, as required by the semantics of the I/D machine.</p>
</div>
<div id="pu18" class="pu"><h1>x86 assembly (Intel syntax/MASM)-Brainfuck  2127 bytes.</h1>
<p>Still golf able</p>
<pre><code>.386
.model flat,stdcall
.stack 4096
include \masm32\include\masm32.inc
includelib \masm32\lib\masm32.lib
ExitProcess proto,dwExitCode:dword
.data
bfsrc BYTE 200 dup(0) 
bfcells BYTE 100 dup(0) 
loopStack DD 5 dup(0) 
charBuf BYTE 5 dup(0) 
newline BYTE 10,0 
prompt BYTE &quot;$&quot;,0 
hr BYTE 50 dup('-'),0 
space BYTE ' ',0
.code
EvalBf proc
    start:
    invoke StdOut, addr prompt
    invoke StdIn, addr bfsrc,200
    cmp bfsrc,0
    je exit
    mov eax,0 
    mov ebx,0 
    mov ecx,0 
    processInstruction:
    cmp BYTE PTR bfsrc[ebx], '+'
    je plus
    cmp BYTE PTR bfsrc[ebx], '-'
    je minus
    cmp BYTE PTR bfsrc[ebx], '&gt;'
    je fwd
    cmp BYTE PTR bfsrc[ebx], '&lt;'
    je back
    cmp BYTE PTR bfsrc[ebx], '['
    je open
    cmp BYTE PTR bfsrc[ebx], ']'
    je close
    cmp BYTE PTR bfsrc[ebx], '.'
    je dot
    jmp processNextInstruction
    plus:
    inc BYTE PTR bfcells[eax]
    jmp processNextInstruction
    minus:
    dec BYTE PTR bfcells[eax]
    jmp processNextInstruction
    fwd:
    inc eax
    jmp processNextInstruction
    back:
    dec eax
    jmp processNextInstruction
    open:
    mov loopStack[ecx*4],ebx
    inc ecx
    jmp processNextInstruction
    close:
    dec ecx
    cmp BYTE PTR bfcells[eax], 0
    je processNextInstruction
    mov ebx,loopStack[ecx*4]
    inc ecx
    jmp processNextInstruction
    dot:
    mov dl, BYTE PTR bfcells[eax]
    mov BYTE PTR charBuf[0], dl
    mov BYTE PTR charBuf[1],0anything
    push eax
    push ecx
    invoke StdOut, addr charBuf
    pop ecx
    pop eax
    jmp processNextInstruction
    processNextInstruction:
    inc ebx
    cmp BYTE PTR bfsrc[ebx], 0
    je done
    jmp processInstruction
    done:
    invoke StdOut, addr newline
    mov eax, 0
    printNext:
    cmp eax, 100
    jge reset
    push eax
    invoke dwtoa, BYTE PTR bfcells[eax], addr charBuf
    invoke StdOut, addr charBuf
    invoke StdOut, addr space
    pop eax
    inc eax
    jmp printNext
    reset:
    invoke StdOut, addr newline
    invoke StdOut, addr hr
    invoke StdOut, addr newline
    jmp start

    exit:
    invoke ExitProcess,0
EvalBf endp
end EvalBf
</code></pre>
</div>
<div id="pu19" class="pu"><h1>CJam → ResPlicate Variant, <s>15</s> <s>14</s> 13 bytes</h1>

<p><sup>-1 byte thanks to @ais523</sup></p>

<pre><code>l~{(/((*+e_}h
</code></pre>

<p>The variant is the same as the one in <a href="https://codegolf.stackexchange.com/a/119502/61384">this answer</a>, except that the number of items taken off the queue is one less than the top number on the queue.</p>

<p>The <code>l~{ ... }h</code> part just takes an array as input and repeats until that array is empty.</p>

<p>Explanation for the main loop:</p>

<pre><code>    e# Stack:             | [3 2 1 1 2 2 2 1]
(   e# Pop first element: | [2 1 1 2 2 2 1] 3
/   e# Split chunks:      | [[2 1 1] [2 2 2] [1]]
(   e# Pop first:         | [[2 2 2] [1]] [2 1 1]
(   e# Pop first:         | [[2 2 2] [1]] [1 1] 2
*   e# Repeat array:      | [[2 2 2] [1]] [1 1 1 1]
+   e# Concatenate:       | [[2 2 2] [1] 1 1 1 1]
e_  e# Flatten:           | [2 2 2 1 1 1 1 1]
</code></pre>
</div>
<div id="pu20" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="noreferrer">Jelly</a> → "Add minimum to transpose", <s>5</s> 4 bytes</h1>

<pre><code>+"Ṃẞ
</code></pre>

<p><a href="https://tio.run/##y0rNyan8/19b6eHOpv///0dHG@oY6RjH6kQbmuoYGuiYglgGBjpGQGxsYBAbCwA" rel="noreferrer" title="Jelly – Try It Online">Try it online!</a> (runs only one iteration, to avoid timeouts)</p>

<p>A very simple Turing-complete construction: we take a square matrix as a program, and loop forever, identifying the lexicographically smallest row, then increasing each element of the first row by the first element of the lexicographically smallest, each element of the second row by the second element of the lexicographically smallest, and so on. (The Jelly program is "<code>+"</code> add corresponding elements {of the input and} <code>Ṃ</code> the minimum {of original}, <code>ẞ</code> loop"; this is a byte shorter than my previous program <code>Z+ṂZß</code>, which did exactly the same thing. Clearly I should have focused on golfing the Jelly, not just golfing the implemented language.)</p>

<p>The resulting language is Turing-complete for much the same reason as <a href="https://esolangs.org/wiki/Kangaroo" rel="noreferrer">Kangaroo</a>. The first element of each row acts like a skip count (although instead of the skip count of each command reducing when it's skipped, we instead increase the skip count of each command when it's run, and look for the command with the lowest skip count rather than commands with zero skip counts; this comes to the same thing). We ensure that this first element is higher than the other elements (which represent the number of times each command appears in each command's multiset), thus ensuring that the  first row is never the minimum; the remainder of the first row can be garbage. The only remaining trouble is modelling the way that commands with equal skip count run cyclically in sequence, but we can do that by multiplying all the skip counts by a large constant, then adding on small "initial" skip counts to the first column to serve as a tiebreak. This gives us a tiebreak of "first nonskipped command runs", not "nonskipped commands run cyclically in sequence", but the Turing-completeness construction for Kangaroo does not care about this difference.</p>
</div>
<div id="pu21" class="pu"><h1><a href="https://github.com/JCumin/Brachylog" rel="noreferrer">Brachylog</a> (2) → <a href="https://en.wikipedia.org/wiki/Post_correspondence_problem" rel="noreferrer">Post correspondence problem</a>, 9 bytes</h1>

<pre><code>~h=∋ᵐ\cᵐ=
</code></pre>

<p><a href="https://tio.run/nexus/brachylog2#@1@XYfuoo/vh1gkxyUDC9v//6GilRCUdpaTERKVYHSA7CciBspOSwDJJSrGx/6MA" rel="noreferrer" title="Brachylog – TIO Nexus">Try it online!</a></p>

<p>Input is a list of lists of strings. (In the Post correspondence problem as defined on Wikipedia, the inner lists have two elements each, although this program can actually handle a generalisation to any number of elements.) This program brute-forces solutions to the problem, in order of length, until a solution is found. The Post correspondence problem is known to be able to simulate a Turing-machine, and thus brute-forcing solutions to it is Turing complete. If run as a function, rather than a program, it actually produces meaningful output as well.</p>

<p>The program in the TIO link above is <code>[["a","baa"],["ab","aa"],["bba","bb"]]</code>, which I copied from Wikipedia. The solution (which the program finds fairly quickly) is <code>["bbaabbbaa","bbaabbbaa"]</code>.</p>

<h2>Explanation</h2>

<p>This is pretty much just a direct translation of the Post correspondence problem to Brachylog.</p>

<pre><code>~h=∋ᵐ\cᵐ=
~h         Find {the shortest possible} list which starts with {the input}
  =        and for which all elements are equal
   ∋ᵐ      such that taking an element of each element,
     \cᵐ   and concatenating elements in corresponding positions,
        =  produces a list all of whose elements are equal.
</code></pre>

<p>Basically, we create a list that's repeated copies of the input (as few as possible, meaning that we don't miss any possibilities when brute-forcing), take one element from each copy, then concatenate corresponding elements (as in the Post correspondence problem).</p>
</div>
<div id="pu22" class="pu"><h2>Clojure, 75 bytes (Cyclic tag system)</h2>

<p>Update 1: replaced <code>some?</code> with <code>nil?</code>.</p>

<p>Update 2: Fixed a missing <code>S</code> in else branch of <code>if s</code>.</p>

<pre><code>#(loop[[p &amp; P](cycle %)[s &amp; S]%2](if(nil? s)S(recur P(if s(concat S p)S))))
</code></pre>

<p>Implements the <a href="http://esolangs.org/wiki/Cyclic_tag_system" rel="nofollow noreferrer">cyclic tag system</a>, returns <code>nil</code> if the program halts, loops forever otherwise. Clojure really shines here with infinite lazy sequences (such as <a href="https://clojuredocs.org/clojure.core/cycle" rel="nofollow noreferrer">cycle</a>) and <a href="https://clojure.org/guides/destructuring" rel="nofollow noreferrer">destructuring</a>. Ones and zeros are indicated as true and false values. When the data string runs out <code>s</code> becomes <code>nil</code>.</p>

<p>Ungolfed:</p>

<pre><code>(def f #(loop[[p &amp; P] (cycle %) [s &amp; S] %2 i 5]
          (do
            (pprint [p (concat [s] S)])
            (if (and (some? s) (pos? i))
              (recur P (if s (concat S p) S) (dec i))))))
</code></pre>

<p>Example results:</p>

<pre><code>(f [[false]] [true true])
[[false] (true true)]
[[false] (true false)]
[[false] (false false)]
[[false] (false)]
[[false] (nil)]

(f [[false true true] [true false] [true false true]] [true])
[[false true true] (true)]
[[true false]      (false true true)]
[[true false true] (true true)]
[[false true true] (true true false true)]
[[true false]      (true false true false true true)]
[[true false true] (false true false true true true false)]
</code></pre>
</div>
<div id="pu23" class="pu"><h1><a href="https://github.com/Phlarx/chip" rel="nofollow noreferrer">Chip</a>, 20+3 = 23 bytes (Rule 110)</h1>

<pre><code>AZZ
&gt;}/a
`)\'E~Zte*f
</code></pre>

<p>+3 for flag <code>-z</code></p>

<p><a href="https://tio.run/nexus/chip#@@8YFcVlV6ufyJWgGaPuWhdVkqqV9v@/IQgYAIGhgaHhf90qAA" rel="nofollow noreferrer" title="Chip – TIO Nexus">Try it online!</a></p>

<p>This submission isn't perfect, as Chip doesn't (yet) have any looping ability, so the output must be passed in as the input to simulate multiple generations, with <a href="https://tio.run/nexus/bash#TY49C8IwEIb3@xU3FNpYbBPXfoBDXd2LgyVNaKAkIY2Cov71Gquoz3DDHc/7Hu881uhOo2CMZnywWJYYN/tdPG/bFup73sGRHOLm0XqxknO4ACgv3FRtKJy7sYoSHjIiqUZBAAQfDEZhD9I4TBJd0UKXi1DoNCUEegP44a1bp7SXi4Q3zI31OR@UXUZmL7i@/v9HvvavqjdazOwFDTDK2BM" rel="nofollow noreferrer" title="Bash – TIO Nexus">something like this</a> (of course, you could run that loop indefinitely, and Chip can handle arbitrarily long input, so this combination is Turing Complete).</p>

<p>This implementation take input and given output in the form of ASCII <code>0</code>s and <code>1</code>s. The logic here is as follows:</p>

<pre><code>p := value of left neighbor cell    AZZ
q := value of current cell          AZ
r := value of right neighbor cell   A

q' := ((r xor q) and p) or          &gt;}/a
      ((r or q) and ~p)             `)\'
</code></pre>

<p>The remainder of the elements are for housekeeping: <code>e*f</code> causes ASCII numeral output, and <code>E~Zt</code> terminates execution two bytes after the input is exhausted (since the width grows by 2 each generation).</p>
</div>
<div id="pu24" class="pu"><h2>Clojure, <s>82</s> 81 bytes (Turing Machine)</h2>

<p>Update: removed a space from <code>t{} s</code>.</p>

<pre><code>#(loop[p 0 t{}s 1](if-let[[S M N](%[(or(t p)0)s])](recur(+ p M)(assoc t p S)N)t))
</code></pre>

<p>Implements the Turing Machine as a loop, returns the tape when the halting state is reached. In state transition rules this is indicated by ommitting the transition state. This settins <code>N</code> to <code>nil</code> and the subsequent <code>if-let</code> will abort as the corresponding state transition is not found from the input hash-map <code>%</code>. Actually any value for this state will do, such as <code>:abort</code>, 0 or -1.</p>

<p>Ungolfed with an example 3-state 2-symbol busy beaver from <a href="https://en.wikipedia.org/wiki/Turing_machine#Formal_definition" rel="nofollow noreferrer">Wikipedia</a>.</p>

<pre><code>(def f #(loop[pos 0 tape {} state 1]
          (if-let [[sym move next-state](%[(get tape pos 0)state])]
            (do (println [pos tape state])
                (recur(+ pos move)(assoc tape pos sym)next-state))
            tape)))

(f {[0 1] [1  1 2]
    [0 2] [1 -1 1]
    [0 3] [1 -1 2] 
    [1 1] [1 -1 3]
    [1 2] [1  1 2]
    [1 3] [1  1]})

{0 1, 1 1, -1 1, -2 1, -3 1, 2 1}
</code></pre>

<p><a href="https://tio.run/nexus/clojure#dc5BCoMwEAXQvaf4UAozFMHEc@jGZciiWANCMCFJV@LZ7VAslEpn@/78mZ0ek4PDhXwI0UQ0KOuGDGVpdrWfijEDOvSWroZCooLIDWfLltI0PhPdENEx3XMOI0QxcM@FmauKYpqX4heQw2oa6YRRgIK2Fb5HTL@tVhI6WfsxCf2gOkoFW3sy/fegOkplfZNX9/0F" rel="nofollow noreferrer">Try it online</a>.</p>

<p>On a single core of 6700K this runs the 5-state 2-symbol busy beaver (47.1 million steps) in about 29 seconds, or 1.6 million steps / second.</p>
</div>
<div id="pu25" class="pu"><h1>Lua interpreting Brainf***, 467 bytes</h1>

<pre><code>b,r,a,i,n,s=0,io.read,{0},1,1,"&gt;&lt;+-.,[]"c,f=r(),{function()n=n+1;a[n]=a[n]or 0;end,function()n=n-1;a[n]=a[n]or 0;end,function()a[n]=a[n]+1;end,function()a[n]=a[n]-1;end,function()io.write(string.char(a[n]))end,function()a[n]=io.read():byte()end,function()i=a[n]~=0 and i or c:find("]",i)end,function()if a[n]~=0 then b,x=1,""repeat i=i-1 x=c:sub(i,i)b=x=="["and b-1 or x=="]"and b+1 or b until b==0 and x=="["end end}repeat f[s:find(c:sub(i,i),1,1)]()i=i+1 until i&gt;#c
</code></pre>

<p>I know there's still some slimming down I can do later, but here's where my first pass ended. Takes the brainf code from standard input.</p>
</div>
<div id="pu26" class="pu"><h2>Clojure, 87 bytes (Rule 110)</h2>

<p>Credit for the <a href="https://codegolf.stackexchange.com/a/111732/59617">parity code</a> goes to Jens Renders! I was really struggling on how to express this and I was going to go with converting <code>[p q r]</code> from binary to an integer and use a lookup table.</p>

<pre><code>#(iterate(fn[S](for[[p q r](partition 3 1(concat[0]S[0]))](mod(+ q(* q(+ 1 p)r)r)2)))%)
</code></pre>

<p>Here <code>partition</code> and Clojure's destructuring makes the logic application quite simple. This function returns an infinite sequence of states, so the caller is responsible to <code>take</code> as many as they need or just <code>nth</code> to skip to a specific state. If paddings with zero were two elements instead of just one then the tape would constantly grow, avoiding boundary issues. Now it stays the original width.</p>

<p>Example:</p>

<pre><code>(def f #(iterate(fn[S](for[[p q r](partition 3 1(concat[0]S[0]))](mod(+ q(* q(+ 1 p)r)r)2)))%))

(pprint (take 5 (f '(0 0 0 0 0 1 1 1 0 0 1 0 0))))
((0 0 0 0 0 1 1 1 0 0 1 0 0)
 (0 0 0 0 1 1 0 1 0 1 1 0 0)
 (0 0 0 1 1 1 1 1 1 1 1 0 0)
 (0 0 1 1 0 0 0 0 0 0 1 0 0)
 (0 1 1 1 0 0 0 0 0 1 1 0 0))
</code></pre>
</div>
<div id="pu27" class="pu"><h1>BF/P" implemented in a Turing Machine, 842 bytes</h1>

<p><a href="https://pastebin.com/3bj1RSv1" rel="nofollow noreferrer">Transition table (linked because of length)</a></p>

<p><a href="https://pastebin.com/1Y4anzSa" rel="nofollow noreferrer">Transition table, less golfed version</a></p>

<p><a href="http://morphett.info/turing/turing.html" rel="nofollow noreferrer">Turing Machine simulator I used</a></p>

<p>This certainly isn't going to win any awards for length, but it's something I've always wanted to do, since BF is so similar to a Turing Machine. Each cell stores a value from <code>0x0</code>-<code>0xF</code>. The width is however far the Turing Machine website can go without crashing your browser. The <code>,</code> and <code>.</code> functions (input and output) are not defined, so it's a bit more like P" than true BF.</p>

<p>To run it, paste the transition table into the Turing Machine simulator, set the input to some BF code, and press run.</p>

<p>The tape of the TM stores both the BF code and the BF data, with a single space in the middle. It keeps track of its position in the code by modifying the character that it is currently running (<code>[</code> -> <code>(</code>, etc) and its position in the data with a <code>^</code> in front of the cell. Once it reads a command character, it moves until it hits the caret, moves one cell to the right, and performs the appropriate function. Then it goes back, looking for one of the "modified" command characters in the BF code, and moves on to the next one, repeating the whole process. Once it runs out of code, it halts. </p>

<p>The best way to understand how it works is by running the ungolfed version, putting it on step mode, and watching which lines lead to which others and what each state/block of lines does.</p>

<p>The golfed and ungolfed versions are exactly alike in terms of how they work, but the ungolfed version has more human-friendly names and is broken up into sections.</p>
</div>
<div id="pu28" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="noreferrer">Jelly</a> → <a href="https://en.wikipedia.org/wiki/Tag_system" rel="noreferrer">2-Tag system</a>, 8 bytes</h1>

<pre><code>µḢị⁴⁸;Ḋß
</code></pre>

<p><a href="https://tio.run/nexus/jelly#@39o68OdLQ93LHq4u/tR45ZHjTusH@7oOjz/////0YY6QBj7PzraSMc4VifaEITBQrEA" rel="noreferrer">Try it online!</a></p>

<p>I have a bounty going favouring practical languages, but thought I might as well try to win the original task while I was at it (as I can't exactly win my own bounty).</p>

<p>Implements a variant of tag systems with no halt state, as it isn't needed for Turing completeness. The states are numbered from 1, consecutively, and the initial string comes before the program.</p>

<p>For example, Wikipedia gives an example of a tag system {<code>a</code>,<code>b</code>,<code>c</code>}, {<code>a</code> → <code>bc</code>, <code>b</code> → <code>a</code>, <code>c</code> → <code>aaa</code>} with initial string <code>aaa</code>; in this input format, that's <code>[1,1,1]</code>, <code>[[2,3],[1],[1,1,1]]</code>. (Tag systems don't have a fixed syntax, and this seems like a reasonable way to do it.)</p>

<p>The TIO link has an added <code>Ṅ</code> ("write internal state and a newline to stdout") in order to show that the program is in fact working.</p>

<h2>Explanation</h2>

<pre><code>µḢị⁴⁸;Ḋß
           {implicit: initialise internal state from first argument}
µ          Disregard the second command-line argument by default
 Ḣ         Take the first element, removing it from the internal state
  ị⁴       Use the value to index into the second argument
    ⁸;     Prepend (the rest of) the internal state
      Ḋ    Discard the first element of the internal state
       ß   Loop forever
</code></pre>
</div>
<div id="pu29" class="pu"><h1><a href="https://esolangs.org/wiki/Collatz_function" rel="noreferrer">Iterated Generalized Collatz Functions</a> -> Python 2, 46 bytes</h1>

<pre><code>a,b,x,m=input()
while-~x%m:x=x/m*a[x%m]+b[x%m]
</code></pre>

<p>Call this function with a lists of m-1 a's and b's, the starting value x, and the divisor m, which collectively constitute a "program" for IGCF. Rather than taking a third array to indicate on which moduli to halt, this simply halts whenever the modulus is m-1. This simplification means it may take some extra effort to convert a given Fractran program into this variant, but it does save a couple of bytes in the interpreter.</p>

<p><a href="https://tio.run/nexus/python2#@5@ok6RToZNrm5lXUFqioclVnpGZk6pbV6Gaa1VhW6Gfq5UYDWTHaieBKeuCosy8EoWK//@jjWN1og1idczNzc10jAA" rel="noreferrer" title="Python 2 – TIO Nexus">Try it online!</a> This TIO demonstrates how to add 5+5 with this language. The program a=[3],b=[0],m=2 does addition, and starting with 7776=2^5*3^5 eventually yields 59049=3^10.</p>
</div>
<div id="pu30" class="pu"><h1><a href="https://esolangs.org/wiki/ResPlicate" rel="noreferrer">ResPlicate</a> variant -> Python 2, 47 bytes</h1>

<pre><code>l=input()
while l:l=l[2+l[0]:]+l[2:2+l[0]]*l[1]
</code></pre>

<p>This function interprets a variant of ResPlicate</p>

<ul>
<li>for which a program is a python list of even length with even elements at even indices.</li>
<li>with no I/O.</li>
<li>for which trying to copy more values than exist in the remainder of the queue simply copies the remainder of the queue (i.e., the copied bit is not padded with zeroes to the required length).</li>
</ul>

<p>The last change means that some ResPlicate programs (which meet the first condition) will not behave the same in this variant, but fortunately, the BCT interpreters do not require the removed functionality, and so the language remains TC.</p>

<p><a href="https://tio.run/nexus/python2#LYy9CsIwGAD3PEXolNQItoNIpIODiKCLjiFDqKn94MsPaYq@uHNV2uk4Dq5LwdEBnt4gBRdDyiV52I72xj/QJvZPoxNdMs5ySWgyMFh6fLc2ZgieFRmcpWHMBSfzht3Pp8PldhXLghODJjlW8Qkb8HHMjJNXD2gpSmxQ1StUGy31D7WcRZeoKr2PCXymOE1qK2qxE5VYqD8@rFvT9vYL" rel="noreferrer" title="Python 2 – TIO Nexus">Try it online!</a> This TIO has a print wedged into it to show that it works and a header that kills the program after 1 second and an example that manages to generate more output than TIO can handle in that one second.</p>
</div>
<div id="pu31" class="pu"><h1><a href="https://github.com/fergusq/roda" rel="nofollow noreferrer">Röda</a> implementing <a href="https://en.wikipedia.org/wiki/FRACTRAN" rel="nofollow noreferrer">Fractran</a>, <s>114</s> <s>112</s> 106 bytes</h1>

<p><em>1 byte saved thanks to @fergusq by rearranging parameters</em></p>

<pre><code>f&amp;n,a{x=1{x=0;(a/" ")()|[_/`/`]|[parseInteger(_[0],_1[1])]|{|q,w|{n*=q/w;x=1}if[n%w&lt;1,x&lt;1]}_,_}while[x&gt;0]}
</code></pre>

<p><a href="https://tio.run/nexus/roda#FYxBCoMwFET3PUUItGgJfL@puFC77xlCiFnEVmg/1RYiJDm7TRfzhgfD7NOJhA3bgDlVV1jgjJdFGZWBEUYd1duuH3ejr7u7tTCq0sKgQl3qGOIifAx0HhbwXb5I86To6HsUW486GWGSf8xPp7ZrpdP@sjOxcGCMhrbONTES/NI0ICVDBMwERCah/WudTfI8U6QPaf8B" rel="nofollow noreferrer" title="Röda – TIO Nexus">Try it online!</a></p>

<p>Call the function like so: <code>f reference_to_input program</code>. The output will be stored in the location of the <code>input</code>.</p>
</div>
<div id="pu32" class="pu"><h1>JavaScript interpreting <a href="https://en.wikipedia.org/wiki/Rule_110" rel="nofollow noreferrer">Rule 110</a>, 131 bytes (99 bytes?, 28 bytes?)</h1>

<pre><code>a=(p,q,r)=&gt;q+r+q*r+p*q*r
b=l=&gt;{r="";for(i=0;i&lt;l.length-2;i++)r+=a(l[i],+l[i+1],+l[i+2])%2;return r}
c=(l,n)=&gt;!n?l:c(b(0+l+0),n-1)
</code></pre>

<p>As you can see, the code defines 3 functions, <code>a</code>, <code>b</code> and <code>c</code>. Perhaps it's possible to save bytes by combining them in 1 function (I don't see how), but it's good that there separate because each of them already fulfills this challenge in some sense.</p>

<p>Function <code>a</code>takes 3 numbers as input and computes some weird polynomial of them. When these 3 numbers are <code>0</code>or <code>1</code>they can bee seen as Rule 110 cells. The parity of the output of <code>a</code> can then be seen as the value of the middle cell in the next generation. So in some sense, this simple function is already a Rule 110 'interpreter' (28 bytes):</p>

<pre><code>a=(p,q,r)=&gt;(q+r+q*r+p*q*r)%2
</code></pre>

<p>We can then create a new function <code>b</code> that evaluates <code>a</code> on every character of a string of ones and zeros. This <code>b</code>is then, in a better way than <code>a</code>, a Rule 110 interpreter. Taking mod 2 after the evaluation of a saves brackets (99 bytes):</p>

<pre><code>a=(p,q,r)=&gt;q+r+q*r+p*q*r
b=l=&gt;{r="";for(i=0;i&lt;l.length-2;i++)r+=a(l[i],+l[i+1],+l[i+2])%2;return r}
</code></pre>

<p>To actually compute a function with Rule 110, the user must specify the starting state and the number of generations after which the output will 'appear'. We can make a third function <code>c</code> that takes a string of ones and zeros, and a positive integer <code>n</code>, that then evaluates <code>b</code>on the string, <code>n</code>times. Like this we can really see Rule 110 as a programming language, where a program is an intitial state and a number <code>n</code>, and the output is the state after <code>n</code>generations. The function <code>c</code>is now an actual interpreter for that programming language so the final code for this challenge is what I presented above.</p>
</div>
<div id="pu33" class="pu"><h1><a href="https://www.perl.org/" rel="noreferrer">Perl</a> → <a href="http://esolangs.org/wiki/Three_Star_Programmer" rel="noreferrer">Three Star Programmer</a> variant, 26 + 1 = 27 bytes</h1>



<pre class="lang-perl prettyprint-override"><code>++$a[$a[$a[$_]]]for@F;redo
</code></pre>

<p><a href="https://tio.run/nexus/perl#U9GxVdJRULIuTqx0SLRWqdDWtjM0UFNLrcgssf6vra2SGA1F8bGxsWn5RQ5u1kWpKfn//xsqGCkYK5gomP7XTfQ11TMwNAAA" rel="noreferrer" title="Perl – TIO Nexus">Try it online!</a> (This link contains a header that exits the program after a set number of iterations (so that TIO doesn't time out), and to print the internal state every iteration (so that it does something observable).)</p>

<p>Run with <code>-a</code> (1 byte penalty, as you can fit it in before the <code>-M5.010</code> to produce <code>-aM5.010</code>).</p>

<p>Specifically, this implements Three Star Programmer in which commands are separated by spaces and no comments are allowed in the file, without I/O extensions. (These changes make no difference to the language's Turing-completeness, obviously.) There isn't a proof of Turing-completeness for Three Star Programmer online, but it is Turing-complete (I've been sharing a sketch proof of its Turing-completeness with other esoprogrammers, but stopped working on the language when I discovered that it was actually fairly easy to program in once you'd gotten over the original shock).</p>

<p>The program doesn't really need much explanation; Three Star Programmer has a very simple specification, and this is a direct translation of it. The only subtle points: <code>@F</code> is the input to the program in array form (this is a consequence of <code>-a</code>); and <code>redo</code> will repeat the entire program as it's in an implicit loop (also a consequence of <code>-a</code>).</p>
</div>
<div id="pu34" class="pu"><h1><a href="https://github.com/dloscutoff/pip" rel="noreferrer">Pip</a> interpreting <a href="http://esolangs.org/wiki/Cyclic_tag_system" rel="noreferrer">cyclic tag systems</a>, 16 bytes</h1>

<pre><code>YqWyyPBg@++vXPOy
</code></pre>

<p>Takes the productions of the tag system as command-line arguments and the initial data string from stdin.</p>

<p>The above code is kinda hard to verify because it doesn't produce any output (so the only observable behavior is "terminates" vs. "doesn't terminate"). Therefore, here's an ungolfed version that outputs the data string after each step, and also terminates after 20 steps so TIO doesn't have to deal with tons of output from infinite loops: <a href="https://tio.run/nexus/pip#@x9ZyBWuUGZjZKCgphBQyaVQqRDgpJDuoK1dphChEOBf@f@/4X8DQ8P/hgZAZAgA" rel="noreferrer" title="Pip – TIO Nexus">Try it online!</a></p>

<h3>Cyclic tag systems</h3>

<p>Cyclic tag systems are an extremely <a href="https://en.wikipedia.org/wiki/Tag_system#Cyclic_tag_systems" rel="noreferrer">simple yet Turing-complete</a> computational model. They consist of a list of <em>productions</em> that define operations on a <em>data string</em>. The productions and data string consist of 1's and 0's.</p>

<p>At each step, the leftmost character of the data string is removed.</p>

<ul>
<li>If the character is 1, the current production is appended to the right side of the data string.</li>
<li>If the character is 0, nothing is appended.</li>
</ul>

<p>In either case, the current production moves to the next production in the list, cyclically: if we were at the last production, we loop around to the first. Execution continues until the data string is empty.</p>

<h3>Explanation</h3>

<pre><code>                  g is list of cmdline args; v is -1 (implicit)
 q                Read a line of stdin for the data string
Y                 and yank it into the y variable
  Wy              While data string is nonempty:
       g@++v       Retrieve the next production from g (using cyclic indexing)
             POy   Pop the first character of y
            X      String-multiply: result is the production if the first character of y
                   was 1, or empty string if it was 0
    yPB            Push that string to the back end of y
</code></pre>
</div>
<div id="pu35" class="pu"><h1>Mathematica interpreting Conway's Game of Life, 64 bytes</h1>

<pre><code>CellularAutomaton@{224,{2,{t={2,2,2},{2,1,2},t}},{1,1}}~Nest~##&amp;
</code></pre>

<p><a href="https://en.wikipedia.org/wiki/Conway&#39;s_Game_of_Life" rel="noreferrer">Conway's Game of Life</a> is known to be Turing complete; and cellular automata are Stephen Wolfram's truest obsession. <code>CellularAutomaton@{224,{2,{t={2,2,2},{2,1,2},t}},{1,1}}</code> is a rule that transforms a two-dimensional array of 0s and 1s according to one step of Conway's Game of Life. (I think the default behavior is that this array wraps around its edges, so is really a discrete torus.) <code>~Nest~##&amp;</code> turns this rule into a function which, when given an initial board state (of any dimensions) and an integer <code>n</code> as arguments, outputs the result of <code>n</code> iterations of the Game of Life rule.</p>

<p>For your own enjoyment, you could use the wrapped version</p>

<pre><code>b = RandomInteger[1,{50,50}];
Manipulate[ArrayPlot[
  CellularAutomaton@{224,{2,{t={2,2,2},{2,1,2},t}},{1,1}}~Nest~##&amp;
    [b, n] ]
, {{n,0}, 0, 100, 1}]
</code></pre>

<p>and scroll your way through 100 generations on a 50x50 board.</p>
</div>
<div id="pu36" class="pu"><h1><a href="https://github.com/Destructible-Watermelon/Turtl-d" rel="nofollow noreferrer">Turtlèd</a> interpreting <a href="http://esolangs.org/wiki/Cyclic_tag_system" rel="nofollow noreferrer">CT</a>, 49 bytes</h1>

<p>I might be able to golf this</p>

<p>Also, this doesn't output anything useful. it just halts if and only if the given CT program halts.</p>

<p>this is one I made a while ago actually (then golfed some now)</p>

<pre><code>!-l[*+.r_]' !l[ l]r[ u.(;d' u)d(1[ r].[ l])( r)+]
</code></pre>

<h2>How it works:</h2>

<p>Turtlèd uses grid cells. When I say "write something on the grid" I mean that a contiguous group of characters is placed on the grid. example</p>

<pre><code>[ ][ ][ ][ ][ ][ ][ ]
[ ][H][E][L][L][O][ ]
[ ][ ][ ][ ][ ][ ][ ]
[ ][ ][ ][ ][ ][ ][ ]
</code></pre>

<p>onto the program</p>

<p>data is inputted first:</p>

<pre><code>!-l[*+.r_]' 
</code></pre>

<p>this is essentially a cat program. it writes the input onto the grid.</p>

<p>then the commands are inputted:</p>

<pre><code>!
</code></pre>

<p>what it does with these commands:</p>

<p>these commands are "productions". if the leftmost data bit is a 1, it copies the production onto the end of the data string. otherwise nothing happens. then the leftmost data bit is removed, and it uses the next production with the next left most data bit. the program halts when there are no bits in the data string. A way to do these productions is to deal with the bits and end of productions separately. this is what our program does. it separately copies bits from the command string on to the end of the data string, and separately deletes bits from the datastring</p>

<p>on to how this program does it. after inputting the commands, the turtle/grid pointer moves back to the leftmost bit of the datastring. it then goes into a loop</p>

<pre><code>[ u.(;d' u)d(1[ r].[ l])( r)+]
</code></pre>

<p>what it does in this loop, is it moves up from the leftmost datastring, and writes down the current command character (u.). if it is ;, the end of a production, it moves down and deletes the leftmost data bit beneath it and moves back up (<code>(;d' u)</code>). then, either way, it moves down one (<code>d</code>). if the bit there was not deleted, it means it must check whether to copy a bit from the commands at the end. so, if this character that is or was the leftmost databit is a 1, it will move to the end of the right end of the data string, copy the bit from the command string, and move back to the space left of the leftmost data bit (<code>(1[ r].[ l])</code>). now, it is either on the leftmost databit, which was a zero, or left of the leftmost databit. so, we move right if on a space (<code>( r)</code>). then, the command pointer is incremented so we will write down the next command in the next iteration of the loop. If there is no more datastring, this means we will be on a space and the loop will end. otherwise we rerun the loop.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/111278/">111278</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




