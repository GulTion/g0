<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::111278</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>003</td><td>Jelly → Addition Automaton with b = 10</td><td>230821T000214Z</td><td><a href="https://codegolf.stackexchange.com/questions/111278/turing-complete-language-interpreter/264429#264429">ais523</a></td></tr>
<tr d-ix="1"><td>087</td><td>Python 3 interpreting I/D machine</td><td>221215T025224Z</td><td><a href="https://codegolf.stackexchange.com/questions/111278/turing-complete-language-interpreter/255506#255506">Fmbalbue</a></td></tr>
<tr d-ix="2"><td>050</td><td>Haskell</td><td>220813T202307Z</td><td><a href="https://codegolf.stackexchange.com/questions/111278/turing-complete-language-interpreter/251064#251064">Benji</a></td></tr>
<tr d-ix="3"><td>004</td><td>Vyxal implementing "add minimum to transpose"</td><td>220606T103741Z</td><td><a href="https://codegolf.stackexchange.com/questions/111278/turing-complete-language-interpreter/248276#248276">emanresu</a></td></tr>
<tr d-ix="4"><td>004</td><td>><> interpreting "Craw><>"</td><td>220219T064407Z</td><td><a href="https://codegolf.stackexchange.com/questions/111278/turing-complete-language-interpreter/243067#243067">Twilight</a></td></tr>
<tr d-ix="5"><td>084</td><td>Headass interpreting BCT</td><td>220204T051625Z</td><td><a href="https://codegolf.stackexchange.com/questions/111278/turing-complete-language-interpreter/242335#242335">thejonym</a></td></tr>
<tr d-ix="6"><td>138</td><td>Nim Three Star Programmer</td><td>211013T072622Z</td><td><a href="https://codegolf.stackexchange.com/questions/111278/turing-complete-language-interpreter/236240#236240">Qaziquza</a></td></tr>
<tr d-ix="7"><td>182</td><td>C clang interpreting Brainfuck</td><td>170508T071401Z</td><td><a href="https://codegolf.stackexchange.com/questions/111278/turing-complete-language-interpreter/119524#119524">jdt</a></td></tr>
<tr d-ix="8"><td>114</td><td>JavaScript Lambda Calculus</td><td>190409T145342Z</td><td><a href="https://codegolf.stackexchange.com/questions/111278/turing-complete-language-interpreter/182909#182909">SYZYGY-D</a></td></tr>
<tr d-ix="9"><td>004</td><td>M → Tip</td><td>180712T130716Z</td><td><a href="https://codegolf.stackexchange.com/questions/111278/turing-complete-language-interpreter/168471#168471">ais523</a></td></tr>
<tr d-ix="10"><td>015</td><td>APL Dyalog → Fractran variant</td><td>180426T124028Z</td><td><a href="https://codegolf.stackexchange.com/questions/111278/turing-complete-language-interpreter/163444#163444">user4180</a></td></tr>
<tr d-ix="11"><td>031</td><td>C implementing the 2</td><td>170507T002605Z</td><td><a href="https://codegolf.stackexchange.com/questions/111278/turing-complete-language-interpreter/119342#119342">a52</a></td></tr>
<tr d-ix="12"><td>015</td><td>APL Dyalog Unicode</td><td>180416T090128Z</td><td><a href="https://codegolf.stackexchange.com/questions/111278/turing-complete-language-interpreter/162381#162381">Ad&#225;</a></td></tr>
<tr d-ix="13"><td>024</td><td>Perl a → I/D machine</td><td>180318T031349Z</td><td><a href="https://codegolf.stackexchange.com/questions/111278/turing-complete-language-interpreter/159493#159493">ais523</a></td></tr>
<tr d-ix="14"><td>2127</td><td>x86 assembly Intel syntax/MASMBrainfuck</td><td>170510T155959Z</td><td><a href="https://codegolf.stackexchange.com/questions/111278/turing-complete-language-interpreter/119941#119941">user6318</a></td></tr>
<tr d-ix="15"><td>013</td><td>CJam → ResPlicate Variant</td><td>170516T223009Z</td><td><a href="https://codegolf.stackexchange.com/questions/111278/turing-complete-language-interpreter/120967#120967">Esolangi</a></td></tr>
<tr d-ix="16"><td>004</td><td>Jelly → "Add minimum to transpose"</td><td>170611T081643Z</td><td><a href="https://codegolf.stackexchange.com/questions/111278/turing-complete-language-interpreter/125815#125815">user6213</a></td></tr>
<tr d-ix="17"><td>009</td><td>Brachylog 2 → Post correspondence problem</td><td>170517T005322Z</td><td><a href="https://codegolf.stackexchange.com/questions/111278/turing-complete-language-interpreter/120979#120979">user6213</a></td></tr>
<tr d-ix="18"><td>075</td><td>Clojure</td><td>170507T144009Z</td><td><a href="https://codegolf.stackexchange.com/questions/111278/turing-complete-language-interpreter/119410#119410">NikoNyrh</a></td></tr>
<tr d-ix="19"><td>nan</td><td>Chip</td><td>170511T221503Z</td><td><a href="https://codegolf.stackexchange.com/questions/111278/turing-complete-language-interpreter/120155#120155">Phlarx</a></td></tr>
<tr d-ix="20"><td>081</td><td>Clojure</td><td>170506T111716Z</td><td><a href="https://codegolf.stackexchange.com/questions/111278/turing-complete-language-interpreter/119246#119246">NikoNyrh</a></td></tr>
<tr d-ix="21"><td>467</td><td>Lua interpreting Brainf***</td><td>170508T180249Z</td><td><a href="https://codegolf.stackexchange.com/questions/111278/turing-complete-language-interpreter/119607#119607">Blab</a></td></tr>
<tr d-ix="22"><td>nan</td><td>Clojure</td><td>170508T153102Z</td><td><a href="https://codegolf.stackexchange.com/questions/111278/turing-complete-language-interpreter/119586#119586">NikoNyrh</a></td></tr>
<tr d-ix="23"><td>842</td><td>BF/P" implemented in a Turing Machine</td><td>170507T064220Z</td><td><a href="https://codegolf.stackexchange.com/questions/111278/turing-complete-language-interpreter/119362#119362">a52</a></td></tr>
<tr d-ix="24"><td>008</td><td>Jelly → 2Tag system</td><td>170508T044708Z</td><td><a href="https://codegolf.stackexchange.com/questions/111278/turing-complete-language-interpreter/119513#119513">user6213</a></td></tr>
<tr d-ix="25"><td>046</td><td>Iterated Generalized Collatz Functions > Python 2</td><td>170508T014155Z</td><td><a href="https://codegolf.stackexchange.com/questions/111278/turing-complete-language-interpreter/119506#119506">quintopi</a></td></tr>
<tr d-ix="26"><td>047</td><td>ResPlicate variant > Python 2</td><td>170508T010943Z</td><td><a href="https://codegolf.stackexchange.com/questions/111278/turing-complete-language-interpreter/119502#119502">quintopi</a></td></tr>
<tr d-ix="27"><td>106</td><td>Röda implementing Fractran</td><td>170506T125011Z</td><td><a href="https://codegolf.stackexchange.com/questions/111278/turing-complete-language-interpreter/119252#119252">user4180</a></td></tr>
<tr d-ix="28"><td>nan</td><td>JavaScript interpreting Rule 110</td><td>170228T222554Z</td><td><a href="https://codegolf.stackexchange.com/questions/111278/turing-complete-language-interpreter/111732#111732">Jens Ren</a></td></tr>
<tr d-ix="29"><td>nan</td><td>Perl → Three Star Programmer variant</td><td>170227T082621Z</td><td><a href="https://codegolf.stackexchange.com/questions/111278/turing-complete-language-interpreter/111479#111479">user6213</a></td></tr>
<tr d-ix="30"><td>016</td><td>Pip interpreting cyclic tag systems</td><td>170227T074315Z</td><td><a href="https://codegolf.stackexchange.com/questions/111278/turing-complete-language-interpreter/111469#111469">DLosc</a></td></tr>
<tr d-ix="31"><td>064</td><td>Mathematica interpreting Conway's Game of Life</td><td>170227T030027Z</td><td><a href="https://codegolf.stackexchange.com/questions/111278/turing-complete-language-interpreter/111454#111454">Greg Mar</a></td></tr>
<tr d-ix="32"><td>049</td><td>Turtlèd interpreting CT</td><td>170226T015135Z</td><td><a href="https://codegolf.stackexchange.com/questions/111278/turing-complete-language-interpreter/111297#111297">Destruct</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="nofollow noreferrer">Jelly</a> → <a href="https://esolangs.org/wiki/Addition_Automaton" rel="nofollow noreferrer">Addition Automaton</a> with <em>b</em> = 10, 3 bytes</h1>
<pre><code>ṃḌç
</code></pre>
<p><a href="https://tio.run/##y0rNyan8///hzuaHO3oe7mw5vPz///9GBkZGRgYWRgYgYPY/2hBE6xjpQARMgGwgzwACgRwzEDYy0DGEMQxiAQ" rel="nofollow noreferrer" title="Jelly – Try It Online">Try it online!</a> (contains added <code>Ṅ</code> so that you can see the program being interpreted)</p>
<p>Me in 2018:</p>
<blockquote>
<p>Is three bytes possible? [...] at this point it surely seems like it'd be possible somehow, as there are so many ways to do it in four and so many Turing-complete languages you could implement.</p>
</blockquote>
<p>Five years later, I finally figured it out.</p>
<p>This program's first argument is the Addition Automaton initial value, and its second argument is the transition table (which is a map). Jelly uses 1-based indexing, so the entry for <em>d</em>=0 actually has to be at the end of the table rather than the start, but otherwise the map is just being specified directly by giving all the mapped-to values in order of the digits being mapped.</p>
<h2>Explanation</h2>
<pre><code>ṃḌç
ṃ    Convert {the left argument} into digits
       in base (element count of {the right argument}),
       then map them using {the right argument} as the map
 Ḍ   1 × the least significant digit, plus
       10 × the second-least significant digit, plus
       100 × the third-least significant digit, etc.
  ç  Recursive call, where the left argument is {the result of Ḋ}
       and the right argument is {this function's right argument}
</code></pre>
<p>Somehow it is not too much of a surprise that the three-byte breakthrough involved using <code>ṃ</code>, a built-in which a) has a very complicated effect and b) for which part of that effect involves indexing into a map/table. Being able to index into a table is the hardest part of implementing many Turing tarpits (not because it's hard, but because the other parts of implementing them are even easier), so finding this answer was a case of looking at what <code>ṃ</code> did and trying to find another builtin that would combine with it to produce a Turing-complete language. (And yes, Addition Automaton was originally discovered by trying to work out what <code>ṃḌ</code> did, although luckily the language as a whole has rather sensible behaviour that can be defined without having to resort to Jelly.)</p>
<p>Addition Automaton is basically defined as &quot;a find-and-replace on the digits of a number, but the replacements can be multiple digits long, and carry into the more significant digits as a consequence&quot;. This is actually a <em>very</em> powerful operation; if you allow bases <em>b</em> above 10, it is possible to implement Turing machines pretty much directly. However, the definition requires the two base conversions (into digits to do the mapping, and then back into a single number to handle the carry) to use the same base, whereas thus Jelly program uses the size of the map to do the first conversion and hardcodes the second base conversion to base 10. As such, the program only actually works when <em>b</em>=10; but fortunately, <em>b</em>=10 turns out to be just enough for Addition Automaton to be Turing-complete (it can implement <a href="https://esolangs.org/wiki/Echo_Tag" rel="nofollow noreferrer">Echo Tag</a> with arbitrary <em>n</em>, which is enough to implement arbitrary tag systems, and from there you can reach Turing machines).</p>
<p>The next challenge in writing very short interpreters in Jelly is likely to try to get them to halt. The effective halt state for this interpreter is &quot;the internal value repeats an older value times a power of 10&quot; – this is something that can be objectively defined, but would take quite a bit of code to implement in Jelly. In Addition Automaton, you have some amount of ability to trade simple halt states for small values of <em>b</em>; <em>b</em>=10 is enough to do things like <a href="https://tio.run/##y0rNyan8///hzuaHO6c93NFzcvqxNf///zcyAIL/0YYGOoYmOiZAygiIzQyAXAMdC5CohY6RjkEsAA" rel="nofollow noreferrer" title="Jelly – Try It Online">run 4-state 2-symbol busy beavers</a>, but the &quot;the value multiplies itself by <em>b</em> every cycle&quot; halt state used there is probably not achievable for arbitrary programs with a <em>b</em> as small as 10, and this program has a tendency to collapse into &quot;the binary builtins aren't chaining the way I want them to&quot; hell as soon as you start trying to use custom bases rather than sticking to decimal. So there's a lot of scope for creative solutions there, and Addition Automaton may well not be the best language for the &quot;exit when the implemented language halts&quot; version of the challenge.</p>
</div>
<div id="pu1" class="pu"><h1><a href="https://docs.python.org/3/" rel="nofollow noreferrer">Python 3</a> interpreting <a href="https://esolangs.org/wiki/I/D_machine" rel="nofollow noreferrer">I/D machine</a>, <s>88</s> 87 bytes</h1>

<pre class="lang-python prettyprint-override"><code>x=input()
l=[]
p=0
while 1:
&#9;for i in x:l+=[0];a=i=="I";print(l);l[p]+=1*a;p=l[p]*(a&lt;1)
</code></pre>
<p><a href="https://tio.run/##FcYxDoQgEAXQWk5BrEAbyXayv9uGMxAKCo2TTHBiMLqnx/iqJ/@67eXT2g0qclZjFSMmJZjUtREv2s2qW/dDk6ai75lHxCn5DAL60Hs5qFTD1nOUNMIN2QveDyZ/nW0t/MID" rel="nofollow noreferrer" title="Python 3 – Try It Online">Try it online!</a></p>

<p>This code probably can be golfed.</p>
<p>See <a href="https://codegolf.stackexchange.com/a/159493/106959">ais523's answer</a> for an explanation of how I/D machine works and why is it turing-complete.</p>
<h2>Ungolfed</h2>
<pre class="lang-python prettyprint-override"><code>x = input()
l = []
p = 0
while 1:
    for i in x:
        l += [0]
        a = i == &quot;I&quot;
        print(l)
        l[p] += 1 * a
        p = l[p] * (a &lt; 1)
</code></pre>
</div>
<div id="pu2" class="pu"><h1><a href="https://www.haskell.org/" rel="nofollow noreferrer">Haskell</a>, 50 bytes</h1>

<pre class="lang-hs prettyprint-override"><code>p#r=([p#(n*r`div`d)|(n,d)&lt;-p,n*r`mod`d&lt;1]++[r])!!0
</code></pre>
<p><a href="https://tio.run/##y0gszk7Nyfn/v0C5yFYjukBZI0@rKCElsywhRbNGI08nRdNGt0AHJJabn5KQYmMYq60dXRSrqaho8D83MTPPtqAoM69EQUUhWsNYx0gzVtlM4T8A" rel="nofollow noreferrer" title="Haskell – Try It Online">Try it online!</a></p>
<p>Implements <a href="https://wikipedia.org/wiki/fractran" rel="nofollow noreferrer">FRACTRAN</a>. Function (#) takes two arguments; a list of tuples containing the (numerator, denominator) pairs that specify a fractran program, and the input number</p>
</div>
<div id="pu3" class="pu"><h1><a href="https://github.com/Vyxal/Vyxal" rel="nofollow noreferrer">Vyxal</a> implementing &quot;add minimum to transpose&quot;, 4 bytes</h1>
<pre><code>{:g+
</code></pre>
<p><a href="https://vyxal.pythonanywhere.com/#WyIiLCIiLCJ7OmcrIiwi4oCmIiwiW1sxLDIsM10sWzE1LDEwLDVdLFsxMDAsMjAwLDMwMF1dIl0=" rel="nofollow noreferrer">Try it Online!</a> (prints each iteration)</p>
<pre><code>{    # Forever
   + # Add to each
 :g  # Corresponding element of minimum row
</code></pre>
<p>See <a href="https://codegolf.stackexchange.com/a/125815/100664">this answer</a> for a better explanation of why this is turing-complete.</p>
</div>
<div id="pu4" class="pu"><h1><a href="https://esolangs.org/wiki/Fish" rel="noreferrer">&gt;&lt;&gt;</a> interpreting &quot;Craw&gt;&lt;&gt;&quot;, 4 bytes</h1>
<pre><code>iiip
</code></pre>
<p><a href="https://tio.run/##S8sszvj/PzMzs@D/fwA" rel="noreferrer" title="&gt;&lt;&gt; – Try It Online">Try it online!</a></p>
<p>Craw&gt;&lt;&gt; is a language I just made up defined by the above implementation. It's almost obvious that you can translate all &gt;&lt;&gt; programs into Craw&gt;&lt;&gt;. Pretty sure someone had this idea before me.</p>
</div>
<div id="pu5" class="pu"><h1><a href="https://esolangs.org/wiki/Headass" rel="nofollow noreferrer">Headass</a> interpreting <a href="https://esolangs.org/wiki/Bitwise_Cyclic_Tag" rel="nofollow noreferrer">BCT</a>, 84 bytes</h1>
<pre><code>U[{U+)]ORO:RO};N-)-E:{UON)}:]+E.{UO+):};UP{N)UO}:E.U[{U+)]ORO:RO};UO^{N)UO}:D)E:]O[E
</code></pre>
<p><a href="https://replit.com/@thejonymyster/HA23" rel="nofollow noreferrer">Try it here!</a> Code will need to be copied, and executed like this:</p>
<pre><code>srun(&quot;U[{U+)]ORO:RO};N-)-E:{UON)}:]+E.{UO+):};UP{N)UO}:E.U[{U+)]ORO:RO};UO^{N)UO}:D)E:]O[E&quot;,&lt;your bct program here&gt;)
</code></pre>
<p>where the program is formatted as individual bits delimited by comma, and the code separated from the datastring by a -1. for example, the bct program <code>111000|111</code> would be executed like this:</p>
<pre><code>srun(&quot;U[{U+)]ORO:RO};N-)-E:{UON)}:]+E.{UO+):};UP{N)UO}:E.U[{U+)]ORO:RO};UO^{N)UO}:D)E:]O[E&quot;,1,1,1,0,0,0,-1,1,1,1)
</code></pre>
<p>The program prints bits deleted by the <code>0</code> command, but this can be disabled for -1 byte by removing the <code>P</code> in the program. Halts by throwing a Headass error.</p>
<p>I chose classic Headass over it's younger, ascii-based brother <a href="https://esolangs.org/wiki/Headass#Headascii" rel="nofollow noreferrer">Headascii</a> because it allowed me to take -1s as inputs, which is conveniently close to 0, as is 1.</p>
<p>Before I get into the explanation I just want to say that if I were allowed to choose a TC subset of this lang I'd be golden, having to validate the input cost me like 5 bytes T_T</p>
<h3>Code breakdown:</h3>
<pre><code>U[{U+)]ORO:RO};N-)-E:{UON)}:]+E     Block 0

U[                                  Store the first command
  {          }                      Loop
   U+)                              If the next number in the program is -1,
      ]O                              Push the stored command to the end of the
                                       program string
        RO                            Push the -1 to the end of the program string
          :   ;                       And then leave the loop
                                    Else
           RO                         Leave it alone and continue
               N-)                  If the data string is empty
                  -E                  Go to block -1 (exit with error)
                    :               Else
                     {UON)}:          Ready the rest of the data for the next block
                            ]+E       Then go to either block 1 or 2 based on if
                                       the stored command was 0 or 1 respectively

.{UO+):};UP{N)UO}:E                 Block 1 (handles 0)

.                                   Block separator
 {UO+):};                           Read through the numbers until after the -1 delimiter
         UP                         Print and discard the first bit of the data string
           {N)UO}:                  Ready the rest of the data for the next block
                  E                 Go to block 0

.U[{U+)]ORO:RO};UO^{N)UO}:D)E:]O[E  Block 2 (handles 1)

.                                   Block separator
 U[{U+)]ORO:RO};                    Same as in block 0
                UO^                 Store the first bit of the data string
                   {N)UO}:          Ready the rest of the data for the next block
                          D)        If the first bit of the data string is 0
                            E         Then go to block 0
                             :      Else
                              ]O      Push the stored bit from the command string
                                       to the end of the data string
                                [E    Go to block 0
</code></pre>
<p>My heftiest explanation yet. Whew!</p>
</div>
<div id="pu6" class="pu"><h1>Nim: <a href="https://esolangs.org/wiki/Three_Star_Programmer" rel="nofollow noreferrer">Three Star Programmer</a>, 138 bytes</h1>
<pre><code>import strutils
var
  r:array[100,int]
  p=readFile(readLine(stdin)).split('\n')
while 1&lt;0:
  for i in 0..&lt;p.len:r[r[r[p[i].parseInt]]]+=1
</code></pre>
<p>A simple implementation, with 100 memory locations, enough for demonstration purposes.</p>
</div>
<div id="pu7" class="pu"><h2>C (clang) interpreting Brainfuck, <s>187</s> 182 bytes</h2>

<pre class="lang-c prettyprint-override"><code>t[99],*p=t,c,i,l;f(*t){for(i=0;c=t[i];i++){c^62?c^60?c^43?c^45?c^46?c^44?c^91:(*p=getchar()):putchar(*p):--*p:++*p:--p:++p;if(c==93&amp;&amp;*p)for(l=1;l&gt;0;)c=t[--i],c==91?l--:c==93?l++:0;}}
</code></pre>
<p><a href="https://tio.run/##VY3RasQgEEWfm8/Yh0WjI0l3uxCN5gf6ByGFIDUV7Fa2lj6E/HpTJw0tveDxMFccCzaM12ldU980Ay@jTtxyz4NypEx0dm834nWlrE69H5RnjM726XLfZVQZ5xPiAXFBnDOaWpL80fSc7Mt4I5TK@PGjZaQSoIySsQwAlKi8I1br5nQ85h4XBl2rYCpFcSuAHzj2dRcA5PayC4zJSi3L@jr6K6HFXNw58nhgv@nNLuZvZrbT5sCQXRgm9kagCJy1LfsfYbYOtuxXFoPFgapiWb@sC@P0vsLnNw" rel="nofollow noreferrer" title="C (clang) – Try It Online">Try it online!</a></p>
</div>
<div id="pu8" class="pu"><h1>JavaScript: Lambda Calculus (<s>123</s> 114)</h1>

<p>Represented using Debruijn Indicies in Duples.</p>

<pre><code>V=function b(c,d){if(!isNaN(c)){for(;--c;)d=d[1];return d[0]}return 0==c[0]?e=&gt;b(c[1],[e,d]):b(c[0],d)(b(c[1],d))}
</code></pre>

<p>The S combinator is <code>[0, [0, [0, [[3, 1], [2, 1]]]]]</code></p>

<p>K is <code>[0, [0, 2]]</code></p>

<p>I is <code>[0, 1]</code></p>

<p>Edit: Shaved 9 bytes by replacing <code>"number"==typeof c</code> with <code>!isNaN(c)</code></p>
</div>
<div id="pu9" class="pu"><h1><a href="https://github.com/DennisMitchell/m" rel="noreferrer">M</a> → <a href="https://esolangs.org/wiki/Tip" rel="noreferrer">Tip</a>, 4 bytes</h1>

<pre><code>Ṅ×ịß
</code></pre>

<p><a href="https://tio.run/##y/3//@HOlsPTH@7uPjz/v6GlmZmBhbWhmfWRjdbGINrw8HaTQ0sUgGoUDi93UDD8DwA" rel="noreferrer" title="M – Try It Online">Try it online!</a></p>

<p>The TIO link adds a footer to call the function with the example Tip program shown on the Esolang page (M's "automatic wrapper" to call functions as though they were programs can't handle rational or fixed-point numbers, or at least I haven't figured out how to tell it how, so I need to make the function into a full program by hand to be able to run it.)</p>

<p>This actually prints useful debug output; the program can't be written in 3 bytes in M because a program consisting of exactly three dyads triggers a special case in the parser, so I had to add an extra command to avoid the special case. Making it <code>Ṅ</code> (print with newline) at least gives it a useful purpose.</p>

<p>Function submission, taking two arguments: the initial IP on the left, the program on the right. The program is 1-indexed (i.e. command 1 is the first command; M uses 1-indexing by default); goto commands are represented as M rationals, and the halt command as <code>ı</code> (i.e. the imaginary unit, \$i=\sqrt{-1}\$). </p>

<p>Does not implement I/O (other than halt/no-halt). I/O is an extension to Tip (not part of the language itself), and not required for Turing-completeness.</p>

<h2>Explanation/background</h2>

<pre><code>Ṅ×ịß
Ṅ     Print {the left argument} and a newline; also resolves a parser ambiguity
  ị   {The left argument}th element of {the right argument}, wrapping on OoB
 ×    Multiply {the left argument} by {the chosen element}
   ß  Recursive call; arguments: {the product} and {the same right argument}
</code></pre>

<p>I was reading through the answers to this entry and realised that iterated <a href="https://esolangs.org/wiki/Collatz_function" rel="noreferrer">Collatz functions</a>, which were used in <a href="https://codegolf.stackexchange.com/a/119506">quintopia's earlier answer</a>, would be fairly short to represent in golfing languages in which list indexing wraps by default (i.e. the fifth element of <code>[1,2,3]</code> is 2, because the list is being treated as <code>[1,2,3,1,<b>2</b>,3,1,2,3,…]</code>). So it's easy to extract a particular Collatz operation from a list in very few characters. Can we implement the Collatz operation easily? Well, a Collatz operation is \$rx+s\$, which is a polynomial, and the "base conversion" builtin that many golfing languages have is actually a general-purpose polynomial evaluator in disguise. So all we have to do is index into a list of lists of digits, base-convert them, and we're done, right?</p>

<p>Unfortunately, it's not that simple. The first problem is that although Collatz functions can be defined entirely in terms of integers, that requires a divmod to extract the new value of \$x\$ (the definition where \$x\$ is the same value that's used to index into the list of Collatz operations requires rationals). Well, we just need a golfing language that supports rationals, right? <a href="https://github.com/DennisMitchell/m" rel="noreferrer">M</a> is a Jelly derivative that supports many types of arbitrary-precision arithmetic, and arithmetic on the rationals is part of its arsenal of mathematical operators.</p>

<p>Then we get to the second problem: M's base-conversion builtin <code>ḅ</code> takes its arguments in the wrong order (it wants the list of digits to appear before the base). The problem with this is that M's default method of chaining together two binary operators given two arguments is \$x\oplus(x\otimes y)\$, and yet we'd want the Collatz operation (which can only fit the \$x\otimes y\$ part of this structure, as it's obtained by an index) to be on the <em>left</em> of the \${\oplus}\$. Sure, we could override the chaining behaviour to pretty much anything we want, but that would cost a whole byte, and the golfing language entries to this question are getting so short that a byte is a lot.</p>

<p>So I looked back and re-evaluated a bit. Are there any operations we could use instead of polynomial evaluation? Ideally, ones that are commutative, so we don't have to worry about argument order? Soon after that, I realised that Collatz functions are more complex than they need to be.</p>

<p>As a result, I created <a href="https://esolangs.org/wiki/Tip" rel="noreferrer">Tip</a>, a simplification/tarpit-ification of iterated Collatz functions in which \$s\$ is always 0, meaning that instead of a polynomial evaluation, we can perform the various operations via a simple multiplication. The language is more complex to prove Turing-complete than Collatz functions are, but it still has enough power to implement any program; there's a proof on the Esolang page.</p>

<p>And of course, unlike base conversion (<code>ḅ</code>), multiplication (<code>×</code>) is commutative, and thus it doesn't matter what order the arguments are placed in. So all we need to write is <code>×ị</code>, and then place the program into an infinite recursion with <code>ß</code>, and we have a Turing-complete language. Right?</p>

<p>Unfortunately, we run into a new problem. If a program starts with three binary operations, M engages in a special case that chains them as \$(x\odot y)\oplus(x\otimes y)\$ which is the worst possible structure for us, as it doesn't have the three nested function calls we'd need (index, multiply, and recursive call). So no matter what, we're going to need a fourth byte to disambiguate. <code>¹×ịß</code> (adding the identity function <code>¹</code> as a no-op so that the program doesn't <em>start with</em> three binary operators) does exactly what we'd need, causing them to nest inside each other in the way we want. We can use other operations in place of <code>¹</code>; <code>Ṅ</code> is a good choice because it produces useful debug output.</p>

<p>Is three bytes possible? Unless I'm missing something, not with this specific choice of implementing and implemented language, but at this point it surely seems like it'd be possible somehow, as there are so many ways to do it in four and so many Turing-complete languages you could implement.</p>
</div>
<div id="pu10" class="pu"><h1><a href="https://www.dyalog.com/" rel="nofollow noreferrer">APL (Dyalog)</a> → <a href="https://esolangs.org/wiki/Fractran" rel="nofollow noreferrer">Fractran</a> variant, 15 bytes</h1>



<pre class="lang-apl prettyprint-override"><code>(⊃0~⍨××0=1|×)⍣≡
</code></pre>

<p><a href="https://tio.run/##dY5BCsIwEEX3OcVftqDQJA1pFx6mIHVTULITxI0gKBS661rceAMPkJvkInEmqbhyMRnyZ@b93x2G9fbYDftdjH24TkW4X6pzGF9@9nO1kSc/l2F8htsjRkdzaQHbALIFlKaibklrTe4SVPRImkmTyxjh/JuOWxo0LFDXBNELgEEMZHg6ZEBNOsOEW7GvcCj@hFMllBCcrjYmX6cc0MD3uyRgx2SRZcsLKq3@bHpY9QE" rel="nofollow noreferrer" title="APL (Dyalog Unicode) – Try It Online">Try it online!</a></p>

<p>The function takes in the rationals as a list of numbers rather than two lists containing the numerator and the denominator, and outputs the result if the program ends. This implements a variant of Fractran that has the rational 1/1 (= 1) at the end of the program. The 1 has no effect on the Turing-completeness (as far as I understand) because the input to the program only lands on the 1 when none of the other rationals work, and when it does, the input is not changed. This is only used so that the function knows when to end.</p>

<p>The TIO link runs the function for 2 iterations (so that you can see the output as the program does not end) on the first input, and runs the second input until completion, after which it returns the output.</p>

<p><code>(⊃0~⍨××0=1|×)⍣≡</code> takes the list of rationals as the left argument, to be referred to as ⊣, and the input as the right argument, to be referred to as ⊢</p>

<p><code>(⊃0~⍨××0=1|×)</code> function train</p>

<ul>
<li><p><code>1|×</code> get the part after the decimal point (modulo 1) of the product <code>×</code> of ⊣ and ⊢</p></li>
<li><p><code>0=</code> does it equal 0?</p></li>
<li><p><code>××</code> multiply this result with ⊣ × ⊢, wherever the rational × ⊢ is not an integer, it is replaced with 0</p></li>
<li><p><code>0~⍨</code> remove all 0s</p></li>
<li><p><code>⊃</code> get the first element</p></li>
</ul>

<p><code>⍣</code> loop until <code>≡</code> input does not change, note that the result of <code>(⊃0~⍨××0=1|×)</code> is reused as the input, so if it stops changing (as a result of the 1 at the end) the program stops</p>
</div>
<div id="pu11" class="pu"><h1>C implementing the <a href="https://en.wikipedia.org/wiki/Wolfram%27s_2-state_3-symbol_Turing_machine" rel="nofollow noreferrer">(2,3) Turing Machine</a>, <s>236</s> 205 bytes (<s>46</s> 31 less if you don't care about awkward inputs)</h1>

<p>Thanks to Appleshell for -11 bytes, VisualMelon for -12 bytes, and Johan du Toit for -7 bytes.</p>

<p><em>CeilingCat made a version that uses only 144 bytes, see <a href="https://tio.run/##DY1LCsIwFADP0kUhnxdoY6vREDxIqVCSWC22hr7nSjx7zHYYZryavc/ZP6ZdJEAIg@5PIyx2nZ4bI/4NA9L@ihubIyFb44qRWIDOgO6PnPPRdcbe3ztLLshWGyvlYsmJpIoikmNaoSIuSKLszpCkY3irCtCqBXR4pVpfKqoPkD5lUBqc21/OTdP8AQ" rel="nofollow noreferrer">here</a>.</em> </p>

<p>(I've added a few line breaks here so you don't have to scroll, but normally most of those would be deleted)
</p>

<pre class="lang-c prettyprint-override"><code>#define c char
j;i;k;c s,d[256];c main(){c*p=d+128;gets(d);
for(;k&lt;256&amp;&amp;d[k];)d[k++]-=48;for(;++j&lt;256;)
{c t=*p;*p=-t*t+(2-s)*t+1+s;p+=(s^t==0)*2-1;s=s?t%2:!t%3;
for(i=0;++i&lt;256;)printf("%d",d[i]);puts("");}}
</code></pre>

<p><a href="https://tio.run/nexus/c-gcc#JY7NDoIwEITvPgViIC21Sak/Ia6ND0IwIS1oJUJD68nw2J5xlcvOJjPzZeaNaVrbN5GO9L0eVw@w0IGO/NaU8nCs8H3Wtif0rTOnDMtlAbcmeGIotMNIoDtjLE1N2VVA8TJWcbUvFpOxx88GbEdBZQ6QwUMWGJHcU9SceXBMEX8NSgmaSZ6DV/4SEnlah2T3x1glkGQXkhttH1oSJybGibai4F44J44pTNM8CyHmTz9wXet78wU" rel="nofollow noreferrer" title="C (gcc) – TIO Nexus">Try it online!</a></p>

<p>To use: Input a string of up to 256 ones, zeros, and twos to initialize the the tape. Any uninitialized values will be zero. (Values other than 0, 1, and 2 may cause undefined behavior.) The program will iterate over 256 steps. The number of steps it iterates over can be increased by modifying the code, but obviously that requires more characters.</p>

<p>It's a pretty long entry, but this is my first time doing one of these and I didn't use a dedicated golfing language. I had a lot of fun, even if it turned out longer than I expected. </p>

<p>A lot of the bytes are from dealing with input and output, and I lost a whole 42 bytes by making it accept 0, 1, and 2 instead of NUL, SOH, STX. (To change that, delete <code>k;</code> from the front and <code>for(;k&lt;256&amp;&amp;d[k];)d[k++]-=48;</code> from the second line.) </p>

<p>The transistion table, especially the line <code>*p=-t*t+(2-s)*t+1+s;</code> (which sets the values on the tape) could probably be compressed more as well.</p>
</div>
<div id="pu12" class="pu"><h1><a href="https://www.dyalog.com/" rel="nofollow noreferrer">APL (Dyalog Unicode)</a>, 15 <a href="https://codegolf.meta.stackexchange.com/a/9429/43319" title="When can APL characters be counted as 1 byte each?">bytes</a><sup><a href="https://github.com/abrudz/SBCS" rel="nofollow noreferrer" title=".dyalog files using a single byte character set">SBCS</a></sup></h1>



<p>Full program which implements a generalised one-dimensional cellular automaton executor. This includes <a href="https://en.wikipedia.org/wiki/Rule_110" rel="nofollow noreferrer">Rule 110</a> which is Turing complete. Prompts stdin for initial state, number of iterations (or <code>≡</code> to continue until stable or <code>{⍵≡⎕←⍺}</code> to display all intermediate values until stable), and rule-set.</p>

<pre class="lang-apl prettyprint-override"><code>⎕∊⍨∘(⊢∘⊂⌺3)⍣⎕⊢⎕
</code></pre>

<p><a href="https://tio.run/##SyzI0U2pTMzJT///qKM97f@jvqmPOroe9a541DFD41HXIiD1qKvpUc8uY81HvYtBskCxvqkgxf8VwCCNy0ABBg2hGEQawlkIHpjmMuHSAEtoKmiApYE0WCmUNgTTIHEA" rel="nofollow noreferrer" title="APL (Dyalog Unicode) – Try It Online">Try it online!</a> (4 iterations of Rule 110)</p>

<p><code>⎕</code> prompt for initial state and </p>

<p><code>⊢</code> yield that (separates the state from the number of iterations)</p>

<p><code>⍣⎕</code> prompt for number of iterations and apply the following function that many times:</p>

<p> <code>(</code>…<code>)</code> apply the following tacit function:</p>

<p>  <code>⌺3</code> get all length-3 neighbourhoods (with info on whether they are at the edge) and apply the following tacit function to each pair:</p>

<p>   <code>⊂</code> enclose the neighbourhood</p>

<p>   <code>∘</code> and</p>

<p>   <code>⊢</code> yield that (discarding the info about being at the edge)</p>

<p> <code>∘</code> then</p>

<p> <code>∊⍨</code> check if they are members of</p>

<p> <code>⎕</code> prompt for list of neighbourhoods leading to being on in the next iteration</p>
</div>
<div id="pu13" class="pu"><h1><a href="https://www.perl.org/" rel="noreferrer">Perl</a> <code>-a</code> → <a href="https://esolangs.org/wiki/I/D_machine" rel="noreferrer">I/D machine</a>, 24 bytes</h1>

<pre class="lang-perl prettyprint-override"><code>$p=$a[$p]+=$_ for@F;redo
</code></pre>
<p><a href="https://tio.run/##K0gtyjH9r6Jjq6SjoGRdnFjpkGitUqGtbWdooKaWWpFZYv1fpcBWJTFapSBW21YlXiEtv8jBzbooNSX//39jBSMFYwVTBQMwNAOx/uUXlGTm5xX/1030NdUzMDQAAA" rel="noreferrer" title="Perl 5 – Try It Online">Try it online!</a> (contains a header that prints the internal state and halts after 10 iterations, so that the behaviour is observable)</p>
<h2>About the language</h2>
<p>I've spent the past couple of days working on the <a href="https://esolangs.org/wiki/I/D_machine" rel="noreferrer">I/D machine</a>, one of my latest ideas for very simple programming languages. It works as follows: the data storage consists of an unbounded RAM, initially all zeros. Each element can store an unbounded integer (although in practice, most I/D machine programs will only store small integers in most of them, and make use of the unbounded integers only as a way of addressing cells with large addresses). There's also a data pointer, which points to a cell (i.e. holds the address as a cell); it's initially also zero.</p>
<p>There are only two commands:</p>
<ul>
<li><strong><code>I</code></strong>: Increment the cell the data pointer points to. (The data pointer itself remains unchanged.)</li>
<li><strong><code>D</code></strong>: Dereference the data pointer, i.e. read the value of the cell that the data pointer points to. Then store the resulting value that you read back into the data pointer.</li>
</ul>
<p>Execution simply runs the program in a loop repeatedly, forever.</p>
<p>It's fairly surprising that a language this simple is Turing-complete, so I've been working on proving that. <a href="https://esolangs.org/wiki/I/D_machine_Turing-completeness_proof" rel="noreferrer">Here's the proof</a>. It's pretty similar to (but simpler than) the proof for Three Star Programmer, a very similar language (and in fact, this submission uses the same basic OISC &quot;shell&quot; around the program, differing only in the actual instruction implemented).</p>
<h2>About the program</h2>
<h3>Usage</h3>
<p>The input should be given on standard input, and is an I/D machine program without comments, and using the RLE/OISC syntax. (The I/D machine has two different, equivalent syntaxes, but for golfiness this program only supports one of them.) In this syntax, a program is a sequence of numbers in decimal, representing the lengths of runs of <code>I</code> commands between <code>D</code> commands. (You can specify two or more consecutive <code>D</code> commands via placing a &quot;run of 0 <code>I</code> commands&quot; between them, so the syntax is fully general.)</p>
<h3>Explanation</h3>
<p>As can be seen from the program, this isn't implementing the <code>I</code> and <code>D</code> commands individually. In fact, it's a (very slightly) optimising interpreter (purely because it's shorter to write this way). The key is to see that a run of <em>n</em> increment commands increment the data pointer's target <em>n</em> times, i.e. add <em>n</em> to it; and a run of 0 increment commands can also be implemented this way, as adding 0 to memory has no effect. So the operation we actually implement is to alternate between implementing a run-of-<code>I</code>s and a <code>D</code>. Or in other words, &quot;add <em>n</em> to the value pointed to by the data pointer (storing it back in the value pointed to by the data pointer), then read the value pointed to by the data pointer and store it in the data pointer&quot;. That's clearly more verbose than it needs to be, and we can further simplify this to &quot;add <em>n</em> to the value pointed to by the data pointer, then store that value both in the data pointer's target and the data pointer itself&quot;.</p>
<p>So that makes for the core of our program. We're using an array <code>$a</code> to store the RAM, and <code>$p</code> as the data pointer (indexing into the array):</p>
<pre class="lang-perl prettyprint-override"><code>$p=$a[$p]+=$_
         + $_  add {the run length}
   $a[$p]      to the element of $a pointed to by $p
   $a[$p] =    storing the result back into that element
$p=            and also in the pointer itself
</code></pre>
<p>Conveniently, Perl interprets uninitialised array elements as 0 when they're treated like numbers, so the array will be lazily initialised to zeroes for us without any explicit code for that being needed. (One potential issue is numerical accuracy when the numbers get large; however, that'll only happen if the amount of the array being used exceeds the machine's address space (Perl integers are large enough to hold pointers), something that can't happen on an idealised machine.)</p>
<p>Finally, all we need to do is to place this program into a couple of loops. The <code>for@F</code> loop, combined with the <code>-a</code> command line option, will loop over the fields of standard input (the default definition of &quot;field&quot; here will split on whitespace). The <code>redo</code> loop will place the entire program in an implicit loop (other than, conveniently, the reading of standard input), which will cause the program to run in a loop repeatedly, as required by the semantics of the I/D machine.</p>
</div>
<div id="pu14" class="pu"><h1>x86 assembly (Intel syntax/MASM)-Brainfuck  2127 bytes.</h1>
<p>Still golf able</p>
<pre><code>.386
.model flat,stdcall
.stack 4096
include \masm32\include\masm32.inc
includelib \masm32\lib\masm32.lib
ExitProcess proto,dwExitCode:dword
.data
bfsrc BYTE 200 dup(0) 
bfcells BYTE 100 dup(0) 
loopStack DD 5 dup(0) 
charBuf BYTE 5 dup(0) 
newline BYTE 10,0 
prompt BYTE &quot;$&quot;,0 
hr BYTE 50 dup('-'),0 
space BYTE ' ',0
.code
EvalBf proc
    start:
    invoke StdOut, addr prompt
    invoke StdIn, addr bfsrc,200
    cmp bfsrc,0
    je exit
    mov eax,0 
    mov ebx,0 
    mov ecx,0 
    processInstruction:
    cmp BYTE PTR bfsrc[ebx], '+'
    je plus
    cmp BYTE PTR bfsrc[ebx], '-'
    je minus
    cmp BYTE PTR bfsrc[ebx], '&gt;'
    je fwd
    cmp BYTE PTR bfsrc[ebx], '&lt;'
    je back
    cmp BYTE PTR bfsrc[ebx], '['
    je open
    cmp BYTE PTR bfsrc[ebx], ']'
    je close
    cmp BYTE PTR bfsrc[ebx], '.'
    je dot
    jmp processNextInstruction
    plus:
    inc BYTE PTR bfcells[eax]
    jmp processNextInstruction
    minus:
    dec BYTE PTR bfcells[eax]
    jmp processNextInstruction
    fwd:
    inc eax
    jmp processNextInstruction
    back:
    dec eax
    jmp processNextInstruction
    open:
    mov loopStack[ecx*4],ebx
    inc ecx
    jmp processNextInstruction
    close:
    dec ecx
    cmp BYTE PTR bfcells[eax], 0
    je processNextInstruction
    mov ebx,loopStack[ecx*4]
    inc ecx
    jmp processNextInstruction
    dot:
    mov dl, BYTE PTR bfcells[eax]
    mov BYTE PTR charBuf[0], dl
    mov BYTE PTR charBuf[1],0anything
    push eax
    push ecx
    invoke StdOut, addr charBuf
    pop ecx
    pop eax
    jmp processNextInstruction
    processNextInstruction:
    inc ebx
    cmp BYTE PTR bfsrc[ebx], 0
    je done
    jmp processInstruction
    done:
    invoke StdOut, addr newline
    mov eax, 0
    printNext:
    cmp eax, 100
    jge reset
    push eax
    invoke dwtoa, BYTE PTR bfcells[eax], addr charBuf
    invoke StdOut, addr charBuf
    invoke StdOut, addr space
    pop eax
    inc eax
    jmp printNext
    reset:
    invoke StdOut, addr newline
    invoke StdOut, addr hr
    invoke StdOut, addr newline
    jmp start

    exit:
    invoke ExitProcess,0
EvalBf endp
end EvalBf
</code></pre>
</div>
<div id="pu15" class="pu"><h1>CJam → ResPlicate Variant, <s>15</s> <s>14</s> 13 bytes</h1>

<p><sup>-1 byte thanks to @ais523</sup></p>

<pre><code>l~{(/((*+e_}h
</code></pre>

<p>The variant is the same as the one in <a href="https://codegolf.stackexchange.com/a/119502/61384">this answer</a>, except that the number of items taken off the queue is one less than the top number on the queue.</p>

<p>The <code>l~{ ... }h</code> part just takes an array as input and repeats until that array is empty.</p>

<p>Explanation for the main loop:</p>

<pre><code>    e# Stack:             | [3 2 1 1 2 2 2 1]
(   e# Pop first element: | [2 1 1 2 2 2 1] 3
/   e# Split chunks:      | [[2 1 1] [2 2 2] [1]]
(   e# Pop first:         | [[2 2 2] [1]] [2 1 1]
(   e# Pop first:         | [[2 2 2] [1]] [1 1] 2
*   e# Repeat array:      | [[2 2 2] [1]] [1 1 1 1]
+   e# Concatenate:       | [[2 2 2] [1] 1 1 1 1]
e_  e# Flatten:           | [2 2 2 1 1 1 1 1]
</code></pre>
</div>
<div id="pu16" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="noreferrer">Jelly</a> → "Add minimum to transpose", <s>5</s> 4 bytes</h1>

<pre><code>+"Ṃẞ
</code></pre>

<p><a href="https://tio.run/##y0rNyan8/19b6eHOpv///0dHG@oY6RjH6kQbmuoYGuiYglgGBjpGQGxsYBAbCwA" rel="noreferrer" title="Jelly – Try It Online">Try it online!</a> (runs only one iteration, to avoid timeouts)</p>

<p>A very simple Turing-complete construction: we take a square matrix as a program, and loop forever, identifying the lexicographically smallest row, then increasing each element of the first row by the first element of the lexicographically smallest, each element of the second row by the second element of the lexicographically smallest, and so on. (The Jelly program is "<code>+"</code> add corresponding elements {of the input and} <code>Ṃ</code> the minimum {of original}, <code>ẞ</code> loop"; this is a byte shorter than my previous program <code>Z+ṂZß</code>, which did exactly the same thing. Clearly I should have focused on golfing the Jelly, not just golfing the implemented language.)</p>

<p>The resulting language is Turing-complete for much the same reason as <a href="https://esolangs.org/wiki/Kangaroo" rel="noreferrer">Kangaroo</a>. The first element of each row acts like a skip count (although instead of the skip count of each command reducing when it's skipped, we instead increase the skip count of each command when it's run, and look for the command with the lowest skip count rather than commands with zero skip counts; this comes to the same thing). We ensure that this first element is higher than the other elements (which represent the number of times each command appears in each command's multiset), thus ensuring that the  first row is never the minimum; the remainder of the first row can be garbage. The only remaining trouble is modelling the way that commands with equal skip count run cyclically in sequence, but we can do that by multiplying all the skip counts by a large constant, then adding on small "initial" skip counts to the first column to serve as a tiebreak. This gives us a tiebreak of "first nonskipped command runs", not "nonskipped commands run cyclically in sequence", but the Turing-completeness construction for Kangaroo does not care about this difference.</p>
</div>
<div id="pu17" class="pu"><h1><a href="https://github.com/JCumin/Brachylog" rel="noreferrer">Brachylog</a> (2) → <a href="https://en.wikipedia.org/wiki/Post_correspondence_problem" rel="noreferrer">Post correspondence problem</a>, 9 bytes</h1>

<pre><code>~h=∋ᵐ\cᵐ=
</code></pre>

<p><a href="https://tio.run/nexus/brachylog2#@1@XYfuoo/vh1gkxyUDC9v//6GilRCUdpaTERKVYHSA7CciBspOSwDJJSrGx/6MA" rel="noreferrer" title="Brachylog – TIO Nexus">Try it online!</a></p>

<p>Input is a list of lists of strings. (In the Post correspondence problem as defined on Wikipedia, the inner lists have two elements each, although this program can actually handle a generalisation to any number of elements.) This program brute-forces solutions to the problem, in order of length, until a solution is found. The Post correspondence problem is known to be able to simulate a Turing-machine, and thus brute-forcing solutions to it is Turing complete. If run as a function, rather than a program, it actually produces meaningful output as well.</p>

<p>The program in the TIO link above is <code>[["a","baa"],["ab","aa"],["bba","bb"]]</code>, which I copied from Wikipedia. The solution (which the program finds fairly quickly) is <code>["bbaabbbaa","bbaabbbaa"]</code>.</p>

<h2>Explanation</h2>

<p>This is pretty much just a direct translation of the Post correspondence problem to Brachylog.</p>

<pre><code>~h=∋ᵐ\cᵐ=
~h         Find {the shortest possible} list which starts with {the input}
  =        and for which all elements are equal
   ∋ᵐ      such that taking an element of each element,
     \cᵐ   and concatenating elements in corresponding positions,
        =  produces a list all of whose elements are equal.
</code></pre>

<p>Basically, we create a list that's repeated copies of the input (as few as possible, meaning that we don't miss any possibilities when brute-forcing), take one element from each copy, then concatenate corresponding elements (as in the Post correspondence problem).</p>
</div>
<div id="pu18" class="pu"><h2>Clojure, 75 bytes (Cyclic tag system)</h2>

<p>Update 1: replaced <code>some?</code> with <code>nil?</code>.</p>

<p>Update 2: Fixed a missing <code>S</code> in else branch of <code>if s</code>.</p>

<pre><code>#(loop[[p &amp; P](cycle %)[s &amp; S]%2](if(nil? s)S(recur P(if s(concat S p)S))))
</code></pre>

<p>Implements the <a href="http://esolangs.org/wiki/Cyclic_tag_system" rel="nofollow noreferrer">cyclic tag system</a>, returns <code>nil</code> if the program halts, loops forever otherwise. Clojure really shines here with infinite lazy sequences (such as <a href="https://clojuredocs.org/clojure.core/cycle" rel="nofollow noreferrer">cycle</a>) and <a href="https://clojure.org/guides/destructuring" rel="nofollow noreferrer">destructuring</a>. Ones and zeros are indicated as true and false values. When the data string runs out <code>s</code> becomes <code>nil</code>.</p>

<p>Ungolfed:</p>

<pre><code>(def f #(loop[[p &amp; P] (cycle %) [s &amp; S] %2 i 5]
          (do
            (pprint [p (concat [s] S)])
            (if (and (some? s) (pos? i))
              (recur P (if s (concat S p) S) (dec i))))))
</code></pre>

<p>Example results:</p>

<pre><code>(f [[false]] [true true])
[[false] (true true)]
[[false] (true false)]
[[false] (false false)]
[[false] (false)]
[[false] (nil)]

(f [[false true true] [true false] [true false true]] [true])
[[false true true] (true)]
[[true false]      (false true true)]
[[true false true] (true true)]
[[false true true] (true true false true)]
[[true false]      (true false true false true true)]
[[true false true] (false true false true true true false)]
</code></pre>
</div>
<div id="pu19" class="pu"><h1><a href="https://github.com/Phlarx/chip" rel="nofollow noreferrer">Chip</a>, 20+3 = 23 bytes (Rule 110)</h1>

<pre><code>AZZ
&gt;}/a
`)\'E~Zte*f
</code></pre>

<p>+3 for flag <code>-z</code></p>

<p><a href="https://tio.run/nexus/chip#@@8YFcVlV6ufyJWgGaPuWhdVkqqV9v@/IQgYAIGhgaHhf90qAA" rel="nofollow noreferrer" title="Chip – TIO Nexus">Try it online!</a></p>

<p>This submission isn't perfect, as Chip doesn't (yet) have any looping ability, so the output must be passed in as the input to simulate multiple generations, with <a href="https://tio.run/nexus/bash#TY49C8IwEIb3@xU3FNpYbBPXfoBDXd2LgyVNaKAkIY2Cov71Gquoz3DDHc/7Hu881uhOo2CMZnywWJYYN/tdPG/bFup73sGRHOLm0XqxknO4ACgv3FRtKJy7sYoSHjIiqUZBAAQfDEZhD9I4TBJd0UKXi1DoNCUEegP44a1bp7SXi4Q3zI31OR@UXUZmL7i@/v9HvvavqjdazOwFDTDK2BM" rel="nofollow noreferrer" title="Bash – TIO Nexus">something like this</a> (of course, you could run that loop indefinitely, and Chip can handle arbitrarily long input, so this combination is Turing Complete).</p>

<p>This implementation take input and given output in the form of ASCII <code>0</code>s and <code>1</code>s. The logic here is as follows:</p>

<pre><code>p := value of left neighbor cell    AZZ
q := value of current cell          AZ
r := value of right neighbor cell   A

q' := ((r xor q) and p) or          &gt;}/a
      ((r or q) and ~p)             `)\'
</code></pre>

<p>The remainder of the elements are for housekeeping: <code>e*f</code> causes ASCII numeral output, and <code>E~Zt</code> terminates execution two bytes after the input is exhausted (since the width grows by 2 each generation).</p>
</div>
<div id="pu20" class="pu"><h2>Clojure, <s>82</s> 81 bytes (Turing Machine)</h2>

<p>Update: removed a space from <code>t{} s</code>.</p>

<pre><code>#(loop[p 0 t{}s 1](if-let[[S M N](%[(or(t p)0)s])](recur(+ p M)(assoc t p S)N)t))
</code></pre>

<p>Implements the Turing Machine as a loop, returns the tape when the halting state is reached. In state transition rules this is indicated by ommitting the transition state. This settins <code>N</code> to <code>nil</code> and the subsequent <code>if-let</code> will abort as the corresponding state transition is not found from the input hash-map <code>%</code>. Actually any value for this state will do, such as <code>:abort</code>, 0 or -1.</p>

<p>Ungolfed with an example 3-state 2-symbol busy beaver from <a href="https://en.wikipedia.org/wiki/Turing_machine#Formal_definition" rel="nofollow noreferrer">Wikipedia</a>.</p>

<pre><code>(def f #(loop[pos 0 tape {} state 1]
          (if-let [[sym move next-state](%[(get tape pos 0)state])]
            (do (println [pos tape state])
                (recur(+ pos move)(assoc tape pos sym)next-state))
            tape)))

(f {[0 1] [1  1 2]
    [0 2] [1 -1 1]
    [0 3] [1 -1 2] 
    [1 1] [1 -1 3]
    [1 2] [1  1 2]
    [1 3] [1  1]})

{0 1, 1 1, -1 1, -2 1, -3 1, 2 1}
</code></pre>

<p><a href="https://tio.run/nexus/clojure#dc5BCoMwEAXQvaf4UAozFMHEc@jGZciiWANCMCFJV@LZ7VAslEpn@/78mZ0ek4PDhXwI0UQ0KOuGDGVpdrWfijEDOvSWroZCooLIDWfLltI0PhPdENEx3XMOI0QxcM@FmauKYpqX4heQw2oa6YRRgIK2Fb5HTL@tVhI6WfsxCf2gOkoFW3sy/fegOkplfZNX9/0F" rel="nofollow noreferrer">Try it online</a>.</p>

<p>On a single core of 6700K this runs the 5-state 2-symbol busy beaver (47.1 million steps) in about 29 seconds, or 1.6 million steps / second.</p>
</div>
<div id="pu21" class="pu"><h1>Lua interpreting Brainf***, 467 bytes</h1>

<pre><code>b,r,a,i,n,s=0,io.read,{0},1,1,"&gt;&lt;+-.,[]"c,f=r(),{function()n=n+1;a[n]=a[n]or 0;end,function()n=n-1;a[n]=a[n]or 0;end,function()a[n]=a[n]+1;end,function()a[n]=a[n]-1;end,function()io.write(string.char(a[n]))end,function()a[n]=io.read():byte()end,function()i=a[n]~=0 and i or c:find("]",i)end,function()if a[n]~=0 then b,x=1,""repeat i=i-1 x=c:sub(i,i)b=x=="["and b-1 or x=="]"and b+1 or b until b==0 and x=="["end end}repeat f[s:find(c:sub(i,i),1,1)]()i=i+1 until i&gt;#c
</code></pre>

<p>I know there's still some slimming down I can do later, but here's where my first pass ended. Takes the brainf code from standard input.</p>
</div>
<div id="pu22" class="pu"><h2>Clojure, 87 bytes (Rule 110)</h2>

<p>Credit for the <a href="https://codegolf.stackexchange.com/a/111732/59617">parity code</a> goes to Jens Renders! I was really struggling on how to express this and I was going to go with converting <code>[p q r]</code> from binary to an integer and use a lookup table.</p>

<pre><code>#(iterate(fn[S](for[[p q r](partition 3 1(concat[0]S[0]))](mod(+ q(* q(+ 1 p)r)r)2)))%)
</code></pre>

<p>Here <code>partition</code> and Clojure's destructuring makes the logic application quite simple. This function returns an infinite sequence of states, so the caller is responsible to <code>take</code> as many as they need or just <code>nth</code> to skip to a specific state. If paddings with zero were two elements instead of just one then the tape would constantly grow, avoiding boundary issues. Now it stays the original width.</p>

<p>Example:</p>

<pre><code>(def f #(iterate(fn[S](for[[p q r](partition 3 1(concat[0]S[0]))](mod(+ q(* q(+ 1 p)r)r)2)))%))

(pprint (take 5 (f '(0 0 0 0 0 1 1 1 0 0 1 0 0))))
((0 0 0 0 0 1 1 1 0 0 1 0 0)
 (0 0 0 0 1 1 0 1 0 1 1 0 0)
 (0 0 0 1 1 1 1 1 1 1 1 0 0)
 (0 0 1 1 0 0 0 0 0 0 1 0 0)
 (0 1 1 1 0 0 0 0 0 1 1 0 0))
</code></pre>
</div>
<div id="pu23" class="pu"><h1>BF/P" implemented in a Turing Machine, 842 bytes</h1>

<p><a href="https://pastebin.com/3bj1RSv1" rel="nofollow noreferrer">Transition table (linked because of length)</a></p>

<p><a href="https://pastebin.com/1Y4anzSa" rel="nofollow noreferrer">Transition table, less golfed version</a></p>

<p><a href="http://morphett.info/turing/turing.html" rel="nofollow noreferrer">Turing Machine simulator I used</a></p>

<p>This certainly isn't going to win any awards for length, but it's something I've always wanted to do, since BF is so similar to a Turing Machine. Each cell stores a value from <code>0x0</code>-<code>0xF</code>. The width is however far the Turing Machine website can go without crashing your browser. The <code>,</code> and <code>.</code> functions (input and output) are not defined, so it's a bit more like P" than true BF.</p>

<p>To run it, paste the transition table into the Turing Machine simulator, set the input to some BF code, and press run.</p>

<p>The tape of the TM stores both the BF code and the BF data, with a single space in the middle. It keeps track of its position in the code by modifying the character that it is currently running (<code>[</code> -> <code>(</code>, etc) and its position in the data with a <code>^</code> in front of the cell. Once it reads a command character, it moves until it hits the caret, moves one cell to the right, and performs the appropriate function. Then it goes back, looking for one of the "modified" command characters in the BF code, and moves on to the next one, repeating the whole process. Once it runs out of code, it halts. </p>

<p>The best way to understand how it works is by running the ungolfed version, putting it on step mode, and watching which lines lead to which others and what each state/block of lines does.</p>

<p>The golfed and ungolfed versions are exactly alike in terms of how they work, but the ungolfed version has more human-friendly names and is broken up into sections.</p>
</div>
<div id="pu24" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="noreferrer">Jelly</a> → <a href="https://en.wikipedia.org/wiki/Tag_system" rel="noreferrer">2-Tag system</a>, 8 bytes</h1>

<pre><code>µḢị⁴⁸;Ḋß
</code></pre>

<p><a href="https://tio.run/nexus/jelly#@39o68OdLQ93LHq4u/tR45ZHjTusH@7oOjz/////0YY6QBj7PzraSMc4VifaEITBQrEA" rel="noreferrer">Try it online!</a></p>

<p>I have a bounty going favouring practical languages, but thought I might as well try to win the original task while I was at it (as I can't exactly win my own bounty).</p>

<p>Implements a variant of tag systems with no halt state, as it isn't needed for Turing completeness. The states are numbered from 1, consecutively, and the initial string comes before the program.</p>

<p>For example, Wikipedia gives an example of a tag system {<code>a</code>,<code>b</code>,<code>c</code>}, {<code>a</code> → <code>bc</code>, <code>b</code> → <code>a</code>, <code>c</code> → <code>aaa</code>} with initial string <code>aaa</code>; in this input format, that's <code>[1,1,1]</code>, <code>[[2,3],[1],[1,1,1]]</code>. (Tag systems don't have a fixed syntax, and this seems like a reasonable way to do it.)</p>

<p>The TIO link has an added <code>Ṅ</code> ("write internal state and a newline to stdout") in order to show that the program is in fact working.</p>

<h2>Explanation</h2>

<pre><code>µḢị⁴⁸;Ḋß
           {implicit: initialise internal state from first argument}
µ          Disregard the second command-line argument by default
 Ḣ         Take the first element, removing it from the internal state
  ị⁴       Use the value to index into the second argument
    ⁸;     Prepend (the rest of) the internal state
      Ḋ    Discard the first element of the internal state
       ß   Loop forever
</code></pre>
</div>
<div id="pu25" class="pu"><h1><a href="https://esolangs.org/wiki/Collatz_function" rel="noreferrer">Iterated Generalized Collatz Functions</a> -> Python 2, 46 bytes</h1>

<pre><code>a,b,x,m=input()
while-~x%m:x=x/m*a[x%m]+b[x%m]
</code></pre>

<p>Call this function with a lists of m-1 a's and b's, the starting value x, and the divisor m, which collectively constitute a "program" for IGCF. Rather than taking a third array to indicate on which moduli to halt, this simply halts whenever the modulus is m-1. This simplification means it may take some extra effort to convert a given Fractran program into this variant, but it does save a couple of bytes in the interpreter.</p>

<p><a href="https://tio.run/nexus/python2#@5@ok6RToZNrm5lXUFqioclVnpGZk6pbV6Gaa1VhW6Gfq5UYDWTHaieBKeuCosy8EoWK//@jjWN1og1idczNzc10jAA" rel="noreferrer" title="Python 2 – TIO Nexus">Try it online!</a> This TIO demonstrates how to add 5+5 with this language. The program a=[3],b=[0],m=2 does addition, and starting with 7776=2^5*3^5 eventually yields 59049=3^10.</p>
</div>
<div id="pu26" class="pu"><h1><a href="https://esolangs.org/wiki/ResPlicate" rel="noreferrer">ResPlicate</a> variant -> Python 2, 47 bytes</h1>

<pre><code>l=input()
while l:l=l[2+l[0]:]+l[2:2+l[0]]*l[1]
</code></pre>

<p>This function interprets a variant of ResPlicate</p>

<ul>
<li>for which a program is a python list of even length with even elements at even indices.</li>
<li>with no I/O.</li>
<li>for which trying to copy more values than exist in the remainder of the queue simply copies the remainder of the queue (i.e., the copied bit is not padded with zeroes to the required length).</li>
</ul>

<p>The last change means that some ResPlicate programs (which meet the first condition) will not behave the same in this variant, but fortunately, the BCT interpreters do not require the removed functionality, and so the language remains TC.</p>

<p><a href="https://tio.run/nexus/python2#LYy9CsIwGAD3PEXolNQItoNIpIODiKCLjiFDqKn94MsPaYq@uHNV2uk4Dq5LwdEBnt4gBRdDyiV52I72xj/QJvZPoxNdMs5ySWgyMFh6fLc2ZgieFRmcpWHMBSfzht3Pp8PldhXLghODJjlW8Qkb8HHMjJNXD2gpSmxQ1StUGy31D7WcRZeoKr2PCXymOE1qK2qxE5VYqD8@rFvT9vYL" rel="noreferrer" title="Python 2 – TIO Nexus">Try it online!</a> This TIO has a print wedged into it to show that it works and a header that kills the program after 1 second and an example that manages to generate more output than TIO can handle in that one second.</p>
</div>
<div id="pu27" class="pu"><h1><a href="https://github.com/fergusq/roda" rel="nofollow noreferrer">Röda</a> implementing <a href="https://en.wikipedia.org/wiki/FRACTRAN" rel="nofollow noreferrer">Fractran</a>, <s>114</s> <s>112</s> 106 bytes</h1>

<p><em>1 byte saved thanks to @fergusq by rearranging parameters</em></p>

<pre><code>f&amp;n,a{x=1{x=0;(a/" ")()|[_/`/`]|[parseInteger(_[0],_1[1])]|{|q,w|{n*=q/w;x=1}if[n%w&lt;1,x&lt;1]}_,_}while[x&gt;0]}
</code></pre>

<p><a href="https://tio.run/nexus/roda#FYxBCoMwFET3PUUItGgJfL@puFC77xlCiFnEVmg/1RYiJDm7TRfzhgfD7NOJhA3bgDlVV1jgjJdFGZWBEUYd1duuH3ejr7u7tTCq0sKgQl3qGOIifAx0HhbwXb5I86To6HsUW486GWGSf8xPp7ZrpdP@sjOxcGCMhrbONTES/NI0ICVDBMwERCah/WudTfI8U6QPaf8B" rel="nofollow noreferrer" title="Röda – TIO Nexus">Try it online!</a></p>

<p>Call the function like so: <code>f reference_to_input program</code>. The output will be stored in the location of the <code>input</code>.</p>
</div>
<div id="pu28" class="pu"><h1>JavaScript interpreting <a href="https://en.wikipedia.org/wiki/Rule_110" rel="nofollow noreferrer">Rule 110</a>, 131 bytes (99 bytes?, 28 bytes?)</h1>

<pre><code>a=(p,q,r)=&gt;q+r+q*r+p*q*r
b=l=&gt;{r="";for(i=0;i&lt;l.length-2;i++)r+=a(l[i],+l[i+1],+l[i+2])%2;return r}
c=(l,n)=&gt;!n?l:c(b(0+l+0),n-1)
</code></pre>

<p>As you can see, the code defines 3 functions, <code>a</code>, <code>b</code> and <code>c</code>. Perhaps it's possible to save bytes by combining them in 1 function (I don't see how), but it's good that there separate because each of them already fulfills this challenge in some sense.</p>

<p>Function <code>a</code>takes 3 numbers as input and computes some weird polynomial of them. When these 3 numbers are <code>0</code>or <code>1</code>they can bee seen as Rule 110 cells. The parity of the output of <code>a</code> can then be seen as the value of the middle cell in the next generation. So in some sense, this simple function is already a Rule 110 'interpreter' (28 bytes):</p>

<pre><code>a=(p,q,r)=&gt;(q+r+q*r+p*q*r)%2
</code></pre>

<p>We can then create a new function <code>b</code> that evaluates <code>a</code> on every character of a string of ones and zeros. This <code>b</code>is then, in a better way than <code>a</code>, a Rule 110 interpreter. Taking mod 2 after the evaluation of a saves brackets (99 bytes):</p>

<pre><code>a=(p,q,r)=&gt;q+r+q*r+p*q*r
b=l=&gt;{r="";for(i=0;i&lt;l.length-2;i++)r+=a(l[i],+l[i+1],+l[i+2])%2;return r}
</code></pre>

<p>To actually compute a function with Rule 110, the user must specify the starting state and the number of generations after which the output will 'appear'. We can make a third function <code>c</code> that takes a string of ones and zeros, and a positive integer <code>n</code>, that then evaluates <code>b</code>on the string, <code>n</code>times. Like this we can really see Rule 110 as a programming language, where a program is an intitial state and a number <code>n</code>, and the output is the state after <code>n</code>generations. The function <code>c</code>is now an actual interpreter for that programming language so the final code for this challenge is what I presented above.</p>
</div>
<div id="pu29" class="pu"><h1><a href="https://www.perl.org/" rel="noreferrer">Perl</a> → <a href="http://esolangs.org/wiki/Three_Star_Programmer" rel="noreferrer">Three Star Programmer</a> variant, 26 + 1 = 27 bytes</h1>



<pre class="lang-perl prettyprint-override"><code>++$a[$a[$a[$_]]]for@F;redo
</code></pre>

<p><a href="https://tio.run/nexus/perl#U9GxVdJRULIuTqx0SLRWqdDWtjM0UFNLrcgssf6vra2SGA1F8bGxsWn5RQ5u1kWpKfn//xsqGCkYK5gomP7XTfQ11TMwNAAA" rel="noreferrer" title="Perl – TIO Nexus">Try it online!</a> (This link contains a header that exits the program after a set number of iterations (so that TIO doesn't time out), and to print the internal state every iteration (so that it does something observable).)</p>

<p>Run with <code>-a</code> (1 byte penalty, as you can fit it in before the <code>-M5.010</code> to produce <code>-aM5.010</code>).</p>

<p>Specifically, this implements Three Star Programmer in which commands are separated by spaces and no comments are allowed in the file, without I/O extensions. (These changes make no difference to the language's Turing-completeness, obviously.) There isn't a proof of Turing-completeness for Three Star Programmer online, but it is Turing-complete (I've been sharing a sketch proof of its Turing-completeness with other esoprogrammers, but stopped working on the language when I discovered that it was actually fairly easy to program in once you'd gotten over the original shock).</p>

<p>The program doesn't really need much explanation; Three Star Programmer has a very simple specification, and this is a direct translation of it. The only subtle points: <code>@F</code> is the input to the program in array form (this is a consequence of <code>-a</code>); and <code>redo</code> will repeat the entire program as it's in an implicit loop (also a consequence of <code>-a</code>).</p>
</div>
<div id="pu30" class="pu"><h1><a href="https://github.com/dloscutoff/pip" rel="noreferrer">Pip</a> interpreting <a href="http://esolangs.org/wiki/Cyclic_tag_system" rel="noreferrer">cyclic tag systems</a>, 16 bytes</h1>

<pre><code>YqWyyPBg@++vXPOy
</code></pre>

<p>Takes the productions of the tag system as command-line arguments and the initial data string from stdin.</p>

<p>The above code is kinda hard to verify because it doesn't produce any output (so the only observable behavior is "terminates" vs. "doesn't terminate"). Therefore, here's an ungolfed version that outputs the data string after each step, and also terminates after 20 steps so TIO doesn't have to deal with tons of output from infinite loops: <a href="https://tio.run/nexus/pip#@x9ZyBWuUGZjZKCgphBQyaVQqRDgpJDuoK1dphChEOBf@f@/4X8DQ8P/hgZAZAgA" rel="noreferrer" title="Pip – TIO Nexus">Try it online!</a></p>

<h3>Cyclic tag systems</h3>

<p>Cyclic tag systems are an extremely <a href="https://en.wikipedia.org/wiki/Tag_system#Cyclic_tag_systems" rel="noreferrer">simple yet Turing-complete</a> computational model. They consist of a list of <em>productions</em> that define operations on a <em>data string</em>. The productions and data string consist of 1's and 0's.</p>

<p>At each step, the leftmost character of the data string is removed.</p>

<ul>
<li>If the character is 1, the current production is appended to the right side of the data string.</li>
<li>If the character is 0, nothing is appended.</li>
</ul>

<p>In either case, the current production moves to the next production in the list, cyclically: if we were at the last production, we loop around to the first. Execution continues until the data string is empty.</p>

<h3>Explanation</h3>

<pre><code>                  g is list of cmdline args; v is -1 (implicit)
 q                Read a line of stdin for the data string
Y                 and yank it into the y variable
  Wy              While data string is nonempty:
       g@++v       Retrieve the next production from g (using cyclic indexing)
             POy   Pop the first character of y
            X      String-multiply: result is the production if the first character of y
                   was 1, or empty string if it was 0
    yPB            Push that string to the back end of y
</code></pre>
</div>
<div id="pu31" class="pu"><h1>Mathematica interpreting Conway's Game of Life, 64 bytes</h1>

<pre><code>CellularAutomaton@{224,{2,{t={2,2,2},{2,1,2},t}},{1,1}}~Nest~##&amp;
</code></pre>

<p><a href="https://en.wikipedia.org/wiki/Conway&#39;s_Game_of_Life" rel="noreferrer">Conway's Game of Life</a> is known to be Turing complete; and cellular automata are Stephen Wolfram's truest obsession. <code>CellularAutomaton@{224,{2,{t={2,2,2},{2,1,2},t}},{1,1}}</code> is a rule that transforms a two-dimensional array of 0s and 1s according to one step of Conway's Game of Life. (I think the default behavior is that this array wraps around its edges, so is really a discrete torus.) <code>~Nest~##&amp;</code> turns this rule into a function which, when given an initial board state (of any dimensions) and an integer <code>n</code> as arguments, outputs the result of <code>n</code> iterations of the Game of Life rule.</p>

<p>For your own enjoyment, you could use the wrapped version</p>

<pre><code>b = RandomInteger[1,{50,50}];
Manipulate[ArrayPlot[
  CellularAutomaton@{224,{2,{t={2,2,2},{2,1,2},t}},{1,1}}~Nest~##&amp;
    [b, n] ]
, {{n,0}, 0, 100, 1}]
</code></pre>

<p>and scroll your way through 100 generations on a 50x50 board.</p>
</div>
<div id="pu32" class="pu"><h1><a href="https://github.com/Destructible-Watermelon/Turtl-d" rel="nofollow noreferrer">Turtlèd</a> interpreting <a href="http://esolangs.org/wiki/Cyclic_tag_system" rel="nofollow noreferrer">CT</a>, 49 bytes</h1>

<p>I might be able to golf this</p>

<p>Also, this doesn't output anything useful. it just halts if and only if the given CT program halts.</p>

<p>this is one I made a while ago actually (then golfed some now)</p>

<pre><code>!-l[*+.r_]' !l[ l]r[ u.(;d' u)d(1[ r].[ l])( r)+]
</code></pre>

<h2>How it works:</h2>

<p>Turtlèd uses grid cells. When I say "write something on the grid" I mean that a contiguous group of characters is placed on the grid. example</p>

<pre><code>[ ][ ][ ][ ][ ][ ][ ]
[ ][H][E][L][L][O][ ]
[ ][ ][ ][ ][ ][ ][ ]
[ ][ ][ ][ ][ ][ ][ ]
</code></pre>

<p>onto the program</p>

<p>data is inputted first:</p>

<pre><code>!-l[*+.r_]' 
</code></pre>

<p>this is essentially a cat program. it writes the input onto the grid.</p>

<p>then the commands are inputted:</p>

<pre><code>!
</code></pre>

<p>what it does with these commands:</p>

<p>these commands are "productions". if the leftmost data bit is a 1, it copies the production onto the end of the data string. otherwise nothing happens. then the leftmost data bit is removed, and it uses the next production with the next left most data bit. the program halts when there are no bits in the data string. A way to do these productions is to deal with the bits and end of productions separately. this is what our program does. it separately copies bits from the command string on to the end of the data string, and separately deletes bits from the datastring</p>

<p>on to how this program does it. after inputting the commands, the turtle/grid pointer moves back to the leftmost bit of the datastring. it then goes into a loop</p>

<pre><code>[ u.(;d' u)d(1[ r].[ l])( r)+]
</code></pre>

<p>what it does in this loop, is it moves up from the leftmost datastring, and writes down the current command character (u.). if it is ;, the end of a production, it moves down and deletes the leftmost data bit beneath it and moves back up (<code>(;d' u)</code>). then, either way, it moves down one (<code>d</code>). if the bit there was not deleted, it means it must check whether to copy a bit from the commands at the end. so, if this character that is or was the leftmost databit is a 1, it will move to the end of the right end of the data string, copy the bit from the command string, and move back to the space left of the leftmost data bit (<code>(1[ r].[ l])</code>). now, it is either on the leftmost databit, which was a zero, or left of the leftmost databit. so, we move right if on a space (<code>( r)</code>). then, the command pointer is incremented so we will write down the next command in the next iteration of the loop. If there is no more datastring, this means we will be on a space and the loop will end. otherwise we rerun the loop.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/111278/">111278</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




