<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::263566</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>016</td><td>Nekomata + n</td><td>230801T041541Z</td><td><a href="https://codegolf.stackexchange.com/questions/263566/calculating-transitive-closure/263594#263594">alephalp</a></td></tr>
<tr d-ix="1"><td>018</td><td>MATL</td><td>230731T225123Z</td><td><a href="https://codegolf.stackexchange.com/questions/263566/calculating-transitive-closure/263590#263590">Luis Men</a></td></tr>
<tr d-ix="2"><td>084</td><td>Python 3.8</td><td>230731T223314Z</td><td><a href="https://codegolf.stackexchange.com/questions/263566/calculating-transitive-closure/263589#263589">CursorCo</a></td></tr>
<tr d-ix="3"><td>074</td><td>JavaScript ES6</td><td>230731T173659Z</td><td><a href="https://codegolf.stackexchange.com/questions/263566/calculating-transitive-closure/263581#263581">Arnauld</a></td></tr>
<tr d-ix="4"><td>110</td><td>Python 3.8</td><td>230731T192200Z</td><td><a href="https://codegolf.stackexchange.com/questions/263566/calculating-transitive-closure/263583#263583">Jonathan</a></td></tr>
<tr d-ix="5"><td>013</td><td>Jelly</td><td>230731T163042Z</td><td><a href="https://codegolf.stackexchange.com/questions/263566/calculating-transitive-closure/263576#263576">Jonathan</a></td></tr>
<tr d-ix="6"><td>012</td><td>Pyth</td><td>230731T170437Z</td><td><a href="https://codegolf.stackexchange.com/questions/263566/calculating-transitive-closure/263579#263579">CursorCo</a></td></tr>
<tr d-ix="7"><td>018</td><td>Charcoal</td><td>230731T163624Z</td><td><a href="https://codegolf.stackexchange.com/questions/263566/calculating-transitive-closure/263577#263577">Neil</a></td></tr>
<tr d-ix="8"><td>240</td><td>Python3</td><td>230731T153346Z</td><td><a href="https://codegolf.stackexchange.com/questions/263566/calculating-transitive-closure/263575#263575">Ajax1234</a></td></tr>
<tr d-ix="9"><td>016</td><td>05AB1E</td><td>230731T140006Z</td><td><a href="https://codegolf.stackexchange.com/questions/263566/calculating-transitive-closure/263571#263571">Kevin Cr</a></td></tr>
<tr d-ix="10"><td>011</td><td>Itr</td><td>230731T125512Z</td><td><a href="https://codegolf.stackexchange.com/questions/263566/calculating-transitive-closure/263568#263568">bsoelch</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://github.com/AlephAlpha/Nekomata" rel="nofollow noreferrer">Nekomata</a> + <code>-n</code>, 16 bytes</h1>
<pre><code>~ᵉ{$#ᵑ{ˣ@j,u}}∕~
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=m70iLzU7PzexJHFNtJJurpKOgpJunlLsgqWlJWm6FtvrHm7trFZRfrh1YvXpxQ5ZOqW1tY86ptYtKU5KLoaqWXCzJDo6VgeMYrmiow2BDAMkFrKwjhGMawTRYagDUmAEUaFjpGMM4oFJY2SNRlABEyA2hZgPsRwA" rel="nofollow noreferrer">Attempt This Online!</a></p>
</div>
<div id="pu1" class="pu"><h1><a href="https://github.com/lmendo/MATL" rel="nofollow noreferrer">MATL</a>, 18 bytes</h1>
<pre><code>Fi&quot;TX@@g&amp;(]tYezwz-
</code></pre>
<p>The input is a cell array of numerical vectors, 1-based. <a href="https://tio.run/##y00syfn/3y1TKSTCwSFdTSO2JDK1qrxK9///6mijWB2FaGMQYQIiTEGEGYgwjK0FAA" rel="nofollow noreferrer" title="MATL – Try It Online">Try it online!</a> Or <a href="https://tio.run/##y00syfmf8N8tUykkwsEhXU0jtiQytaq8Sve/S8j/6uhYHQUIruWqjjYCsQyRmagyOgrGcBFjmE4jHQWwOmOIQqAaHQUTsACUNkE1xRguZgoizKB2AgA" rel="nofollow noreferrer">verify all test cases</a>.</p>
</div>
<div id="pu2" class="pu"><h1><a href="https://docs.python.org/3.8/" rel="nofollow noreferrer">Python 3.8</a>, 84 bytes</h1>

<pre class="lang-python prettyprint-override"><code>lambda a:sum(len((m:={*n},[m:=m|{*a[g]}for f in a for g in m])and m-{*n})for n in a)
</code></pre>
<p><a href="https://tio.run/##bY9hC4IwEIa/9ysOP20yIZ1FCPZHbMRCZ4KbovYhzN9u3jQpcrDtvfeeO@7qZ3evDD/Vzajiy1hKfUslyKh9aFJmhhAdxb1rBpZMQr96Vya5GFTVgILCgASUOUotqDQpaA9xiraxBB1Rd1nbYUh2MJ0kEQzmK9jiBBj6f/EGw4D/2vzTLWBgK/hXyUQzCK27/OFGU74mDvgc12FoZDGc/7qHeOILz7dbF7iPEbCuioywdN0UpiPK6dEaID5Dr8jcgg4OHd8" rel="nofollow noreferrer" title="Python 3.8 (pre-release) – Try It Online">Try it online!</a></p>
<p>Takes 0-indexed input. Essentially a port of my <a href="https://codegolf.stackexchange.com/a/263579/73054">Pyth answer</a>.</p>
</div>
<div id="pu3" class="pu"><h1>JavaScript (ES6), 74 bytes</h1>
<p>Uses 0-based indexing. Returns <code>false</code> for <code>0</code>.</p>

<pre class="lang-javascript prettyprint-override"><code>f=a=&gt;a.some(b=&gt;b.some(i=&gt;a[i].some(v=&gt;!b.includes(v)&amp;&amp;b.push(v))))&amp;&amp;1+f(a)
</code></pre>
<p><a href="https://tio.run/##dZDBcoMgEIbvPsX24sDUkChJLw7e@hSOh8VoY8aIExounT67XSBt0zbdGZaf5eOH5YgObXse5tfVZPbdsvQKVYXCmlPHtKp0VAPV6qGJC6eqBy2GqR0v@84yx9NUi/liDyQp0jR/7BnypawTgLpuMoiD0t9Yr2ETsMIz@X0oYMUt9o/fLywDeZckTAZMfj6uyCCYyluWsF10I6MMtgG4zttv458tyK/dnU9P17bipZukSURvzs/YHhiCquCNTpIAFCecmfYlHaTz0sEKcs5LglozWTN2YjQvzH8vFd95uXwA" rel="nofollow noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a></p>
<h3>Commented</h3>
<pre class="lang-javascript prettyprint-override"><code>f =                  // f is a recursive function taking ...
a =&gt;                 // ... the main list a[]
a.some(b =&gt;          // for each sub-list b[] in a[]:
  b.some(i =&gt;        //   for each value i in b[]:
    a[i].some(v =&gt;   //     for each value v in a[i]:
      !b.includes(v) //       if v is not already in b[],
      &amp;&amp; b.push(v)   //       append v to b[] and trigger all some()'s
    )                //     end of some()
  )                  //   end of some()
)                    // end of some()
&amp;&amp; 1 +               // if truthy, increment the final result
f(a)                 // and do a recursive call with the updated list
</code></pre>
</div>
<div id="pu4" class="pu"><h1><a href="https://docs.python.org/3.8/" rel="nofollow noreferrer">Python 3.8</a>, 110 bytes</h1>

<pre class="lang-python prettyprint-override"><code>f=lambda a,o=0,c=0:a!=(m:=[[*(s:={*sum([a[i]for i in n],n)},c:=c+len(s-{*n}))[0]]for n in a])and c+f(m,o or a)
</code></pre>
<p>A recursive function that accepts the adjacency list, <code>a</code>, and returns the number of required edges (with <code>False</code> <a href="https://codegolf.meta.stackexchange.com/a/9067/53748" title="meta">quacking like</a> <code>0</code>).</p>
<p><strong><a href="https://tio.run/##bZDRasMwDEXf9xVan@xEBbduxzBoP2LM8NKaGRolJNnDCPn2LHa70LEabKOro4uk9nv4bFi/tt08B7r4@uPkwWNDCitSxj@TqA1ZW4je0Fj0X7Ww3kYXmg4iRAZ2yHLCylBVXs4s@u1Y8CSlVS5DnCDvpOcTVGUQNTawyF7OKTuc@yEB4gmWY61DuF6HN2Wfwt2/@AGDoP/K@tdtj5Ar9F3JQiMcsnr7Dw9M9Zo4pudlbUaajKX@3xXQwsftDu62AuvwiXGZbrvIgwibMUkT0BuMQVwtZKmmjZx/AA" rel="nofollow noreferrer" title="Python 3.8 (pre-release) – Try It Online">Try it online!</a></strong></p>
</div>
<div id="pu5" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="nofollow noreferrer">Jelly</a>, 13 <a href="https://github.com/DennisMitchell/jelly/wiki/Code-page" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>;ịFQʋ€ÐLḟ&quot;⁸FL
</code></pre>
<p>A monadic Link that accepts <span class="math-container">\$R\$</span> as a one-indexed adjacency list and yields the required number of edges to add to make a transitive closure, <span class="math-container">\$R*\$</span>, containing <span class="math-container">\$R\$</span>.</p>
<p><strong><a href="https://tio.run/##y0rNyan8/9/64e5ut8BT3Y@a1hye4PNwx3ylR4073Hz@//8fHW0Uq6MQbQwiTECEKYgwAxGGsbEA" rel="nofollow noreferrer" title="Jelly – Try It Online">Try it online!</a></strong> Or see the <a href="https://tio.run/##y0rNyan8/9/64e5ut8BT3Y@a1hye4PNwx3ylR4073Hz@H530cOcMncPtWY8a5ijY2ik8apirGfn/f3R0dKyOAgTH6nApREcbgdiGqBx0WR0FYyQxY5gJRjoKYLXGMMVAdToKJmAhKG2CbpYxXNQURJjBbY8FAA" rel="nofollow noreferrer" title="Jelly – Try It Online">test-suite</a>.</p>
<h3>How?</h3>
<p>Repeatedly add edges that do not yet exist for all traversable pairs of edges, then count the number of new edges.</p>
<pre><code>;ịFQʋ€ÐLḟ&quot;⁸FL - Link: adjacency list, A
      ÐL      - start with X=A and loop until a fixed point applying:
     €        -   for each {node in X}:
    ʋ         -     last four links as a dyad - F(node, X)
 ị            -       {node} index into {X} (vectorises)
;             -       {node} concatenate {that}
  F           -       flatten
   Q          -       deduplicate -&gt; updated node
          ⁸   - chain's left argument -&gt; A
         &quot;    - zip with:
        ḟ     -   {final node} filter discard {original node from A}
           F  - flatten
            L - length
</code></pre>
<hr />
<p>The end, <code>ḟ&quot;⁸FL</code>, seems long, is there something better than this or <code>;ịFQʋ€ÐLn&gt;0SS</code> etc.?</p>
</div>
<div id="pu6" class="pu"><h1><a href="https://github.com/isaacg1/pyth" rel="nofollow noreferrer">Pyth</a>, 12 bytes</h1>
<pre><code>ls-Vum{sam@G
</code></pre>
<p><a href="https://tio.run/##K6gsyfj/P6dYN6w0t7o4MdfB/f//6GijWB2FaBA21FEwANFGsbEA" rel="nofollow noreferrer" title="Pyth – Try It Online">Try it online!</a></p>
<p>Takes zero-indexed input.</p>
<h3>Explanation</h3>
<p>This may be the most implicitly added variables I've ever had in a Pyth golf.</p>
<pre><code>ls-Vum{sam@GkddGQQ    # implicitly add kddGQQ
                      # implicitly assign Q = eval(input())
    u           Q     # find fixed point, repeatedly apply lambda G, H to the previous value, iteration number until we get a result that has occurred before, begin with Q
     m         G      #   map lambda d over G
         m   d        #     map lambda k over d
          @Gk         #       value of G at index k
        a     d       #     append d
       s              #     flatten
      {               #     deduplicate
  -V             Q    # remove any elements originally present in Q, vectorized
 s                    # flatten
l                     # output the length
</code></pre>
</div>
<div id="pu7" class="pu"><h1><a href="https://github.com/somebody1234/Charcoal" rel="nofollow noreferrer">Charcoal</a>, 18 bytes</h1>
<pre><code>ＦθＦιＦ⁻§θκι«⊞ιλ→»Ｉⅈ
</code></pre>
<p><a href="https://tio.run/##S85ILErOT8z5/z8tv0hBo1BTAUxnQmjfzLzSYg3HEs@8lNQKjUIdhWxNHQWgXDUXZ0BpcYZGpo5CjqY1F6dvflmqhlVQZnpGCZBbyxVQlJlXouGcWFyiEaGhqalp/f9/dHS0UayOQjQIG@ooGIBoo9jY2P@6ZTkA" rel="nofollow noreferrer" title="Charcoal – Try It Online">Try it online!</a> Link is to verbose version of code. <code>0</code>-indexed. Explanation:</p>
<pre><code>Ｆθ
</code></pre>
<p>Loop over each vertex.</p>
<pre><code>Ｆι
</code></pre>
<p>Loop over the list of target indices for this vertex. Note that this list can be extended by the innermost loop in which case the additional indices will also be considered.</p>
<pre><code>Ｆ⁻§θκι«
</code></pre>
<p>Loop over the list of target indices for the target vertex, but exclude indices already present in the list of target indices for the source vertex.</p>
<pre><code>⊞ιλ
</code></pre>
<p>Add this index to the list of target indices for the source vertex.</p>
<pre><code>→
</code></pre>
<p>Increment a counter.</p>
<pre><code>»Ｉⅈ
</code></pre>
<p>Output the final count.</p>
<p>Bonus: Reflexive closure, 8 bytes:</p>
<pre><code>ＩΣＥθ¬№ικ
</code></pre>
<p><a href="https://tio.run/##S85ILErOT8z5/z@gKDOvRMM5sbhEI7g0V8M3sUCjUEfBLx8oll8KlMnUUcjWBAPr//@jo6MNYnUUokEYzDCMjY39r1uWAwA" rel="nofollow noreferrer" title="Charcoal – Try It Online">Try it online!</a> Link is to verbose version of code.</p>
<p>Bonus 2: Symmetric closure, 14 bytes:</p>
<pre><code>ＩΣＥθ↨¹Ｅι¬№§θλκ
</code></pre>
<p><a href="https://tio.run/##S85ILErOT8z5/z@gKDOvRMM5sbhEI7g0V8M3sUCjUEfBKbE4VcNQRwHEzdRR8MsHKskvBSp0LPHMS0mtAKnJ0dRRyNaEAuv//6Ojo41idRSiQRio1QBEG8XGxv7XLcsBAA" rel="nofollow noreferrer" title="Charcoal – Try It Online">Try it online!</a> Link is to verbose version of code.</p>
</div>
<div id="pu8" class="pu"><h1>Python3, 240 bytes:</h1>
<pre class="lang-py prettyprint-override"><code>E=enumerate
T=lambda K,g:[(v,l)for i,v in E(K)for _,l in E(K[i+1:])if l not in g[v-1]]
def e(g,n,c=[]):
 for i in g[n-1]:
  yield from T(c+[n,i],g)
  if i not in c:yield from e(g,i,c+[n])
f=lambda g:len({j for i,_ in E(g)for j in e(g,i+1)})
</code></pre>
<p><a href="https://tio.run/##dU@7bsMgFN35ijuCfDs4pFVlyWOmrNkQilwbKBHGluVaiqp@uwvY7jMZAN3zuof@Or52nj/3wzwfSuXfWjVUoyKn0lXtS1PBEU0h6ISO6W4AixNYDwd6TOMZ3ToKm@WFZFaDA9@NETViesilJI3SoKhBj3UpJCsIpKRF4oMkIHC1yjWgh66FE60z4dFKNCwwIdJukXXxQxczLUatZERvfU3hlKfvl2UJnpd@JtW9xCHZspx9sLkfrB@ppkJIhOVIxsg3vItY@APcQu/JEfgNjm8rdgjJy/@agw9hn6j13d/bwb/Yx3g9rTX/5f3WRsH8CQ" rel="nofollow noreferrer">Try it online!</a></p>
</div>
<div id="pu9" class="pu"><h1><a href="https://github.com/Adriandmen/05AB1E/wiki/Commands" rel="nofollow noreferrer">05AB1E</a>, <s>17</s> 16 <a href="https://github.com/Adriandmen/05AB1E/wiki/Codepage" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>āεFè]øε˜ÙINèK}˜g
</code></pre>
<p>0-based indexing.</p>
<p><a href="https://tio.run/##yy9OTMpM/f//SOO5rW6HV8Qe3nFu6@k5h2d6@h1e4V17ek76///R0YY6RrE60SBsDMSxsQA" rel="nofollow noreferrer">Try it online</a> or <a href="https://tio.run/##S0oszvifnFiiYKeQnJ@SqpdfnJiUmapgY6Pg6u/GZa@k8KhtkoKSvdL/I43ntrodXhF7eMe5rafnHJ7p6Xd4hXft6Tnp/5X0wnS4QKq5yjMyc1IVilITUxQy87hS8rkUFPTzC0r0IYZCKTR7bBRUwGrzUv9HRxvqGMXqRIOwMRDHxnJFR4NoKNMQyDBAYiELgzWCuUYQHYY6BmCjwCp0jHRABkJIY2SNMLtMgNgUaj4A" rel="nofollow noreferrer">verify all test cases</a> or <a href="https://tio.run/##VVHNSsNAEL77FENOCilFvSmSW6WIIh4tOYzJNFnY7MbsbGsPPfgYQh@gL6B4Nt4KvlK6P0rxMMsyzPcz32iDT4KGIZmq1vIFJOnV10d2lNxbUwOCFIZBKOCaoENVEcxOU9dwsyNJquI695jv14i6xRb0gjogLGpYoLSUAqoSFBmm0gFLenEv68AYeNwPGRpUK2DRkPF8P@@TfptHzkfRjtlpm1YbugSzxLYVqoJOL8240NI2KmD6zzg/kchMKshaJZ6tmK@iH6GUs@ZXihq7Tf@2jqAHapzvg6lR8G7gOMmmWXIC8043keQAn97125v1f1G3WEUceEJ0eg5YloKFVijlCoqO0AdRaOel8O3gfbeJNNd/2BCtR3MtTArLWnj/BrTtoCNjJfsItOXfo1XZMMzcac7ydObr3FWe7wE" rel="nofollow noreferrer">see what it does step-by-step</a>.</p>
<p><strong>Explanation:</strong></p>

<pre class="lang-python prettyprint-override"><code>ā           # Push a list in the range [1, (implicit) input-length]
 ε          # Map over each value:
  F         #  Loop that many times:
   è        #   Index the inner-most values of the current list into the (implicit)
            #   input-list,
            #   which will use the (implicit) input-list in the first iteration
 ]          # Close both the loop and map
  ø         # Zip/transpose; swapping rows/columns
   ε        # Map over each inner nested list:
    ˜       #  Flatten it
     Ù      #  Uniquify its values
      INè   #  Push the map-index'th list of the input
         K  #  Remove those values from the current list
   }˜       # After the map: flatten it to get all additionally created connections
     g      # Pop and push the length
            # (after which this amount is output implicitly as result)
</code></pre>
<p>Initially I used <code>.Γè}</code> instead of <code>āεFè]</code>, and although it worked for the <a href="https://tio.run/##yy9OTMpM/f9f79zkwytqD@84t/X0nMMzPf0Or/CuPT0n/f//6GhDHaNYnWgQNgbi2FgA" rel="nofollow noreferrer">example test case</a>, it didn't for any test cases that have reflexive vertices (like test case <code>[[1],[0]]</code> for example). Hence the use of <code>āεFè]</code> to loop a fixed amount of times based on the amount of input-vertices.</p>
</div>
<div id="pu10" class="pu"><h1><a href="https://github.com/bsoelch/OneChar.js/blob/main/ItrLang.md" rel="nofollow noreferrer">Itr</a>, 11 bytes <em>(non competing)</em></h1>
<p><code>#µÍ®ääe*¿&lt;S</code></p>
<p>Reads zero-indexed array from standard input, prints the solution to standard output</p>
<p><a href="https://bsoelch.github.io/OneChar.js/?lang=itr&amp;src=I7XNruTkZSq_PFM=&amp;in=W1sxLDJdLFsyXSxbM10sW11d" rel="nofollow noreferrer">online interpreter</a></p>
<h1>Explanation</h1>
<p>The solution is based on the observation that an entry <code>i,j</code> of the <code>k</code>-th power of the adjacency matrix of a graph taken is nonzero iff there is a walk of length <code>k</code> in the graph connecting the vertices <code>i</code> and <code>j</code>.
So the adjacency matrix of the transitive closure has ones in all entries that are non-zero in at least one positive power of the adjacency matrix of the original graph.</p>
<pre><code>#             ; read the array from standard input
 µÍ®          ; compute adjacency matrix of graph
 µ            ; apply to all elements
  Í           ; convert array to array with ones at the indices given by the values of the array
   ®          ; convert nested array to matrix
    ää        ; duplicate matrix twice
      e       ; compute matrix exponential (sum of all powers of matrix)
       *      ; multiply with original matrix (sum of all positive powers of matrix)
        ¿     ; replace all non-zero entries with one
         &lt;    ; point-wise comparison keeps only the entries that appear in A*e^A but not in A 
          S   ; sum up all entries (as all entries are zero or one, this give the number of nonzero entries)
              ; solution is implicitly printed
</code></pre>
<h2>Disclaimer</h2>
<p><em>This language was created after I saw the sandbox version of this challenge.
While the <a href="https://codegolf.meta.stackexchange.com/questions/12877/lets-allow-newer-languages-versions-for-older-challenges">general consensus</a> seems to be that new languages without built-ins designed specifically for a challenge are allowed,
I will still mark this solution as non-competing as this challenge heavily influenced the design process
(for instance built-in matrix operations and the  <code>Í</code> operator were introduced to simplify writing this solution)</em></p>
<hr />
<h1>Itr, <a href="https://bsoelch.github.io/OneChar.js/?lang=itr&amp;src=I7XNruTkTLleU788Uw==&amp;in=W1sxLDJdLFsyXSxbM10sW11d" rel="nofollow noreferrer">13 bytes</a> (no floating point operations)</h1>
<p><code>#µÍ®ääL¹^S¿&lt;S</code></p>
<p><code>äL¹^S</code> directly computes the sum of the first n powers</p>
<pre><code>   ^  ; the matrix to the power of
äL¹   ; the range from 1 to the number of rows
    S ; sum up all results (taking to the power of a vector will give a vector containing all the powers)
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/263566/">263566</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




