<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::4790</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>1074</td><td>Haskell</td><td>120202T131105Z</td><td><a href="https://codegolf.stackexchange.com/questions/4790/hashiwokakero-build-bridges/4824#4824">ceased t</a></td></tr>
<tr d-ix="1"><td>2225</td><td>C#</td><td>120201T220911Z</td><td><a href="https://codegolf.stackexchange.com/questions/4790/hashiwokakero-build-bridges/4814#4814">captncra</a></td></tr>
<tr d-ix="2"><td>1079</td><td>Python</td><td>120202T000856Z</td><td><a href="https://codegolf.stackexchange.com/questions/4790/hashiwokakero-build-bridges/4819#4819">Keith Ra</a></td></tr>
</table>
<div id="pu0" class="pu"><h2>Haskell, 1074 characters</h2>

<pre><code>main=interact$unlines.(\f@(l:_)-&gt;let a=(length l,length f)in head.filter(網(0,0)a).計(0,0)a$f).lines
橋=結"─═"数;結=zip;網 置@(右,下) 域@(幅,高) 地|下&gt;=高=實|右&gt;=幅=網(0,下+1)域 地|目 置 地`含`島
 =折((&amp;&amp;).折((&amp;&amp;).not.(`含`島))實)實(潔 置 域 地)|實=網(右+1,下)域 地
導=[(種,動)|動&lt;-[1,-1],種&lt;-"─═│║"];潔 置 域 地=折(拡 置 域)(換 地 置 '0')導
拡 置 域(種,動)地|([地],置)&lt;-続(行 置 種 動)域 種 動 種 地=潔 置 域 地|實=地
計 置@(右,下)域@(幅,高)地|下&gt;=高=[地]|右&gt;=幅=計(0,下+1)域 地|[価]&lt;-目 置 地`価`島
 =見込(価-環 置 域 地)&gt;&gt;=折(\種-&gt;(fst.続(行 置 種 1)域 種 1' '=&lt;&lt;))[地]&gt;&gt;=計(右+1,下)域
 |實=計(右+1,下)域 地;見込 価|価&lt;0=[]|価&gt;4=[]|實=[[""],["─","│"],["─│","║","═"],["─║","═│"],["═║"]]!!価
続 置 域 種 動 空 地|存 置 域=建 置 域 種 動 空 地|實=([],置)
建 置 域 種 動 空 地|目 置 地`含`島=([地],置)|目 置 地==空=続(行 置 種 動)域 種 動 空(換 地 置 種)
 |實=([],置);存(右,下)(幅,高)|右&gt;=0,幅&gt;右,0&lt;=下=高&gt;下|實=not 實;環 置 域 地=折(環行 置 域 地)0導
環行 置 域 地(種,動)数|置&lt;-行 置 種 動,存 置 域,事&lt;-目 置 地,事==種,[価]&lt;-事`価`(橋++桥)=数+価|實=数
行(右,下)種 数|種`含`橋=(右+数,下)|實=(右,下+数);目(右,下)地=地!!下!!右;島=結"12345678"数
換 地(右,下)事|(上に,線:下に)&lt;-捌 下 地,(左,古:右)&lt;-捌 右 線=上に++(左++(事:右)):下に
折=foldl.flip;捌 0覧=([],覧);捌 数(物:覧)|(一覧,他)&lt;-捌(数-1)覧=(物:一覧,他);實=1&gt;0;数=[1..]
価 _[]=[];価 事((物,数):覧)|事==物=[数]|實=価 事 覧;含 事 覧|[_]&lt;-価 事 覧=實|實=1&lt;0;桥=結"│║"数
</code></pre>

<p><hr>
Originally, I had it even more purely Japanese by also implementing the primitive functions in terms of simple pattern matching and list combinations:</p>

<h2>Haskell, 1192</h2>

<pre><code>main=interact$unlines.(\f@(l:_)-&gt;let a=(length l,length f)in head.filter(網(0,0)a).計(0,0)a$f).lines
橋=結合"─═"数;結合 []_=[];結合(事:覧)(物:一覧)=(事,物):結合 覧 一覧
網 置@(右,下) 域@(幅,高) 地|下&gt;=高=實|右&gt;=幅=網(0,下+1)域 地|目 置 地`含`島
 =折る((&amp;&amp;).折る((&amp;&amp;).反対.(`含`島))實)實(潔 置 域 地)|實=網(右+1,下)域 地
導=[(種,動)|動&lt;-[1,-1],種&lt;-"─═│║"];潔 置 域 地=折る(拡 置 域)(換 地 置 '0')導
拡 置 域(種,動)地|([地],置)&lt;-続(行 置 種 動)域 種 動 種 地=潔 置 域 地|實=地
計 置@(右,下)域@(幅,高)地|下&gt;=高=[地]|右&gt;=幅=計(0,下+1)域 地|[価]&lt;-目 置 地`価`島
 =見込(価-環 置 域 地)&gt;&gt;=折る(\種-&gt;(一.続(行 置 種 1)域 種 1' '=&lt;&lt;))[地]&gt;&gt;=計(右+1,下)域
 |實=計(右+1,下)域 地;見込 価|価&lt;0=[]|価&gt;4=[]|實=[[""],["─","│"],["─│","║","═"],["─║","═│"],["═║"]]!!価
続 置 域 種 動 空 地|存 置 域=建 置 域 種 動 空 地|實=([],置)
建 置 域 種 動 空 地|目 置 地`含`島=([地],置)|目 置 地==空=続(行 置 種 動)域 種 動 空(換 地 置 種)
 |實=([],置);存(右,下)(幅,高)|右&gt;=0,幅&gt;右,0&lt;=下=高&gt;下|實=反対 實;環 置 域 地=折る(環行 置 域 地)0導
環行 置 域 地(種,動)数|置&lt;-行 置 種 動,存 置 域,事&lt;-目 置 地,事==種,[価]&lt;-事`価`結 橋 桥=数+価|實=数
行(右,下)種 数|種`含`橋=(右+数,下)|實=(右,下+数);一(第,第二)=第;目(右,下)地=地!!下!!右;島=結合"12345678"数
換 地(右,下)事|(上に,線:下に)&lt;-捌 下 地,(左,古:右)&lt;-捌 右 線=結 上に(結 左(事:右):下に);変 関[]=[]
変 関(物:覧)=関 物:変 関 覧;折る 関 物[]=物;折る 関 物(事:覧)=折る 関(関 事 物)覧;捌 0覧=([],覧)
捌 数(物:覧)|(一覧,他)&lt;-捌(数-1)覧=(物:一覧,他);實=1&gt;0;反対 真|真=1&lt;0|實=實;数=[1..];結=(++)
価 _[]=[];価 事((物,数):覧)|事==物=[数]|實=価 事 覧;含 事 覧|[_]&lt;-価 事 覧=實|實=1&lt;0;桥=結合"│║"数
</code></pre>

<p><hr><br></p>

<pre><code>$ make ;   def0 +RTS -M1g &lt; test-25x25.txt
ghc -o bin/def0 golfed0.hs -rtsopts -O2
[1 of 1] Compiling Main             ( golfed0.hs, golfed0.o )
Linking bin/def0 ...
2─2─2──2  1 1─2─2──2──2─2
│      │  │1─3═5══4══4─2│
2  2─4─5══5═4═2│2──1 │ │3
│ 2│ ║1│ 1─3═3─2│    │ 2║
│ ║3═4│4══4─4═5─4─3──2 │3
...
</code></pre>

<p>runs in ≈3 minutes on my <em>i5</em>.
<hr>
Commented version:</p>

<pre><code>type Board = [[Char]]
type Location = (Int,Int)
type BoardDimensions = (Int,Int)

main=interact$unlines.(\f@(l:_)
  -&gt;let a=(length l,length f)  -- dimensions of the field from the input
     in head.filter(網(0,0)a)   --   ↙−   determine all possible ways to build bridges
  {-                ↑      -}   .計(0,0)a $ f                                         ).lines
     -- and use the first that is simply connected. 


 --  islands,            bridges
島=結合"12345678"数;  橋=結合"─═"数;  桥=結合"│║"数;               数=[1..]
 -- each with the associated "value" from the natural numbers _↗



     -- plan &amp; commit the building of bridges
計 :: Location -&gt; BoardDimensions -&gt; Board -&gt; [Board]
計    置@(右,下)   域@(幅,高)          地
 |下&gt;=高=[地]        -- Walk over the board until every location was visited.
 |右&gt;=幅=計(0,下+1)域 地
 |[価]&lt;-目 置 地`価`島      -- When there is an island, read it's "value" 価
    =見込(価-環 置 域 地)  -- substract the value of the already-built bridges; fetch the ways to build bridges with the remaining value
     &gt;&gt;=折る(\種-&gt;(一.続(行 置 種 1)域 種 1' '=&lt;&lt;))[地]  -- for each of these ways, try to build a bridge.
      &gt;&gt;=計(右+1,下)域    -- for every possibility where that was successful, go on with the resultant board.
 |實=計(右+1,下)域 地

  -- Ways to build bridges with value 価:
見込 :: Int -&gt; [[Char]]
見込    価
 |価&lt;0=[]   -- not possible to build bridges with negative value
 |価&gt;4=[]   -- nor with value &gt;4  (we're always building south- / eastwards)
 |實=[ [""]      -- value 0
     ,["─","│"]  -- value 1
     ,["─│","║","═"],["─║","═│"],["═║"]]!!価  -- ... and so on

 -- continue, if Location is on the board, with the building of a bridge of type 種
続 :: Location -&gt; BoardDimensions -&gt; Char -&gt; Int -&gt; Char -&gt; Board -&gt; ([Board],Location)
続    置          域                  種      動      空      地
 |存 置 域=建 置 域 種 動 空 地
 |實=([],置)

      -- build that bridge, 
建 :: Location -&gt; BoardDimensions -&gt; Char -&gt; Int -&gt; Char -&gt; Board -&gt; ([Board],Location)
建    置          域                  種      動      空      地
 |目 置 地`含`島=([地],置)  -- but if we've reached an island we're done
 |目 置 地==空 -- if we're in water or what else (空, can also take on the value of 種 if we only want to check if the bridge is already there)
    =続(行 置 種 動)域 種 動 空(換 地 置 種) -- place (換) the bridge and go (行く) to the next location
 |實=([],置)  -- if we've reached something else (i.e. crossing bridges), return no result.

     -- number of connections present at location 置
環 :: Location -&gt; BoardDimensions -&gt; Board -&gt; Int
環 置 域 地=折る(環行 置 域 地)0導  -- for all neighbouring positions
環行 置 域 地(種,動)数
 |置&lt;-行 置 種 動,存 置 域   -- if they're on the board
 ,事&lt;-目 置 地,事==種    --   and there's a bridge in the correct direction
 ,[価]&lt;-事`価`結 橋 桥=数+価  -- check its value and sum it to the previous ones
 |實=数   -- if there's no bridge there, don't sum anything


導=[(種,動)|動&lt;-[1,-1],種&lt;-"─═│║"]     -- directions to go

--     --     --     --     --     --     --     --     --     --     --     --

     -- test for connectedness:
網 :: Location -&gt; BoardDimensions -&gt; Board -&gt; Bool
網    置@(右,下)      域@(幅,高)         地      -- Walk over the board until an island is
 |下&gt;=高=實                                    -- found. 潔 marks all islands connected to
 |右&gt;=幅=網(0,下+1)域 地                        -- that island; then check if any unmarked
 |目 置 地`含`島=折る((&amp;&amp;).折る((&amp;&amp;).反対.(`含`島))實)實(潔 置 域 地)  -- islands are left in the
 |實=網(右+1,下)域 地                                                          -- result.

         -- mark islands connected to the one at 置:
潔 :: Location -&gt; BoardDimensions -&gt; Board -&gt; Board
潔    置           域                 地    =折る(拡 置 域)(換 地 置 '0')[(種,動)|動&lt;-[1,-1],種&lt;-"─═│║"]
 -- mark the island at 置 with '0', then, for all the possible ways to go...
     -- Proceed with the marking in some direction
拡 :: Location -&gt; BoardDimensions -&gt; (Char,Int) -&gt; Board -&gt; [[Char]]
拡 置 域(種,動)地     -- if an island is found in the given direction, give control to 潔 there
 |([地],置)&lt;-続(行 置 種 動)域 種 動 種 地=潔 置 域 地
 |實=地   -- if none is found (i.e. there was no bridge), just return the board without further marking


--     --     --     --     --     --     --     --     --     --     --     --
-- Primitives:

存 :: Location -&gt; BoardDimensions -&gt; Bool
存(右,下)(幅,高)|右&gt;=0,幅&gt;右,0&lt;=下=高&gt;下|實=反対 實  -- check if (右,下) is on the board

行 :: Location -&gt; Char-&gt;Int -&gt; Location
行(右,下)種 数|種`含`橋=(右+数,下)|實=(右,下+数)   -- go in some direction (determined by where 種 leads to)

目 :: Location -&gt; Board -&gt; Char
目(右,下)地=地!!下!!右          -- lookup what's at location (右,下)

   -- replace what's at (右,下) with 事
換 :: Board -&gt; Location -&gt; Char -&gt; Board
換 地(右,下)事|(上に,線:下に)&lt;-捌 下 地,(左,古:右)&lt;-捌 右 線=結 上に(結 左(事:右):下に)




変 :: (a -&gt; b) -&gt; [a] -&gt; [b]
変 関[]=[]                       -- Standard Haskell map function (just noticed I didn't actually use it at all)
変 関(物:覧)=関 物:変 関 覧

折る :: (b -&gt; a -&gt; a) -&gt; a -&gt; [b] -&gt; a
折る 関 物[]=物                            -- equivalent 折る=foldl.flip
折る 関 物(事:覧)=折る 関(関 事 物)覧

捌 0覧=([],覧)
捌 数(物:覧)|(一覧,他)&lt;-捌(数-1)覧=(物:一覧,他)   -- splitAt

實=1&gt;0           --true

反対 真|真=1&lt;0|實=實  -- not


結=(++)     -- list linking

一(第,第二)=第    -- fst

価 :: Eq a =&gt; a -&gt; [(a,b)] -&gt; [b]
価 _[]=[]                             -- lookup function
価 事((物,数):覧)|事==物=[数]|實=価 事 覧

含 :: Eq a =&gt; a -&gt; [(a,b)] -&gt; Bool
含 事 覧|[_]&lt;-価 事 覧=實|實=1&lt;0      -- equivalent 含 x = elem x . map fst


結合 []_=[]                          -- zip
結合(事:覧)(物:一覧)=(事,物):結合 覧 一覧
</code></pre>
</div>
<div id="pu1" class="pu"><h2>C# - <s>6601</s> <s>5661</s> 2225</h2>

<pre><code>using System;using System.Collections.Generic;using Google.OrTools.ConstraintSolver;
using System.Linq;namespace A{class N{public int R,C,Q;public bool F;public N(int r,
int c,int q){R=r;C=c;Q=q;}}class E{private static int i;public N A,B;public int I;
public E(N a,N b){A=a;B=b;I=i++;}}class H{public void G(string i){var o=P(i);var g=
new List&lt;E&gt;();foreach(var m in o){var r=o.Where(x=&gt;x.R==m.R&amp;&amp;x.C&gt;m.C).OrderBy(x=&gt;x.C)
.FirstOrDefault();if(r!=null){g.Add(new E(m,r));}var d=o.Where(x=&gt;x.C==m.C&amp;&amp;x.R&gt;m.R)
.OrderBy(x=&gt;x.R).FirstOrDefault();if(d!=null){g.Add(new E(m,d));}}var s=new Solver("H")
;int n=g.Count;var k=s.MakeIntVarArray(n,0,2);foreach(var j in o){var w=j;var y=g.Where
(x=&gt;x.A==w||x.B== w).Select(x=&gt;k[x.I]).ToArray();s.Add(s.MakeSumEquality(y,j.Q));}
foreach(var u in g.Where(x=&gt;x.A.R==x.B.R)){var e=u;var v=g.Where(x=&gt;x.A.R&lt;e.A.R&amp;&amp;x.B.R
&gt;e.A.R&amp;&amp;x.A.C&gt;e.A.C&amp;&amp;x.A.C&lt; e.B.C);foreach (var f in v){s.Add(s.MakeEquality(k[e.I]*k[f.
I],0));}}if(o.Count&gt;2){foreach(var e in g.Where(x=&gt;x.A.Q==2&amp;&amp;x.B.Q==2)){s.Add(k[e.I]&lt;=1)
;}foreach(var e in g.Where(x=&gt;x.A.Q==1&amp;&amp;x.B.Q==1)){s.Add(k[e.I]==0);}}var z=s.MakePhase
(k,0,0);s.NewSearch(z);int c=0;while(s.
NextSolution()){if(C(k,o,g)){N(k,o,g);Console.WriteLine();c++;}}Console.WriteLine(c);}
bool C(IntVar[]t,List&lt;N&gt;d,List&lt;E&gt;g){var a=d[0];a.F=true;var s=new Stack&lt;N&gt;();s.Push(a);
while(s.Any()){var n=s.Pop();foreach(var e in g.Where(x=&gt;x.A==n||x.B==n)){var o=e.A==n?
e.B:e.A;if(t[e.I].Value()&gt;0&amp;&amp;!o.F){o.F=true;s.Push(o);}}}bool r=d.All(x=&gt;x.F);foreach
(var n in d){n.F=false;}return r;}void N(IntVar[]t,IList&lt;N&gt;n,List&lt;E&gt;e){var l=new 
List&lt;char[]&gt;();for(int i=0;i&lt;=n.Max(x=&gt;x.R);i++){l.Add(new string(' ',n.Max(x=&gt;x.C)+1)
.ToCharArray());}foreach(var o in n){l[o.R][o.C]=o.Q.ToString()[0];N d=o;foreach(var 
g in e.Where(x=&gt;x.A==d)){var v=t[g.I].Value();if(v&gt;0){char p;int c;if(g.B.R==o.R){p=v==1
?'─':'═';c=o.C+1;var r=l[o.R];while(c&lt;g.B.C){r[c]=p;c++;}}else{p=v==1?'│':'║';c=o.R+1;
while(c&lt;g.B.R){l[c][o.C]=p;c++;}}}}}foreach(var r in l){Console.WriteLine(new string(r))
;}}List&lt;N&gt;P(string s){var n=new List&lt;N&gt;();int r=0;foreach(var l in s.Split(new[]{'\r',
'\n'},StringSplitOptions.RemoveEmptyEntries)){for(int c=0;c&lt;l.Length;c++){if(l[c]!=' '
){n.Add(new N(r,c,l[c]-'0'));}}r++;}return n;}}}
</code></pre>

<p>Not particularly well-golfed. Uses constraint programming library from <a href="http://code.google.com/p/or-tools/" rel="nofollow">google or-tools.</a> Builds constraints for total edge counts and to eliminate crossing bridges, but it is a bit harder to define constrains to ensure they are all connected. I did add logic to prune 2=2 and 1-1 components, but I still have to go through the final list (39 on the large one) and eliminate those which are not fully connected. Works pretty fast. Takes only a couple seconds on largest example. Ungolfed:</p>

<pre><code>using System;
using System.Collections.Generic;
using Google.OrTools.ConstraintSolver;
using System.Linq;
namespace Hashi
{
    public class Node
    {
        public int Row, Col, Req;
        public bool Flag;

        public Node(int r, int c, int q)
        {
            Row = r;
            Col = c;
            Req = q;
        }
    }
    public class Edge
    {
        private static int idx = 0;
        public Node A, B;
        public int Index;
        public Edge(Node a, Node b)
        {
            A = a;
            B = b;
            Index = idx++;
        }
    }
    public class HashiSolver
    {
        public void Go(string input)
        {
            IList&lt;Node&gt; nodes = Parse(input);
            var edges = new List&lt;Edge&gt;();
            //add edges between nodes;
            foreach (var node in nodes)
            {
                var r = nodes.Where(x =&gt; x.Row == node.Row &amp;&amp; x.Col &gt; node.Col).OrderBy(x =&gt; x.Col).FirstOrDefault();
                if (r != null)
                {
                    edges.Add(new Edge(node, r));
                }
                var d = nodes.Where(x =&gt; x.Col == node.Col &amp;&amp; x.Row &gt; node.Row).OrderBy(x =&gt; x.Row).FirstOrDefault();
                if (d != null)
                {
                    edges.Add(new Edge(node, d));
                }
            }
            var solver = new Solver("Hashi");
            int n = edges.Count;
            var toSolve = solver.MakeIntVarArray(n, 0, 2);
            //add total node edge total constraints
            foreach (var node in nodes)
            {
                var node1 = node;
                var toConsider = edges.Where(x =&gt; x.A == node1 || x.B == node1).Select(x =&gt; toSolve[x.Index]).ToArray();
                solver.Add(solver.MakeSumEquality(toConsider, node.Req));
            }
            //add crossing edge constraints
            foreach (var ed in edges.Where(x =&gt; x.A.Row == x.B.Row))
            {
                var e = ed;
                var conflicts = edges.Where(x =&gt; x.A.Row &lt; e.A.Row &amp;&amp;
                                                 x.B.Row &gt; e.A.Row &amp;&amp;
                                                 x.A.Col &gt; e.A.Col &amp;&amp;
                                                 x.A.Col &lt; e.B.Col);
                foreach (var conflict in conflicts)
                {
                    solver.Add(solver.MakeEquality(toSolve[e.Index] * toSolve[conflict.Index], 0));
                }
            }
            if (nodes.Count &gt; 2)
            {
                //remove 2=2 connections
                foreach (var e in edges.Where(x =&gt; x.A.Req == 2 &amp;&amp; x.B.Req == 2))
                {
                    solver.Add(toSolve[e.Index] &lt;= 1);
                }
                //remove 1-1 connections
                foreach (var e in edges.Where(x =&gt; x.A.Req == 1 &amp;&amp; x.B.Req == 1))
                {
                    solver.Add(toSolve[e.Index] == 0);
                }
            }
            var db = solver.MakePhase(toSolve, Solver.INT_VAR_DEFAULT, Solver.INT_VALUE_DEFAULT);
            solver.NewSearch(db);
            int c = 0;
            while (solver.NextSolution())
            {
                if (AllConnected(toSolve, nodes, edges))
                {
                    Print(toSolve, nodes, edges);
                    Console.WriteLine();
                    c++;
                }
            }
            Console.WriteLine(c);
        }
        private bool AllConnected(IntVar[] toSolve, IList&lt;Node&gt; nodes, List&lt;Edge&gt; edges)
        {
            var start = nodes[0];
            start.Flag = true;
            var s = new Stack&lt;Node&gt;();
            s.Push(start);
            while (s.Any())
            {
                var n = s.Pop();
                foreach (var edge in edges.Where(x =&gt; x.A == n || x.B == n))
                {
                    var o = edge.A == n ? edge.B : edge.A;
                    if (toSolve[edge.Index].Value() &gt; 0 &amp;&amp; !o.Flag)
                    {
                        o.Flag = true;
                        s.Push(o);
                    }
                }
            }
            bool r = nodes.All(x =&gt; x.Flag);
            foreach (var n in nodes)
            {
                n.Flag = false;
            }
            return r;
        }
        private void Print(IntVar[] toSolve, IList&lt;Node&gt; nodes, List&lt;Edge&gt; edges)
        {
            var l = new List&lt;char[]&gt;();
            for (int i = 0; i &lt;= nodes.Max(x =&gt; x.Row); i++)
            {
                l.Add(new string(' ', nodes.Max(x =&gt; x.Col) + 1).ToCharArray());
            }
            foreach (var node in nodes)
            {
                l[node.Row][node.Col] = node.Req.ToString()[0];
                Node node1 = node;
                foreach (var edge in edges.Where(x =&gt; x.A == node1))
                {
                    var v = toSolve[edge.Index].Value();
                    if (v &gt; 0)
                    {
                        //horizontal
                        if (edge.B.Row == node.Row)
                        {
                            char repl = v == 1 ? '─' : '═';
                            int col = node.Col + 1;
                            var r = l[node.Row];
                            while (col &lt; edge.B.Col)
                            {
                                r[col] = repl;
                                col++;
                            }
                        }
                        //vertical
                        else
                        {
                            char repl = v == 1 ? '│' : '║';
                            int row = node.Row + 1;
                            while (row &lt; edge.B.Row)
                            {

                                l[row][node.Col] = repl;
                                row++;
                            }
                        }
                    }
                }
            }
            foreach (var r in l)
            {
                Console.WriteLine(new string(r));
            }
        }
        private IList&lt;Node&gt; Parse(string s)
        {
            var n = new List&lt;Node&gt;();
            int row = 0;
            foreach (var line in s.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries))
            {
                for (int col = 0; col &lt; line.Length; col++)
                {
                    if (line[col] != ' ')
                    {
                        n.Add(new Node(row, col, line[col] - '0'));
                    }
                }
                row++;
            }
            return n;
        }

    }
}
</code></pre>
</div>
<div id="pu2" class="pu"><h2>Python, 1079 chars</h2>

<pre><code>import sys,re,copy
A=sys.stdin.read()
W=A.find('\n')+1
r=range
V={}
E=[]
for i in r(len(A)):
 if'0'&lt;A[i]&lt;'9':V[i]=int(A[i])
 for d in(1,W):m=re.match('[1-8]( +)[1-8]',A[i::d]);E+=[[i,i+len(m.group(1))*d+d,d,r(3)]]if m else[]
def S(E):
 q,t=0,1
 while q!=t:
  for e in E:
   if any(d[0]and e[3][0]==0and any(i in r(a+c,b,c)for i in r(e[0]+e[2],e[1],e[2]))for a,b,c,d in E):e[3]=[0]
  for i in V:
   m=sum(min(e[3])for e in E if i in e[:2]);n=sum(max(e[3])for e in E if i in e[:2])
   if m&gt;V[i]or n&lt;V[i]:return
   for e in E:
    if m+2&gt;V[i]and i in e[:2]:e[3]=e[3][:V[i]-m+1]
    if n-2&lt;V[i]and i in e[:2]:e[3]=e[3][V[i]-n-1:]
  t=q;q=sum(len(e[3])for e in E)
 Q=[min(V)]
 i=0
 while Q[i:]:
  x=Q[i];i+=1
  for e in E:
   if x in e[:2]:
    if sum(e[3]):
     for y in e[:2]:
      if y not in Q:Q+=[y]
 if len(Q)!=len(V):return
 U=[e for e in E if e[3][1:]]
 if U:
  for w in U[0][3]:U[0][3]=[w];S(copy.deepcopy(E))
 else:
  B=A
  for a,b,c,d in E:
   if d[0]:
    for i in r(a+c,b,c):B=B[:i]+[{1:'─',W:'│'},{1:'═',W:'║'}][d[0]-1][c]+B[i+1:]
  print(B)
  sys.exit(0)
S(E)
</code></pre>

<p>The code does a pretty straightforward exhaustive search in <code>S</code>, using some constraint propagation to make it run in a reasonable time.  <code>E</code> represents the current set of edges, in the format <em>[from,to,delta,possible weights]</em>.   <em>from</em> and <em>to</em> are island identifiers and <em>delta</em> is either 1 for horizontal edges or <em>W</em> (=width of lines) for vertical edges.  <em>possible weights</em> is a sublist of <em>[0,1,2]</em> encoding the current known state of that edge (0=no bridge, 1 = single bridge, 2 = double bridge).</p>

<p><code>S</code> does three things.  First it propagates information, like if one edge no longer has a 0 weight as a possibility, then all edges that cross it are eliminated (their possible weights are set to [0]).  Similarly, if the sum of the minimum weight for edges incident on an island equals the island's weight, then all of those edges are set to their minimum.</p>

<p>Second, <code>S</code> checks that the graph is still connected using non [0] edges (the <code>Q</code> computation).</p>

<p>Finally, <code>S</code> picks an edge that is still not fully determined and calls itself recursively, setting that edge to one of its remaining possibilities.</p>

<p>Takes about 2 minutes for the biggest example.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/4790/">4790</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




