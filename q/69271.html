<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::69271</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>065</td><td>JavaScript Node.js</td><td>231024T142220Z</td><td><a href="https://codegolf.stackexchange.com/questions/69271/fractal-smoke-sequence/266198#266198">l4m2</a></td></tr>
<tr d-ix="1"><td>nan</td><td>Nibbles</td><td>231023T143345Z</td><td><a href="https://codegolf.stackexchange.com/questions/69271/fractal-smoke-sequence/266181#266181">Dominic </a></td></tr>
<tr d-ix="2"><td>013</td><td>05AB1E</td><td>231023T150531Z</td><td><a href="https://codegolf.stackexchange.com/questions/69271/fractal-smoke-sequence/266182#266182">Kevin Cr</a></td></tr>
<tr d-ix="3"><td>028</td><td>Uiua</td><td>231023T093721Z</td><td><a href="https://codegolf.stackexchange.com/questions/69271/fractal-smoke-sequence/266178#266178">Bubbler</a></td></tr>
<tr d-ix="4"><td>037</td><td>APL Dyalog Extended</td><td>190905T123336Z</td><td><a href="https://codegolf.stackexchange.com/questions/69271/fractal-smoke-sequence/191345#191345">Sherlock</a></td></tr>
<tr d-ix="5"><td>019</td><td>Jelly</td><td>190906T105648Z</td><td><a href="https://codegolf.stackexchange.com/questions/69271/fractal-smoke-sequence/191386#191386">Sherlock</a></td></tr>
<tr d-ix="6"><td>071</td><td>Ruby</td><td>190328T171417Z</td><td><a href="https://codegolf.stackexchange.com/questions/69271/fractal-smoke-sequence/182385#182385">histocra</a></td></tr>
<tr d-ix="7"><td>031</td><td>Brachylog</td><td>190327T071637Z</td><td><a href="https://codegolf.stackexchange.com/questions/69271/fractal-smoke-sequence/182283#182283">DLosc</a></td></tr>
<tr d-ix="8"><td>083</td><td>Haskell</td><td>160117T234159Z</td><td><a href="https://codegolf.stackexchange.com/questions/69271/fractal-smoke-sequence/69595#69595">Michael </a></td></tr>
<tr d-ix="9"><td>114</td><td>ES6</td><td>160117T222546Z</td><td><a href="https://codegolf.stackexchange.com/questions/69271/fractal-smoke-sequence/69586#69586">Neil</a></td></tr>
<tr d-ix="10"><td>147</td><td>MATLAB</td><td>160113T165716Z</td><td><a href="https://codegolf.stackexchange.com/questions/69271/fractal-smoke-sequence/69348#69348">Andras D</a></td></tr>
<tr d-ix="11"><td>095</td><td>Mathematica</td><td>160112T232013Z</td><td><a href="https://codegolf.stackexchange.com/questions/69271/fractal-smoke-sequence/69289#69289">Martin E</a></td></tr>
<tr d-ix="12"><td>095</td><td>Python 2</td><td>160112T215358Z</td><td><a href="https://codegolf.stackexchange.com/questions/69271/fractal-smoke-sequence/69284#69284">xnor</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://nodejs.org" rel="nofollow noreferrer">JavaScript (Node.js)</a>, 65 bytes</h1>

<pre class="lang-javascript prettyprint-override"><code>f=(n,x=1,g=d=&gt;--d?2*f(d)-x!=f(2*d-n)?g(d):g(n,++x):x)=&gt;n&gt;0?g(n):f
</code></pre>
<p><a href="https://tio.run/##JcpBDoMgEEDRs3THCNOg3WEHz2JEyLQGjBhDevhSkv7ly3/N15yXg/cTY3JrrZ5EVIV6FciRRXTT0HnhAMuNvBg6hxGm0MCENkpZwBQgG61uGsH46tMhmPqRnw89SsmwpJjTtt63FAQrLxigftN@cvOK@ZyXN2b@rNTrfz8" rel="nofollow noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a></p>
<p>Slow</p>
</div>
<div id="pu1" class="pu"><h1><a href="http://golfscript.com/nibbles/index.html" rel="nofollow noreferrer">Nibbles</a>, <s>12.5</s> 10.5 bytes (21 nibbles)</h1>
<pre><code>.~~1/-,~!*2$`%~&gt;&gt;@-
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=m708LzMpKSe1eMGCpaUlaboWm_Xq6gz1dXXqFLWMVBJU6-zsHHQhMlAFCxZyQRgA" rel="nofollow noreferrer">Attempt This Online!</a></p>
<p>Outputs the infinite sequence.<br />
'Nnumbers-the-new-value-must-avoid' approach taken from <a href="https://codegolf.stackexchange.com/a/69284/95126">xnor's Python answer</a>.</p>
<pre><code>.~~1/-,~!*2$`%~&gt;&gt;@-     # full program
.~~1/-,~!*2$`%~&gt;&gt;@-$    # with implicit variable shown:
.~~                     #  append until null,
   1                    #  starting with the 1-element list [1]:
                        #   get the numbers the new value must avoid:
        !               #    zip together:
         *2$            #     twice the current list
            `%~&gt;&gt;@      #     and its even-indexed elements
                  -     #     by subtraction,
     -                  #   now remove the numbers to avoid from  
      ,~                #    the infinite list of natural numbers
    /              $    #   and get the first element.
</code></pre>
</div>
<div id="pu2" class="pu"><h1><a href="https://github.com/Adriandmen/05AB1E/wiki/Commands" rel="nofollow noreferrer">05AB1E</a>, 13 <a href="https://github.com/Adriandmen/05AB1E/wiki/Codepage" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>ƒ¯Âxsιθ-∞sKнˆ
</code></pre>
<p>Inspired by the <a href="https://codegolf.stackexchange.com/a/69284/52210">Python</a>, <a href="https://codegolf.stackexchange.com/a/266181/52210">Nibbles</a>, and <a href="https://codegolf.stackexchange.com/a/191386/52210">Jelly</a> answers, so make sure to upvote those as well!</p>
<p><a href="https://tio.run/##ASIA3f9vc2FiaWX//8aSwq/DgnhzzrnOuC3iiJ5zS9C9y4b//zQw" rel="nofollow noreferrer">Try it online.</a></p>
<p><strong>Explanation:</strong></p>

<pre class="lang-python prettyprint-override"><code>ƒ             # Loop the (implicit) input+1 amount of times:
 ¯            #  Push the global array (empty by default)
  Â           #  Bifurcate it; short for Duplicate &amp; Reverse copy
   x          #  Double each value in the reversed list (without popping)
    s         #  Swap so the non-doubled reversed list is at the top again
     ι        #  Uninterleave it into two parts
      θ       #  Pop and leave the last part, for all (0-based) odd-indiced values
       -      #  Remove the values in the lists from one another at the same positions,
              #  removing any trailing items, since the lists are of unequal lengths
        ∞     #  Push an infinite positive list: [1,2,3,...]
         s    #  Swap so the generated list is at the top again
          K   #  Remove all those values from the infinite list
           н  #  Pop and keep the first/smallest value remaining
            ˆ #  Pop and add it to the global array for the next iteration
              # (after the loop, the global array that's still on the stack after the
              # bifurcation is output implicitly as result, hence why we loop +1 amount
              # of times)
</code></pre>
</div>
<div id="pu3" class="pu"><h1><a href="https://uiua.org" rel="nofollow noreferrer">Uiua</a>, 28 <a href="https://codegolf.stackexchange.com/a/265917/97916">bytes</a></h1>
<pre><code>⇌⍥(⊂⊗0⍘⊚∸↥0-⬚∞-,▽◿2⇡⧻...)∶[]
</code></pre>
<p><a href="https://www.uiua.org/pad?src=ZiDihpAg4oeM4o2lKOKKguKKlzDijZjiipriiLjihqUwLeKsmuKIni0s4pa94pe_MuKHoeKnuy4uLiniiLZbXQpmIDEwMAojIDEsIDEsIDIsIDEsIDEsIDIsIDIsIDQsIDQsIDEsIDEsIDIsIDEsIDEsIDIsIDIsIDQsIDQsCiMgMiwgNCwgNCwgNSwgNSwgOCwgNSwgNSwgOSwgMSwgMSwgMiwgMSwgMSwgMiwgMiwgNCwgNCwKIyAxLCAxLCAyLCAxLCAxLCAyLCAyLCA0LCA0LCAyLCA0LCA0LCA1LCA1LCA4LCA1LCA1LCA5LAojIDksIDQsIDQsIDUsIDUsIDEwLCA1LCA1LCAxMCwgMiwgMTAsIDEzLCAxMSwgMTAsIDgsIDExLAojIDEzLCAxMCwgMTIsIDEwLCAxMCwgMTIsIDEwLCAxMSwgMTQsIDIwLCAxMw==" rel="nofollow noreferrer">Try it online!</a></p>
<p>I don't think I like the &quot;quadruplicate&quot; up front...</p>
<p>Takes n and outputs the first n values of the sequence.</p>
<pre><code>⇌⍥(⊂⊗0⍘⊚∸↥0-⬚∞-,▽◿2⇡⧻...)∶[]    input: n
⇌⍥(...):[]    repeat n times to the empty list and reverse the result...
⊂⊗0⍘⊚∸↥0-⬚∞-,▽◿2⇡⧻...    input: current list L reversed, output: next item prepended
                 ▽◿2⇡⧻.      extract every 2nd element using mask 0 1 0 1...
           -⬚∞-,        .     2L minus the above, where the above is padded with ∞
         ↥0                    convert negatives to 0 to appease ⍘⊚
        ∸                     prepend 0 to get 1 at the first iteration
     ⍘⊚                      inverse where; counts of 0, 1, ...
  ⊗0                         index of 0 (the smallest nonnegative integer
                              not in the list before ⍘⊚)
⊂                        .   prepend it to L
</code></pre>
</div>
<div id="pu4" class="pu"><h1><a href="https://github.com/abrudz/dyalog-apl-extended" rel="nofollow noreferrer">APL (Dyalog Extended)</a>, 37 <a href="https://codegolf.meta.stackexchange.com/a/9429/43319" title="When can APL characters be counted as 1 byte each?">bytes</a><sup><a href="https://github.com/abrudz/SBCS" rel="nofollow noreferrer" title=".dyalog files using a single byte character set">SBCS</a></sup></h1>



<p>Many thanks to Adám for his help in writing and golfing this answer in <a href="https://chat.stackexchange.com/rooms/52405/the-apl-orchard">The APL Orchard</a>, a great place to learn the APL language. <a href="https://tio.run/##SyzI0U2pTMzJT9dNrShJzUtJTfn/qKNdIe3/o5691Y96t@o86l3xqKtZ41HvZkPtR52LgEKadbqH1hs96loKZEcbHZ7@qLfhUS@Qs/lRT5fR4e0gDWB1sbWPehc/6psKNGINyFCutEdtEx719hkCjVavrVbXUQdKgnCROlC1@qOuRUaPerYD@clF6mnqCo965yqUFCWmpOUplOQrAKn/j9omgpykkQZyRO2hFYYGBgYA" rel="nofollow noreferrer" title="APL (Dyalog Extended) – Try It Online">Try it online!</a></p>

<p><strong>Edit:</strong> -6 bytes thanks to Adám</p>

<pre class="lang-apl prettyprint-override"><code>⌽{⍵,⍨⊃(⍳1+≢⍵)~-¯2⊥⍵[2×⍀⍥⍳⌊2÷⍨≢⍵]}⍣⎕,⍬
</code></pre>

<p><strong>Explanation</strong></p>

<pre class="lang-apl prettyprint-override"><code>{⍵,⍨⊃(⍳1+≢⍵)~-¯2⊥⍵[2×⍀⍥⍳⌊2÷⍨≢⍵]}  ⍵ is our right argument, the sequence S

                        ⌊2÷⍨≢⍵    We start by calculating X = ⌊len(S)÷2⌋
                       ⍳          Get a range [1, X]
                   2×⍀⍥           With that we can get S[:X] and S[:X×2:2]
                                  or S up to halfway and every 2nd element of S
             -¯2⊥⍵[           ]   And with that we can get 2*S[:X] - S[:X×2:2]
                                  Which is C=2*B-A of a progression A B C
     (⍳1+≢⍵)~                     We remove these Cs from our possible a(n)s
                                  I use range [1, len(S)+1]
    ⊃                             Get the first result, which is the minimum
 ⍵,⍨                              And then prepend that to S


⌽{...}⍣⎕,⍬

 {...}⍣⎕    We iterate an "input" ⎕ times
        ,⍬  with an empty list ⍬ as the initial S
⌽           and reversing S at the end as we have built it backwards
</code></pre>

<h1><a href="https://www.dyalog.com/" rel="nofollow noreferrer">APL (Dyalog Unicode)</a>, <s>43</s> <s>39</s> 38 <a href="https://codegolf.meta.stackexchange.com/a/9429/43319" title="When can APL characters be counted as 1 byte each?">bytes</a><sup><a href="https://github.com/abrudz/SBCS" rel="nofollow noreferrer" title=".dyalog files using a single byte character set">SBCS</a></sup></h1>

<p>Here is a faster but less golfy solution that can calculate <code>⍺(10000)</code> in a few seconds.</p>

<pre class="lang-apl prettyprint-override"><code>⌽{⍵,⍨⊃(⍳1+≢⍵)~-⌿⍵[1 2 1∘.×⍳⌊2÷⍨≢⍵]}⍣⎕,⍬
</code></pre>

<p><a href="https://tio.run/##SyzI0U2pTMzJT///qKNdIe3/o5691Y96t@o86l3xqKtZ41HvZkPtR52LgEKadbqPevYDGdGGCkYKho86Zugdng6Uf9TTZXR4O0g9WFls7aPexY/6pgJNWAMykyvtUduER719hkCT1Wur1XXUgZIgXKQOVK3@qGuR0aOe7UB@cpF6mrrCo965CiVFiSlpeQol@QpA6v@jtokgF2mkgdxQe2iFoQEQAAA" rel="nofollow noreferrer" title="APL (Dyalog Unicode) – Try It Online">Try it online!</a></p>
</div>
<div id="pu5" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="nofollow noreferrer">Jelly</a>, <s>24</s> 19 bytes</h1>

<p>This is my first Jelly answer in quite a while. Glad to be back.</p>

<p>This is a port of <a href="https://codegolf.stackexchange.com/a/191345/47581">my APL answer</a> which itself is an adaptation of many of the algorithms used here. The main difference is that this is 0-indexed.</p>

<p><strong>Edit:</strong> -5 bytes thanks to Jonathan Allan.</p>

<p><a href="https://tio.run/##ATAAz/9qZWxsef//4biKbTLJk@G5geG4pF8KxbtK4bifw4fhuYI7CjHDh8KhVf///zEwMDA" rel="nofollow noreferrer" title="Jelly – Try It Online">Try it online!</a></p>

<pre><code>Ḋm2ɓṁḤ_
ŻJḟÇṂ;
1Ç¡U
</code></pre>

<p><strong>Explanation</strong></p>

<pre><code>Ḋm2ɓṁḤ_  First link. Takes our current sequence S as our left argument.

         We are trying to calculate, of an arithmetic progression A B C, 
           the C using the formula, C = 2*B - A
Ḋ        Remove the first element of S.
 m2      Get every element at indices 0, 2, 4, ...
           This is equivalent to getting every second element of S, a list of As.
   ɓ     Starts a dyad with reversed arguments.
           The arguments here are S and As.
    ṁ    This molds S in the shape of As, giving us a list of Bs.
     Ḥ   We double the Bs.
      _  And subtract As from 2 * Bs.

ŻJḟÇṂ;  Second link. Takes S as our left argument.

Ż       Append a 0 to S.
 J      Range [1, len(z)]. This gets range [1, len(S) + 1].
  ḟÇ    Filter out the results of the previous link, our Cs.
    Ṃ   Take the minimum of Cs.
     ;  And concatenate it with the rest of the sequence so far.

1Ç¡U  Third link. Where we feed our input, n.

1     A list with the element 1.
 Ç¡   Run the previous link n times.
   U  Reverse everything at the end.
</code></pre>
</div>
<div id="pu6" class="pu"><h1><a href="https://www.ruby-lang.org/" rel="nofollow noreferrer">Ruby</a>, 71 bytes</h1>



<pre class="lang-ruby prettyprint-override"><code>-&gt;n,*a{a.fill(0,n){|s|([*1..n]-(1..s/2).map{|o|2*a[s-o]-a[s-2*o]})[0]}}
</code></pre>

<p><a href="https://tio.run/##NcWxCsMgEADQPV@RUSVeTvf2R@SG6yAEjEpth6B@u20Iect7f1/H8I@hn3FRXBn8FoLAJcraShNOGYBIWvwrq5Wwc64tNavYFZ1In1mVqEuH1PvIs3eGpjN7ZfAekSBw@Ywf" rel="nofollow noreferrer" title="Ruby – Try It Online">Try it online!</a></p>

<p>Generates all forbidden values, then takes the complement of that array in (1..n) and takes the first value of the result. That means I am assuming that <code>a[n] &lt;= n</code> for all n, which is easily proven using induction (if the first n/2 terms are all less than n/2, then there can't be an arithmetic progression leading to n).</p>

<p>The syntactic trick here is also mildly interesting: <code>*a</code> is used to initialize an array of additional arguments (which would be ignored if we passed any), and then <code>a.fill</code> mutates the argument array and implicitly returns it.</p>
</div>
<div id="pu7" class="pu"><h1><a href="https://github.com/JCumin/Brachylog" rel="nofollow noreferrer">Brachylog</a>, <s>33</s> 31 bytes</h1>

<pre><code>;Ė{~b.hℕ₁≜∧.¬{ġh₃hᵐs₂ᶠ-ᵐ=}∧}ⁱ⁽↔
</code></pre>

<p><a href="https://tio.run/##SypKTM6ozMlPN/r/3/rItOq6JL2MRy1THzU1Puqc86hjud6hNdVHFmY8amrOeLh1QvGjpqaH2xboApm2tUDZ2keNGx817n3UNuX/fyPT/1EA" rel="nofollow noreferrer" title="Brachylog – Try It Online">Try it online!</a></p>

<p><em>In case it matters: The 2-byte golf was possible thanks to a feature I <a href="https://chat.stackexchange.com/transcript/message/49663867#49663867">requested</a> after working on this challenge.</em></p>

<h3>Explanation</h3>

<p>We iteratively generate the sequence as a list in reverse order, e.g. <code>[2,2,1,1,2,1,1]</code>, and reverse it at the end.</p>

<p>There are a couple of nested predicates here. Let's look at them from the inside out. The first one, <code>ġh₃hᵐs₂ᶠ-ᵐ=</code>, takes a candidate subsequence <code>a(n),a(n-1),...,a(0)</code> and determines whether <code>a(n),a(n-k),a(n-2k)</code> is an arithmetic sequence for some <code>k</code>.</p>

<pre><code>ġ            Group the list into equal-length sublists (with the possible exception of
             the last sublist, which might be shorter)
 h₃          Get the first 3 sublists from that list
   hᵐ        and get the head of each of those 3 sublists
             We now have a list containing a(n),a(n-k),a(n-2k) for some k
     s₂ᶠ     Find all 2-element sublists of that list: [a(n),a(n-k)] and [a(n-k),a(n-2k)]
        -ᵐ   Find the difference of each pair
          =  Assert that the two pairwise differences are equal
</code></pre>

<p>For example, with input of <code>[1,2,1,1,2,1,1]</code>:</p>

<pre><code>ġ has possible outputs of
    [[1],[2],[1],[1],[2],[1],[1]]
    [[1,2],[1,1],[2,1],[1]]
    [[1,2,1],[1,2,1],[1]]
    [[1,2,1,1],[2,1,1]]
    [[1,2,1,1,2],[1,1]]
    [[1,2,1,1,2,1],[1]]
    [[1,2,1,1,2,1,1]]
h₃ has possible outputs of
    [[1],[2],[1]]
    [[1,2],[1,1],[2,1]]
    [[1,2,1],[1,2,1],[1]]
hᵐ has possible outputs of
    [1,2,1]
    [1,1,2]
    [1,1,1]
s₂ᶠ has possible outputs of
    [[1,2],[2,1]]
    [[1,1],[1,2]]
    [[1,1],[1,1]]
-ᵐ has possible outputs of
    [-1,1]
    [0,-1]
    [0,0]
= is satisfied by the last of these, so the predicate succeeds.
</code></pre>

<p>The next predicate outwards, <code>~b.hℕ₁≜∧.¬{...}∧</code>, inputs a subsequence <code>a(n-1),a(n-2),...,a(0)</code> and outputs the next bigger subsequence <code>a(n),a(n-1),a(n-2),...,a(0)</code>.</p>

<pre><code>~b.hℕ₁≜∧.¬{...}∧
~b.                 The input is the result of beheading the output; i.e., the output is
                    the input with some value prepended
  .h                The head of the output
    ℕ₁              is a natural number &gt;= 1
      ≜             Force a choice as to which number (I'm not sure why this is necessary,
                    but the code doesn't work without it)
        ∧           Also,
         .          the output
          ¬{...}    does not satisfy the nested predicate (see above)
                    I.e. there is no k such that a(n),a(n-k),a(n-2k) is an arithmetic sequence
                ∧   Break unification with the output
</code></pre>

<p>Finally, the main predicate <code>;Ė{...}ⁱ⁽↔</code> takes an input number and outputs that many terms of the sequence.</p>

<pre><code>;Ė{...}ⁱ⁽↔
;           Pair the input number with
 Ė          the empty list
  {...}ⁱ⁽   Using the first element of the pair as the iteration count and the second
            element as the initial value, iterate the nested predicate (see above)
         ↔  Reverse, putting the sequence in the proper order
</code></pre>
</div>
<div id="pu8" class="pu"><h1>Haskell, <s>90</s>, <s>89</s>, <s>84</s>, 83 bytes</h1>
<p>Can probably be golfed more, but this is still a decent <s>first</s> attempt:</p>
<pre><code>a n|n&lt;1=0|n&lt;3=1|1&lt;2=[x|x&lt;-[1..],and[x/=2*a(n-k)-a(n-k-k)||a(n-k-k)&lt;1|k&lt;-[1..n]]]!!0
</code></pre>
<p>Ungolfed:</p>
<pre><code>a n | n&lt;1        = 0 
    | n&lt;3        = 1
    | otherwise  = head (goods n)

goods n = [x | x &lt;- [1..], isGood x n]

isGood x n = and [ x - a(n-k) /= a(n-k) - a(n-k-k) || a(n-k-k) == 0 | k &lt;- [1..n] ]
</code></pre>
<p>This is a simple implementation which returns '0' for out of bounds. Then, for each possible value, it checks that for all k &lt;= n and in bounds, [x, a(x-k), a(x-2k)] is not an arithmetic sequence.</p>
<p>Upper bound on time complexity (using the fact from the OEIS page that a(n) &lt;= (n+1)/2:</p>
<pre><code>t n &lt;= sum[ sum[2*t(n-k) + 2*t(n-k-k) | k &lt;- [1..n]] | x &lt;- [1..(n+1)/2]]
    &lt;= sum[ sum[4*t(n-1)              | k &lt;- [1..n]] | x &lt;- [1..(n+1)/2]]
    &lt;= sum[     4*t(n-1)*n                         ] | x &lt;- [1..(n+1)/2]]
    &lt;=          4*t(n-1)*n*(n+1)/2
    -&gt;
O(t(n)) == O(2^(n-2) * n! * (n+1)!)
</code></pre>
<p>I'm not sure how good this bound is because calculating the first 1k values of 't' and using a linear model on the logs of the values gave appx. O(22^n), with p-value &lt; 10^(-1291), in case it matters.</p>
<p>On an implementation level, compiling with '-O2', it took ~35 min to calculate the first 20 values.</p>
</div>
<div id="pu9" class="pu"><h2>ES6, 114 bytes</h2>

<pre><code>n=&gt;[...r=Array(n)].map((x,i,s)=&gt;{for(y=1;x&amp;&amp;x[y];y++);r[i]=y;for(j=i;++j&lt;n;s[j][y+y-r[i+i-j]]=1)s[j]=s[j]||[]}&amp;&amp;r
</code></pre>

<p>Returns an array of the first n elements of the sequence, so the indices are 1 off the ungolfed version below. I used the sieve approach. This version slows down after about n=2000; a previous version avoided reading off the beginning of the array which meant it didn't slow down until about n=2500. An older version used the sieve array as a list of forbidden values rather than a boolean array of which values were forbidden; this could get to about n=5000 without breaking sweat. My original version tried to use bitmasks but that turned out to be unhelpful (and was also far too long at 198 bytes).</p>

<p>The not quite so slow version ungolfed:</p>

<pre><code>function smoke(n) {
    result = [];
    sieve = [];
    for (i = 1; i &lt;= n; i++) {
        value = 1;
        if (sieve[i]) {
            while (sieve[i][value]) {
                value++;
            }
        }
        result[i] = value;
        for (j = 1; j &lt; i &amp;&amp; i + j &lt;= n; j++) {
            if (!sieve[i + j]) sieve[i + j] = [];
            sieve[i + j][value + value - result[i - j]] = true;
        }
    }
    return result;
}
</code></pre>
</div>
<div id="pu10" class="pu"><h2>MATLAB, <strike>156</strike> 147 bytes</h2>

<p>I've finally gotten to golf this down a bit:</p>



<pre><code>N=input('');s=[0;0];for n=1:N,x=s(n,~~s(n,:));try,a(n)=find(~ismember(1:max(x)+1,x),1);catch,a(n)=1;end,s(n+1:2*n-1,end+1)=2*a(n)-a(n-1:-1:1);end,a
</code></pre>

<p>Ungolfed:</p>



<pre><code>N=input('');                                   % read N from stdin

s=[0;0];
for n=1:N,
    x=s(n,~~s(n,:));                           % x=nonzeros(s(n,:));
    try,
        a(n)=find(~ismember(1:max(x)+1,x),1);  % smallest OK number
    catch,
        a(n)=1;                                % case of blank page for n
    end,

    s(n+1:2*n-1,end+1)=2*a(n)-a(n-1:-1:1);     % determined new forbidden values
end,
a                                              % print ans=...
</code></pre>

<p>Input is read from STDIN, and printing is done automatically with <code>ans=</code> and stuff appended. I hope this qualifies as "reasonable" output.</p>

<p>This is also a sieve-based solution: the variable <code>s(i,:)</code> keeps track of those sequence values which are <em>forbidden</em> for <code>a(i)</code>. The <code>try-catch</code> block is needed to treat the case of an empty (meaning full zero) <code>s</code> matrix: in this case the lowest value of <code>1</code> is already allowed.</p>

<p>However, the memory need (or runtime?) gets pretty messy above <code>N=2000</code>. So here's a non-competing, more efficient solution:</p>

<pre><code>%pre-alloc
s = zeros([N,fix(N*0.07+20)]); %strict upper bound, needs adjusting later
i = zeros(1,N);

a = 1;
for n = 2:N,
    x = s(n,1:i(n));
    if isempty(x),
        a(n) = 1;
    else
        a(n) = find(~ismember(1:max(x)+1,x),1);
    end,

    j = n+1:min(2*n-1,N);
    i(j) = i(j)+1;
    s(N,max(i(j))) = 0;   %adjust matrix size if necessary
    b = a(n-1:-1:1);
    s(sub2ind([N,size(s,2)+1],j,i(j))) = 2*a(n)-b(1:length(j));
end
</code></pre>

<p>In this implementation the <code>s</code> matrix again contains forbidden values, but in a well-ordered way, without any zero blocks (which are present in the competing version).  The index vector <code>i</code> keeps track of the number of forbidden vectors in <code>s</code>. At first sight cells would be great to keep track of the information stored in <code>s</code>, but those would be slow, and we couldn't index a bunch of them at the same time.</p>

<p>One nasty feature of MATLAB is that while you can say <code>M(1,end+1)=3;</code> and automatically expand a matrix, you can't do the same with linear indexing. It sort of makes sense (how should MATLAB know the resulting array size, in the framework of which it should interpret the linear indices?), but it still surprised me. This is the reason for the superfluous line <code>s(N,max(i(j))) = 0;</code>: this will expand the <code>s</code> matrix for us whenever necessary. The starting size guess <code>N*0.07+20</code> comes from a linear fit to the first few elements, by the way.</p>

<p>In order to test runtime, I also checked a slightly modified version of the code, where I initialized the <code>s</code> matrix to have size <code>N/2</code>. For the first <code>1e5</code> elements this seems to be a very generous guess, so I removed the expansion step of <code>s</code> mentioned in the previous paragraph. These together imply that the code will be faster, but also less robust at very high <code>N</code> (since I don't know how the series looks like there).</p>

<p>So here are a few runtimes, comparing</p>

<ul>
<li>v1: the competing golfed version,</li>
<li>v2: the low-starting-size, fool-proof version and</li>
<li>v3: the generous-starting-size, might-fail-for-large-N version.</li>
</ul>

<p>I measured these on R2012b, taking the best of 5 runs inside a named function definition with <code>tic/toc</code>.</p>

<ol>
<li><code>N=100</code>:

<ul>
<li>v1: <code>0.011342 s</code></li>
<li>v2: <code>0.015218 s</code></li>
<li>v3: <code>0.015076 s</code></li>
</ul></li>
<li><code>N=500</code>:

<ul>
<li>v1: <code>0.101647 s</code> </li>
<li>v2: <code>0.085277 s</code></li>
<li>v3: <code>0.081606 s</code></li>
</ul></li>
<li><code>N=1000</code>:

<ul>
<li>v1: <code>0.641910 s</code></li>
<li>v2: <code>0.187911 s</code></li>
<li>v3: <code>0.183565 s</code></li>
</ul></li>
<li><code>N=2000</code>:

<ul>
<li>v1: <code>5.010327 s</code></li>
<li>v2: <code>0.452892 s</code></li>
<li>v3: <code>0.430547 s</code></li>
</ul></li>
<li><code>N=5000</code>:

<ul>
<li>v1: N/A (didn't wait)</li>
<li>v2: <code>2.021213 s</code></li>
<li>v3: <code>1.572958 s</code></li>
</ul></li>
<li><code>N=10000</code>:

<ul>
<li>v1: N/A</li>
<li>v2: <code>6.248483 s</code></li>
<li>v3: <code>5.812838 s</code></li>
</ul></li>
</ol>

<p>It would seem that the <code>v3</code> version is significantly, but not overwhelmingly faster. I don't know whether an element of uncertainty (for very large <code>N</code>) is worth the minor increase in runtime.</p>
</div>
<div id="pu11" class="pu"><h2>Mathematica, 95 bytes</h2>

<pre><code>For[n_~s~k_=0;n=0,n&lt;#,For[i=n,--i&gt;0,s[2n-i,2f@n-f@i]=1];For[++n;i=1,n~s~i&gt;0,++i];Print[f@n=i]]&amp;
</code></pre>

<p>Certainly not the golfiest approach, but this is actually fairly efficient, compared to the algorithms I tried from the OEIS page.</p>

<p>As opposed to checking all the forbidden values for each <em>s(n)</em> when we get there I'm using a sieve-based approach. When we find a new value <em>s(n)</em> we check immediately which values this forbids for <em>m > n</em>. Then we just solve the <em>s(n+1)</em> by looking for the first value that wasn't forbidden.</p>

<p>This can be made even more efficient by changing the conditional <code>--i&gt;0</code> to <code>2n-#&lt;=--i&gt;0</code>. In that case, we avoid checking forbidden values for <em>n</em> greater than the input.</p>

<p>For a somewhat more readable version, I started with this code, which stores the results up to <code>max</code> in a function <code>f</code>, and then golfed it to the above one-line pure function:</p>

<pre><code> max = 1000;
 ClearAll[sieve, f];
 sieve[n_, k_] = False;
 For[n = 0, n &lt; max,
  temp = f[n];
  For[i = n - 1, i &gt; 0 &amp;&amp; 2 n - i &lt;= max, --i,
   sieve[2 n - i, 2 temp - f[i]] = True;
   ];
  ++n;
  i = 1;
  While[sieve[n, i], ++i];
  f@n = i;
  ]
</code></pre>
</div>
<div id="pu12" class="pu"><h2>Python 2, 95 bytes</h2>

<pre class="lang-python prettyprint-override"><code>l=[];n=input()
exec&quot;a=min(set(range(n))-{2*b-c for b,c in zip(l,l[1::2])});print-~a;l=[a]+l;&quot;*n
</code></pre>
<p>The main trick is in generating the numbers the new value must avoid. Keeping the reversed sequence so far in <code>l</code>, let's look at what elements might form a three-term arithmetic progression with the value we're about to add.</p>
<pre class="lang-python prettyprint-override"><code>? 4 2 2 1 1 2 1 1   a b c
^ ^ ^               ? 4 2
^   ^   ^           ? 2 1
^     ^     ^       ? 2 2
^       ^       ^   ? 1 1
</code></pre>
<p>The other numbers are the paired members of <code>l</code> and every second element of <code>l</code>, so <code>zip(l,l[1::2])</code>. If this pair is <code>(b,c)</code> then the arithmetic progression <code>(a,b,c)</code> happens for <code>a=2*b-c</code>. After generating the set of <code>a</code>'s to avoid, the code takes the minimum of the complement, prints it, and prepends it to the list. (Actually, the computation is done with numbers decreased by 1, and printed 1 higher, to let <code>range(n)</code> serve as a universe of candidates.)</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/69271/">69271</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




