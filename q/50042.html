<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::50042</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>697</td><td>Python3</td><td>240624T190048Z</td><td><a href="https://codegolf.stackexchange.com/questions/50042/scientist-seals-stranded-upon-an-iceberg/273775#273775">Ajax1234</a></td></tr>
<tr d-ix="1"><td>nan</td><td></td><td>150512T182044Z</td><td><a href="https://codegolf.stackexchange.com/questions/50042/scientist-seals-stranded-upon-an-iceberg/50077#50077">edc65</a></td></tr>
<tr d-ix="2"><td>628</td><td>C++</td><td>150516T222005Z</td><td><a href="https://codegolf.stackexchange.com/questions/50042/scientist-seals-stranded-upon-an-iceberg/50313#50313">Reto Kor</a></td></tr>
<tr d-ix="3"><td>520</td><td>Python 3</td><td>150512T061415Z</td><td><a href="https://codegolf.stackexchange.com/questions/50042/scientist-seals-stranded-upon-an-iceberg/50049#50049">DLosc</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>Python3, 697 bytes</h1>
<p>Long, but fast.</p>
<pre class="lang-py prettyprint-override"><code>E=enumerate
def f(b):
 d,h={},{}
 for x,r in E(b):
  for y,v in E(r):d[(x,y)]=v;h[v]=(x,y)
 q,s=[(d,[],[])],[d]
 M=[(1,0),(0,1),(-1,0),(0,-1)]
 while q:
  q=sorted(q,key=lambda x:x[-1].count('D'))[::-1]
  d,c,C=q.pop(0)
  if'D'not in d.values():continue
  for i in d:
   if d[i].isalpha():
    for X,Y in M:
     x,y=i;p=[]
     while(K:=d.get(v:=(x:=x+X,y:=y+Y)))in['#','*']:p+=[v]
     if K and'D'==d[i]and p and'*'==d[p[-1]]:return c+[(X,Y)]
     D=eval(str(d))
     D[i]='#'
     if(F:=K and K.isalpha())and p:
      if'*'==D[p[-1]]:continue
      D[p[-1]]=d[i]
     j,k=h['*']
     if D not in s and(d[i]!='D'or F)and any(D[(j+J,k+K)].isalpha()for J,K in M):q+=[(D,c+[(X,Y)],c+[d[i]])];s+=[D]
</code></pre>
<p><a href="https://tio.run/##hVRNT@MwED1vfoWXHGqnJqKUw8rIpw0cqNgzyBut0trdmgYnTdJsI8RvL2M7/Vi2sFYU2W888@Y9ZVJ2zaIw429ltd3ecGXWz6rKGhVINUdzPCUsQJIu@MsrfXkN0Lyo0IZWSBt044MO6mjroYowKfCGdiTl7fVCtCl3pwCtaM0FllSk8BB4yTRA9wCN6AWh@IKO4H2@O5yPCIT/LHSu0MqyrHhdVI2SeEWXquN59jyVGdqwjTgfpfGsWJsGD5IBIYIxQCBD0hn9zldxWZT4AhpAeg4XTNHYTmXcZvla1ZiwWWEabdaql6Jd2FJCApJCp7Gus7xcZNjJ9bce6KO9d@8RsKTj@rrkIvVn1zieMC7j36rBLQMXGN8MH2jHeDd8JIRoIwbhgA6iQcrKIQenfCqQTlBmJPTKuaWHPSodEjmktIpTVqlmXRk0GwoMzZA@O@EKhOG6qbAkpMegCAeuXX18y7ijQJODNOJoejnWKkuW7MiOPPIVPe7689gTXfKFsGr2MhLUm11bMmzvfuUgC@y7dXSZ6XAi8NPwji6HE3JktLX4jk6cxYStwB6c0L1Uu7PV4DO6riGWpNt6hDg6OzsL4o9WEIenVx9J/gKj5SFyOudDHttFffm@nSDOXOZ0V1T68nm0J3oOS7dLwjicHVP4kuN3JYN4Ckmz2F8MHQIiZNQeUn3m1f@88fz/wr4112K/2v0uCT/P@twg93tpil/TIqskrmGyvvQftBCRTg@TONd5oyr8ozCKojquy1zDoP80MOlpEJSVhrmf40OlEYzWCfjyNDw@DV8BvH0D" rel="nofollow noreferrer">Try it online!</a></p>
</div>
<div id="pu1" class="pu"><h1>JavaScript (ES6) 322 <s>334 323</s></h1>

<p><strong>Edit2</strong> Added animation in the snippet</p>

<p><strong>Edit</strong> Bug fix, remember initial posiiton of '*', so I find it even when a seal slide over it and erase it.</p>

<p>Implemented as a function with the input string as parameter (probably invalid but waiting for a clarification). Output via popup.<br>
The problem with multiline string input in JavaScript is that <code>prompt</code> does not manage it well.</p>

<p>As for the algorithm: a BFS, should find an optimal solution. 
I keep a queue of game status in variable <code>l</code>, the status beeing the character grid <code>g</code> and the sequence of moves so far <code>s</code>. Besides, there is a set of grids obtained so far in variable <code>k</code>, to avoid exploring the same grid again and again.</p>

<p>The main loop is</p>

<ul>
<li>dequeue a game status</li>
<li>try all possibile moves, enqueue the status after each valid move (IIF the resulting grid is not already present) </li>
<li>if solution found then exit the loop</li>
</ul>

<pre class="lang-js prettyprint-override"><code>F=s=&gt;{
  o=~s.match(/\d+/),g=[...z=s.replace(/.*/,'')];
  for(l=[[g,'']],k=[];[g,s]=l.shift(),!g.some((c,p)=&gt;
      c&gt;'A'&amp;&amp;[-1,1,o,-o].some((d,j)=&gt;{
        t=s+' '+[c,'LRUD'[j]];
        for(q=p;(u=g[q+d])&lt;'.';)q+=d;
        return(c&lt;'a'&amp;z[q]=='*')||
        c&gt;'D'|u&gt;'.'&amp;&amp;!(
          f=[...g],u=='.'?0:f[q]=c,f[p]='#',
          k[h=f.map(v=&gt;v&gt;'D'?0:v)]||(k[h]=l.push([f,t]))
        )
      })
    ););
  alert(t)
}
</code></pre>

<p>Run Snippet to test in FireFox</p>

<p><div class="snippet" data-lang="js" data-hide="true">
<div class="snippet-code snippet-currently-hidden">
<pre class="snippet-code-js lang-js prettyprint-override"><code>F=s=&gt;{
  o=~s.match(/\d+/),g=[...z=s.replace(/.*/,'')];
  for(l=[[g,k=[]]];[g,s]=l.shift(),!g.some((c,p)=&gt;
      c&gt;'A'&amp;&amp;[-1,1,o,-o].some((d,j)=&gt;{
        t=s+' '+[c,'LRUD'[j]];
        for(q=p;(u=g[q+d])&lt;'.';)q+=d;
        return(c&lt;'a'&amp;z[q]=='*')||
        c&gt;'D'|u&gt;'.'&amp;&amp;!(
          f=[...g],u=='.'?0:f[q]=c,f[p]='#',
          k[h=f.map(v=&gt;v&gt;'D'?0:v)]||(k[h]=l.push([f,t]))
        )
      })
    ););
  return t
}

$('.T td').each(function(i,td) { $('.R td').eq(i).text(F($(td).text())) });

$(".R").on('click','td',function(){ 
  var i = $(this).index();
  var $td = $('.T td').eq(i);
  var t = $td.text().trim();
  animate($td, $td.text().trim(), $('.R td').eq(i).text().trim());
});

$('#GO').on('click',function() { 
  var s = T0.value, h=F(s)
  console.log(s)
  $('#R0').text(h);
  animate($('#A'), s,h);
});

function animate($out, s, h){
  o=~s.match(/\d+/),g=[...s.replace(/.*/,'')];
  
  fr=[g.join('')];
  h.replace(/.,(.)/g, (c,d)=&gt;{
    i = g.indexOf(c=c[0]);
    d = [-1,1,o,-o]['LRUD'.search(d)]
    for(;g[i+d]&lt;'.';i+=d)
    {
      g[i]='#',z=[...g],g[i+d]=c,z[i+d]='&lt;b&gt;'+c+'&lt;/b&gt;', fr.push(z.join(''))
    }
    if(g[i+d]=='.')
    {
      g[i]='#', fr.push(g.join(''))
    }
  })

  var fa = ()=&gt;{
    var f=fr.shift();                  
    f ? $out.html(f) : (
      clearInterval(i), 
      $out.text(s), 
      $out.toggleClass('Anim')
  )};
  $out.toggleClass('Anim');
  fa();
  var i=setInterval(fa, 500);  
}</code></pre>
<pre class="snippet-code-css lang-css prettyprint-override"><code>td { vertical-align: top; font-family: monospace; white-space: pre; }
textarea { width: 99%;  height:10em;}
pre { margin: 0; }
.R td { background: #fdc; padding: 6px 0; }
.R td:hover { background: #ffc }
.T td { background: #ddf}
B { color: red }
.T td.Anim, td.Anim { background: #ffc; }</code></pre>
<pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"&gt;&lt;/script&gt;
&lt;table cellspacing=5&gt;
  &lt;tr&gt;
    &lt;th colspan=4&gt;Predefined tests&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr class=T&gt;
    &lt;td&gt;25,5
.........................
.#######################.
.####D#############*k###.
.#######################.
.........................&lt;/td&gt;
    &lt;td&gt;9,7
.........
.a#####b.
.#####d#.
.##l*###.
.###m#p#.
.#D#.#c#.
.........&lt;/td&gt;
&lt;td&gt;26,5
..........................
.###..................###.
.l*##########v#########D#.
.###..................###.
..........................&lt;/td&gt;
&lt;td&gt;8,5
........
.##c###.
.a#*#D#.
.##b###.
........&lt;/td&gt;
    &lt;/tr&gt;
  &lt;tr&gt;&lt;td colspan=4&gt;Click on solution text to start animation&lt;/td&gt;
  &lt;/tr&gt;  
  &lt;tr class=R&gt;  
    &lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;
  &lt;/tr&gt;  
  &lt;tr&gt;&lt;th colspan=2&gt;Your test  &lt;/th&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td colspan=2&gt;&lt;textarea id=T0&gt;&lt;/textarea&gt;&lt;/td&gt;
    &lt;td colspan=2 id=A&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td colspan=2&gt;Find solution and animate &lt;button id=GO&gt;go&lt;/button&gt;&lt;/td&gt;
    &lt;td colspan=2 id=R0&gt;&lt;/td&gt;
  &lt;/tr&gt;  
&lt;/table&gt;</code></pre>
</div>
</div>
</p>
</div>
<div id="pu2" class="pu"><h2>C++, 628 bytes</h2>

<p>Well, this didn't turn out very short:</p>

<pre><code>#include &lt;set&gt;
#include &lt;iostream&gt;
using namespace std;struct R{string b,m;bool operator&lt;(R r)const{return b&lt;r.b;}};int w,h,t,j,k,z=1;char c,f;set&lt;R&gt; p,q;int m(R r,int x,int d,char a){for(j=x,c=r.b[x];(f=r.b[j+=d])==35;);if(c-68||f-46){r.b[x]=35;if(f-46)r.b[j-d]=c;r.m+=c;r.m+=44;r.m+=a;r.m+=10;if(c==68&amp;j-d==t){cout&lt;&lt;r.m;z=0;}if(p.count(r)+q.count(r)==0){q.insert(r);}}}int main(){cin&gt;&gt;w&gt;&gt;c&gt;&gt;h&gt;&gt;c;R r;string l;for(;k++&lt;h;){getline(cin,l);r.b+=l;}t=r.b.find(42);r.b[t]=35;q.insert(r);for(;z;){r=*q.begin();q.erase(q.begin());p.insert(r);for(k=0;z&amp;&amp;k&lt;w*h;++k){if(r.b[k]&gt;64){m(r,k,-1,76);m(r,k,1,82);m(r,k,-w,85);m(r,k,w,68);}}}}
</code></pre>

<p>I chose C++ because I wanted to use the data structures (<code>set</code>, <code>string</code>), but it's inherently quite verbose. The solution does reasonably well on performance, solving test 2 in a little over 2 seconds on a MacBook Pro, even though it's not optimized for runtime.</p>

<p>Code before starting to eliminate whitespace and some other length reduction:</p>

<pre><code>#include &lt;set&gt;
#include &lt;iostream&gt;

using namespace std;

struct R {
    string b, m;
    bool operator&lt;(R r) const {return b &lt; r.b; }
};

int w, h, t;
set&lt;R&gt; p, q;
bool z = true;

void m(R r, int k, int d, char a) {
    int j = k;
    char s = r.b[k], f;
    for (; (f = r.b[j += d]) == 35;);
    if (s - 68 || f - 46) {
        r.b[k] = 35;
        if (f - 46) {
            r.b[j - d] = s;
        }
        r.m += s;
        r.m += 44;
        r.m += a;
        r.m += 10;
        if (s == 68 &amp;&amp; j - d == t) {
            cout &lt;&lt; r.m;
            z = false;
        }
        if (p.count(r) + q.count(r) == 0) {
            q.insert(r);
        }
    }
}

int main() {
    char c;
    cin &gt;&gt; w &gt;&gt; c &gt;&gt; h &gt;&gt; c;
    string b, l;
    int k;
    for (k = 0; k &lt; h; ++k) {
        getline(cin, l);
        b += l;
    }

    t = b.find(42);
    b[t] = 35;

    R r;
    r.b = b;
    q.insert(r);

    for ( ; z; ) {
        r = *q.begin();
        q.erase(q.begin());
        p.insert(r);

        for (k = 0; z &amp;&amp; k &lt; w * h; ++k) {
            c = r.b[k];
            if (c &gt; 64) {
                m(r, k, -1, 76);
                m(r, k, 1, 82);
                m(r, k, -w, 85);
                m(r, k, w, 68);
            }
        }
    }

    return 0;
}
</code></pre>

<p>The core idea behind the algorithm is that two sets are maintained:</p>

<ul>
<li><code>q</code> is the set of configurations that are pending processing.</li>
<li><code>p</code> is the set of configurations that have been processed.</li>
</ul>

<p>The algorithm starts with the initial configuration in <code>q</code>. In every step, a configuration is popped from <code>q</code>, added to <code>p</code>, all possible seal movements are generated, and the resulting new configurations inserted into <code>q</code>.</p>

<p>Test run:</p>

<pre><code>bash-3.2$ ./a.out &lt;test1
D,R
bash-3.2$ time ./a.out &lt;test2
p,U
c,U
p,R
c,L
m,L
b,L
a,L
D,U
b,L
D,R
D,D
D,L

real    0m2.267s
user    0m2.262s
sys 0m0.003s
bash-3.2$ ./a.out &lt;test3
v,U
D,L
bash-3.2$
</code></pre>
</div>
<div id="pu3" class="pu"><h1>Python 3, 520 bytes</h1>



<pre class="lang-python prettyprint-override"><code>R=range
g=[list(input())for i in R(int(input().split(',')[1]))]
f=set(sum(g,[]))-set(".#*")
L=8
def P(p,g):
 if len(p)&gt;L:return
 for s in f:
  c=sum(y.index(s)for y in g if s in y)
  if c&lt;1:continue
  r,=[n for n in R(len(g))if s in g[n]]
  for d in R(4):
   m=p+s+",%s\n"%"LURD"[d];G=[y[:]for y in g];o="#";i,j=I,J=r,c
   while"#"==o:G[i][j]="#";G[I][J]=s;i,j=I,J;I,J=i+d%2*(d-2),j+(~d%-2&amp;d-1);o=G[I][J]
   if"."==o:G[i][j]="#"
   if"D"==s:
    if"."==o:continue
    if"*"==o:print(m);1/0
   P(m,G)
while 1:P("",g);L+=4
</code></pre>

<p>I may do a more detailed explanation later if people want, but basically this runs a <a href="http://en.wikipedia.org/wiki/Iterative_deepening_depth-first_search" rel="nofollow">depth-first search with iterative deepening</a> on the state space of possible moves. If a move causes the daddy seal to fall off, it is immediately rejected. If the daddy ends up next to the transmitter, the sequence of moves is printed, and the program divides by zero to force an exit.</p>

<p>I can make the code run significantly faster by adding <code>if G!=g:</code> at the beginning of the second-last line, for 8 extra bytes--this rejects moves that don't change anything, such as <code>k,L</code> in the first test case.</p>

<p>The runtime varies noticeably from one run to the next, even with the same input--evidently a result of the fact that I pick the next seal to move by iterating over a <code>set</code>, which is an unordered type. I timed the second test case at 5 minutes 30 seconds, though it didn't seem that long the first time I ran it. With the optimization mentioned above, it's more like 40 seconds.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/50042/">50042</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




