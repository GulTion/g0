<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::60716</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>426</td><td>Python3</td><td>240829T161324Z</td><td><a href="https://codegolf.stackexchange.com/questions/60716/can-i-slide-apart-the-puzzle/275240#275240">Ajax1234</a></td></tr>
<tr d-ix="1"><td>nan</td><td></td><td>151014T204720Z</td><td><a href="https://codegolf.stackexchange.com/questions/60716/can-i-slide-apart-the-puzzle/60837#60837">edc65</a></td></tr>
<tr d-ix="2"><td>017</td><td>CJam</td><td>151014T042334Z</td><td><a href="https://codegolf.stackexchange.com/questions/60716/can-i-slide-apart-the-puzzle/60752#60752">Reto Kor</a></td></tr>
<tr d-ix="3"><td>082</td><td>JavaScript ES6</td><td>151014T013544Z</td><td><a href="https://codegolf.stackexchange.com/questions/60716/can-i-slide-apart-the-puzzle/60729#60729">intrepid</a></td></tr>
<tr d-ix="4"><td>069</td><td>Mathematica</td><td>151014T135140Z</td><td><a href="https://codegolf.stackexchange.com/questions/60716/can-i-slide-apart-the-puzzle/60778#60778">DavidC</a></td></tr>
<tr d-ix="5"><td>022</td><td>Dyalog APL</td><td>151014T143219Z</td><td><a href="https://codegolf.stackexchange.com/questions/60716/can-i-slide-apart-the-puzzle/60782#60782">Zgarb</a></td></tr>
<tr d-ix="6"><td>094</td><td>JavaScript ES6</td><td>151014T140732Z</td><td><a href="https://codegolf.stackexchange.com/questions/60716/can-i-slide-apart-the-puzzle/60780#60780">ETHprodu</a></td></tr>
<tr d-ix="7"><td>014</td><td>Snails</td><td>151014T122806Z</td><td><a href="https://codegolf.stackexchange.com/questions/60716/can-i-slide-apart-the-puzzle/60773#60773">feersum</a></td></tr>
<tr d-ix="8"><td>118</td><td>Javascript ES6</td><td>151014T011853Z</td><td><a href="https://codegolf.stackexchange.com/questions/60716/can-i-slide-apart-the-puzzle/60724#60724">DankMeme</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>Python3, 426 bytes</h1>
<pre class="lang-py prettyprint-override"><code>M=[(1,0),(-1,0),(0,-1),(0,1)]
E=enumerate
def G(d):
 q=[*d]
 while q:
  Q=[q.pop(0)]
  s=[*Q]
  for x,y in Q:
   for X,Y in M:
    if(T:=(x+X,y+Y))in q and d[T]==d[(x,y)]:s+=[T];Q+=[T];q=[*{*q}-{T}]
  yield s
def f(b):
 a,u=G({(x,y):v for x,r in E(b)for y,v in E(r)})
 q=[(u,*i)for i in M]
 for b,x,y in q:
  if[]==b:return 1
  B,F=[],1
  for X,Y in b:
   if(T:=(x+X,y+Y))in a:F=0;break
   if T in u:B+=[T]
  if F:q+=[(B,x,y)]
</code></pre>
<p><a href="https://tio.run/##jVNLb9pAED6zv2LEhTUsEU4vlaM92FLIKZWQOCRyrcqWbcUp9WPXpEGI305nZg2UKmpr0O48vnl8o9l217809afPrTkeH3UsfbXwlJy7a6HmPl@@l4h7XdTbH4VJ@0LkRQkPMvcCAZ2Op3ki4OdLtSmgQwusdNzdtE0rFxgGYBGxIqFsDLyrHVQ1rAjHhif1TIZHNkBVynWg5fvsSe1mz56Hng7SOoc8Xida57HEBF4S2JlGw93KXdTDftod5vv1gQrtqmKTg@U2S5lRm6na6ge55/DgbWjFUOV7BJC6U29ONd7BY15yq6YV@ypuEVOTkqmBBJOtyhgbywJT9FtTg4@mSC11nChfXDHMmOEHBNNgqRd3mSnS7w4Ba8Jvg4jZcQ1YBh1qMlLM/2h90DAej0UURSIKQ75REAJFPCL6i/DkQIFNTokQ5w4C8Bmyjz/xmzzop@9fflfmyoCFLj9xFUd9c1I0u@Tkd01@KETXgqMXMg1Bs7C3l6HwVOjgQmc9POvnVOGJwTm164xieXxU4I9hhW6Wg3XAsf7fpMK/kHIJ3X0ix8vcN9@yJjW5tLjTo2Hl4nhaJectLatNXxj5pakLBfbGtpuql5Ov9cTDxygE4VIFGUFjaX0F@MJB2lsFFIJPS4wI80qA9BJOCdA1Sq0tTI@v6tzKq@fh/gvRmqpGaF/Y3kJLuHziHX8B" rel="nofollow noreferrer">Try it online!</a></p>
</div>
<div id="pu1" class="pu"><h1>JavaScript (ES6) 72 <s>74</s></h1>

<p><strong>Edit</strong> 2 bytes saved thx @NotthatCharles</p>

<p>I have the intuitive understanding that if one piece can slide just a fraction of step, then it's free. The current test cases confirm this.</p>

<p>So I check just one step in each direction. </p>

<p>Characters used: 1 and 0<br>
2 bytes more to use any 2 printable characters like A and B</p>

<p>Test running the snippet below in an EcmaScript 6 compliant browser (supporting the spread operator - IE Firefox)</p>

<p><div class="snippet" data-lang="js" data-hide="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>f=s=&gt;[w=~s.search`
`,-w,-1,1].some(o=&gt;![...s].some((x,p)=&gt;x+s[p+o]==10))

// 4 bytes more- for any symbol, not just 1 and 0 (for instance A and B):
g=s=&gt;[w=~s.search`
`,-w,-1,1].some(o=&gt;![...s].some((x,p)=&gt;x+s[p+o]=='AB'))

//TEST
console.log=x=&gt;O.innerHTML+=x+'\n'

testOk = [
 '111\n100\n111',
 '10',
 '0\n1',
 '01\n01',
 '000\n111',
 '00001\n01111',
 '0110\n0110\n0000',
 '000000111111111\n001111111111111\n000000000011111\n001111111111111\n000000000000001',
 '000000000000\n010101010101\n111111111111',
 '10000011\n11000111\n11101111\n11101111\n11101111\n11111111\n11111111',
 '000\n100\n000'
]

testKo = [
 '1111\n1001\n1011',
 '1111\n1001\n0011',
 '1111111\n1111101\n0000001\n1111111',
 '1000\n1010\n1110\n0010\n0000',
 '0000000\n0111110\n0000010\n1111110',
 '10000011\n11000111\n11101111\n11101111\n11100111\n11111111\n11111111',
 '000\n010\n110\n010\n000'
]

console.log('Expecting true')
testOk.forEach(t=&gt;console.log(t+'\n'+f(t)+'\n'))
console.log('Expecting false')
testKo.forEach(t=&gt;console.log(t+'\n'+f(t)+'\n'))</code></pre>
<pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;pre id=O&gt;&lt;/pre&gt;</code></pre>
</div>
</div>
</p>
</div>
<div id="pu2" class="pu"><h1>CJam, <s>33</s> <s>32</s> <s>20</s> <s>19</s> 17 bytes</h1>

<p>Revised version, with massive support from @Sp3000 and @MartinBüttner:</p>

<pre><code>qN/_z]{:e`z,3&lt;}/|
</code></pre>

<p><a href="http://cjam.aditsu.net/#code=qN%2F_z%5D%7B%3Ae%60%3A.%7C%2C3%3C%7D%2F%7C&amp;input=AAAAAAAAAAAA%0AABABABABABAB%0ABBBBBBBBBBBB">Try it online</a></p>

<h3>Contributions</h3>

<ul>
<li>@Sp3000 suggested a critical simplification to my original algorithm.</li>
<li>@MartinBüttner applied his mad golfing skills to the revised approach, which almost certainly resulted in shorter code than I would have come up with even after considering the simplification.</li>
</ul>

<h3>Algorithm and Proof</h3>

<p>The following explains the criteria for the puzzle sliding apart horizontally. The vertical case can be determined by looking at columns instead of rows, or transposing the character matrix and looking at the rows again.</p>

<p>I'll use the term "stretch" for a maximum sequence of the same letters. For example, the following rows have 1, 2, and 3 stretches respectively:</p>

<pre><code>AAAAAAAA
BBBAAAAA
AABBBAAA
</code></pre>

<p>I'll also use the term "interlocked" for a row/puzzle that cannot slide apart.</p>

<p>The key observation is that <strong>the puzzle can slide apart if and only if all rows have at most 2 stretches</strong>. Or reversed, it is <strong>interlocked if and only if there is any row with more than 2 stretches</strong>.</p>

<p>The following might not qualify as a strict mathematical proof, but I believe that it makes for a convincing explanation why this has to be the case.</p>

<p>It is easy to see that the puzzle is interlocked if it has rows of more than 2 stretches. Looking at a row with 3 stretches:</p>

<pre><code>BBBAAB
</code></pre>

<p>it is clear that it prevents the puzzle from sliding apart because the <code>A</code> stretch is locked between the <code>B</code> stretches. This means that the row is interlocked, which in turn makes the whole puzzle interlocked.</p>

<p>The opposite direction of the proof is not quite as obvious. We need to show that there are no interlocked puzzles where all rows have only 1 or 2 stretches. Starting with a couple of observations:</p>

<ul>
<li>Rows with only 1 stretch do not contribute to a puzzle being interlocked, since they can slide in either direction without any collisions.</li>
<li>If all rows with 2 stretches have the same order of <code>A</code> and <code>B</code>, the puzzle is clearly not interlocked. In this case, all <code>A</code> cells are left of all <code>B</code> cells, or vice versa, and there are no collisions when sliding the two pieces apart.</li>
</ul>

<p>The only tricky case would be puzzles where we have rows with 2 stretches of different order. I'm going to show that such puzzles <strong>do not exist</strong> under the given specifications. To show this, let's look at a partial puzzle that does have this configuration, where <code>.</code> are wildcards:</p>

<pre><code>.......
AAABBBB
.......
BBAAAAA
.......
</code></pre>

<p>Now, the specification says that both the <code>A</code> and <code>B</code> cells are simply connected in all valid puzzles. To make the <code>A</code> cells connected in the partial puzzle above, we have two options:</p>

<ol>
<li><p>We loop around one of the stretches of <code>B</code>, for example:</p>

<pre><code>..AAAAAA
AAABBBBA
.......A
BBAAAAAA
........
</code></pre>

<p>To do this, we unavoidably extend one of the rows to have 3 stretches, so this will never give us a valid puzzle where all rows have at most 2 stretches.</p></li>
<li><p>We connect them on a direct path:</p>

<pre><code>.......
AAABBBB
..A....
BBAAAAA
.......
</code></pre>

<p>The <code>A</code> cells are now simply connected, and there are still no rows with more than 2 stretches. However, the <code>B</code> cells also need to be simply connected. The direct path is now blocked by the connected <code>A</code> cells, and the only way to connect the <code>B</code> cells is to loop around one of the stretches of <code>A</code> cells. This leads back to case 1, where we can't do that without creating rows of 3 stretches.</p></li>
</ol>

<p>To count the stretches, the implementation uses the CJam RLE operator.</p>

<h3>Explanation of Code</h3>

<pre><code>qN/     Get input and split at newlines.
_z      Make a transposed copy.
]       Wrap the original and transposed puzzle in an array so that we can
        loop over the two.
{       Start of loop over original and transposed puzzle.
  :e`     Apply RLE to all rows.
  z,      Transpose the matrix with the RLE rows, and take the element count of the
          result. Or in other words, take the column count. This will be the length
          of the longest row after RLE.
  3&lt;      Check the length for less than 3.
}/      End of loop over original and transposed puzzle.
|       Or the results of the two.
</code></pre>
</div>
<div id="pu3" class="pu"><h1>JavaScript (ES6), <s>108</s> <s>107</s> <s>98</s> <s>91</s> 82 bytes</h1>
<pre><code>a=&gt;!(T=[],R=/AB+A|BA+B/).test([...a].map((c,i)=&gt;T[i%-~a.search`
`]+=c))|!R.test(a)
</code></pre>
<p><a href="http://jsfiddle.net/intrepidcoder/vdzwnca8/" rel="noreferrer">Live demo</a>. Tested in Firefox. Takes input as a newline-delimited string.</p>
<p>Edits:</p>
<ul>
<li>Saved 1 byte by changing <code>\n</code> to a literal newline.</li>
<li>Saved 9 bytes by doing the RegExp test directly on the multi-line string instead of converting to an array.</li>
<li>Eliminated another 9 bytes by using array comprehensions to split string, moving ! into <code>g</code> function and calling RegExp directly on array instead of using <code>find</code>.</li>
<li>Continued the arthmetic sequence by saving another 9 bytes. Did a modulus on the index instead of splitting the array by newlines before taking the transpose.</li>
</ul>
<h3>How it works</h3>
<p>Previous version:</p>
<pre><code>a=&gt;(T=[],a.split`
`.map(s=&gt;s.split``.map((c,i)=&gt;T[i]+=c)),!T.find(g=s=&gt;/AB+A|BA+B/.test(s)))|!g(a)
</code></pre>
<ol>
<li>Take the input <code>a</code> and split it by newlines into an array of strings.</li>
<li>Transpose <code>a</code> and store it in <code>T</code>. Use <code>map</code> to iterate over each element of <code>a</code>, split the string into a character array, and use <code>map</code> again to append the <code>i</code>th character in the line to the <code>i</code>th line of  <code>T</code>. Since each element of <code>T</code> is uninitialized, it will end up looking something like <code>&quot;undefinedAAABBA&quot;</code>, but this won't matter.</li>
<li>Create a RegExp based testing function <code>g</code> that matches the pattern <code>/AB+A|BA+B/</code>. If it matches, the pieces are locked in the given direction because then there are a set of <code>B</code>s sandwiched between two or more <code>A</code>s or vice-versa.</li>
<li>Use the testing function <code>g</code> to test all elements of the block <code>a</code> and its transpose <code>T</code> for a match using <code>find</code>. If both match, then the pieces are locked in both directions, so output a falsy value, otherwise a truthy one.</li>
</ol>
</div>
<div id="pu4" class="pu"><h1>Mathematica <s>100</s> 69 bytes</h1>
<p>With a massive 31 bytes saved, thanks to @Martin Buttner,</p>
<pre><code>g=Max[Length/@Split/@#]&lt;3&amp;;g[c=Characters@StringSplit@#]||g@Thread@c&amp;
</code></pre>
<p>Formats the input as a matrix of characters; it also makes a transpose of the matrix.   If either the matrix or its transpose has no more than 2 runs per row then the puzzle is can slide.</p>
<p><code>{a,a,b,b,b}</code> has 2 runs of letters.</p>
<p><code>{a,a,b,a,a}</code> has 3 runs of letters.</p>
<p><code>{a,a,b,a,a,a,b,b,b,b,b,b,b,b}</code> has 4 runs of letters.</p>
</div>
<div id="pu5" class="pu"><h2>Dyalog APL, 22 bytes</h2>

<pre><code>(∨/{∧/2&gt;+/2≠/⍵}¨)⊂∘⍉,⊂
</code></pre>

<p><a href="http://tryapl.org/" rel="nofollow">Try it here.</a>
This is a function that takes in a 2D array of characters, and returns <code>1</code> for sliding instances and <code>0</code> for non-sliding ones.
The algorithm is similar to most other answers: check for the matrix and its transpose that no row contains more than one adjacent pair of different letters.
For the 4x3 input matrix</p>

<pre><code>AAAA
ABBB
AAAB
</code></pre>

<p>the function can be invoked as</p>

<pre><code>f ← (∨/{∧/2&gt;+/2≠/⍵}¨)⊂∘⍉,⊂
f 4 3 ⍴ 'AAAAABBBAAAB'
</code></pre>

<p>which results in <code>1</code>.</p>

<h2>Explanation</h2>

<pre><code>⊂∘⍉,⊂   The matrix and its transpose.
{...}¨   For each of them:
  2≠/⍵   On each row, replace each adjacent pair with 1 if they differ, with 0 otherwise
  2&gt;+/    Take the sum on each row and check that it's less than 2
  ∧/     AND over all rows
∨/      OR over the resulting two values
</code></pre>
</div>
<div id="pu6" class="pu"><h1>JavaScript (ES6), 94 bytes</h1>



<pre class="lang-js prettyprint-override"><code>x=&gt;!(y=/AB+A|BA+B/).test(x)|(z=[],x.split`
`.map(b=&gt;b.split``.map((c,i)=&gt;z[i]+=c)),!y.test(z))
</code></pre>

<p>Same-size alternate method:</p>

<pre class="lang-js prettyprint-override"><code>x=&gt;(t=s=&gt;!/AB+A|BA+B/.test(s),z=[],x.split`
`.map(b=&gt;b.split``.map((c,i)=&gt;z[i]+=c)),t(x)|t(z))
</code></pre>

<p>This returns <code>1</code> for a truthy input and <code>0</code> for falsy. I started work on this before any other answers had been posted. I also originally tried using ES7's array comprehensions, but that ended up about 10 chars longer than this method.</p>

<p>Try it out:</p>

<p><div class="snippet" data-lang="js" data-hide="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>a=x=&gt;!(y=/AB+A|BA+B/).test(x)|(z=[],x.split`
`.map(b=&gt;b.split``.map((c,i)=&gt;z[i]+=c)),!y.test(z))

P.onclick=_=&gt;Q.innerHTML='Result: '+a(O.value)</code></pre>
<pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;textarea id=O cols="20" rows="8"&gt;AAAAAABBBBBBBBB
AABBBBBBBBBBBBB
AAAAAAAAAABBBBB
AABBBBBBBBBBBBB
AAAAAAAAAAAAAAB&lt;/textarea&gt;
&lt;button id=P&gt;Test&lt;/button&gt;
&lt;p id=Q&gt;Result: &lt;/p&gt;</code></pre>
</div>
</div>
</p>

<p>Suggestions welcome!</p>
</div>
<div id="pu7" class="pu"><h1>Snails, 14</h1>
<pre><code>o(t\B+~)+!(t\B
</code></pre>
<p>If the puzzle can be slid apart, it prints the area of the input. Otherwise, it prints 0.</p>
<p>It's a bit slow for the larger examples, as it takes time factorial in the area of the grid.</p>
<pre><code>         ,, the program will print the number of starting cells matching this pattern
o        ,, pick a cardinal direction
(
    t    ,, teleport to any cell on the grid
    \B+  ,, match &quot;B&quot; 1 or more times, moving in the direction set by 'o'.
         ,, when a cell is matched, it gets slimed and can't be matched again.
    ~    ,, match an out-of-bounds cell
)+       ,, do parenthesized instructions 1 or more times
!(       ,, the following must not match:
    t\B  ,, teleport to some cell and match 'B'
</code></pre>
</div>
<div id="pu8" class="pu"><h1>Javascript (ES6), 118</h1>

<p><div class="snippet" data-lang="js" data-hide="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>slidey=
// code
a=&gt;!a.match(R=/AB+A|BA+B/)||!(a=a.split`
`.map(b=&gt;b.split``))[0].map((_,c)=&gt;a.map(d=&gt;d[c])).some(e=&gt;e.join``.match(R))

// IO
var S =document.getElementById('S');
S.onkeyup = _=&gt; document.getElementById('P').innerText = slidey(S.value);

document.getElementById('P').innerText = slidey(S.value);</code></pre>
<pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;textarea id='S'&gt;BAAAAABB
BBAAABBB
BBBABBBB
BBBABBBB
BBBABBBB
BBBBBBBB
BBBBBBBB&lt;/textarea&gt;
&lt;p id='P'&gt;&lt;/p&gt;</code></pre>
</div>
</div>
</p>

<p>Explanation:</p>

<pre class="lang-js prettyprint-override"><code>a=&gt; !/* check string horizontally */ || !/* check string vertically by transposing it and
                                            running the same horizontal check */

a=&gt; !a.match(R=/AB+A|BA+B/) || !/* ... */
// check for lines containing something like BAAAAAB or ABBBBBBBA
// this is the only way something can get blocked horizontally
// eg AAAAAAA
//    AAABAAA &lt;&lt;&lt; note the B in the middle of As here
//    AAABBBB &lt;&lt;&lt; blocked from being pulled out horizontally
//    AAAAAAA

a=&gt; /* ... */ ||!( a = a.split('\n').map(b=&gt; b.split('')) ) // split a into 2D array
    [0].map((_,c)=&gt;a.map(d=&gt;d[c])) // transpose it
    .some(e=&gt;e.join``.match(R)) // run the check again using `some` to go line by line
                                // which is shorter than .join().match() outside

a=&gt; !/* returns null if no horizontal obstacles and an array if there are */
    || !/* same thing */
// negate both to cast to a boolean (false if obstacles, true if not)
// an input can only be unslidable if both directions are blocked
// so (no obstacles vertically? || no obstacles horizontally?) gives the answer
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/60716/">60716</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




