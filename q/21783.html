<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::21783</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>101</td><td>Python 2</td><td>240316T015021Z</td><td><a href="https://codegolf.stackexchange.com/questions/21783/print-n-weird-numbers/271868#271868">Stefan P</a></td></tr>
<tr d-ix="1"><td>015</td><td>Jelly</td><td>200910T163104Z</td><td><a href="https://codegolf.stackexchange.com/questions/21783/print-n-weird-numbers/210895#210895">caird co</a></td></tr>
<tr d-ix="2"><td>174</td><td>Perl</td><td>140222T205942Z</td><td><a href="https://codegolf.stackexchange.com/questions/21783/print-n-weird-numbers/21803#21803">Heiko Ob</a></td></tr>
<tr d-ix="3"><td>173</td><td>Perl</td><td>140224T233202Z</td><td><a href="https://codegolf.stackexchange.com/questions/21783/print-n-weird-numbers/22052#22052">n̴̖̋h̷͉̃</a></td></tr>
<tr d-ix="4"><td>nan</td><td></td><td>140223T195226Z</td><td><a href="https://codegolf.stackexchange.com/questions/21783/print-n-weird-numbers/21914#21914">Dr. beli</a></td></tr>
<tr d-ix="5"><td>255</td><td>Python 2.7</td><td>140223T204412Z</td><td><a href="https://codegolf.stackexchange.com/questions/21783/print-n-weird-numbers/21917#21917">Elisha</a></td></tr>
<tr d-ix="6"><td>458</td><td>C++</td><td>140222T221947Z</td><td><a href="https://codegolf.stackexchange.com/questions/21783/print-n-weird-numbers/21808#21808">user1076</a></td></tr>
<tr d-ix="7"><td>131</td><td>SageMath</td><td>140222T231534Z</td><td><a href="https://codegolf.stackexchange.com/questions/21783/print-n-weird-numbers/21812#21812">yo&#39;</a></td></tr>
<tr d-ix="8"><td>143</td><td>Smalltalk</td><td>140223T011154Z</td><td><a href="https://codegolf.stackexchange.com/questions/21783/print-n-weird-numbers/21819#21819">blabla99</a></td></tr>
<tr d-ix="9"><td>152</td><td>Ruby</td><td>140223T003537Z</td><td><a href="https://codegolf.stackexchange.com/questions/21783/print-n-weird-numbers/21816#21816">fgp</a></td></tr>
<tr d-ix="10"><td>129</td><td>Haskell</td><td>140222T223805Z</td><td><a href="https://codegolf.stackexchange.com/questions/21783/print-n-weird-numbers/21810#21810">shiona</a></td></tr>
<tr d-ix="11"><td>164</td><td>R</td><td>140222T191806Z</td><td><a href="https://codegolf.stackexchange.com/questions/21783/print-n-weird-numbers/21792#21792">Sven Hoh</a></td></tr>
<tr d-ix="12"><td>267</td><td>PHP</td><td>140222T182517Z</td><td><a href="https://codegolf.stackexchange.com/questions/21783/print-n-weird-numbers/21789#21789">Razvan</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://docs.python.org/2/" rel="nofollow noreferrer">Python 2</a>, 101 bytes</h1>
<pre><code>n=input()
i=0
while n:
 i+=1;s=1
 for d in range(1,i):s|=s&lt;&lt;d*(i%d&lt;1)
 s&gt;&gt;=i
 if s&gt;1&gt;s&amp;1:print i;n-=1
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=Lc1BCsIwEEDRfU4xGyVRC45uJO3kLkJSOyDTkKSI4E3cxIV4Jm9joe7e5vOfn3gvwyiHWt9T6ZvTNwixxKloo5j26jbwNYBYBbwlbDOhgn5M4IEF0lkuQeOOjc0Pyl3nN5pXvkOjIDtHPFf9LHR5jTYmlgLcSkO4zP7P-jou-AE" rel="nofollow noreferrer">Attempt This Online!</a></p>
<p>I use the integer <code>s</code> as a bitset, telling me the sums of divisors of <code>i</code>. The k-th bit tells me whether k is a sum of the divisors found.</p>
</div>
<div id="pu1" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="nofollow noreferrer">Jelly</a>, 15 bytes</h1>
<pre><code>ÆḌŒP§e@=ÆḌS&lt;Ɗµ#
</code></pre>
<p><a href="https://tio.run/##y0rNyan8//9w28MdPUcnBRxanupgC@YE2xzrOrRV@f9/QwA" rel="nofollow noreferrer" title="Jelly – Try It Online">Try it online!</a></p>
<p>Takes input via STDIN.</p>
<p>Insanely inefficient, times out for <span class="math-container">\$n &gt; 1\$</span> on TIO, as it checks each <span class="math-container">\$k = 1, 2, \dots\$</span> until it finds <span class="math-container">\$n\$</span> values that fit, and for each <span class="math-container">\$k\$</span> it generates <span class="math-container">\$2^{\sigma(k)-k}\$</span> sublists (where <span class="math-container">\$\sigma(k)\$</span> is the <a href="https://en.wikipedia.org/wiki/Divisor_function" rel="nofollow noreferrer">sum of divisors function</a>)</p>
<h2>How it works</h2>
<pre><code>ÆḌŒP§e@=ÆḌS&lt;Ɗµ# - Main link, takes no arguments
             µ# - Take an integer from STDIN, n, and run the previous code over each integer, k, from 0 until n truthy values are found:
ÆḌŒP§e@         -   First check for weirdness:
ÆḌ              -     Take the proper divisors of k
  ŒP            -     Find the powerset of the proper divisors
    §           -     Get the sum of each
                -       This gives the sum of each subset of proper divisors
     e@         -     Is k equal to one of the sums?
                -     This gives 0 if no combination of these numbers sum to k and 1 otherwise
        ÆḌS&lt;Ɗ   -   Second check for weirdness:
            Ɗ   -     Group the previous 3 commands together:
        ÆḌS     -       Is the proper divisor sum of k...
           &lt;    -       Less than k?
                -     This gives 0 if the proper divisor sum of k is greater than k and 1 otherwise
      =         -   Are the two checks equal?
                -     There are three possible values that the two checks could output:
                -        0, 1: k cannot be expressed as a sum of a subset of its proper divisors and k is less than or equal to its proper divisor sum, therefore k is not weird
                -        1, 0: k can be expressed as a sum of a subset of its proper divisors and k is greater than its proper divisor sum, therefore k is not weird
                -        0, 0: k cannot be expressed as a sum of a subset of its proper divisors and k is greater than its proper divisor sum, therefore k is weird
                -     1, 1 cannot be a possibility as that would require that k can be expressed as a sum of a subset of its proper divisors and that k is greater than its proper divisor sum, which are contradictory
                -     Therefore, checking whether the two checks result in the same value suffices to check for weirdness
</code></pre>
</div>
<div id="pu2" class="pu"><h2>Perl, <strike>176</strike> 174 bytes</h2>

<pre class="lang-perl prettyprint-override"><code>$n=&lt;&gt;;$i=9;X:while($n){@d=grep{!($i%$_)}1..$i-1;$l=0;map{$a=$_;$s=0;$s+=$d[$_]for grep{2**$_&amp;$a}0..@d-1;$i++,next X if$s==$i;$l=1 if$s&gt;$i}0..2**@d-1;$n--,print$i,$/if$l;$i++}
</code></pre>

<p>The number of weird numbers are expected in STDIN and the found numbers are printed to STDOUT.</p>

<h2>Ungolfed version</h2>

<pre class="lang-perl prettyprint-override"><code>#!/usr/bin/env perl
use strict;
$^W=1;

# read number from STDIN
my $n=&lt;&gt;;
# $i is the loop variable that is tested for weirdness
my $i=9; # better start point is 70, the smallest weird number
# $n is the count of numbers to find
X: while ($n) {
    # find divisors and put them in array @divisors
    my @divisors = grep{ !($i % $_) } 1 .. $i-1; # better: 1 .. int sqrt $i
    # $large remembers, if we have found a divisor sum greater than the number
    my $large = 0;
    # looping through all subsets. The subset of divisors is encoded as
    # bit mask for the divisors array.
    map {
        my $subset = $_;
        # calculate the sum for the current subset of divisors
        my $sum = 0;
        map { $sum += $divisors[$_] }
            grep { 2**$_ &amp; $subset }
                0 .. @divisors-1;
        # try next number, if the current number is pseudoperfect
        $i++, next X if $sum == $i; # better: $i+=2 to skip even numbers
        $large = 1 if $sum &gt; $i;
    } 0 .. 2**@divisors - 1;
    # print weird number, if we have found one
    $n--, print "$i\n" if $large;
    $i++; # better: $i+=2 to skip even numbers
}
__END__
</code></pre>

<h2>Limitations</h2>

<ul>
<li>Slow, brute force.</li>
<li>The count of divisors for a number is limited to the "bitness" of integers in Perl.</li>
</ul>
</div>
<div id="pu3" class="pu"><h1>Perl, 173</h1>

<p>Let me add another useless solution. This solution is so slow that it can't even output anything past the first weird number. I dare say it is the slowest of all the solution here.</p>

<pre><code>$n=&lt;&gt;;$i=2;while($n){$b=qr/^(?=(.+)\1{2}$)((.+)(?=.*(?(2)(?=\2$)\3.+$|(?=\1$)\3.+$))(?=.*(?=\1$)\3+$))+/;$_='x'x3x$i;if(/$b/&amp;&amp;($+[0]&gt;$i)&amp;&amp;!/$b\1{2}$/){print"$i\n";$n--}$i++}
</code></pre>

<p><a href="http://ideone.com/akLq4W" rel="nofollow">Demo</a></p>

<p>The same code written in Java (which I am more comfortable with) can't even recognize the 2nd weird number (836), and I have already fed the number directly to the checking method (instead of looping and checking every number).</p>

<p>The core of this solution lies in the regex:</p>

<pre><code>^(?=(.+)\1{2}$)((.+)(?=.*(?(2)(?=\2$)\3.+$|(?=\1$)\3.+$))(?=.*(?=\1$)\3+$))+
</code></pre>

<p>And how the string is set up to be 3 times the number that we are checking.</p>

<p>The length of the string is set up to be 3 times the number that we are checking <code>i</code>: the first 2 <code>i</code> is for matching summation of factors and the last 1 <code>i</code> is reserved for checking whether a number is a factor of <code>i</code>.</p>

<p><code>(?=(.+)\1{2}$)</code> is used to capture the number that we are checking.</p>

<p><code>((.+)(?=.*(?(2)(?=\2$)\3.+$|(?=\1$)\3.+$))(?=.*(?=\1$)\3+$))+</code> matches the factors of the number. Later iteration will match a smaller factor than an earlier iteration.</p>

<ul>
<li>We can see that these 2 parts <code>(.+)</code> and <code>(?=.*(?=\1$)\3+$)</code> together selects a factor of the number being checked.</li>
<li><code>(?=.*(?(2)(?=\2$)\3.+$|(?=\1$)\3.+$))</code> makes sure that the factor selected is smaller than the number being checked in the first iteration, and is smaller than previous factor in subsequent iterations.</li>
</ul>

<p>The regex tries to match as many factors of the number as it can within the limit of 2 <code>i</code>. But we don't care about the actual value of sum of divisors, we only care whether the number is abundant.</p>

<p>Then the 2nd regex, which is the first regex with <code>\1{2}$</code> added. As a result, the regex makes sure the sum of (some) factors of the number being checked is equal to the number itself:</p>

<pre><code>^(?=(.+)\1{2}$)((.+)(?=.*(?(2)(?=\2$)\3.+$|(?=\1$)\3.+$))(?=.*(?=\1$)\3+$))+\1{2}$
</code></pre>

<p>The constraint added will cause the regex engine to perform a backtracking search on all possible subsets of factors, so it is going to be extremely slow.</p>
</div>
<div id="pu4" class="pu"><h1> Mathematica <s>99</s> <s>94</s> 87 </h1>

<p>Spaces not needed. Slow!:</p>

<pre><code>j = i = 0;
While[j&lt;#, i++; If[Union@Sign[Tr /@ Subsets@Most@Divisors@i-i]=={-1, 1}, j++; Print@i]]&amp;
</code></pre>

<p>At the expense of a few chars this is a faster version that checks only even numbers and skips multiples of <code>6</code> that are never weird:</p>

<pre><code>j = i = 0;
While[j &lt; #, 
      i += 2; If[Mod[i, 6] != 0 &amp;&amp; Union@Sign[Tr /@ Subsets@Most@Divisors@i - i] == {-1, 1}, 
                 j++; Print@i]] &amp;@3
</code></pre>

<p>it's still too slow for any useful purpose. Finds the first two in a few seconds but gets slower and slower as the number of divisors increase.</p>
</div>
<div id="pu5" class="pu"><h2>Python 2.7 (255 bytes)</h2>

<pre class="lang-python prettyprint-override"><code>import itertools as t
a=int(raw_input())
n=1
while a&gt;0:
    d=[i for i in range(1,n/2+1) if not n%i]
    if all([n not in map(sum,t.combinations(d,i)) for i in range(len(d))]+[sum(d)&gt;n]):
        print n
        a-=1
    n+=1
</code></pre>
</div>
<div id="pu6" class="pu"><h1>C++ - 458</h1>
<p>This is not all my solution as I had to ask on SO for help calculating the sum of the subsets, but everything else is mine:</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;
#define v vector&lt;int&gt;
#define r return
#define c const_iterator
v x(int i){v d;for(int k=1;k&lt;i;k++)if(i%k==0)d.push_back(k);r d;}bool u(v::c i,v::c e,int s){if(s==0)r 0;if(i==e)r 1;r u(i+1,e,s-*i)&amp;u(i+1,e,s);}bool t(v&amp;d,int i){bool b=u(d.begin(),d.end(),i);if(b)cout&lt;&lt;i&lt;&lt;endl;r b;}int main(){v d;int n;cin&gt;&gt;n;for(int i=2,j=0;j&lt;n;i++){d=x(i);int l=0;for(int k=0;k&lt;d.size();k++)l+=d[k];if(l&gt;i)if(t(d,i))j++;}}
</code></pre>
<p>Long version:</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;

vector&lt;int&gt; divisors(int i) {

    vector&lt;int&gt; divs;
    for(int k = 1; k &lt; i; k++)
        if(i%k==0)
            divs.push_back(k);
    return divs;
}

bool u(vector&lt;int&gt;::const_iterator vi, vector&lt;int&gt;::const_iterator end, int s) {

    if(s == 0) return 0;
    if(vi == end) return 1;
    return u(vi + 1, end, s - *vi) &amp; u(vi + 1, end, s);
}

bool t(vector&lt;int&gt;&amp;d, int i) {

    bool b = u(d.begin(), d.end(), i);
    if(b) cout&lt;&lt; i &lt;&lt; endl;
    return b;
}

int main() {

    vector&lt;int&gt; divs;
    int n;
    cin&gt;&gt;n;
    
    for(int i = 2, j = 0; j &lt; n; i++) {
        divs = divisors(i);

        int sum_divs = 0;
        for(int k = 0; k &lt; divs.size(); k++)
            sum_divs += divs[k];
        
        if(sum_divs &gt; i)
            if(t(divs, i))
                j++;
    }
}
</code></pre>
<p>It has currently only calculated the first two (70 and 836).  I killed it after that.</p>
</div>
<div id="pu7" class="pu"><h2>SageMath:<s> 143</s> 131 bytes</h2>
<pre><code>x=1
def w():
 l=x.divisors()
 return 2*x&gt;=sum(l)or max(2*x==sum(i)for i in subsets(l))
while n:
 while w():x+=1
 print x;n-=1;x+=1
</code></pre>
<p>It's moreorless not even golfed, there's not too much to golf anyways in the code. The biggest thing is that you should do the test <code>2*x&gt;=sum(l)</code> first, it would save a lot of computation time. One has to realize that <code>max</code> on booleans is <code>or</code> Second thing is that <code>w(x)</code> is <code>False</code> for weird numbers and <code>True</code> for non-weird numbers. Ungolfed version:</p>
<pre><code>def w(x) :
 Divisors = x.divisors()
 return 2*x &gt;= sum(Divisors) or max ( sum(SubS) == 2*x for SubS in subsets(Divisors) )

x=1

for k in xrange(n) :
 while w(x) : x += 1
 print x
 x += 1
</code></pre>
</div>
<div id="pu8" class="pu"><h1>Smalltalk, 143</h1>
<pre><code>((1to:(Integer readFrom:Stdin))reject:[:n||d|d:=(1to:n//2)select:[:d|(n\\d)=0].d sum&lt;n or:[(PowerSet for:d)contains:[:s|s sum=n]]])map:#printCR
</code></pre>
<p>input:</p>
<pre><code>1000
</code></pre>
<p>output:</p>
<pre><code>70
836
</code></pre>
</div>
<div id="pu9" class="pu"><h2>Ruby - 152</h2>

<pre><code>x=2;gets.to_i.times{x+=1 while((a=(1..x/2).find_all{|y|x%y==0}).reduce(:+)&lt;=x||(1..a.size).any?{|b|a.combination(b).any?{|c|c.reduce(:+)==x}});p x;x+=1}
</code></pre>

<h2>Ruby With ActiveSupport - 138</h2>

<pre><code>x=2;gets.to_i.times{x+=1 while((a=(1..x/2).find_all{|y|x%y==0}).sum&lt;=x||(1..a.size).any?{|b|a.combination(b).any?{|c|c.sum==x}});p x;x+=1}
</code></pre>

<p>Really slow and I'm almost sure there is still room for golfing...</p>
</div>
<div id="pu10" class="pu"><h1>Haskell - 129</h1>

<p>I'm sure there's lots to golf here, but since the competition seems low for now I'll throw this in.</p>

<p>Don't try running this though, I managed to wait only the two first elements, third will start taking minutes.</p>

<pre><code>(%)=filter
w n=take n$e%[1..]
e x=let d=((==0).mod x)%[1..x-1]in sum d&gt;x&amp;&amp;all((/=x).sum)(i d)
i[]=[[]]
i(y:z)=map(y:)(i z)++(i z)
</code></pre>
</div>
<div id="pu11" class="pu"><h2>R, 164</h2>

<pre><code>r=0;x=1;n=scan();while(r&lt;n){i=which(!x%%(2:x-1));if(sum(i)-1&amp;&amp;!any(unlist(lapply(2:sum(i|T),function(o)colSums(combn(i,o))==x)))&amp;sum(i)&gt;x){r=r+1;cat(x,"\n")};x=x+1}
</code></pre>

<p>Un-golfed version:</p>

<pre><code>r = 0
x = 1
n = scan()
while(r &lt; n) {
  i = which(!x %% (2:x - 1))
  if( sum(i) - 1 &amp;&amp;
       !any(unlist(lapply(2:sum(i | T),
                          function(o) colSums(combn(i, o)) == x))) &amp;
       sum(i) &gt; x
     ){ r = r + 1
        cat(x, "\n")
  }
  x = x + 1
}
</code></pre>

<p>This takes some time due to brute-force.</p>
</div>
<div id="pu12" class="pu"><h2>PHP, 267 bytes</h2>
<pre><code>$n=$x=0;while($n&lt;$argv[1]){$x++;for($i=1,$s=0,$d=array();$i&lt;$x;$i++){if($x%$i){continue;}$s+=$i;$d[]=$i;}if($s&lt;$x){continue;}$t=pow(2,$m=count($d));for($i=0;$i&lt;$t;$i++){for($j=0,$s=0;$j&lt;$m;$j++){if(pow(2,$j)&amp;$i){$s+=$d[$j];}}if($s==$x){continue 2;}}$n++;print&quot;$x\n&quot;;}
</code></pre>
<p>And here's the original source code:</p>
<pre><code>$n = 0;
$x = 0;

while ($n &lt; $argv[1]) {
    $x++;
    
    for ($i = 1, $sum = 0, $divisors = array(); $i &lt; $x; $i++) {
        if ($x % $i) {
            continue;
        }
        
        $sum += $i;
        $divisors[] = $i;
    }
    
    if ($sum &lt; $x) {
        continue;
    }
    
    $num = count($divisors);
    $total = pow(2, $num);

    for ($i = 0; $i &lt; $total; $i++) {  
        for ($j = 0, $sum = 0; $j &lt; $num; $j++) { 
            if (pow(2, $j) &amp; $i) {
                $sum += $divisors[$j];
            }
        }
        
        if ($sum == $x) {
            continue 2;
        }
    }
    
    print &quot;$x\n&quot;;
}
</code></pre>
<p>You will note that it takes some time to output the numbers as it is performing a brute-force verification (you should get to 70 pretty fast, though).</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/21783/">21783</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




