<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="g.js"></script>
    <title>cg::247947</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>103</td><td>Haskell</td><td>220529T082929Z</td><td><a href="https://codegolf.stackexchange.com/questions/247947/determine-uilta-pitch-accent/247963#247963">Wheat Wi</a></td></tr>
<tr d-ix="1"><td>049</td><td>Raku</td><td>230718T001932Z</td><td><a href="https://codegolf.stackexchange.com/questions/247947/determine-uilta-pitch-accent/262951#262951">bb94</a></td></tr>
<tr d-ix="2"><td>045</td><td>Vyxal</td><td>220601T022435Z</td><td><a href="https://codegolf.stackexchange.com/questions/247947/determine-uilta-pitch-accent/248052#248052">naffetS</a></td></tr>
<tr d-ix="3"><td>034</td><td>05AB1E</td><td>220530T132807Z</td><td><a href="https://codegolf.stackexchange.com/questions/247947/determine-uilta-pitch-accent/247998#247998">Kevin Cr</a></td></tr>
<tr d-ix="4"><td>038</td><td>Retina 0.8.2</td><td>220528T145745Z</td><td><a href="https://codegolf.stackexchange.com/questions/247947/determine-uilta-pitch-accent/247949#247949">Neil</a></td></tr>
<tr d-ix="5"><td>059</td><td>Java JDK</td><td>220530T132357Z</td><td><a href="https://codegolf.stackexchange.com/questions/247947/determine-uilta-pitch-accent/247997#247997">Olivier </a></td></tr>
<tr d-ix="6"><td>039</td><td>Charcoal</td><td>220530T125622Z</td><td><a href="https://codegolf.stackexchange.com/questions/247947/determine-uilta-pitch-accent/247996#247996">Neil</a></td></tr>
<tr d-ix="7"><td>113</td><td>Python 2</td><td>220530T033540Z</td><td><a href="https://codegolf.stackexchange.com/questions/247947/determine-uilta-pitch-accent/247989#247989">math jun</a></td></tr>
<tr d-ix="8"><td>078</td><td>Haskell + hgl</td><td>220529T235850Z</td><td><a href="https://codegolf.stackexchange.com/questions/247947/determine-uilta-pitch-accent/247981#247981">Wheat Wi</a></td></tr>
<tr d-ix="9"><td>193</td><td>C# Visual C# Interactive Compiler</td><td>220529T024420Z</td><td><a href="https://codegolf.stackexchange.com/questions/247947/determine-uilta-pitch-accent/247962#247962">Gymhgy</a></td></tr>
<tr d-ix="10"><td>650</td><td>Python3</td><td>220528T221226Z</td><td><a href="https://codegolf.stackexchange.com/questions/247947/determine-uilta-pitch-accent/247958#247958">Ajax1234</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://www.haskell.org/" rel="nofollow noreferrer">Haskell</a>, <s>154</s> <s>108</s> 103 bytes</h1>
<p><em>5 bytes saved thangks to <a href="https://codegolf.stackexchange.com/users/85334/unrelated-string">Unrelated String</a></em></p>
<pre class="lang-haskell prettyprint-override"><code>v=(`elem`&quot;iu@oEOa&quot;)
g&quot;S&quot;=&quot;tS&quot;
g&quot;Z&quot;=&quot;dZ&quot;
g x=x
m(x:y:z)|v x&gt;v y=g[y]++[x]|1&gt;0=m$y:z
m x=x
</code></pre>
<pre><code>m.tail.reverse
</code></pre>
<p><a href="https://tio.run/##TYtBi8IwEEbv/RVD8NDiKruwJyEllz26PXhrLTqQqMFMLO20pOJ/7wYFu7f35s13we5qnJumQaZH4wwdhe3V7adAkSVnsRNS8E5EKiPpMhIEGRJKw2bc3LPHACEfYJTnaqyXyyrUj6/8U9IixoSerydJa0br1q0ZTNuZidB6kKBvCQBhsz1AuocAqxya1nqGBZwgZDECVCA8flvxlA8QVBRv5v5XeV3O0TrEtzTI6GYNSBqZ54NSV1bztENsuP@31iX6l9bTHw" rel="nofollow noreferrer" title="Haskell – Try It Online">Try it online!</a></p>
<h1>Explanation</h1>
<p>This is overall pretty simple.  The first thing we do is <code>reverse</code> the input.  We do this because the pitch accent is easier to describe relative to the end of a word than the beginning.  From there we use <code>tail</code> to remove the final character.  If this is a primary mora we've broken it up and the solution is now the final primary mora.  If it wasn't well now we removed the final mora, and the solution is the new final primary mora.</p>
<p>So we are looking for the final primary mora.  That's a vowel followed by a non-vowel.  So <code>m</code> does just that, it trims until it finds a vowel followed by a consonatn and returns them reversed.  We use a small bit of extra logic to handle <code>tS</code> and <code>dZ</code>:  If the non-vowel was <code>S</code> or <code>Z</code>, we replace it with <code>tS</code> or <code>dZ</code> respectively otherwise we leave it alone.</p>
<p>And that's it, it gives us the accent peak.</p>
</div>
<div id="pu1" class="pu"><h1><a href="https://github.com/nxadm/rakudo-pkg" rel="nofollow noreferrer">Raku</a>, 49 bytes</h1>
<p>Port of <a href="https://codegolf.stackexchange.com/a/247997/14109">Olivier Grégoire’s Java answer</a>.</p>

<pre class="lang-perl6 prettyprint-override"><code>{S:g/.*((^|&lt;-[iu@oEOaSZ]&gt;S?Z?)&lt;[iu@oEOa]&gt;).+/$0/}
</code></pre>
<p><a href="https://tio.run/##PY3NTsMwEITP3aewIgslrZoUCXHoT@oLBy7JIbfQIi04Aat2GmJHtCrh1YNttVxW883OzrZVJx9HdSZ3NdmMl2L5kcTTMHz9Wc9fRM@OTzkW5T4ttuU2Wt@cfRrFs4QukmFcQX3sCJ0@Z7EUTaXJBSaiJkm4K2YRCcg8tcND4lYT@4kKsiG/dLG6YuXx/oadxTqkInKGxjMJlNAKzfvn0p3aOO0C0jey0tpR9WWN/6xN2Jc2AZMBhrHBB280CCrPnVI5mD5jDS/9ImMgJKKTEqFFg9KDQTih4miMR47A2MEwp@2FRmxN70Aj8BIPrQer4E2YQpx80ApbIr6Rc7y2/AE" rel="nofollow noreferrer" title="Perl 6 – Try It Online">Try it online!</a></p>
</div>
<div id="pu2" class="pu"><h1><a href="https://github.com/Vyxal/Vyxal" rel="nofollow noreferrer">Vyxal</a>, 45 bytes</h1>
<pre><code>Ṫλ&amp;›`dtSZ`$c¬¥*;Ḋ2l:hhp'ɽkv\@J$vcṅ⌊1=;tfṅĠvhṅ
</code></pre>
<p><a href="https://vyxal.pythonanywhere.com/#WyIiLCLGmyIsIuG5qs67JuKAumBkdFNaYCRjwqzCpSo74biKMmw6aGhwJ8m9a3ZcXEBKJHZj4bmF4oyKMT07dGbhuYXEoHZo4bmFIiwiO1rGm2AgPT4gYGo74oGLIiwiW1wibmE0aVwiLCBcIm1PT1wiLCBcInR1TkBuZFppXCIsIFwiaWxhYVwiLCBcInBhdGFsYVwiLCBcInhhbWRhdHRhXCIsIFwiQEBrdEBcIiwgXCJpc2FhcHR1XCIsIFwiZFpha3B1XCIsIFwiYml0U2l4QFwiLCBcInhhaXdhZGRhYVwiXSJd" rel="nofollow noreferrer">Try it Online!</a></p>
<p>Port of 05AB1E.</p>
</div>
<div id="pu3" class="pu"><h1><a href="https://github.com/Adriandmen/05AB1E/wiki/Commands" rel="nofollow noreferrer">05AB1E</a>, 34 <a href="https://github.com/Adriandmen/05AB1E/wiki/Codepage" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>¨.γ&quot;tSdZ&quot;så_N*}ü2¬нšʒžM'@«slåJ}θJÔ
</code></pre>
<p>Inspired by <a href="https://codegolf.stackexchange.com/a/247963/52210"><em>@WheatWizard♦</em>'s Haskell answer</a>.</p>
<p><a href="https://tio.run/##AUAAv/9vc2FiaWX//8KoLs6zImR0U1oic8OlX04qfcO8MsKs0L3FocqSxb5NJ0DCq3Nsw6VKfc64SsOU//9iaXRTaXhA" rel="nofollow noreferrer">Try it online</a> or <a href="https://tio.run/##yy9OTMpM/V9Waa@k8KhtkoKSfeX/Qyv0zm1WSikJjlIqPrw03k@r9vAeo0NrLuw9uvDUpKP7fNUdDq0uzjm81Kv23A6vw1P@6/yPVspLNMlU0lFQyvX3B1ElpX4OeSlRYKHMnMREEF2QWJKYA2ZVJOamJJaUgNkODtklDmBlxYmJBSWlIGZKVGJ2AZiVlFkSnFnhANGUWZ6YkgI0KxYA" rel="nofollow noreferrer">verify all test cases</a>.</p>
<p><strong>Explanation:</strong></p>

<pre class="lang-python prettyprint-override"><code>¨             # Remove the final character of the (implicit) input-string
.γ            # Adjacent group by:
        s     #  Check if the current character
         å_   #  is NOT in
  &quot;dtSZ&quot;      #  string &quot;dtSZ&quot;
           N* #  Multiply it by the index, so everything else is in its own group
 }ü2          # After the group-by: get all overlapping pairs of this list
    ¬нš       # For the edge case of a leading vowel:
    ¬         #  Get the first pair (without popping the list)
     н        #  Pop and get its first character
      š       #  Prepend it to the list
ʒ             # Filter this list of pairs (plus the single leading item) by:
 žM           #  Push the vowels &quot;aeiou&quot;
   '@«       '#  Append a &quot;@&quot;
      s       #  Swap so the current pair is at the top of the stack
       l      #  Convert all letters to lowercase
        å     #  Check if its in the vowels string
         J    #  Join these checks together
              #  (truthy: &quot;1&quot;/&quot;01&quot;; falsey: &quot;0&quot;/&quot;00&quot;/&quot;10&quot;/&quot;11&quot;)
}θ            # After the filter: pop and keep the last valid item
  J           # Join this pair back together to a string
   Ô          # For the edge case of &quot;tt&quot; or &quot;dd&quot;:
   Ô          #  Connected uniquify
              # (after which the result is output implicitly)
</code></pre>
</div>
<div id="pu4" class="pu"><h1><a href="https://github.com/m-ender/retina/wiki/The-Language/a950ad7d925ec9316e3e2fb2cf5d49fd15d23e3d" rel="nofollow noreferrer">Retina 0.8.2</a>, <s>102</s> <s>77</s> <s>39</s> 38 bytes</h1>
<pre><code>.*((^|[^iu@oEOaSZ]S?Z?)[iu@oEOa]).+
$1
</code></pre>
<p><a href="https://tio.run/##LcmxCoMwEAbg/Z7DQrQgFLp7i7iZIVtE8QcdDjWKXqBD3z1S6PjxnbNKQHqYZkxlYczw7QaJvNcWzveu8lXe/d3n5ZOyV0oBb6HNWtLYcpi8kKwAHVCsoA@2Caog5kWZ5AIOjb91CDc" rel="nofollow noreferrer" title="Retina 0.8.2 – Try It Online">Try it online!</a> Link includes test cases. Explanation: Now heavily inspired by @WheatWizard's Haskell answer, simply matches the last nonterminal vowel with its immediately preceding consonant or at the beginning of the string. Edit: Saved 1 byte thanks to @OlivierGrégoire.</p>
</div>
<div id="pu5" class="pu"><h1><a href="http://jdk.java.net/" rel="nofollow noreferrer">Java (JDK)</a>, 59 bytes</h1>

<pre class="lang-java prettyprint-override"><code>s-&gt;s.replaceAll(&quot;.*((^|[^iu@oEOaSZ]S?Z?)[iu@oEOa]).+&quot;,&quot;$1&quot;)
</code></pre>
<p><a href="https://tio.run/##hZDBctowEIbveoodT5mRKShh2lNpiHtoTy3M1DcYMrOxRSKQhWqtCEzDU/TQS5@uL0KRMWCSQy9e/d5/v3@lOa6wO88XO1XYZUkw32vhSWnR7rNX/2beZKSWJjQzjc7BN1QGfjIA6@@1ysAR0r6sliqHYt/jKZXKPEymgOWDiysrwJea8/HQ7RzKAGZws3PdgROltBoz@UlrHok253fPkzvlk@XnEabjaXo7vo0ntZ7G4m3Uid70onjXr@hUbvgKS3AZGiNLuAEjnyA9KJ5uHMlCKBMftwF4elRaAq8HxCO6oVzTV2Ukb7gAApWkoz3y6DUno3BWK@IRdAcQxf2LIWWsD1NheHI9vWzKtZUZyfy7dF6fXL0XrvLYnQm0Vm94xWzkqBnwS5SQPzxqxw@jFzcBqN9h6UnY/evTjEd///yCVu/ahRu03rmWiTqHzTt1eiNtC1I7@X/i7ybxvOAHaLn4dUDnxWM0A1mzhu@WbdlVmxl8r1gxGjHyw8TkY8WURmQWCTWyNRY5EiFLkgUlTDlES57lY1xYz@4VpWqdsPbVLmDCmgYDLJyKMzLIYVKBw1Ef8UHQOSTIvI4K51NeEA7r1Mo1xmN4xUjVPw" rel="nofollow noreferrer" title="Java (JDK) – Try It Online">Try it online!</a></p>
<h2>Credits</h2>
<ul>
<li>-96 bytes by porting the <a href="https://codegolf.stackexchange.com/users/17602/neil">Neil</a>'s <a href="https://codegolf.stackexchange.com/a/247949/16236">Retina answer</a>, thanks to <a href="https://codegolf.stackexchange.com/users/52210/kevin-cruijssen">Kevin Cruijssen</a>.</li>
</ul>
</div>
<div id="pu6" class="pu"><h1><a href="https://github.com/somebody1234/Charcoal" rel="nofollow noreferrer">Charcoal</a>, 39 bytes</h1>
<pre><code>≔…θ⌈⌕Ａ⁺00⭆…θ⊖Ｌθ№iu@oEOaι01η✂η±⁺²№SZ§η±²
</code></pre>
<p><a href="https://tio.run/##VY09C8IwGIR3f0XI9AYi1K4ulqogWC1kcwvpSxNIk34kUn99LBVEbzqOu@eUlqPy0qZUTJNpHZQvZbHUvoeBk0rOposdnI1rCmuhtnECmmWUExFG49pK9v@LI6oRO3QBG7iia4OGgTHGSemjC0BNPPjTXS4As8Y029HVaLbf1AsygLBGIWhObtjKgJ/T/EsQj2VchItrcP5p5WzVPqVeBiFd2j7tGw" rel="nofollow noreferrer" title="Charcoal – Try It Online">Try it online!</a> Link is to verbose version of code. Alternative formulation, also 39 bytes:</p>
<pre><code>≔✂θ⁰±⌕⪫00⭆Φ⮌θκ№iu@oEOaι10¹η✂η±⁺²№SZ§⮌η¹
</code></pre>
<p><a href="https://tio.run/##PY1BCsIwEEX3niJkNYEIqdtuLKKgoBazcxfa0ARDUpO0ePs4FunAZ2CG935nVOyCcqU0KdnBg3S20/DmRHBy04PKGk7W93AJ1gMVgnIic7R@uKoRPy7rCA8965iQYpy8MIcw@QzUTvtwvCskLGN4ppWgv11hDKs3LWryv9Csba2bEuxWiXwi3@Sz7/VnLTKLZZm6lFFlqXzZzu4L" rel="nofollow noreferrer" title="Charcoal – Try It Online">Try it online!</a> Link is to verbose version of code. Explanation: Ports of @WheatWizard's Haskell answer.</p>
<pre><code>≔…θ⌈⌕Ａ⁺00⭆…θ⊖Ｌθ№iu@oEOaι01η
</code></pre>
<p>Except for the last letter, map each letter to whether it is a vowel or not, prefix <code>00</code> to the result, find the last index of <code>01</code>, and truncate the input string at that point, which thanks to the <code>00</code> prefix will be just after the desired primary mora, although the second <code>0</code> does double duty by allowing an initial vowel to be detected as a primary mora.</p>
<pre><code>≔✂θ⁰±⌕⪫00⭆Φ⮌θκ№iu@oEOaι10¹η
</code></pre>
<p>Reverse the string except for the last letter, map each letter to whether it is a vowel or not, wrap the result in <code>00</code>, find the index of <code>10</code>, and remove that many characters from the end of the input string. The leading <code>0</code> adjusts the find index to be the number of characters to remove while the trailing <code>0</code> allows an initial vowel to match as a primary mora.</p>
<pre><code>✂η±⁺²№SZ§η±²
✂η±⁺²№SZ§⮌η¹
</code></pre>
<p>Output the last two characters of the remaining string, unless the second last character is <code>S</code> or <code>Z</code>, in which case output the last three.</p>
</div>
<div id="pu7" class="pu"><h1>Python 2, 113 Bytes</h1>

<pre class="lang-python prettyprint-override"><code>lambda s,v='iu@oEOa':(['dt'[i&lt;'T'][:i in'SZ']+i+j for i,j in zip(s[:-1],s[1:-1])if(i in v)&lt;(j in v)][-1:]or s)[0]
</code></pre>
<p><a href="https://tio.run/##fY47b4MwGEV3foUVBhsBUkk6WUnkDl3DkE64Hr4IodoFg2ITtf3zlFeC00j14sfxd89tvu1HrdddsXvvSqhOOSATXXZYtqx@TQFTwnFuMZdb/IYFpxJJjY8ZFqEMFSrqM5KR6t/Qj2yI4TRORGR4MuyBLMjwHV2CLVHTQfA4oaKfMgF/Ep2PXkpToyTZnDwf/edXs1/d/CqUj/54TecK8Yb@KbG/lbj6Pa85S21JQVYanuUqCFC/fBTvkYaFVWk6o4lV6cJse2A6z4bZkR3YwmQJ4GaWTmYDFsqJjsw67AuqHKyFa2buMMY@LZtCR@bqDEBj2wGOyNzp8gz0outvd12OLuxv3S8" rel="nofollow noreferrer">Try it online!</a></p>
<p>Heavily inspired by Wheat Wizard's <a href="https://codegolf.stackexchange.com/a/247963/65425">Haskell answer</a>.</p>
<h3>Approach</h3>
<ul>
<li>Split the word into two-letter chunks, excluding the last letter</li>
<li>Find all chunks of the form CV (consonant then vowel)
<ul>
<li>If no such chunk exists, return the first letter of the word</li>
<li>Return the last such chunk</li>
</ul>
</li>
</ul>
</div>
<div id="pu8" class="pu"><h1>Haskell + <a href="https://gitlab.com/WheatWizard/haskell-golfing-library" rel="nofollow noreferrer">hgl</a>, 78 bytes</h1>
<pre><code>v=kB$fe&quot;iu@oEOa&quot;
</code></pre>
<pre><code>rv&lt;gj&lt;gP(h_*&gt;l2p(p&lt;v)(nA v*&gt;hds++pM&quot;&quot;en++(ʃ&gt;/wR&quot;St Zd&quot;)))&lt;rv
</code></pre>
<h1>Explanation</h1>
<p>This works a lot like my <a href="https://codegolf.stackexchange.com/a/247963/">haskell answer</a>.</p>
<p>First we setup <code>v</code> which is a parser which accepts any vowel.  With that the first step in our function is to reverse the input with <code>rv</code>.  We do this since we want to do things relative to the end of the list rather than the front of the list.</p>
<p>From here we have the actual parser.</p>
<pre><code>h_*&gt;l2p(p&lt;v)(nA v*&gt;hds++pM&quot;&quot;en++(ʃ&gt;/wR&quot;St Zd&quot;))
</code></pre>
<p>The actual parser just finds all primary morae except ones that end the list  First it does <code>h_</code> which parses one or more characters then we parse a primary mora.</p>
<p>Since <code>h_</code> never parses 0 characters this breaks up any primary mora that would be at the end of the list.</p>
<p>The part that parses a primary mora is a little bit more complex</p>
<pre><code>l2p(p&lt;v)(nA v*&gt;hds++pM&quot;&quot;en++(ʃ&gt;/wR&quot;St Zd&quot;))
</code></pre>
<p>But it can be broken down into further parts, first it parses a vowel <code>p&lt;v</code> which parses a single vowel as a string.  Then it parses a non-vowel, it does this with a negative look-ahead to check it's not a vowel <code>nA v</code>.  Then it parses either, any one character <code>hds</code>, the end of the string <code>pM&quot;&quot;en</code> or one of the digraphs <code>ʃ&gt;/wR&quot;St Zd&quot;</code>.  It can do both the first and last option at the same time, but since the digraphs are placed last they will have higher priority in the final result.</p>
<p>Once we have that parser we can run it.  We run it with <code>gP</code> to get all results as a list. We use <code>gj</code> to get the last result, which do to the way we've done things will be the mora closest to the end of the string.  This is also where the digraphs get higher priority than single characters, they will always appear later in the list.</p>
<p>Finally we reverse the given mora back to the correct order.</p>
<h2>Relfection</h2>
<p>There were some pretty painful things here.  When I first started I immediately realized there were some very important functions missing.  I added them to the repo, although they are not present above.</p>
<p>I won't go into much detail but they would have saved 3 bytes overall:</p>
<pre><code>v=xay&quot;iu@oEOa&quot;
</code></pre>
<pre><code>rv&lt;gj&lt;gP(h_*&gt;l2p(p&lt;v)(nA v*&gt;hds++pM&quot;&quot;en++asy[&quot;St&quot;,&quot;Zd&quot;]))&lt;rv
</code></pre>
<p>However there are still some things that could be improved:</p>
<ul>
<li><code>pM&quot;&quot;en</code> is so painful.  It's just an extremely expensive way to say the end of the list.  <code>en</code> should in theory do that, but it returns a <code>()</code> instead and we need it to be an empty list.  A version of <code>en</code> that returns an empty list would be useful.</li>
<li>We really shouldn't have to do <code>gj&lt;&lt;gP</code>, there should be a built in way to get the highest / lowest priority parse, and only that.</li>
</ul>
</div>
<div id="pu9" class="pu"><h1><a href="http://www.mono-project.com/docs/about-mono/releases/5.0.0/#csc" rel="nofollow noreferrer">C# (Visual C# Interactive Compiler)</a>, 193 bytes</h1>

<pre class="lang-cs prettyprint-override"><code>s=&gt;System.Text.RegularExpressions.Regex.Match(s,$&quot;^((?&lt;P&gt;{C}?{V}){V}?{C}?)((?&lt;P&gt;{C}{V}){V}?{C}?)*?({C}{V})?$&quot;).Groups[&quot;P&quot;].Captures[^1].Value;string T=&quot;iu@oEOa&quot;,C=$&quot;([^{T}][SZ]?)&quot;,V=$&quot;([{T}])&quot;;
</code></pre>
<p><a href="https://tio.run/##VY9Na8JAEIbv@yuWxcNujQuF3jQfILaXtkoVC4YIQ1zt0mQTMhOIhPz2NNFS6GGG4YF35pkUZyna/rl26QKpsu7ina4OcpsGZ79HP9hekUyud6Yh/WEudQbVqikrg2gLhyMyjX4DSr8kehNxlDJcbIJ22YXtvlNDheOs/vA/@hDKXxROhNIvVVGXGIuNSPQSSqqHM/HxMdF7yGozv/vxnS9sHRWrNQhv6U@EjI/trkvi7SEJlfD2NzQSJeY9u4fihAwS93kkHDxZlq/XjOr3yJ0OltkMgJVAkAFrID8BEbAo@qaIWYTRQ@htmVmSas7ORWVgfPYug9w6Pu5WLfusLJlX64xEPuWCz4KhTflZohqCXf8D" rel="nofollow noreferrer" title="C# (Visual C# Interactive Compiler) – Try It Online">Try it online!</a></p>
<pre class="lang-cs prettyprint-override"><code>^((?&lt;P&gt;{C}?{V}){V}?{C}?)((?&lt;P&gt;{C}{V}){V}?{C}?)*?({C}{V})?$
</code></pre>
<p>This regex does all of the work. C and V stand for consonants and vowels respectively.</p>
<pre class="lang-cs prettyprint-override"><code>((?&lt;P&gt;{C}?{V}){V}?{C}?)
</code></pre>
<p>The first part matches the first syllable, and captures its primary mora in capturing group <code>P</code>.</p>
<pre class="lang-cs prettyprint-override"><code>((?&lt;P&gt;{C}{V}){V}?{C}?)*?
</code></pre>
<p>This part matches the next syllables, again capturing their primary mora in capturing group <code>P</code>. Note the lazy quantifier at the end.</p>
<pre class="lang-cs prettyprint-override"><code>({C}{V})?
</code></pre>
<p>This matches a single-mora syllable at the very end, if any.</p>
<p>We can then take the final mora captured within <code>P</code>, since it is guranteed to be primary, and also guranteed to not be the final mora (since that would either be captured within the last part, or it would be non-primary).</p>
</div>
<div id="pu10" class="pu"><h1>Python3, 650 bytes:</h1>
<pre class="lang-py prettyprint-override"><code>lambda x:[*s(T(x),1)][0]
T=lambda x,c=[]:c if''==x else T(x[len((t:=[(a,b)for a,b in[('C','tS'),('C','dZ')]+[('C',i)for i in'mnJNptkbdgsx4ljw']+[('V',i)for i in'iu@oEOa']if x[:len(b)]==b][0])[1]):],c+[t])
P=lambda x:''.join(i[1]for i in x)
def M(w):
 w=[i for j in w for i in j]
 for i in[-2,-3,-4]:
  if w[i][0]:return w[i][1]
def s(t,l,c=[]):
 if[]==t:yield M([[(1,P(i[:I[0]+1])),*[(0,P([j]))for j in i[I[0]+1:]]]if(I:=[x for x,(a,_)in enumerate(i)if'V'==a])else i for i in c]);return
 for i in'CVVC CVV CVC CV VVC VV VC V'.split():
  if len(t)&gt;=len(i)and(i[0]!='V'or l)and all(a==k for(a,b),k in zip(t,i)):yield from s(t[len(i):],0,c+[t[:len(i)]])
</code></pre>
<p><a href="https://tio.run/##VVLBbtswDD3PX6HlIrFRimTNYfCgIkCwQwesKbAih6rCQMf2pkRWDFtB3P58RtlJih0s8ZFP5CPp@i383fu7r3VzKtXryWGV5ci6VN@04ll0IGdg9NQkz@oSkhulTbphtuRcqY4Vri0YUbUrvBAhVVqgzKDcN4xuZr0WfMklD784yMHMXziY8eC3PdMSj1f@x2Mddln@p@3mbnvkPWf9H8ceFvvvK@TGlqzTaayZgVEqiypBzwykRm7GOhhInq6aU85vt3vrhSXGJRfrIMmLkv0UR0gTdlTashjbxtiRXWlbk1yBnnyRkzs5mRt6QSNgR21j5bQpwqHxA5yZPm8rgnT9tGJ6W2qSGdI3W7icamotZvKJBKUP9H5MwkHeaDEln94SuCqxeiCkxlDT4oEG3PV6OkmD/g1EKfyhKhoMhbBAa1nTXtBAvxj70cfGwLdB5kc/fLleLxkd9MWbRUgonvy2rZ0NAs6txlkHuFfxtoA@J/FT81lRPcrmooehcwKV2sUC/W8gd7H0u61pGBbg3H7Z7Ks4Hz3kopVN@6UNC7VgDJyuukejkce5ZZN75jGpVqtoVaskHB4XPn/pA4@LxDrEaDpMagzoehAw6bDKMYQe5pgsFruwiDa9aBHrcIigRapy7pe/ek49f0LJMqaYvbgjjwP527ZoAisFAlOKZad/" rel="nofollow noreferrer">Try it online!</a></p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../index.html">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/247947/">247947</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




