<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::40913</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>022</td><td>Vyxal 3 d</td><td>240319T162057Z</td><td><a href="https://codegolf.stackexchange.com/questions/40913/eating-candy-in-the-correct-order/271967#271967">pacman25</a></td></tr>
<tr d-ix="1"><td>029</td><td>Pyth</td><td>141109T221115Z</td><td><a href="https://codegolf.stackexchange.com/questions/40913/eating-candy-in-the-correct-order/41345#41345">Optimize</a></td></tr>
<tr d-ix="2"><td>030</td><td>CJam</td><td>141104T134316Z</td><td><a href="https://codegolf.stackexchange.com/questions/40913/eating-candy-in-the-correct-order/40914#40914">Optimize</a></td></tr>
<tr d-ix="3"><td>025</td><td>Pyth</td><td>141104T192815Z</td><td><a href="https://codegolf.stackexchange.com/questions/40913/eating-candy-in-the-correct-order/40931#40931">isaacg</a></td></tr>
<tr d-ix="4"><td>124</td><td>Python 3.x</td><td>141105T224820Z</td><td><a href="https://codegolf.stackexchange.com/questions/40913/eating-candy-in-the-correct-order/41100#41100">recursiv</a></td></tr>
<tr d-ix="5"><td>166</td><td>R</td><td>141105T191444Z</td><td><a href="https://codegolf.stackexchange.com/questions/40913/eating-candy-in-the-correct-order/41083#41083">Brian Di</a></td></tr>
<tr d-ix="6"><td>038</td><td>APL</td><td>141105T132334Z</td><td><a href="https://codegolf.stackexchange.com/questions/40913/eating-candy-in-the-correct-order/41047#41047">Moris Zu</a></td></tr>
<tr d-ix="7"><td>062</td><td>Perl 5</td><td>141104T200630Z</td><td><a href="https://codegolf.stackexchange.com/questions/40913/eating-candy-in-the-correct-order/40937#40937">nutki</a></td></tr>
<tr d-ix="8"><td>nan</td><td></td><td>141104T180001Z</td><td><a href="https://codegolf.stackexchange.com/questions/40913/eating-candy-in-the-correct-order/40927#40927">FryAmThe</a></td></tr>
<tr d-ix="9"><td>118</td><td>Mathematica</td><td>141104T155306Z</td><td><a href="https://codegolf.stackexchange.com/questions/40913/eating-candy-in-the-correct-order/40918#40918">Martin E</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://github.com/Vyxal/Vyxal/tree/version-3" rel="nofollow noreferrer">Vyxal 3</a> <code>d</code>, 22 bytes</h1>
<pre><code>ᵏ“ḶṚ:ᵂ…lD∆L÷ė←⸠«r⸠×rTė
</code></pre>
<p><a href="https://vyxal.github.io/latest.html#WyJkIiwiIiwi4bWP4oCc4bi24bmaOuG1guKApmxE4oiGTMO3xJfihpDiuKDCq3LiuKDDl3JUxJciLCIiLCJvcm95YmdyYmJ5cm9yeXBvcHJyIiwiMy40LjIiXQ==" rel="nofollow noreferrer">Try it Online!</a></p>
</div>
<div id="pu1" class="pu"><h1>Pyth, 29 bytes</h1>
<p>This is a direct translation of my <a href="https://codegolf.stackexchange.com/a/40914/31414">CJam answe</a>r in Pyth</p>
<pre><code>oc/|$Y.append(N)$YN/zNo_/zZSz
</code></pre>
<p><a href="http://isaacg.scripts.mit.edu/pyth/index.py" rel="nofollow noreferrer">Try it online here</a></p>
<hr />
<p>There is a rather long story behind this solution and @isaacg helped me a lot in understanding this new language.</p>
<p>Ideally this is the exact word to word translation of my CJam code (<strong>17 bytes</strong>):</p>
<pre><code>oc/~kNN/zNo_/zZSz
</code></pre>
<p>which means:</p>
<pre><code>o         order_by(lambda N:
 c                 div(
  /                    count(
   ~kN                       k+=N,                #Update k (initially &quot;&quot;), add N
   N                         N),                  #Count N in updated k
  /zN                  count(z, N)),
 o                 order_by(lambda Z:
  _                         neg(
   /zZ                          count(z, Z)),
  Sz                        sorted(z)))
</code></pre>
<p>But sadly Python does not return anything in a <code>+=</code> call, so that was not a valid Python code, thus an invalid Pyth code too as in Pyth, a lambda can only be a return statement.</p>
<p>Then I looked into various methods and finally found that Python's <code>list.append</code> returns a <code>None</code> value, which I can use. Making the code to be (<strong>19 bytes</strong>):</p>
<pre><code>oc/|aYNYN/zNo_/zZSz
</code></pre>
<p>which means:</p>
<pre><code>o         order_by(lambda N:
 c                 div(
  /                    count(
   |aYN                      (Y.append(N) or
    Y                         Y)                 #Update Y (initially []), append N
   N                         N),                 #Count N in updated Y
  /zN                  count(z, N)),
 o                 order_by(lambda Z:
  _                         neg(
   /zZ                          count(z, Z)),
  Sz                        sorted(z)))
</code></pre>
<p>But sadly, support of <code>a</code> (append) was removed from Pyth and the version which do has the support, does not have the support for <code>o</code>.</p>
<p><em>Update : <code>a</code> support has been added back in Pyth now so the above 19 byte code will work in the online compiler. But since this is a new feature which was added after the OP, I am not putting it up as my score and letting the 29 byte code as my solution.</em></p>
<p>Therefore I had to rely on raw Python in that case, making the code to be</p>
<pre><code>o         order_by(lambda N:
 c                 div(
  /                    count(
   |$Y.append(N)$            (Y.append(N) or
    Y                         Y)                 #Update Y (initially []), append N
   N                         N),                 #Count N in updated Y
  /zN                  count(z, N)),
 o                 order_by(lambda Z:
  _                         neg(
   /zZ                          count(z, Z)),
  Sz                        sorted(z)))
</code></pre>
</div>
<div id="pu2" class="pu"><h1>CJam, <s>78 68 61 45 42 39 31</s> 30 bytes</h1>
<pre><code>l$:L{L\/,~}${:DM+:MD/,LD/,d/}$
</code></pre>
<p>Takes the input string via STDIN</p>
<p>Inspired by recursive's approach, but a little different. No need of transpose or rectangle at all!.</p>
<p><strong>How it works:</strong></p>
<pre><code>l$:L                              &quot;Sort the input line and store it in L&quot;;
    {     }$                      &quot;Sort the string based on this code block output&quot;;
     L\/,~                        &quot;Sort based on number of occurrences of each&quot;;
                                  &quot;character in the full string&quot;;
            {               }$    &quot;Sort the sorted string again&quot;;
             :DM+:M               &quot;Store each character in D, add to M and update M&quot;;
                   D/,            &quot;Count occurrences of D in M&quot;;
                      LD/,        &quot;Count occurrences of D in L&quot;;
                          d/      &quot;Sort string based on the ratio of two occurrences&quot;;
</code></pre>
<p>(Sad that CJam can no longer complete with Pyth due to need of so much bloat as syntax)</p>
<p><a href="http://cjam.aditsu.net/" rel="nofollow noreferrer">Try it here</a></p>
</div>
<div id="pu3" class="pu"><h1><a href="https://github.com/isaacg1/pyth" rel="noreferrer">Pyth</a>, 25</h1>
<pre><code>shCoc/NhN/zhNm&gt;o_/zZSzdUz
</code></pre>
<p>Uses an all new algorithm, inspired by <a href="https://codegolf.stackexchange.com/a/41100/20080">this answer</a>.</p>
<pre><code>(implicit)          z = input()
(implicit)          print
s                   combine list of strings into one string
 h                  first list in
  C                 matrix transpose of (e.g. first characters in first list, etc.)
   o                order_by(lambda N:
    c                        float_div(
     /NhN                              N.count(N[0]),
     /zhN                              z.count(N[0])),
    m                        map(lambda d:
     &gt;                           slice_head(
      o                                     order_by(lambda Z:
       _/zZ                                          -1*z.count(Z),
       Sz                                            sorted(z)),
      d                                     d),
     Uz                          range(len(z))
     
</code></pre>
<p>Step by step:</p>
<ol>
<li><p>First, we sorted the characters by their commonness, ties broken alphabetically. This is <code>o_/zZSz</code>. <code>o</code> is the same as Python's <code>sorted(&lt;stuff&gt;,key=&lt;stuff&gt;)</code>, with a lambda expression for the key, except it keeps it as a string.</p>
</li>
<li><p>Then we generate a list of the prefixes of that string, from length <code>len(z)</code> to length 1. <code>&gt;</code> is equivalent to python's <code>&lt;stuff&gt;[&lt;int&gt;:]</code>.</p>
</li>
<li><p>Then, we reorder this list of prefix strings by the fractional location, 0 being the left edge and 1 being the right, of the first character of the prefix on the rectangular layout seen in the question. <code>/NhN</code> counts how many times the first character in the prefix occurs in the prefix, while <code>/zhN</code> gives the number of occurrences of the first character in the prefix in the string as a hole. This assigns each prefix being led by each character in a group a different fraction, from <code>1/k</code> for the right most occurrence of that character to <code>k/k</code> for the left most. Reordering the prefix list by this number gives the appropriate position in the layout. Ties are broken using the prior ordering, which was first by count then alphabetical, as desired.</p>
</li>
<li><p>Finally, we need to extract the first character from each prefix string, combine them into a single string, and print them out. Extracting the first characters is <code>hC</code>. <code>C</code> performs a matrix transpose on the list, actually <code>zip(*x)</code> in Python 3. <code>h</code> extracts the first row of the resultant matrix. This is actually the only row, because the presence of the 1 character prefix prevents any other complete rows from being formed. <code>s</code> sums the characters in this tuple into a single string. Printing is implicit.</p>
</li>
</ol>
<p><strong>Test:</strong></p>
<pre><code>$ pyth -c 'shCoc/NhN/zhNm&gt;o_/zZSzdUz' &lt;&lt;&lt; 'oroybgrbbyrorypoprr'
rorbyroprbyorrobypg
</code></pre>
<p>Incremental program pieces on <code>oroybgrbbyrorypoprr</code>:</p>
<pre><code>Sub-Piece                  Output

Sz                         bbbgoooopprrrrrryyy
o_/zNSz                    rrrrrroooobbbyyyppg      (uses N because o uses N on first use.)
m&gt;o_/zNSzdUz               ['rrrrrroooobbbyyyppg', 'rrrrroooobbbyyyppg', 'rrrroooobbbyyyppg', 'rrroooobbbyyyppg', 'rroooobbbyyyppg', 'roooobbbyyyppg', 'oooobbbyyyppg', 'ooobbbyyyppg', 'oobbbyyyppg', 'obbbyyyppg', 'bbbyyyppg', 'bbyyyppg', 'byyyppg', 'yyyppg', 'yyppg', 'yppg', 'ppg', 'pg', 'g']
oc/NhN/zhNm&gt;o_/zZSzdUz     ['roooobbbyyyppg', 'obbbyyyppg', 'rroooobbbyyyppg', 'byyyppg', 'yppg', 'rrroooobbbyyyppg', 'oobbbyyyppg', 'pg', 'rrrroooobbbyyyppg', 'bbyyyppg', 'yyppg', 'ooobbbyyyppg', 'rrrrroooobbbyyyppg', 'rrrrrroooobbbyyyppg', 'oooobbbyyyppg', 'bbbyyyppg', 'yyyppg', 'ppg', 'g']
Coc/NhN/zhNm&gt;o_/zZSzdUz    [('r', 'o', 'r', 'b', 'y', 'r', 'o', 'p', 'r', 'b', 'y', 'o', 'r', 'r', 'o', 'b', 'y', 'p', 'g')]
shCoc/NhN/zhNm&gt;o_/zZSzdUz  rorbyroprbyorrobypg
</code></pre>
<hr />
<p>Old answer:</p>
<h1><a href="https://github.com/isaacg1/pyth" rel="noreferrer">Pyth</a>, 34</h1>
<pre><code>ssCm*+t*u*G/zHS{-zd1]kd/zdo_/zNS{z
</code></pre>
<p>This program works by calculating how many times to replicate a certain sublist. The sub-list looks like <code>['', '', '', '', ... , 'r']</code>. The total length of this sub-list is the product of the number of occurrences of all of the other candies, which is <code>u*G/zHS{-zd1</code>. The full sublist is constructed by replicating the list of the empty string ,<code>]k</code>, that many times, then removing and element with <code>t</code> and add the candy name to the end with <code>+d</code>.</p>
<p>Then, this sub-list is replicated as many times as that candy is found in the input, <code>/zd</code>, ensuring each candy's list is of equal length.</p>
<p>Now, with this function mapped over all of the unique candies in proper sorted order (<code>o_/zNS{z</code>), we have a rectangle similar to the one in the question statement, but with empty strings instead of periods. Doing a matrix transpose (<code>C</code>) followed by two summations (<code>ss</code>) gives the final string.</p>
<p>Verification:</p>
<pre><code>$ pyth programs/candy.pyth &lt;&lt;&lt; 'oroybgrbbyrorypoprr'
rorbyroprbyorrobypg
</code></pre>
</div>
<div id="pu4" class="pu"><h2>Python 3.x - 124 bytes</h2>

<pre><code>C=input()
print("".join(s[1]for s in sorted(enumerate(C),key=lambda
t:((C[:t[0]].count(t[1])+1+1e-10)/C.count(t[1]),t[1]))))
</code></pre>
</div>
<div id="pu5" class="pu"><h1>R - 166 characters</h1>

<pre><code>library("plyr");s=function(a){l=table(strsplit(a,s="")[[1]]);l=ldply(l[order(-l,names(l))],function(n)data.frame(seq_len(n)/n));paste(l[order(l[[2]]),1],collapse="")}
</code></pre>

<p>ungolfed version</p>

<pre><code>library("plyr")
s &lt;- function(a) {
    tbl &lt;- table(strsplit(a, split = "")[[1]])
    tbl &lt;- tbl[order(-tbl, names(tbl))]
    tbl &lt;- ldply(tbl, function(n) {data.frame(seq_len(n)/n)})
    paste(tbl[order(tbl[[2]]),1], collapse = "")
}
</code></pre>

<p>Explanation:</p>

<ul>
<li>Split into individual characters</li>
<li>Tabulate number of each character</li>
<li>Sort table into most frequent and then by lexical order</li>
<li>Index positions for selection at 1/n, 2/n, 3/n, ... n-1/n, 1 where n is the number of candies</li>
<li>Sort candy names by index (<code>order</code> is stable in sorting, so will maintain the most frequent/lexical naming order when a tie in the index, particularly important with the last candies)</li>
<li>Concatenate the candy names together to make the output string</li>
</ul>

<hr>

<p>The matrix nature of the problem made me think R might have a shot at this, but the best literal interpretation of the algorithm I could do was 211 characters:</p>

<pre><code>l=function(a){l=table(strsplit(a,s="")[[1]]);l=l[order(-l,names(l))];o=Reduce(`*`,l);m=matrix("",nc=o,nr=length(l));for(r in seq_along(l)){x=l[r];for(c in seq_len(x)*o/x){m[r,c]&lt;-names(x)}};paste(m,collapse="")}
</code></pre>

<p>ungolfed:</p>

<pre><code>l &lt;- function(a) {
    tbl &lt;- table(strsplit(a, split = "")[[1]])
    tbl &lt;- tbl[order(-tbl, names(tbl))]
    o &lt;- Reduce(`*`, tbl)
    m &lt;- matrix("", ncol = o, nrow = length(tbl))
    for (r in seq_along(tbl)) {
        for (c in seq_len(tbl[r])*o/tbl[r]) {
            m[r,c] &lt;- names(tbl[r])
        }
    }
    paste(m, collapse="")
}
</code></pre>
</div>
<div id="pu6" class="pu"><p><strong>APL: 38</strong></p>

<pre><code>v⌷⍨⊂⍋⌽(n/-n),⍪∊+\¨n⍴¨÷n←{≢⍵}⌸v←{⍵[⍋⍵]}
</code></pre>

<p><strong>Explanation:</strong></p>

<pre><code>v←{⍵[⍋⍵]}    orders input string
n←{≢⍵}⌸v     counts how many times each element appears in v
∊+\¨n⍴¨÷n     makes incremental sums in each letter "group" 
⍋⌽(n/-n),⍪   appends number of elements in letter group and orders the obtained matrix
v⌷⍨⊂         orders vector v with computed indices
</code></pre>

<p>Can be tested on tryapl.org </p>
</div>
<div id="pu7" class="pu"><h1>Perl 5 - 62</h1>

<p>61 code + 1 flag.</p>

<pre><code>#!perl -n
print map/(.$)/,sort map/(.$)/*$_/$$1.~$_.$1,map++$$_.$_,/./g
</code></pre>

<p>First split the input into character array - <code>/./g</code>.</p>

<p>Add occurrence index to each letter leaving the counts in variables <code>$a</code>..<code>$z</code> with <code>map++$$_.$_</code>. Now the array is:</p>

<pre><code>1o
1r
2o
1y
1b
1g
2r
2b
3b
2y
3r
3o
4r
3y
1p
4o
2p
5r
6r
</code></pre>

<p>Then convert it to a sort key concatenating: ratio <code>$_/$$1</code>, count tie breaker <code>~$_</code> and ASCII value tie breaker <code>$_</code>. This will result in (here with added spaces for clarity).</p>

<pre><code>0.25 18446744073709551614 o
0.166666666666667 18446744073709551614 r
0.5 18446744073709551613 o
0.333333333333333 18446744073709551614 y
0.333333333333333 18446744073709551614 b
1 18446744073709551614 g
0.333333333333333 18446744073709551613 r
0.666666666666667 18446744073709551613 b
1 18446744073709551612 b
0.666666666666667 18446744073709551613 y
0.5 18446744073709551612 r
0.75 18446744073709551612 o
0.666666666666667 18446744073709551611 r
1 18446744073709551612 y
0.5 18446744073709551614 p
1 18446744073709551611 o
1 18446744073709551613 p
0.833333333333333 18446744073709551610 r
1 18446744073709551609 r
</code></pre>

<p>This can be sorted with lexicographical (default) order. In the end extract last character and print: <code>print map/(.$)/</code></p>
</div>
<div id="pu8" class="pu"><h2><a href="https://github.com/isaacg1/pyth" rel="nofollow noreferrer">Pyth</a> 45 <s>47 48 51</s></h2>
<p>This could also almost certainly be golfed further ;)</p>
<pre><code>Ko_/zNS{zFGK~Y]*+*t/u*GHm/zdK1/zG]k]G/zG)ssCY
</code></pre>
<p>Works by building a list of lists, where each inner list is a row of empty strings and the name of the candy. This list is transposed and then the inner lists are joined followed by these lists being joined.</p>
<p>Thanks @isaacg for reminding me about sum!</p>
</div>
<div id="pu9" class="pu"><h2>Mathematica, <s>123</s> <s>119</s> 118 bytes</h2>

<pre><code>f=FromCharacterCode[s=SortBy;#&amp;@@@s[Join@@(s[Tally@ToCharacterCode@#,-Last@#&amp;]/.{x_,n_}:&gt;({x,#/n}&amp;~Array~n)),{Last}]]&amp;
</code></pre>

<p>Defines a named function <code>f</code>. Ungolfed:</p>

<pre><code>f = FromCharacterCode[
   s = SortBy;
   # &amp; @@@ s[
     Join @@ (
       s[
         Tally@ToCharacterCode@#,
         -Last@# &amp;
         ] /. {x_, n_} :&gt; ({x, #/n} &amp;~Array~n)
       ),
     {Last}
     ]
   ] &amp;
</code></pre>

<p>Using built-in rational types seemed like a good idea for this. Of course, this is nowhere near CJam. Basically, I'm representing the grid shown in the challenge as a list of pairs. The first thing in the pair is the character code, the second is it's position as a fraction less than or equal to 1 (the final column being 1). Having made sure that the individual characters are already in the right order, I just need to sort this stably by said fraction to get the desired result.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/40913/">40913</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




