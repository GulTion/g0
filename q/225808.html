<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::225808</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>213</td><td>Ruby 3+</td><td>240709T060038Z</td><td><a href="https://codegolf.stackexchange.com/questions/225808/interpret-underload/274036#274036">Aearnus</a></td></tr>
<tr d-ix="1"><td>001</td><td>Underload</td><td>210715T151917Z</td><td><a href="https://codegolf.stackexchange.com/questions/225808/interpret-underload/231423#231423">Helen</a></td></tr>
<tr d-ix="2"><td>080</td><td>CJam</td><td>210715T164405Z</td><td><a href="https://codegolf.stackexchange.com/questions/225808/interpret-underload/231428#231428">Helen</a></td></tr>
<tr d-ix="3"><td>087</td><td>Charcoal</td><td>210518T102451Z</td><td><a href="https://codegolf.stackexchange.com/questions/225808/interpret-underload/225895#225895">Neil</a></td></tr>
<tr d-ix="4"><td>189</td><td>JavaScript V8</td><td>210518T054331Z</td><td><a href="https://codegolf.stackexchange.com/questions/225808/interpret-underload/225881#225881">tsh</a></td></tr>
<tr d-ix="5"><td>221</td><td>JavaScript Node.js</td><td>210517T174227Z</td><td><a href="https://codegolf.stackexchange.com/questions/225808/interpret-underload/225836#225836">Arnauld</a></td></tr>
<tr d-ix="6"><td>072</td><td>Stax</td><td>210517T170123Z</td><td><a href="https://codegolf.stackexchange.com/questions/225808/interpret-underload/225830#225830">Razetime</a></td></tr>
<tr d-ix="7"><td>322</td><td>Haskell</td><td>210517T181526Z</td><td><a href="https://codegolf.stackexchange.com/questions/225808/interpret-underload/225838#225838">NoLonger</a></td></tr>
<tr d-ix="8"><td>093</td><td>Jelly</td><td>210517T230046Z</td><td><a href="https://codegolf.stackexchange.com/questions/225808/interpret-underload/225853#225853">Nick Ken</a></td></tr>
<tr d-ix="9"><td>238</td><td>Python 3</td><td>210517T154938Z</td><td><a href="https://codegolf.stackexchange.com/questions/225808/interpret-underload/225821#225821">ovs</a></td></tr>
<tr d-ix="10"><td>252</td><td>Haskell</td><td>210517T205545Z</td><td><a href="https://codegolf.stackexchange.com/questions/225808/interpret-underload/225844#225844">Delfad0r</a></td></tr>
<tr d-ix="11"><td>157</td><td>Retina</td><td>210517T211554Z</td><td><a href="https://codegolf.stackexchange.com/questions/225808/interpret-underload/225846#225846">Neil</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://www.ruby-lang.org/" rel="nofollow noreferrer">Ruby 3+</a>, 213 bytes</h1>
<pre class="lang-rb prettyprint-override"><code>$s=[]
def g(i)=i==&quot;&quot;?0:(s=$s;i=~/^(\(((\g&lt;1&gt;|[^()])*)\))/?(s&lt;&lt;$2;g $'):('gqVas&lt;&lt;&quot;(#{q})&quot;V~a,b=q,q;s&lt;&lt;a;s&lt;&lt;bV:s&lt;&lt;s[-1]V!qV%a,b=q,q;s&lt;&lt;b+aVSprintqV'=~/#{i[0].tr'*','%'}([^V]+)/;eval($1.gsub'q','(s.pop)');g i[1..]))
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=TZBBasMwEEXp1qeIHQfNKI4dd1VkqzlEQBvHApkmRlBay7ILJY0u0k0W7aV6mso4hc7iD_PfwAz_86sfm_fr9XscTpuHnzuILa_q4Ol4WrSgkWvOo2i3ZWB5bAvNXSbhAACHtswfPyoJWCPFA2K2A1uW8X3RLmKCDEhrhPJOBMuzuWAknEoabhJTeFNN0gjm1VabvBahEat_vFkrse96_TIYQfzN5VlX2zodekJJQlbkApUU9Rqz4vimniHO09aODTEegk271w4J-kd0ladpjRgELQE2l3-NAUgG6AAYUidROSrD0BsS0dGpSw-lgglSNVsz98O0K_dkDuyW219-vw" rel="nofollow noreferrer">Attempt This Online!</a></p>
<p>Pass Underload code into the <code>g</code> function.</p>
<p>Note that this uses the new <code>def</code> syntax from Ruby 3 so it won't parse on previous versions.</p>
<p>Does a few regex tricks, like matching paren blocks in one pass or saving a few bytes by not escaping the start anchor before it's interpolated into the instruction decoding regex. This entry encodes the Undercode instruction names and does instruction lookup in a similar way to <a href="https://codegolf.stackexchange.com/a/225881/19339">this entry</a>.</p>
</div>
<div id="pu1" class="pu"><h1 id="underload-1-byte-zsd1"><a href="https://esolangs.org/wiki/Underload" rel="nofollow noreferrer">Underload</a>, 1 byte</h1>
<pre><code>^
</code></pre>
<p><b><a href="https://tio.run/##K81LSS3KyU9M@a/xXyNRwypOUytY0yruv2bcfwA" rel="nofollow noreferrer">Try it online!</a></b></p>
<p>If we assume the input program is put on the stack as an element (<code>(PROGRAM)</code>), then all that is required is to run that program!</p>
<p><em>Note:</em> In the TIO, the header and footer wrap the &quot;Code&quot; section in parentheses, making it not run, but instead become an element at the top of the stack. Then at the end of the footer is the <code>^</code> which runs the code.</p>
<hr />
<p><i>This is only a joke/non-competing answer, since although interpreting languages in themselves isn't always trivial/boring, in this case it really is.</i></p>
</div>
<div id="pu2" class="pu"><h1 id="cjam-80-bytes-haqf"><a href="https://sourceforge.net/p/cjam/wiki/Home/" rel="nofollow noreferrer">CJam</a>, 80 bytes</h1>
<pre><code>{`(;);EDero}:S{[\\]`(;);&quot;} {&quot;/~+~}:B{a`&quot;[]&quot;Eer~}:Cq&quot;()~:!*^a&quot;:D&quot;{}\_;B~C&quot;:Eer~];
</code></pre>
<p><b><a href="http://cjam.aditsu.net/#code=%7B%60(%3B)%3BEDero%7D%3AS%7B%5B%5C%5C%5D%60(%3B)%3B%22%7D%20%7B%22%2F%7E%2B%7E%7D%3AB%7Ba%60%22%5B%5D%22Eer%7D%3ACq%22()%7E%3A!*%5Ea%22%3AD%22%7B%7D%5C_%3BB%7EC%22%3AEer%7E%5D%3B&amp;input=%7BC%7B_%7E%7DBS%7D" rel="nofollow noreferrer">Try it online!</a></b></p>
<p>Could probably be a fair bit smaller ;)</p>
<hr />
<h3 id="how-it-works-gn4g">How it works</h3>
<p>The interpreter is split into two parts: first, we define helper functions; then, we convert the Underload program into a CJam program and run it.</p>
<p><b>Conversion</b></p>
<pre><code>q&quot;()~:!*^a&quot;:D&quot;{}\_;B~C&quot;:Eer
</code></pre>

<pre><code>q                                Reads in the Underload program as a string
 &quot;()~:!*^a&quot;  &quot;{}\_;B~C&quot;  er      Replaces &quot;(&quot; with &quot;{&quot;, &quot;)&quot; with &quot;}&quot;, etc
           :D          :E        We take the opportunity to define these strings as D and E,
                                 since we have to &quot;unreplace&quot; when we print
</code></pre>
<p><b>Helper functions</b></p>
<p>We call the printing function <code>S</code> so we can avoid having to replace characters when <code>S</code> comes up in the Underload program.</p>
<pre><code>{`(;);EDero}:S
</code></pre>

<pre><code>{          }:S   Define a function named S
 `               Since the elements are represented as blocks, we have to turn the block into a
                 string
  (;);           On top of that, all the blocks are surrounded by 1 too many parentheses when  we
                 turn them into strings, so we remove those
      EDer       We translate backwards into Underload by &quot;unreplacing&quot; the special characters
          o      And then print and pop the string
</code></pre>
<p>We call the concatenation function <code>B</code> (for no particular reason).</p>
<pre><code>{[\\]`(;);&quot;} {&quot;/~+~}:B
</code></pre>

<pre><code> [\\]                     Make an array with ONLY the top two elements of the stack
     `(;);                And turn it into a string (remembering to remove the square brackets
                          we got when we turned it into an array)
          &quot;} {&quot;/          The only gap between two curly brackets is between the two elements
                          that we want to merge, so we split along that gap
                ~+~       Then we merge and turn it back into a block
</code></pre>
<p>We call the array-enising function <code>C</code> (we unfortunately cannot use <code>a</code> as lowercase letters are reserved for language-defined functions)</p>
<pre><code>{a`&quot;[]&quot;Eer~}:C
 a`               Array-enise our block in CJam and turn it into a string
   &quot;[]&quot;Eer        Replace the array characters with &quot;{}&quot; (luckily the extra characters
                  in E are ignored)
          ~       Convert it from a string to a block
</code></pre>
<p><b>Running the converted program (&amp; cleanup)</b></p>
<p>It takes 1 character to run the converted program after we've made it: <code>~</code>.</p>
<p>After this we need to clean up our functions, since they are sitting on the stack and <i>will</i> be printed if we don't get rid of them. We do this by collecting everything left on the stack and popping it: <code>];</code>.</p>
</div>
<div id="pu3" class="pu"><h1><a href="https://github.com/somebody1234/Charcoal" rel="nofollow noreferrer">Charcoal</a>, 87 bytes</h1>
<pre><code>≔⪪⮌Ｓ¹θＷθ≡⊟θ~ＦＥ²⊟υ⊞υκ:⊞υ§υ±¹!≔⊟υδ*⊞υ⪫⮌Ｅ²⊟υω(⊞υ⭆⊖Ｌ⌊ΦＥθ…⮌θ⊕λ›№κ)№κ(⊟θa⊞υ⪫()⊟υ^Ｆ⪪⮌⊟υ¹⊞θκS⊟υ
</code></pre>
<p><a href="https://tio.run/##XZFNT8MwDIbv@xUmJ2cKh3Esp2kIVMTQRO@TotZro2Vpm6YrCMFfL@m6frBIkRL79RO/TpxJG@dSt@26qlRqMCq0cvhBZ7IVYWiK2kXOKpMi5wJWfpf8cdFkShNgyaFqlIszwF1e@CuH70UsKwL2ywI45BZwKwt8ENDla@4Fu7rKsBZw9JheGnjpEF270CT02R3fKZWOcOWLBuWdV1777HkCkjG5nGFec2VGEzcdCGgmIs6Kep@d@oliSycyjhJ8I5O6DLfKqFN9wmelHdkLsxSw@Yo1bTJPHh4rPT80U7m@vPhiSXZlm7w2Do8CGGc@PF2R8cvq2yxnnuWtLYacjW4G1X4Y9///u6q6j7tOvpxPPurY3rTDEffTtigx2PNlxIN9e3/Wfw" rel="nofollow noreferrer" title="Charcoal – Try It Online">Try it online!</a> Link is to verbose version of code. Explanation:</p>
<pre><code>≔⪪⮌Ｓ¹θ
</code></pre>
<p>Reverse the input and split it into characters so that it can be processed more easily.</p>
<pre><code>Ｗθ≡⊟θ
</code></pre>
<p>Loop over each character in turn.</p>
<pre><code>~ＦＥ²⊟υ⊞υκ
</code></pre>
<p>If it's a <code>~</code> then pop the top two elements from the stack and push them again, swapping them.</p>
<pre><code>:⊞υ§υ±¹
</code></pre>
<p>If it's a <code>:</code> then duplicate the top element of the stack.</p>
<pre><code>!≔⊟υδ
</code></pre>
<p>If it's a <code>!</code> then discard the top element of the stack.</p>
<pre><code>*⊞υ⪫⮌Ｅ²⊟υω
</code></pre>
<p>If it's a <code>*</code> then concatenate the top two elements of the stack. (Annoyingly the elements pop in the wrong order.)</p>
<pre><code>(⊞υ⭆⊖Ｌ⌊ΦＥθ…⮌θ⊕λ›№κ)№κ(⊟θ
</code></pre>
<p>If it's a <code>(</code> then find the shortest unbalanced prefix and push the characters up to the unbalanced <code>)</code> to the stack. (The <code>)</code> doesn't get removed but unrecognised characters get ignored anyway.)</p>
<pre><code>a⊞υ⪫()⊟υ
</code></pre>
<p>If it's an <code>a</code> then wrap the top of the stack in <code>()</code>s.</p>
<pre><code>^Ｆ⪪⮌⊟υ¹⊞θκ
</code></pre>
<p>If it's a <code>^</code> then push the top of the stack to the input.</p>
<pre><code>S⊟υ
</code></pre>
<p>If it's a <code>S</code> then pop and print the top of the stack.</p>
</div>
<div id="pu4" class="pu"><h1><a href="https://v8.dev/" rel="nofollow noreferrer">JavaScript (V8)</a>, 189 bytes</h1>

<pre class="lang-javascript prettyprint-override"><code>f=([C,...P],X=T=L='',Y,...S)=&gt;C?eval(`f(P,${L*(L-=C=='('?-1:C==')')?'X+C,Y':`
^P.unshift(...X)&amp;&amp;Y
~Y,X
:X,X,Y
!Y
*Y+X
a'('+X+')',Y
S(T+=X,Y)
('',X,Y
)X,Y`.match(`
[${C}](.*)`)[1]},...S)`):T
</code></pre>
<p><a href="https://tio.run/##bY49b4MwEIZ3/4qSUnwHBilb5cqlEksHBiQYbCGQnTQoVDSJCKVDlPx16rRDpZLldHrej7t3M5rjum8PQzg@TlMjoExYFEVZxaQoRCooZeoKchTPSbwZTQe6gYy5p9SHNBSJEBRoHC75dUOKMZVBwhTlmtRZ9Lk7bttmANsg0fMUuSgmCZdMMkUcRXwVSGJsQyADm7YwhyIQVkUC9vbVhnbo6MMM6y1oUrqn5FxB5KPGclmdf5/TyIvp0Le7ARpYwOum6/bs7mvfd28O5gvEJ/KnOi/37kPt@YAzySCs8JLfxM5N6s@p@Y9WaGk9MwKvbRx5/SNM3w" rel="nofollow noreferrer" title="JavaScript (V8) – Try It Online">Try it online!</a></p>
<pre class="lang-javascript prettyprint-override"><code>f=(
[C,...P], // C = Current command; P = Following program
X= // X, Y = Top 2 of stack; S = Remaining stack
T= // Output
L='', // Current brackets level
Y,...S
)=&gt;C? // Is program not finished?
// Recursive call fol following command
eval(`f(P,${
L*(L-=C=='('?-1:C==')')? // If currently we are in brackets
'X+C,Y': // We append this character to the top element of stack
// Otherwise, based on different command (1st letter each line)
// we execute different codes here
// And the the result is whatever placed on top of stack
`
^P.unshift(...X)&amp;&amp;Y
~Y,X
:X,X,Y
!Y
*Y+X
a'('+X+')',Y
S(T+=X,Y)
('',X,Y
)X,Y`.match(
// We use thi regex to get codes we need execute
`
[${C}](.*)`)[1]
},...S)` // Remaining stack
):T // Everything done, output goes here
</code></pre>
</div>
<div id="pu5" class="pu"><h1><a href="https://nodejs.org" rel="nofollow noreferrer">JavaScript (Node.js)</a>, <s> 237 </s> 221 bytes</h1>
<p><em>Saved 8 bytes thanks to @tsh</em></p>

<pre class="lang-javascript prettyprint-override"><code>f=([c,...s],S=p=[O=o=''])=&gt;c?((n=Buffer(c)[0],n-40?n-41?p:--p||!S.push(o):p++)?o+=c:eval(&quot;o=''0(q=1,1)+q)0q=1,q)/1/s=[...1,...s]/01,1)0`(${1})`)/O+=1&quot;.replace(/\d/g,n=&gt;+n?'S.pop()':'/S.push(').split`/`[n%15%11]),f(s,S)):O
</code></pre>
<p><a href="https://tio.run/##bY3BboJAFEX3/QqgWt6TgWGSdkMy0nTVnQuWFAIiWJsJM4LaRW1/nY7aYhQ3k8l55977ke/ytmhWauPWclF2XcUhLojneW1CIq54POOS23aCfFqEADV/2VZV2UCBsZ@Q2n30Q/2wUAWuq/Z7M/LUtn0HiYFyHAylw4ug3OUCrEOND2vOCENnjf7ht0bKaMtjvcdOo9Q/3P0MRl/sGzOkM4czy2tKJfKiBPq2oEtS86lTh7bekgrQDmz6N2uj1yqx2mQ0i@sxexozliCpoCURYjDrClm3UpSekEuowILXUghJjE/ZiIWJkYVoUGpc0LvrjPl8PxqnDxNAHTAM45Q500EgR5jjT3SUjT6Qz2@LZu/9i7e9ycC7VZifrV7UeGDOUdP0ulLjYScEqR7HILUuOnvc/QI" rel="nofollow noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a></p>
<h3>Commented</h3>
<p>For readability, let's assign the list of commands to an explicit variable <code>cmd</code>:</p>
<pre class="lang-javascript prettyprint-override"><code>cmd =
  &quot;o=''0(q=1,1)+q)0q=1,q)/1/s=[...1,...s]/01,1)0`(${1})`)/O+=1&quot;
  .replace(/\d/g, n =&gt; +n ? 'S.pop()' : '/S.push(')
  .split`/`
</code></pre>
<p>This expands to:</p>
<pre class="lang-javascript prettyprint-override"><code>[
  &quot;o=''&quot;,                          // non-nested closing parenthesis
  'S.push((q=S.pop(),S.pop())+q)', // '*' (concatenate)
  'S.push(q=S.pop(),q)',           // ':' (duplicate)
  'S.pop()',                       // '!' (drop)
  's=[...S.pop(),...s]',           // '^' (append to the program)
  '',                              // not used
  'S.push(S.pop(),S.pop())',       // '~' (swap)
  'S.push(`(${S.pop()})`)',        // 'a' (enclose)
  'O+=S.pop()'                     // 'S' (print)
]
</code></pre>
<p>The main code now reads as:</p>
<pre class="lang-javascript prettyprint-override"><code>f = (                      // f is a recursive function taking:
  [ c,                     //   c   = next character
       ...s ],             //   s[] = array of remaining characters
  S =                      //   S[] = stack
  p = [                    //   p   = counter of opened parentheses
    O =                    //   O   = output string
    o = ''                 //   o   = current string
  ]                        //
) =&gt;                       //
  c ?                      // if c is defined:
    (                      //
      (                    //   parentheses processing:
        n = Buffer(c)[0],  //     n = ASCII code of c
        n - 40 ?           //     if c is not an opening parenthesis:
          n - 41 ?         //       if c is not a closing parenthesis:
            p              //         yield p
          :                //       else:
            --p ||         //         pre-decrement p
           !S.push(o)      //         push o to the stack if p = 0
        :                  //     else:
          p++              //       post-increment p
      )                    //   end of parentheses processing
      ?                    //   if the above is truthy (i.e. we are
                           //   currently within a string definition):
        o += c             //     append c to o
      :                    //   else:
        eval(              //     evaluate the command which is indexed
          cmd[n % 15 % 11] //     by (n mod 15) mod 11
        ),                 //
      f(s, S)              //   recursive call to f
    )                      //
  :                        // else:
    O                      //   we're done: return the final output
</code></pre>
</div>
<div id="pu6" class="pu"><h1><a href="https://github.com/tomtheisen/stax" rel="nofollow noreferrer">Stax</a>, <sup><s>88</s></sup> 72 <a href="https://github.com/tomtheisen/stax/blob/master/docs/packed.md#packed-stax" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>ï9╓╩¢▬'D└⌡○♠↨ó•ó♀▒m5E■V\╖O|é░xÄ9ª╝╬K╝╝∩1◄3`-2*♫▓☼╤?÷°ZôyZ┘¿{ClñI▀«╛■ß«R9
</code></pre>
<p><a href="https://staxlang.xyz/#p=8b39d6ca9b162744c0f5090617a207a20cb16d3545fe565cb74f7c82b0788e39a6bcce4bbcbcef311133602d322a0eb20fd13ff6f85a93795ad9a87b436ca449dfaebefee1ae5239&amp;i=%28Hello,+world%21%29S%0A%28%21%40%23%24%25%5E%26*%28%29%29S%0A%28a%29%28b%29%7ESS%0A%28a%29%28b%29%21S%0A%28a%29%28b%29*S%0A%28a%29aS%0A%28b%29%28a%29%5ES%0A%28a%28%3A%5E%29*S%29%3A%5E%0A%28%3AaSS%29%3AaSS%0A%28%3AaS%28%3A%5ES%5E%3A%29Sa%3A%29%3A%5ES%5E%3A%28%3AaS%28%3A%5ES%5E%3A%29Sa%3A%29%0A%28%3A%3A%3A%3A%29%3A%28%3A%28%28%5E%3A%28%29%7E%28%28%3A%29*%7E%5E%29a%7E*%5E%21%21%28%29%7E%5E%29%29%7E*%28%29%7E%5E%5E%29%7E%28%5Ea%28*%7E%5E%29*a%7E*%28%29%7E%5E%21%28%29%7E%5E%29a%7E**%5E%21%21%5ES&amp;m=2" rel="nofollow noreferrer">Run and debug it</a></p>
<p>I thought this would be simple with a stack based language. I was wrong.</p>
<p>Fixed a bug which caused <code>()</code> to immediately halt the program.</p>
<h2>Explanation</h2>
<pre><code>w # while top of stack isn't empty:
 yB # remove first char of program
 sY # store rest of program in register Y 
 sc40= # is first char a '('?
 { # if true:
  d1y # delete char, push 1 and program 
  { # take chars while the following returns true
   c.()# # is current char in &quot;()&quot;? 
   {]&quot;(^)v&quot;|tl} #if so, if (, increment the 1 otherwise decrement
   {d}? # otherwise delete the char
   c copy the 1
  }h
  sdc%^Na)Yd # remove length + 1 chars from the program, store in Y 
 }
 { # otherwise, execute stack command:
  sd] # delete copy of input
  &quot;~s:c!d*+Sp^&quot;&quot;y+Yd&quot;97.:{3l+ # underload to stax translation array
  :t # translate the current char to stax
  l  # execute
 }?
 y # push y at the end(if empty, ends the program)
</code></pre>
</div>
<div id="pu7" class="pu"><h1>Haskell, 322 bytes</h1>
<p>Function is <code>l []</code>.</p>
<pre><code>l(s:t:v)('~':x)=l(t:s:v)x
l(s:t)(':':x)=l(s:s:t)x
l(_:s)('!':x)=l s x
l(s:t:v)('*':x)=l((s++t):v)x
l(s:t)('a':x)=l(('(':s++&quot;)&quot;):t)x
l(s:t)('^':x)=l t(s++x)
l(s:t)('S':x)=s++l t x
l t('(':x)=h t 0&quot;&quot;x
h t 0a(')':x)=l(reverse a:t)x
h t n a(')':x)=h t(n-1)(')':a)x
h t n a('(':x)=h t(n+1)('(':a)x
h t n a(c:x)=h t n(c:a)x
</code></pre>
</div>
<div id="pu8" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="nofollow noreferrer">Jelly</a>, 93 bytes</h1>
<pre><code>“Ṫ,Ṫ;@“0ịṭ“Ṗ“Ṫ;@Ṫṭ“Ṫ⁾()jṭ“ṪȮṛ”W€“~:!*aS”żẎy
Żi@þØ(Ä_/Ṣ⁼Ø.ƊƝœp;1ÇṾ;”ṭWƊƭ€ṖẎ
ṪÇß}v⁼”^$?@ƒ
WÇṛ“”
</code></pre>
<p><a href="https://tio.run/##y0rNyan8//9Rw5yHO1fpALG1A5Bt8HB398Oda8Gi0yBy1g5AAia26lHjPg3NLDj3xLqHO2c/apgb/qhpDVCkzkpRKzEYyD@65@Guvkquo7szHQ7vOzxD43BLvP7DnYseNe45PEPvWNexuUcnF1gbHm5/uHOfNVA50LxwoOhaoClAe4FauYBmH24/PL@2DKgFqCBOxd7h2CSucJAOoH1zgEL/gRrnKOjaKQDZYGccbgcZdWgb1E0gNZr//0craXgAvZqvo1CeX5SToqgZrKTDpaSh6KCsohqnpqWhCRVI1NRI0qwLRuIoIrG1YOxECCNJE8iOgwpqWMUBFWhaxSnFAgA" rel="nofollow noreferrer" title="Jelly – Try It Online">Try it online!</a></p>
<p>This feels far too long!</p>
<p>A full program taking an Underload program as it’s argument and printing the output to STDOUT. In principle, translates the program to a series of Jelly chains and executes them, with special handling for the <code>^</code> command.</p>
</div>
<div id="pu9" class="pu"><h1><a href="https://docs.python.org/3/" rel="nofollow noreferrer">Python 3</a>, <s>243</s> <s>242</s> 238 bytes</h1>

<pre class="lang-python prettyprint-override"><code>s=input()
q=[]
P=q.pop
d=w=i=0
while s[i:]:
 c=ord(s[i]);i+=1
 if 40==c:d+=1;w=[i,w][d&gt;1]
 elif d:x=41==c;d-=x;q+=[s[w:i-1]][d:]*x
 else:y=P();exec(&quot;q+=y,y q+='(%s)'%y, q+=P()+y, print(end=y) y s=s[:i]+y+s[i:] q+=y,P()&quot;.split()[c%20%9%7])
</code></pre>
<p><a href="https://tio.run/##NZBBb4MwDIXv@RVpN0ZSaFW2StOCPO3SabdV6m5RkFqSqdEQ0EAFueyvM0PXi/1e/FnyS@3bU1U@DXmlDQUahuHQgC3rS8s4OYNUZAfnVV3VREMHFtakO9nC0EZaoQShOVROM3SKpzaChFD7TTdrgFxotGkH0sadkvo1UYSaAqda9LBJkEj1Evr0HIFsZCfsMlHICbXoR7AxwsOO8dT0JmdzpHzsKbaQBQ0PAx@PBoEIVe1s2TJTavCcetpAI4VVkY@mM@m0jOh81dSFxWQyDx7XwUvwrPhw3eUEo5P/cF/uYjAbbZ0fG6XTDeMXcTKa3NQt3X6@b52r3JU4OnP4GdiHKYoqpl3lCj3je8Jmb3f3QfawYHx0B86O/Hd/U7ObWEzigPXIUWSjZSLDdy6yPw" rel="nofollow noreferrer" title="Python 3 – Try It Online">Try it online!</a></p>
<p><strong>Pseudo Code:</strong></p>
<pre class="lang-python prettyprint-override"><code>read program from STDIN into s
initialize 
  empty stack q
  parenthesis nesting level d
  string start index w
  instruction pointer i

while the program has instructions left:
  get current instruction; increment instruction pointer

  if current instruction c is '(':
    increment parenthesis nesting level d
    update string start index if new nesting level is 1

  elif we are in a string:
    if the current command is ')':
      decrement nesting level d
      push string to stack if we reached level 0

  otherwise
    execute the code for the current command
</code></pre>
</div>
<div id="pu10" class="pu"><h1><a href="https://www.haskell.org/" rel="nofollow noreferrer">Haskell</a>, <sup><s>272</s>…</sup> 252 bytes</h1>

<pre class="lang-hs prettyprint-override"><code>([]?)
s?('(':r)|l&lt;-1%r=(take(l-1)r:s)?drop l r
(x:s)?('^':r)=s?(x++r)
(x:s)?('S':r)=x++s?r
s?(c:r)=s!c?r
s?e=e
(x:y:s)!'~'=y:x:s
(x:s)!':'=x:x:s
(_:s)!'!'=s
(x:y:s)!'*'=(y++x):s
(x:s)!'a'=('(':x++&quot;)&quot;):s
0%r=0
n%(c:r)=1+(n+sum[1|c=='(']-sum[1|c==')'])%r
</code></pre>
<p><a href="https://tio.run/##RZDBboMwEETvfAVOS72LSxWuqIYee8iNYwqVQyCN4gCyiQpSlE8vtUEJF2veeMa78o/Qp1LKseJfI2yzBB2dAAUaKbzK9yD0FIdOnEqQQYgq0pjsVdO60lUO9BaB5jbMTa1nTOHDTifbeDpR9tFiSpFiopKXNjiYKKE3yofItOYqoRHl/czfExPK9ZL2KYeBsR6XgjCW3dkMW@HKXqzN3mun9uapIYOa6ct5G14Lzk0yCxZCmqGnxrM41vxQdptjXcYxby9d2qlN/VbFsb0a4dN8U/Pq/jZK7gmmDpCPp2cvf/EBLQmEHd7SuyJ34U9CmHOHRuQWIcqNj1H@V1RSHPQYFG37Dw" rel="nofollow noreferrer" title="Haskell – Try It Online">Try it online!</a></p>
<p>The relevant function is <code>([]?)</code>, which takes an Underload program as a <code>String</code> as input and returns a <code>String</code> as output.</p>
<p>There is already an interesting Haskell answer, make sure to go upvote that as well (once it's fixed)! <s>I decided to post my own answer because, well, I finally found a use for the <code>Monad</code> instance of <code>(,) a</code>!</s> Yeah, I knew it couldn't last...</p>
</div>
<div id="pu11" class="pu"><h1><a href="https://github.com/m-ender/retina/wiki/The-Language" rel="noreferrer">Retina</a>, 157 bytes</h1>
<pre><code>.{/^S/&amp;*&gt;,G1`
^((\^)|[S!])(.*)¶(.*)|^:(.*(¶.*))
$#2*$4$3$5$6
^((~)|\*)(.*)¶(.*)(¶.*)
$3$5$#2*¶$4
^\((((\()|(?&lt;-3&gt;\))|[^()¶])*)\)(.*)
$4¶$1
^a(.*¶)(.*)
$1($2)
</code></pre>
<p><a href="https://tio.run/##TY09CsJAEIX7PYUho8xb/CEaLYKoXQTLlK5DIqYQgoIIFgaPlQPkYnESFdxi9nvD95hbfj9fsqDpc5w24@dEksnAroZxkBphdoJyn3gH8NiirtpZSqQf15UyDPlTSyHNaE6LtvBC6eyf/fFMJ6haVxQacazPMUpeL0ezlYMeEdbGARauaxsK1Q2MZJrq6rsLmKZoEKfG7dKGt3lRXIe9x/VWnDwkhr2NT30ZWEabMvARr@RH3g9sB5nOIxSkjRyJ7hHJGw" rel="noreferrer" title="Retina – Try It Online">Try it online!</a> Link includes test suite. Explanation:</p>
<pre><code>.
</code></pre>
<p>Don't output the stack at the end of the program.</p>
<pre><code>{
</code></pre>
<p>Repeat until the program has been processed (assuming no invalid instructions).</p>
<pre><code>/^S/&amp;*&gt;,G1`
</code></pre>
<p>If the next instruction is <code>S</code> then print the top of the stack (this does not pop the stack yet).</p>
<pre><code>^((\^)|[S!])(.*)¶(.*)|^:(.*(¶.*))
$#2*$4$3$5$6
</code></pre>
<p>If the next instruction is <code>S</code> or <code>!</code> then discard the top of the stack, but if it is <code>\^</code> then prepend it to the remainder of the program, while if it is <code>:</code> then duplicate the top of the stack.</p>
<pre><code>^((~)|\*)(.*)¶(.*)(¶.*)
$3$5$#2*¶$4
</code></pre>
<p>If the next instruction is <code>~</code> then swap the two elements of the stack otherwise if it is <code>*</code> then join then together (this needs the elements to be swapped first, so the functions are combined here.)</p>
<pre><code>^\((((\()|(?&lt;-3&gt;\))|[^()¶])*)\)(.*)
$4¶$1
</code></pre>
<p>If the next instruction is a <code>(</code> then push a (presumably) balanced string until the matching <code>)</code>. (If there aren't any <code>)</code>s then the interpreter will give up while if there aren't enough <code>)</code>s then the interpreter will match until the last one.)</p>
<pre><code>^a(.*¶)(.*)
$1($2)
</code></pre>
<p>If the next instruction is an <code>a</code> then wrap the top of the stack in <code>(</code> and <code>)</code>.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/225808/">225808</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




