<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::58189</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>128</td><td>Mathematica</td><td>170111T012021Z</td><td><a href="https://codegolf.stackexchange.com/questions/58189/truth-tables-your-great-grandfathers-computer/106427#106427">user6198</a></td></tr>
<tr d-ix="1"><td>048</td><td>Dyalog APL</td><td>160531T055505Z</td><td><a href="https://codegolf.stackexchange.com/questions/58189/truth-tables-your-great-grandfathers-computer/80981#80981">Ad&#225;</a></td></tr>
<tr d-ix="2"><td>302</td><td>C/C++ 302 Bytes</td><td>170111T002505Z</td><td><a href="https://codegolf.stackexchange.com/questions/58189/truth-tables-your-great-grandfathers-computer/106419#106419">user6428</a></td></tr>
<tr d-ix="3"><td>119</td><td>Python3</td><td>160531T005030Z</td><td><a href="https://codegolf.stackexchange.com/questions/58189/truth-tables-your-great-grandfathers-computer/80970#80970">Karl Nap</a></td></tr>
<tr d-ix="4"><td>129</td><td>Mathematica</td><td>160531T131431Z</td><td><a href="https://codegolf.stackexchange.com/questions/58189/truth-tables-your-great-grandfathers-computer/80994#80994">Xanderha</a></td></tr>
<tr d-ix="5"><td>2347</td><td>MediaWiki template</td><td>160530T103146Z</td><td><a href="https://codegolf.stackexchange.com/questions/58189/truth-tables-your-great-grandfathers-computer/80946#80946">leo</a></td></tr>
<tr d-ix="6"><td>288</td><td>Python</td><td>150922T113508Z</td><td><a href="https://codegolf.stackexchange.com/questions/58189/truth-tables-your-great-grandfathers-computer/58461#58461">SjoerdPe</a></td></tr>
<tr d-ix="7"><td>141</td><td>JavaScript ES6</td><td>150918T091449Z</td><td><a href="https://codegolf.stackexchange.com/questions/58189/truth-tables-your-great-grandfathers-computer/58210#58210">edc65</a></td></tr>
<tr d-ix="8"><td>161</td><td>Julia</td><td>150918T033208Z</td><td><a href="https://codegolf.stackexchange.com/questions/58189/truth-tables-your-great-grandfathers-computer/58196#58196">Alex A.</a></td></tr>
</table>
<div id="pu0" class="pu"><h2>Mathematica, 128 characters</h2>
<pre><code>TraditionalForm@Grid[({#}~Join~BooleanTable[#,Cases[b,_Symbol,{0,∞}]]&amp;/@Cases[b=ToExpression@#,_,{0,∞}]/.{0&lt;1-&gt;&quot;T&quot;,0&gt;1-&gt;&quot;F&quot;})]&amp;
</code></pre>
<p><code></code> is the private use character <code>U+F3C7</code> representing <code>\[Transpose]</code>.</p>
<p>Luckily for us Mathematica golfers, <code>∧</code> and <code>∨</code> <em>already</em> represent <code>And</code> and <code>Or</code>, so all we have to do is convert the input string into a Mathematica expression and we can do symbolic logical operations on it.</p>
<p>Note that this solution will also handle <code>Not</code> (<a href="https://symbl.cc/en/00AC/" rel="nofollow noreferrer"><code>¬</code></a>), <code>Implies</code> (<a href="https://symbl.cc/en/F523/" rel="nofollow noreferrer"><code></code></a>), <code>Equivalent</code> (<a href="https://symbl.cc/en/29E6/" rel="nofollow noreferrer"><code>⧦</code></a>), <code>Xor</code> (<a href="https://symbl.cc/en/22BB/" rel="nofollow noreferrer"><code>⊻</code></a>), <code>Nand</code> (<a href="https://symbl.cc/en/22BC/" rel="nofollow noreferrer"><code>⊼</code></a>), <code>Xor</code> (<a href="https://symbl.cc/en/22BB/" rel="nofollow noreferrer"><code>⊻</code></a>), and <code>Nor</code> (<a href="https://symbl.cc/en/22BD/" rel="nofollow noreferrer"><code>⊽</code></a>), but it doesn't get the bonus because <code>~p</code> is a syntax error in Mathematica. Meh.</p>
<p><a href="https://i.sstatic.net/4c698.png" rel="nofollow noreferrer"><img src="https://i.sstatic.net/4c698.png" alt="enter image description here" /></a></p>
<h2>Explanation</h2>
<pre><code>b=ToExpression@#
</code></pre>
<p>Converts the input string into a Mathematica expression and stores it in <code>b</code>.</p>
<pre><code>Cases[b=ToExpression@#,_,{0,∞}]
</code></pre>
<p>This is a list every possible subexpression of the input. Each will receive its own column.</p>
<pre><code>Cases[b,_Symbol,{0,∞}]
</code></pre>
<p>This is a list of all of the variables that appear in the input.</p>
<pre><code>BooleanTable[#,Cases[b,_Symbol,{0,∞}]]&amp;
</code></pre>
<p>Pure function which takes an input expression <code>#</code> and returns a list of truth values for all possible combinations of truth values for the variables.</p>
<pre><code>{#}~Join~BooleanTable[...]
</code></pre>
<p>Prepends the expression itself to this list.</p>
<pre><code>.../@Cases[b=ToExpression@#,_,{0,∞}]
</code></pre>
<p>Applies this function to each subexpression of the input.</p>
<pre><code>.../.{0&lt;1-&gt;&quot;T&quot;,0&gt;1-&gt;&quot;F&quot;}
</code></pre>
<p>Then replace true (<code>0&lt;1</code>) with &quot;T&quot; and false (<code>0&gt;1</code>) with &quot;F&quot;.</p>
<pre><code>(...)
</code></pre>
<p>Interchange rows and columns.</p>
<pre><code>Grid[...]
</code></pre>
<p>Display the result as a <code>Grid</code>.</p>
<pre><code>TraditionalForm@Grid[...]
</code></pre>
<p>Convert the <code>Grid</code> to traditional form so that it uses the fancy symbols.</p>
</div>
<div id="pu1" class="pu"><h1><a href="http://dyalog.com/download-zone.htm" rel="nofollow noreferrer">Dyalog APL</a>, <s>58</s> 48 characters</h1>

<p>Requires <code>⎕IO←0</code>, which is default on many systems. Takes string as argument.</p>

<pre><code>{('p q ',⍵)⍪'FT '[p,q,⍪⍎⍵]\⍨324⊤⍨9⍴≢p q←↓2 2⊤⌽⍳4}
</code></pre>

<p>No bonuses, but on the plus side, any operator works.</p>

<p><code>⍳4</code>&emsp;first four indices (0 1 2 3)</p>

<p><code>⌽</code>&emsp;reverse (3 2 1 0)</p>

<p><code>2 2⊤</code>&emsp;two-bit Boolean table</p>

<p><code>↓</code>&emsp;split into two-element list of lists (high-bits, low-bits)</p>

<p><code>p q←</code>&emsp;store as <em>p</em> and <em>q</em></p>

<p><code>≢</code>&emsp;tally them (2)*</p>

<p><code>9⍴</code>&emsp;cyclically reshape that to length 9 (2 2 2 2 2 2 2 2 2)</p>

<p><code>324⊤⍨</code>&emsp;encode 324 thusly, i.e. as 12-bit binary (1 0 1 0 0 0 1 0 0)</p>

<p><code>\⍨</code>&emsp;use that to expand (insert a space for each 0)...</p>

<p><code>'FT '[</code>...<code>]</code>&emsp;the string "FT&ensp;", indexed by</p>

<p>&emsp;<code>⍎⍵</code>&emsp;the executed argument (valid since <em>p</em> and <em>q</em> now have values)</p>

<p>&emsp;<code>⍪</code> make that into a column matrix</p>

<p>&emsp;<code>q,</code>&emsp;prepend a column consisting of <em>q</em> (1 1 0 0)</p>

<p>&emsp;<code>q,</code>&emsp;prepend a column consisting of <em>p</em> (1 0 1 0)</p>

<p><code>(</code>...<code>)⍪</code>&emsp;insert a row above, consisting of</p>

<p>&emsp;<code>⍵</code>&emsp;the argument</p>

<p>&emsp;<code>'p q ',</code>&emsp;prepended with the string "p&ensp;q&ensp;"</p>

<hr>

<p>*&nbsp;Please star <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=620629" rel="nofollow noreferrer">this issue</a> if you see <code>≢</code> as <code>≢</code> and not as <code≯≡</code>.</p>
</div>
<div id="pu2" class="pu"><h2>C/C++ 302 Bytes</h2>

<p>335 characters less 10% for handling negation. Formatting incomplete but submitting before I see what the impact of completion is.</p>

<p>Marked as C/C++ because my gcc and g++ accepts it with -fpermissive and it looks far more C like than C++ to me.</p>

<pre><code>#include &lt;stdio.h&gt;
void T(char*S) { int (*P)(char*,...)=printf;char*v[2]={"F","T"};for(int m=4;m--;){P("|");char*s=S;int x=m&amp;1;X:P(" %s |",v[x]);if(*++s!=' '){x=x^1;goto X;}char*o=++s;s+=3;int y=(m&gt;&gt;1)&amp;1;Y:P(" %s |",v[y]);if(*++s){y=y^1;goto Y;}int g;for(g=o-S+1;g--;)P(" ");P(*++o==39?v[x&amp;y]:v[x|y]);for(g=s-o;g--;)P(" ");P("|\n");}}
</code></pre>

<p>I'm sure there's probably a few tweaks that could be applied. In fact handling the nots adds more than the 10% bonus removes.</p>

<p>This does assume the input format is as stated, i.e. 2 input values (p and q), with or without the not prefix and nothing else, and all tokens delimited by a single space.</p>

<p>Ungolfed:</p>

<pre><code>void ungolfed(char* S)
{
   int (*P)(char*,...) = printf;         // useful lookup stuff
   char* v[2] = {"F","T"};

   for(int m = 4; m--;) {                // loop over all 2 bit bit patterns (truth table inputs)

      P("|");                            // start of line format
      char* s=S;                         // iterator to start of equation for each bit pattern

      int x = m&amp;1;                       // input 1 (aka. p which I called x here to be awkward)
X:    P(" %s |",v[x]);                   // input 1 output and format

      if(*++s!=' ') {                    // if next character is not a space then input must be prefixed with the not character
         x=x^1;                          // so negate the input
         goto X;                         // and redo input 1 output
      }

      char* o = ++s;                     // remember where the operator is
      s+=3;                              // and skip it and following space

      int y = (m&gt;&gt;1)&amp;1;                  // input 2 (aka. q which I called y obviously) processing as for input 1
Y:    P(" %s |",v[y]);

      if(*++s) {
         y=y^1;
         goto Y;
      }

      int g;

      for(g=o-S+1;g--;) P(" ");         // pre-result value padding

      P(*++o==39?v[x&amp;y]:v[x|y]);      // result

      for(g=s-o;g--;) P(" ");           // post-result value padding and format
      P("|\n");
   }
}
</code></pre>

<p>and the tests:</p>

<pre><code>int main()
{
   T("p \x22\x27 q");  // p &amp; q
   puts("");

   T("p \x22\x28 q");  // p | q
   puts("");

   T("\x7ep \x22\x27 q");  // ~p &amp; q
   puts("");

   T("\xacp \x22\x28 q");  // ~p | q
   puts("");

   T("p \x22\x28 \xacq");  // p | ~q
   puts("");

   return 0;
}
</code></pre>
</div>
<div id="pu3" class="pu"><h2>Python3, <strike>145</strike> <strike>139</strike> <strike>120</strike> 119 Bytes</h2>

<p>No bonus (with bonus at the end)</p>

<pre><code> def f(s):
 a,m,b=s.split(" ");print(a,b,s);F,T,c=0,1,"FT"
 for p in c:
  for q in c:print(p,q," ",c[eval(p+"+*"[m=="∧"]+q)&gt;0])
</code></pre>

<p>Needing Python3 for Unicode support out of the box.</p>

<p>Based on DJgamer98 Python code, figuring out his table is not right.</p>

<p>Edit1: Splitting into distinct variables and ommiting the operator string variable</p>

<p>Edit2: (ab)using F and T as both variables and string characters</p>

<p>Edit3: Saving one space thanks to NoOneIsHere</p>

<h3>With Bonus, 215 * 0.6 = 129</h3>

<pre><code>def f(s):
 r="+---"*3+"----+"
 a,m,b=s.split(" ");F,T,c=0,1,"FT"
 print("%s\n| %s | %s | %s |\n%s"%(r,a,b,s,r));
 for p in c:
  for q in c: print("| %s | %s |   %s   |\n%s"%(p,q,c[eval(p+"+*"[m=="∧"]+q)&gt;0],r));
</code></pre>
</div>
<div id="pu4" class="pu"><h2>Mathematica, 129 Bytes</h2>

<p><strong>Golfed:</strong></p>

<pre><code>t=InputString[];s=Append[StringCases[t,LetterCharacter],t];Grid[Prepend[Map[If[#,"T","F"]&amp;,BooleanTable[ToExpression[s]],{2}],s]]
</code></pre>

<p><strong>Ungolfed:</strong></p>

<pre><code>(*Take input*)
t=InputString[];
(* Find all occurrences of letters and append the final statement.*)
s=Append[StringCases[t,LetterCharacter],t];
(* Evaluate the list as expressions and create a boolean table of True/False values, then display as a table. *)
(* To satisfy the output conditions, we must convert each True/False to T/F *)
Grid[Prepend[Map[If[#,"T","F"]&amp;,BooleanTable[ToExpression[s]],{2}],s]]
</code></pre>

<p>Not a Mathematica expert, but I found this rather elegant compared to having to do direct character comparison.</p>

<p>I had a solution that worked for negation, but it was longer than the score reduction would take off.</p>

<p>Depending on what qualifies for pretty printing, I might try for that bonus. I feel like outputting in ASCII in Mathematica would be far too expensive for the score reduction to compensate, but if the two main features are a dotted border and specified padding inside the cells, that's only a couple options in Grid.</p>

<p><strong>With pretty printing, 171 * 0.6 = 102.6 Bytes</strong></p>

<pre><code>t=InputString[];s=Append[StringCases[t,LetterCharacter],t];Grid[Prepend[Map[If[#,"T","F"]&amp;,BooleanTable[ToExpression[s]],{2}],s],Spacings-&gt;1,Frame-&gt;All,FrameStyle-&gt;Dashed]
</code></pre>
</div>
<div id="pu5" class="pu"><h1>MediaWiki template - 2347 characters</h1>
<p>MediaWiki has a built template function called <code>{{#expr}}</code> that can handle logical expressions. This must be the perfect challenge for MediaWiki templates! Features such as variables, loops and a readable syntax would have helped a bit, though. Also, the fact that there is no NOT operator for the expr function made it a bit more complex.</p>
<pre><code>{{#sub:{{#replace:{{#replace:{{{1}}}|~|}}|¬|}}|0|1}} {{#sub:{{{1}}}|{{#expr:{{#len:{{{1}}}}}-1}}|{{#len:{{{1}}}}}}} {{{1}}}&lt;br&gt;T T &amp;nbsp;{{#if:{{#pos:{{#sub:{{#replace:{{{1}}}|~|¬}}|0|1}}|¬}}|&amp;nbsp;|}} {{#replace:{{#replace:{{#expr:{{#replace:{{#replace:{{#replace:{{#replace:{{#replace:{{#replace:{{{1}}}|~|¬}}|{{#sub:{{#replace:{{#replace:{{{1}}}|~|}}|¬|}}|0|1}}|{{#if:{{#pos:{{#replace:{{{1}}}|~|¬}}|¬{{#sub:{{#replace:{{#replace:{{{1}}}|~|}}|¬|}}|0|1}}}}|0|1}}}}|{{#sub:{{{1}}}|{{#expr:{{#len:{{{1}}}}}-1}}|{{#len:{{{1}}}}}}}|{{#if:{{#pos:{{#replace:{{{1}}}|~|¬}}|¬{{#sub:{{{1}}}|{{#expr:{{#len:{{{1}}}}}-1}}|{{#len:{{{1}}}}}}}}}|0|1}}|0|1}}|¬|}}|∧|and}}|∨|or}}}}|1|T}}|0|F}}&lt;br&gt;T F &amp;nbsp;{{#if:{{#pos:{{#sub:{{#replace:{{{1}}}|~|¬}}|0|1}}|¬}}|&amp;nbsp;|}} {{#replace:{{#replace:{{#expr:{{#replace:{{#replace:{{#replace:{{#replace:{{#replace:{{#replace:{{{1}}}|~|¬}}|{{#sub:{{#replace:{{#replace:{{{1}}}|~|}}|¬|}}|0|1}}|{{#if:{{#pos:{{#replace:{{{1}}}|~|¬}}|¬{{#sub:{{#replace:{{#replace:{{{1}}}|~|}}|¬|}}|0|1}}}}|0|1}}}}|{{#sub:{{{1}}}|{{#expr:{{#len:{{{1}}}}}-1}}|{{#len:{{{1}}}}}}}|{{#if:{{#pos:{{#replace:{{{1}}}|~|¬}}|¬{{#sub:{{{1}}}|{{#expr:{{#len:{{{1}}}}}-1}}|{{#len:{{{1}}}}}}}}}|1|0}}|1|0}}|¬|}}|∧|and}}|∨|or}}}}|1|T}}|0|F}}&lt;br&gt;F T &amp;nbsp;{{#if:{{#pos:{{#sub:{{#replace:{{{1}}}|~|¬}}|0|1}}|¬}}|&amp;nbsp;|}} {{#replace:{{#replace:{{#expr:{{#replace:{{#replace:{{#replace:{{#replace:{{#replace:{{#replace:{{{1}}}|~|¬}}|{{#sub:{{#replace:{{#replace:{{{1}}}|~|}}|¬|}}|0|1}}|{{#if:{{#pos:{{#replace:{{{1}}}|~|¬}}|¬{{#sub:{{#replace:{{#replace:{{{1}}}|~|}}|¬|}}|0|1}}}}|1|0}}}}|{{#sub:{{{1}}}|{{#expr:{{#len:{{{1}}}}}-1}}|{{#len:{{{1}}}}}}}|{{#if:{{#pos:{{#replace:{{{1}}}|~|¬}}|¬{{#sub:{{{1}}}|{{#expr:{{#len:{{{1}}}}}-1}}|{{#len:{{{1}}}}}}}}}|0|1}}|0|1}}|¬|}}|∧|and}}|∨|or}}}}|1|T}}|0|F}}&lt;br&gt;F F &amp;nbsp;{{#if:{{#pos:{{#sub:{{#replace:{{{1}}}|~|¬}}|0|1}}|¬}}|&amp;nbsp;|}} {{#replace:{{#replace:{{#expr:{{#replace:{{#replace:{{#replace:{{#replace:{{#replace:{{#replace:{{{1}}}|~|¬}}|{{#sub:{{#replace:{{#replace:{{{1}}}|~|}}|¬|}}|0|1}}|{{#if:{{#pos:{{#replace:{{{1}}}|~|¬}}|¬{{#sub:{{#replace:{{#replace:{{{1}}}|~|}}|¬|}}|0|1}}}}|1|0}}}}|{{#sub:{{{1}}}|{{#expr:{{#len:{{{1}}}}}-1}}|{{#len:{{{1}}}}}}}|{{#if:{{#pos:{{#replace:{{{1}}}|~|¬}}|¬{{#sub:{{{1}}}|{{#expr:{{#len:{{{1}}}}}-1}}|{{#len:{{{1}}}}}}}}}|1|0}}|1|0}}|¬|}}|∧|and}}|∨|or}}}}|1|T}}|0|F}}
</code></pre>
<p><strong>Test:</strong></p>
<pre><code>{{TemplateName|¬X ∧ ~Y}}

{{TemplateName|p ∨ q}}
</code></pre>
<p><strong>Result:</strong></p>
<pre><code>X Y ¬X ∧ ~Y
T T    F
T F    F
F T    F
F F    T

p q p ∨ q
T T   T
T F   T
F T   T
F F   F
</code></pre>
<p>I'm assuming MediaWiki &gt;= 1.18, where the ParserFunctions extensions comes bundled with the software.</p>
</div>
<div id="pu6" class="pu"><h2>Python - 288 characters (+10 penalty cause I couldn't get unicode to work :c)</h2>

<p>No bonuses. This is my very first codegolf answer.</p>

<pre><code>def f(i):
    i=i.split(" ")
    print i[0],i[2],
    for f in i[0:3]: print f,
    print ""
    for t in["TT","TF","FT","FF"]:
        p,q=t[0],t[1]
        y = t[0]+" "+t[1]
        if i[1]=="^": r=(False,True)[p==q]
        if i[1]=="v": r=(False,True)[p!=q]
        if r: y+="   T"
        else: y+="   F"
        print y
</code></pre>

<p><code>i</code> is the input.</p>

<p><strong>EDIT:</strong> Removed a few spaces and it now uses function args as input.</p>
</div>
<div id="pu7" class="pu"><h1>JavaScript (ES6), 141</h1>

<p>Simple function, no bonus, 141 chars. (140 uft8, 1 unicode wide)</p>

<p>Complex function handling ~ or ¬, 254 chars (253 utf, 1 unicode wide), score 229</p>

<p>Could save 6 bytes using <code>alert</code> instead of <code>console.log</code>, but <code>alert</code> is particularly unfit to display tables.</p>

<p>Test running the snippet below in an EcmaScript 6 compliant browser (tested with Firefox. Won't work in Chrome as Chrome does not support <code>...</code>. Also, the bonus version use an extension of <code>split</code> that is Firefox specific).</p>

<p><div class="snippet" data-lang="js" data-hide="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>/* TEST: redirect console.log into the snippet body */ console.log=x=&gt;O.innerHTML+=x+'\n'

// Simple
F=s=&gt;{[a,o,b]=[...s],z='  ',r=a+z+b+z+a+` ${o} ${b}
`;for(w='FT',n=4;n--;r+=w[c]+z+w[e]+z+z+w[o&lt;'∧'?c|e:c&amp;e]+`
`)c=n&amp;1,e=n&gt;&gt;1;console.log(r)}

// Simple, more readable
f=s=&gt;{
   [a,o,b]=[...s]
   r=a+'  '+b+'  '+a+` ${o} ${b}\n`
   for(w='FT',n=4; n--; )
   {
     c = n&amp;1, e = n&gt;&gt;1, x=o&lt;'∧' ? c|e : c&amp;e
     r += w[c]+'  '+w[e]+'    '+w[x]+'\n'
   }
   console.log(r)
}

// 10% Bonus
B=s=&gt;{[a,o,b]=s.split(/([∧∨])/),t=a&gt;'z',u=b&gt;'z',z='  ',r=(t?a[1]+z:'')+a+z+(u?b[1]+z:'')+b+z+a+` ${o} ${b}
`;for(s=v=&gt;'FT'[v]+z,n=4;n--;r+=s(c)+(t?s(d)+' ':'')+s(e)+(u?s(f)+' ':'')+(t?'   ':z)+s(o&lt;'∧'?d|f:d&amp;f)+`
`)c=n&amp;1,d=c^t,e=n&gt;&gt;1,f=e^u;console.log(r)}

Test1 = ['q∨p','q∧p']
Test2 = Test1.concat([
  '~q∨p','q∨~p','~q∨~p','~q∧p','q∧~p','~q∧~p',
  '¬q∨p','q∨¬p','¬q∨¬p','¬q∧p','q∧¬p','¬q∧¬p'
])


console.log('SIMPLE')
Test1.forEach(t=&gt;F(t));

console.log('BONUS')
Test2.forEach(t=&gt;B(t));</code></pre>
<pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;pre id=O&gt;&lt;/pre&gt;</code></pre>
</div>
</div>
</p>
</div>
<div id="pu8" class="pu"><h1>Julia, 161 bytes</h1>



<p>No bonuses.</p>

<pre class="lang-julia prettyprint-override"><code>s-&gt;(S=split(s);P=println;p=S[1];q=S[3];a=[&amp;,|][(S[2]=="∨")+1];c="  ";P(p,c,q,c,s);for t=["TT","TF","FT","FF"] P(t[1],c,t[2],c^2,"FT"[a(t[1]&gt;'F',t[2]&gt;'F')+1])end)
</code></pre>

<p>Ungolfed:</p>

<pre class="lang-julia prettyprint-override"><code>function f(s::String)
    # Split the input on spaces
    S = split(s)

    # Separate out the pieces of the statement
    p = S[1]
    q = S[3]
    a = [&amp;, |][(S[2] == "∨") + 1]

    # Print the header
    println(p, "  ", q, "  ", s)

    # Create the table entries in a loop
    for t = ["TT", "TF", "FT", "FF"]
        println(t[1], "  ", t[2], "    ", "FT"[a(t[1] &gt; 'F', t[2] &gt; 'F') + 1])
    end
end
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/58189/">58189</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




