<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::209142</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>378</td><td>Python3</td><td>240219T171511Z</td><td><a href="https://codegolf.stackexchange.com/questions/209142/minimal-cost-path-in-wall-breaking-maze/270166#270166">Ajax1234</a></td></tr>
<tr d-ix="1"><td>178</td><td>JavaScript ES7</td><td>200806T103436Z</td><td><a href="https://codegolf.stackexchange.com/questions/209142/minimal-cost-path-in-wall-breaking-maze/209152#209152">Arnauld</a></td></tr>
<tr d-ix="2"><td>092</td><td>Charcoal</td><td>200806T222158Z</td><td><a href="https://codegolf.stackexchange.com/questions/209142/minimal-cost-path-in-wall-breaking-maze/209202#209202">Neil</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>Python3, 378 bytes</h1>
<pre class="lang-py prettyprint-override"><code>def f(b):
 Q,W=len(b),len(b[0])
 q,d=[(0,0,[(0,0)],0)],{}
 for x,y,p,c in q:
  if(x,y)==(Q-1,W-1):d[c]=p;continue
  for X,Y in[(1,0),(0,1),(-1,0),(0,-1)]:
   if 0&lt;=x+X&lt;Q and 0&lt;=y+Y&lt;W and(T:=(x+X,y+Y))not in p and(((F:='#'!=b[x+X][y+Y])and(c not in d or len(p)+1&lt;=len(d[c])))or(not d or(c+1&lt;=max(d)and(c+1 not in d or len(p)+1&lt;=len(d[c+1]))))):q+=[(*T,p+[T],c+(not F))]
 return d
</code></pre>
<p><a href="https://tio.run/##jZJLj9owEMfP60/h4kM8GxMRXlul@LrHSkhI7MqNKvJSXbFOSLISqOpnp2MnQLaHFhTGnsfv74kz1an9UZrZ56o@n7O8oAVPICJ0LbZynxt0hFvUJAZCDyKTik/ERDgLsfv/@k1oUdb0KE6iEinVhh5QguqCYwik5OtxKLbjEKJMpbGsvqSlabV5z7HIgi/iFSHFQ5QTKByiHV8cxGKrhnJ0spJH/2W1pjuTWefkv6621uGbSHJMCYwAmLK1TVQuw/lzJD3mfZKJwopYYUkMNpPSvjCj2IR9zQr8cOXe2zYKAGXNbY0t4KnNve2OPOtoP/w374dWASA6@HhpjxtR@WoTi9R3ks8AMaF13r7XKHBuQirpaDQiQcDcQ6zTTC9RjASYw7VLzK7lXXxoXMF8qPfB2ihpFjdl1GRoGe4Zu@SXgwOsKHO/4OoHXcD5N9WnIcWuGBtsgr8U2GDTQZ2YHca2/J6UuzrjDc7kQ39ZSj3q2I6Ntndf6H2b1/xraXJBm6Cp9rrl3jfj2ft1InVusrzuhTLhpBLscyBOHvr5dV9TvWn8gDh1ODA4LrH0fO9yulUOfpZY4PWrBnptJgFCqlqbln84tOC3s0IA7BNtXwj/A6YOmN4PzBwwux@YO2B@P7BwwOJ@YOmA5f3AkwPQkvMf" rel="nofollow noreferrer">Try it online!</a></p>
</div>
<div id="pu1" class="pu"><h1>JavaScript (ES7), <s> 198 185 179 </s> 178 bytes</h1>
<p>Expects a matrix of integers with <code>-1</code> for a wall and <code>0</code> for an empty cell. Returns a matrix of Boolean values.</p>

<pre class="lang-javascript prettyprint-override"><code>m=&gt;(g=(Y,w,n,X)=&gt;w&gt;=W&amp;&amp;w&gt;W|n&gt;N?0:m[Y+1]||1/m[Y][X+1]?m.map((r,y)=&gt;r.map((v,x)=&gt;v&gt;0?1:(X-x)**2+(Y-y)**2^1?0:r[r[x]=1,g(y,w-v,-~n,x),x]=v)):o=g(-1,W=w,N=n))(0,0,W=++m[0][0]/0,0)&amp;&amp;o
</code></pre>
<p><a href="https://tio.run/##XZBfb4IwFMXf@RRNmsitlAp7dCk@bY978UENYwlBZCzSuuJAM7ev7m7LdH9IuT2/23PatC95l7eFqXf7UOl1ed7IcyMTqCSseM8VXzKZ9IlcjEZ9sjip5GEWTZt0FcTZ6RRPUGXpEmHWiCbfARh@xIAZoOMHhC6JZvEUluGBjcc3AazCoxVPMe5kUpMeMhnzCo68DzsefioMcex1jE21rCCM@UL2/EEqxiDiEVIQNGmU4Zggs9FIn035@labEvxN6zNhynx9X2/L@VEVEDGx1/O9qVUFTLS7bb0H/1E9KjRutLnLi2doiUzIu0dIQyRpf0xosRdxy6kQos0cF5ZDO0niU58xdotZU6KPbKBxVGjV6m0ptroCXHE5Y3PD23RW@mLpp0GXMfGiawU@7vSt7NEkIG6@9T7YWXiesL/nBHUDFVZsWbLtQf8ug/dPtSG0U6wUNb1ErZ26T1xZDA3HQ/ai6MVK/2WuIfpLDCHxBQ" rel="nofollow noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a></p>
<h3>Commented</h3>
<p>This is a depth-first search. Visited cells are marked with <code>1</code>. We keep track of the number of broken walls in <code>w</code> and the total number of visited cells in <code>n</code>. We abort as soon as the current path is worse than the best path found so far.</p>
<pre class="lang-javascript prettyprint-override"><code>m =&gt; (                         // m[] = input matrix
  g = (                        // g is a recursive function taking:
    Y, w, n, X                 //   (X, Y) = current position
                               //   w = number of broken walls
  ) =&gt;                         //   n = number of visited cells
  w &gt;= W &amp;&amp; w &gt; W | n &gt; N ?    // if (w, n) is worse than (W, N):
    0                          //   abort
  :                            // else:
    m[Y + 1] ||                //   if there's a cell below the current cell
    1 / m[Y][X + 1] ?          //   or a cell on the right:
      m.map((r, y) =&gt;          //     for each row r[] at position y in m[]:
        r.map((v, x) =&gt;        //       for each value v at position x in r[]:
          v &gt; 0 ?              //         if v is positive:
            1                  //           yield 1
          :                    //         else:
            (X - x) ** 2 +     //           if the squared distance between
            (Y - y) ** 2 ^ 1 ? //           (X, Y) and (x, y) is not equal to 1:
              0                //             do nothing
            :                  //           else:
              r[r[x] = 1,      //             mark r[x] as visited by setting it to 1
                g(y, w - v,    //             do a recursive call at (x, y) with n+1
                  -~n, x),     //             if v = -1, w is also incremented
                x              //             actual index ...
              ] = v            //             ... to restore r[x] to v afterwards
        )                      //       end of inner map()
      )                        //     end of outer map()
    :                          //   else (bottom-right cell):
      o = g(-1, W = w, N = n)  //     update (W, N) and use a last recursive call
                               //     with X undefined and Y=-1 to build the output o
)(0, 0, W = ++m[0][0] / 0, 0)  // initial call to g at (0, 0); set the cell at (0, 0)
                               // to 1 and set W to +inf
&amp;&amp; o                           // return o
</code></pre>
<p>The purpose of the last recursive call <code>o = g(-1, W = w, N = n)</code> is to create a copy of the current maze where all visited cells are marked with <em>true</em> and all other cells are marked with <em>false</em>.</p>
<p>For this call, it's important to notice that:</p>
<ul>
<li>because <code>W = w</code> and <code>N = n</code>, the abort test is always false</li>
<li>because <code>Y = -1</code>, the test on <code>m[Y + 1]</code> is always true</li>
<li>because <code>X</code> is undefined, the squared distance is always <em>NaN</em></li>
</ul>
<p>Therefore, what is actually done is simply:</p>
<pre class="lang-javascript prettyprint-override"><code>m.map((r, y) =&gt; r.map((v, x) =&gt; v &gt; 0 ? 1 : 0))
</code></pre>
</div>
<div id="pu2" class="pu"><h1><a href="https://github.com/somebody1234/Charcoal" rel="nofollow noreferrer">Charcoal</a>, 92 bytes</h1>
<pre><code>≔⟦⟧θＷＳ⊞θι⊞υ⟦⁰¦⁰ω⟧≔⟦⟧ηＦυ«⪫θ¶←Ｆ§ι²✳κ+¿∨ⅈⅉＦruld«≔⊟ＫＤ²✳κζＦ№#.∨ζ+⊞υＥι⁺μ⎇⁼ν²κ⁼ν⌕#.ζ»⊞ηι⎚»Ｆ⊟⌊η✳ι+¦+
</code></pre>
<p><a href="https://tio.run/##bVDBTgIxED3vfsWke5nGSgxHPRHUBCNxEz1ogMOGLWxDaaG7BcXw7eu0i8LBpk1npjPvvb55Vbi5LXTbDupaLQ1OZgK2/C7dV0pLwJHZ@Oa1ccoskXPIfV3hVoCijhh7AZMbAbT3M6pdgFSULqwD9By@0yQniAafrDJhnk0N49SQjO1O4u2zXDQhi/2DZmRK@YlKQD9QxsF75eS8UdbgitP4FQvtagH44vAdqfRB8jhEAOa8LllkTU6CcrvBXMrVGaYv4BKTE8QhYHYahtYTKct6TAAxHDrKXwPo0@NiEwTm2te4FvAmnSncFz5sfaFrNEG6gJWAc@FRmfKEeOBxEdsxTaSuZQdbdb4mQy0LhxQdOwOD@LEyau3XWPF/LFF/lnQvMW7bXpb1aKUZ3XTSkFCYttc7/QM" rel="nofollow noreferrer" title="Charcoal – Try It Online">Try it online!</a> Link is to verbose version of code. Times out for larger grids (can just about do 3×8 but can't do 4×6). Takes grid in example format and outputs using <code>+</code>s and spaces. Explanation:</p>
<pre><code>≔⟦⟧θＷＳ⊞θι
</code></pre>
<p>Input the grid.</p>
<pre><code>⊞υ⟦⁰¦⁰ω⟧
</code></pre>
<p>Start with an initial state of no <code>.</code>s, no <code>#</code>s and no moves. (Strictly speaking this is incorrect but all paths must include the initial square so it cancels out.)</p>
<pre><code>≔⟦⟧η
</code></pre>
<p>Start with no paths that reach from the end to the start.</p>
<pre><code>Ｆυ«
</code></pre>
<p>Perform a breadth-first search of the states.</p>
<pre><code>⪫θ¶←
</code></pre>
<p>Draw the input to the canvas, leaving the cursor at the end point.</p>
<pre><code>Ｆ§ι²✳κ+
</code></pre>
<p>Draw the path so far.</p>
<pre><code>¿∨ⅈⅉ
</code></pre>
<p>If the start hasn't been reached, then:</p>
<pre><code>Ｆruld«
</code></pre>
<p>Loop over the orthogonal directions.</p>
<pre><code>≔⊟ＫＤ²✳κζ
</code></pre>
<p>Look at the next character in that direction.</p>
<pre><code>Ｆ№#.∨ζ+
</code></pre>
<p>If the character is a <code>#</code> or a <code>.</code>, then...</p>
<pre><code>⊞υＥι⁺μ⎇⁼ν²κ⁼ν⌕#.ζ
</code></pre>
<p>Create a new state, formed by adding to the existing state; for index 2, add the current direction; for index 1, add 1 if the character is a <code>.</code>; for index 0, add 1 if the character is a <code>#</code>. Push this state to the list of states.</p>
<pre><code>»⊞ηι
</code></pre>
<p>But if the start was reached, then record this state.</p>
<pre><code>⎚»
</code></pre>
<p>Clear the canvas ready for the next state (or the final output).</p>
<pre><code>Ｆ⊟⌊η✳ι+¦+
</code></pre>
<p>Get the minimum state, which is that with the fewest walls, or for states with equal walls, the one with the fewest non-walls (which is equivalent to the shortest path). (For states with equal wall and path length, the tie is broken by preferring paths that go left rather than up from the end.) Draw this state, plus the final position.</p>
<p>Much faster 101-byte version readily handles all the test cases:</p>
<pre><code>≔⟦⟧θＷＳ⊞θι⊞υ⟦⁰¦⁰ω⟧≔⟦⟧ηＷ∧υ⊟υＦ∨¬η‹ιη«⪫θ¶←Ｆ§ι²✳λ+¿∨ⅈⅉＦruld«≔⊟ＫＤ²✳λζＦ№#.∨ζ+⊞υＥι⁺ν⎇⁼ξ²λ⁼ξ⌕#.ζ»≔ιη⎚»Ｆ⊟η✳ι+¦+
</code></pre>
<p><a href="https://tio.run/##bZDBTgIxEIbPu0/RlMs01o3hqCeCmmBAN9GDBjlsoLCNTQvtFhDDs6/T7sruwUkP0@nM9/@dZVnYpSlUXY@ckxsN8wUnO3aXHkqpBIGJ3vrqtbJSb4AxkntXwo4TiR0x95zMbzjBc1hgrQcpO8hIr0JjbrbgGVLWxhJ4sfBsKigZJ1PhHMgwgo8/aZKjXAVPRuqgRT81ZQhLZmYv4HYq1lW4RciomuiVOIbhYbAXB@@lFctKGg0K4fSKhna5jpLvgKUPuLig1qsVjapJaz7YzIX46jBDTvpMhohTYDYexsajKB1klBNUODWSf8vCf8@KbTCYK@9Ac/ImrC7sNzzsfKEcHIN1ThQnXeFR4sYa4onFQLVzmgjlBGltymbFyViJwgJm5zTaCfbLf3YhL7toXmJe11mIQZalgyZ6SdZGmrWlXtIMZWl9vVe/" rel="nofollow noreferrer" title="Charcoal – Try It Online">Try it online!</a> Link is to verbose version of code. Explanation:</p>
<pre><code>≔⟦⟧θＷＳ⊞θι
</code></pre>
<p>Input the grid.</p>
<pre><code>⊞υ⟦⁰¦⁰ω⟧
</code></pre>
<p>Create the initial state.</p>
<pre><code>≔⟦⟧η
</code></pre>
<p>Start with no path.</p>
<pre><code>Ｗ∧υ⊟υ
</code></pre>
<p>Perform a depth-first search of the states, by removing the most recently added state each time.</p>
<pre><code>Ｆ∨¬η‹ιη«
</code></pre>
<p>If we don't have a path yet, or it's longer than our path so far, then:</p>
<pre><code>⪫θ¶←Ｆ§ι²✳λ+
</code></pre>
<p>Draw the input and the path so far.</p>
<pre><code>¿∨ⅈⅉＦruld«≔⊟ＫＤ²✳λζＦ№#.∨ζ+⊞υＥι⁺ν⎇⁼ξ²λ⁼ξ⌕#.ζ»
</code></pre>
<p>If the start hasn't yet been reached then consider all possible steps and push the resulting state to the list of states.</p>
<pre><code>≔ιη
</code></pre>
<p>Otherwise this must be the shortest path so far, so save it.</p>
<pre><code>⎚»
</code></pre>
<p>Clear the canvas ready for the next state (or the final output).</p>
<pre><code>Ｆ⊟η✳ι+¦+
</code></pre>
<p>Draw the shortest path found.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/209142/">209142</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




