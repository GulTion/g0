<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::119714</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>037</td><td>J</td><td>231016T053124Z</td><td><a href="https://codegolf.stackexchange.com/questions/119714/visualize-the-euclidean-algorithm-again/266019#266019">Bubbler</a></td></tr>
<tr d-ix="1"><td>078</td><td>J</td><td>231016T025501Z</td><td><a href="https://codegolf.stackexchange.com/questions/119714/visualize-the-euclidean-algorithm-again/266018#266018">Jonah</a></td></tr>
<tr d-ix="2"><td>111</td><td>JavaScript V8</td><td>231013T011414Z</td><td><a href="https://codegolf.stackexchange.com/questions/119714/visualize-the-euclidean-algorithm-again/265956#265956">l4m2</a></td></tr>
<tr d-ix="3"><td>181</td><td>Haskell</td><td>170726T183333Z</td><td><a href="https://codegolf.stackexchange.com/questions/119714/visualize-the-euclidean-algorithm-again/135941#135941">ბიმო</a></td></tr>
<tr d-ix="4"><td>090</td><td>Haskell</td><td>170726T195513Z</td><td><a href="https://codegolf.stackexchange.com/questions/119714/visualize-the-euclidean-algorithm-again/135954#135954">Anders K</a></td></tr>
<tr d-ix="5"><td>032</td><td>Jelly</td><td>170511T040636Z</td><td><a href="https://codegolf.stackexchange.com/questions/119714/visualize-the-euclidean-algorithm-again/120007#120007">fireflam</a></td></tr>
<tr d-ix="6"><td>030</td><td>Charcoal</td><td>170510T204248Z</td><td><a href="https://codegolf.stackexchange.com/questions/119714/visualize-the-euclidean-algorithm-again/119983#119983">Neil</a></td></tr>
<tr d-ix="7"><td>034</td><td>Pyth</td><td>170509T102934Z</td><td><a href="https://codegolf.stackexchange.com/questions/119714/visualize-the-euclidean-algorithm-again/119749#119749">Leaky Nu</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://www.jsoftware.com" rel="nofollow noreferrer">J</a>, 37 bytes</h1>
<pre><code>[:u:97+f=:$&amp;0`({.1+[:f]-/:*|.)@.(~:/)
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=m70wa8FOJT0F9XQFWysFdR0FAwUrINbVU3AO8nFbWlqSpmtxUzXaqtTK0lw7zdZKRc0gQaNaz1A72iotVlffSqtGT9NBT6POSl8TonghlF5w0yZdwdBAwYRLV1eXK13BBMiBMs0QTEMFQwQLLmigYAgxBAA" rel="nofollow noreferrer">Attempt This Online!</a></p>
<p>Recursive function seems to be the way here. Takes a vector of two positive integers and returns a character matrix. If a numeric matrix is acceptable, <a href="https://ato.pxeger.com/run?1=m70wa8FOJT0F9XQFWysFdR0FAwUrINbVU3AO8nFbWlqSpmuxR0XNIEGjWs9QO9pKxSpWV99Kq0ZP00FPo85KXxOiZCGUXnDTJl3B0EDBhEtXV5crXcEEyIEyzRBMQwVDBAsuaKBgCDEEAA" rel="nofollow noreferrer">28 bytes</a>: <code>$&amp;0`({.1+[:$:]-/:*|.)@.(~:/)</code>.</p>
<pre><code>[:u:97+f=:$&amp;0`({.1+[:f]-/:*|.)@.(~:/)
       f=:$&amp;0`({.1+[:f]-/:*|.)@.(~:/)    inner recursive function
             `                @.(~:/)    if two parts are equal,
          $&amp;0                            create a zero matrix of that dimensions
              (              )      otherwise,
                      ]-/:*|.       subtract the smaller part from the larger part
                   [:f              recurse
               {.1+                 add 1 to each element and pad to the requested size
                                    with zeros
[:u:97+    map 0, 1, ... to a, b, ...
</code></pre>
</div>
<div id="pu1" class="pu"><h1><a href="https://www.jsoftware.com" rel="nofollow noreferrer">J</a>, 78 bytes</h1>
<pre><code>&gt;/|:[:u:97+1(0&amp;g@{:]F.:(((g=.$~,~)~1+0{,),(~:#)|:])}:)@}.0}:@{0|:(&lt;.,|@-)/^:a:
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=tdHNTgIxEAfweOUp_sjKttky22KCMnxkogknw8ErLoYYQI3RxMBpu_siXvDAQ-HTWFnCiauHppPp5DeT6df362Z30a2zyzp17sZx7ZziBQaMGAYWHE6LcHt_N9quV4vW9W48TD1PeM3dq8Qp21xKztmIWCm1HFBUmlKXLrG50UaV3NCeM12wloJswZJbz6pPxktLp1OecaX-nGW6Nr4hOChl90hgsXehTCkTRHAJXE5GMh1GO9qo8EcXGhz08Hz09-rsbTX_fJ-t5oxhCs-YMFRPCv6DchKTeJaIxZNEesrBTkMgvTCDFvVC0kDSpCGMhmqjHfUp1ej36BIPXEa2avI_8vzp-QMLdOBsFYcvOuTcqZyFO1FXbXmzqe5f" rel="nofollow noreferrer">Attempt This Online!</a></p>
<p>Surprisingly tough to golf in J.  Tried a few approaches, this was the best of them, but still feels like there's room for improvement.</p>
<p>Basic approach:</p>
<ul>
<li>Generate successive differences until a repeat, eg: <code>10 6</code> gives <code>6 4 2 2</code>.</li>
<li>&quot;Roll it up&quot; starting from the smaller squares (ie, stack a 2x2 on a 2x2, then transpose it and put a 4x4 on that, then transpose that and put a 6x6x on top of it).  We do transposes as needed to make the side lengths line up.  We always stack our new larger square atop the result up to that point.  The whole computation is expressed as a fold.</li>
<li>The first square starts as a square of zeroes, and as we add each additional square its number increments by one.  At the end we have our result but with numbers instead of letters.</li>
<li>Convert the numbers to ascii letters.</li>
<li>Finally, transpose the entire result if needed, so that the result dimensions match the order of the arguments.</li>
</ul>
</div>
<div id="pu2" class="pu"><h1><a href="https://v8.dev/" rel="nofollow noreferrer">JavaScript (V8)</a>, 111 bytes</h1>

<pre class="lang-javascript prettyprint-override"><code>x=&gt;h=(y,i=x,j=y)=&gt;j?(g=(x,y,k)=&gt;(x&gt;y?x-=y:y-=x,i)?x&lt;i|y&lt;j?k:g(x,y,k+1):`
`)(x,y,0)+(i?h(y,i-1,j):h(y,x,j-1)):''
</code></pre>
<p><a href="https://tio.run/##XYzLCoMwEEX3/ogzmJSm0AfBSX5FkaqJYkotkoH@exrbXXf3HA7Xt1u7dk/3eMntlnpKkcxIwMJRFJ4YyXgLA0EULKZMEA3bKIk1y5w4tLF2b669nfTwqyqFuika/NIRK3B23B@lEh71PvO1VIi6LFMXljXM98McBuhBnRDOiMWfvSJcsk0f" rel="nofollow noreferrer" title="JavaScript (V8) – Try It Online">Try it online!</a></p>
</div>
<div id="pu3" class="pu"><h1><a href="https://haskell.org" rel="nofollow noreferrer">Haskell</a>, 181 bytes</h1>



<pre class="lang-hs prettyprint-override"><code>import Data.List
(['!'..'~']&amp;)
a#[]=a
a#b=zipWith(++)a$transpose b
(s&amp;a)b|b&lt;1=[]|b&gt;a=transpose$s&amp;b$a|n&lt;-div a b,(t,u)&lt;-splitAt n s=foldl1(#)((&lt;$[1..b]).(&lt;$[1..b])&lt;$&gt;t)#(u&amp;b$mod a b)
</code></pre>

<p><a href="https://tio.run/##RYxRS8MwFEbf@ytuaVkTtgaLIgjJYEzZy5SBiA9dkRvaumCblOZOh1b/eq0I@nQOnI/vgP6laprxI41gu7rbPKw2N7De7SBKPwPTdq4nuEZCsTWeglrtR5YnYSJE8pUUMx5glBcKJ2j1brpHQwc2n3OMqUfrO@cr0AHzM@R60DJTeTHoJaq/GvuZjnGwMi3NKyDoBaPFkcvUd42hFYEFr2rXlE3GIs6YjPNMCF1w8a8yXhKP2HF6al35c8LHoEVjQUGL3e0TdEe6p35rQQDbnzykS6iBnXwYnvFfZpxPcVpDX2E56ZvrSw9KSniuaO0sVZb8eHkB51ff" rel="nofollow noreferrer" title="Haskell – Try It Online">Try it online!</a></p>

<p>For <code>10</code> bytes more you get a nice spiral instead :)</p>

<pre class="lang-hs prettyprint-override"><code>!!!!!!!!!!!!!$$$#####
!!!!!!!!!!!!!$$$#####
!!!!!!!!!!!!!$$$#####
!!!!!!!!!!!!!%%'#####
!!!!!!!!!!!!!%%&amp;#####
!!!!!!!!!!!!!""""""""
!!!!!!!!!!!!!""""""""
!!!!!!!!!!!!!""""""""
!!!!!!!!!!!!!""""""""
!!!!!!!!!!!!!""""""""
!!!!!!!!!!!!!""""""""
!!!!!!!!!!!!!""""""""
!!!!!!!!!!!!!""""""""
</code></pre>

<p><a href="https://tio.run/##RY1RS8MwFIXf@yvuaFkTtgaLIgjJYEzZy5TBEB@6Ijc0c8E2LcndHDr967Xiw56@A@fwnT2Gd1PX/VcWw2r@tHyeLx9gsV5DnH1HtulaT3CPhGJlA0U7te1ZkY5SIdKftBzzCOOiVDhAq0/bvVjas8mEY0IeXejaYBJvjsYHI5OZjlgYI9dnLXNVlGc9Q3XZhbFO8OxkVtkjIOgpo@mByyx0taU5gYOgdm1d1TmLOWMyKXIhdMnFJQ4fxGN2GExNW/1JeB81aB0oaLB7fIXuQBvyKwcC2PYUIJvBDtgpjEZX/J8550M5rMEbrIb40foqgJIS3gwtWkfGUehvb@D67hc" rel="nofollow noreferrer" title="Haskell – Try It Online">Try it online!</a></p>

<h3>Ungolfed</h3>

<p>The <code>(#)</code> operator puts two matrices next to each other, but transposes the right one, eg:</p>

<pre class="lang-hs prettyprint-override"><code>!!!                !!!"
!!! # "#$    -&gt;    !!!#
!!!                !!!$

a # [] = a
a # b  = zipWith (++) a $ transpose b
</code></pre>

<p>This is basically the recursive version of Euclid's algorithm, but instead of forgetting the divisors&amp;remainders and returning the <code>gcd</code>, it builds squares from it and accumulates these with <code>(#)</code>. The <code>s</code> variable are the remaining characters that we can use:</p>

<pre class="lang-hs prettyprint-override"><code>(s &amp; a) b
  | b == 0 = []                     -- Base case
  | b &gt; a = transpose $ (s &amp; b) a   -- In this case we can just flip the arguments and rotate the result by 90 degrees
  | n &lt;- div a b                    -- set n to the number of squares we need
  , (t,u) &lt;- splitAt n s =          -- take n characters, ..
               ((&lt;$[1..b]).(&lt;$[1..b]) &lt;$&gt; t)                     -- .. build squares from them and ..
    foldl1 (#)                                                   -- put them next to each other
                                             (u &amp; b $ mod a b)   -- recursively build the smaller squares with the remaining characters..
                                            #                    -- .. flip them and put them next to the previous one(s)
</code></pre>

<p>The actual function just calls the function from above with a string of all printable characters:</p>

<pre class="lang-hs prettyprint-override"><code>(['!'..'~']&amp;)
</code></pre>
</div>
<div id="pu4" class="pu"><h1><a href="https://www.haskell.org/" rel="nofollow noreferrer">Haskell</a>, 90 bytes</h1>



<pre class="lang-hs prettyprint-override"><code>(['a'..]!)
a?x=a&lt;$[1..x]
((a:b)!y)x|x*y&lt;1=""?y|x&gt;y=map(a?y++)$b!y$x-y|z&lt;-y-x=a?x?x++(b!z)x
</code></pre>

<p><a href="https://tio.run/##DctBC4IwFADgu79ik4FbYyMvHcK1Q9cCoUtgEs/IilQkDd4Tf3vL@/c9YXjfmybU7hJkkUBibclVBB4dZKJIrcUykhK2leKkcMYVZamLY08z7si10EvwpLUSFSeBhuYpM2SW7dGj1rLik8LQwqtjji38eGX9dzyNn0PHBKvZhqXr8LvVDTyGYM77PP8D" rel="nofollow noreferrer" title="Haskell – Try It Online">Try it online!</a></p>
</div>
<div id="pu5" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="nofollow noreferrer">Jelly</a>, 32 bytes</h1>

<pre><code>Ṁ,ạ/y
³,⁴ÇÐĿp/€Fs2
pµ¢ṣLµ€+95ỌsY
</code></pre>

<p><a href="https://tio.run/nexus/jelly#AT0Awv//wrMs4oG0wrXhuYAs4bqhL3nCtcOQxL9wL@KCrEZzMgrCouG5o0wKcMOH4oKsKzk14buMc1n///82/zEw" rel="nofollow noreferrer" title="Jelly – TIO Nexus">Try it online!</a></p>

<p><code>Ṁ,ạ/y</code> you want an explanation? Here it is.</p>

<pre><code>Ṁ,ạ/y          - perform one step of the Euclidean Algorithm, input 2-element list
 ,             - pair of the following two:
Ṁ              -  maximum of the the input list
  ạ/           -  absolute difference of the two elements
    y          - use this as a mapping on the input.

³,⁴ÇÐĿp/€Fs2   - apply Euclidean Algorithm
³,⁴            - start with the pair [input 1, input 2]
   Ç           - apply a step of the Euclidean Algorithm
    ÐĿ         - repetitively until the results repeat
      p/€      - take the Cartesian product of each step
         Fs2   - flatten and split into all coordinate pairs of letters

pµ¢ṣLµ€+95ỌsY
p              - Cartesian product of inputs: provides all possible coordinate pairs.
 µ   µ€       - for each coordinate
   ṣL         - find the number of times it is included in
  ¢           - the above list of covered coordinates.
       +95Ọ   - convert number of times to letters
           s  - split into rows
            Y - join by newlines.
</code></pre>

<p>I can likely golf a little more by using implicit arguments instead of <code>³,⁴</code>.</p>
</div>
<div id="pu6" class="pu"><h1><a href="https://github.com/somebody1234/Charcoal" rel="nofollow noreferrer">Charcoal</a>, 30 bytes</h1>

<pre><code>ＮδＮγＦβ¿×γδ«ＵＯγδι¿‹γδＡ⁻δγδＡ⁻γδγ
</code></pre>

<p><a href="https://tio.run/nexus/charcoal#@/9@z7pzW0DE5vd7lp3bdGj/4ennNp/bcmj1@z1b3@9ZD2Kf23lo/6OGnSDm@z0LHzXuBgoh2CAFm///N@MyNAAA" rel="nofollow noreferrer" title="Charcoal – TIO Nexus">Try it online!</a> Explanation:</p>

<pre><code>Ｎδ      Input d
Ｎγ      Input g
Ｆβ      For i In ['a' ... 'z']
 ¿×γδ«   If g * d
  ＵＯγδι   Oblong g, d, i
  ¿‹γδ    If g &lt; d
   Ａ⁻δγδ   d = d - g
   Ａ⁻γδγ   Else g = g - d
</code></pre>

<p>Annoyingly Charcoal's Oblong command won't take <code>0</code> for a dimension, which costs me 4 bytes. The other approach would be to loop while <code>g * d</code>, but then I couldn't work out how to iterate over <code>b</code> (which is predefined to the lowercase letters).</p>
</div>
<div id="pu7" class="pu"><h1><a href="https://github.com/isaacg1/pyth" rel="nofollow noreferrer">Pyth</a>, 34 bytes</h1>

<pre><code>M?*GH?&lt;HGCgHG+*G]jk*G]~hZgG-HGYjgF
</code></pre>

<p><a href="https://pyth.herokuapp.com/?code=M%3F%2aGH%3F%3CHGCgHG%2B%2aG%5Djk%2aG%5D~hZgG-HGYjgF&amp;input=6%2C10&amp;debug=0" rel="nofollow noreferrer">Try it online!</a></p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/119714/">119714</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




