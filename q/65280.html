<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::65280</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>032</td><td>Wolfram Language Mathematica</td><td>240215T143247Z</td><td><a href="https://codegolf.stackexchange.com/questions/65280/count-the-number-of-sides-on-a-polygon/270083#270083">Mukundan</a></td></tr>
<tr d-ix="1"><td>nan</td><td>Python 2 + PIL</td><td>151130T155500Z</td><td><a href="https://codegolf.stackexchange.com/questions/65280/count-the-number-of-sides-on-a-polygon/65349#65349">Ell</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://www.wolfram.com/wolframscript/" rel="nofollow noreferrer">Wolfram Language (Mathematica)</a>, 32 bytes</h1>
<pre><code>Length[ImageCorners[#,3,.01,4]]&amp;
</code></pre>
<p><a href="https://tio.run/##1VdL06u4dp33rzjVqUrde@kK2GDAgx5I4v0wCBsDPnUGGIPAPM3DGG7lt3f4@lbSlVEqlZtBSwNtNpJK0l57LamOxzyt47FI4t@yX3@z0oaM@Xe9jkmK2r5J@@H7v/zC/vJvzO4X7sePf/3tL3/7dh7j/ttfxj5uhi7u02b8do@TkvTt1Dz@@u1vf/2pqMm3X7/pddf243nsi4Z8/7m4QsebGVMlLdjK6eznsk82C399yltrby2s31JbfXnU0FMCzbvc9zfmsVeWG4bwph6L2xka90BpblejigLvkCRV5X4NADd8UTzly6K30j3qjP19boPxy8OFnqVqXKG5ORDvVzK@ei07sbc5NEsdAjVCC7u8HJcz3Tl2jXrZ790Uh3t0i8dQyvEEK60yY4EP1SG04sRfrdXIakV5qU9lUqt7gySVnkNOsVG2hHMwW5Pdg6IGV3JU/Rn5yIjURTJ0J5di3abagSwm7AFP@48LYMl9sHvFiMFo7yJ4joXDCZiXS3ZgtAxM5ZWxriADQXtegDhrs0KBDF85KBCnupNwD3xsSOBQhFgTFVfi3wd68M9oxJ2o7Y9vBb0ZeRcW00w72QPls5vnvqy1c19IK17FcbhdFxgHXkKCsQx15X1TPvCueglOLdCgzBJhnRHYDBlJ05UmMkloDuqNOym@37CyVA17DiSPmgXwoF5tqHfjB3Bll08OZSurKqEltLHr3pKZJLBcz5uPTu@VPQnAJ9c7GB4lK8uk4GVQXodqJ5uNAOX5YUeSI/VPcFkeIkZekFT@iGNE2rDvkLwqAzh/MALGagf6CfUWZniEF6tUVZ@YMZjnqyBXT772TYk670hnDhhcq/k@n16vk91he1e74MqD1ru02qCl6LrNT5LRfy5427VlsaABUEX3lEZGfhWllfN9qnmR7lW2YL9KZoT27d33bkx6jQ62g98yyA9E0XfsJ8RU2Hqi@xaqhksoaS@2H7G953TOAOuZPZmnlGHKnJ@RLgx5w/Z7VYUamaySs0vttTZU4lzgw/6I4w7cn24DTohIPg/eHx6j131mErPzvfvOvmUKxkbKEhSBwCW9LIPKEWYLTXAvildGqYH8oQYztaTBsOaLSMNbDOEs6p@GCe7uHDltKwL9SUsPfzp2p3Q@b2H0byzP6Gt4dR5ewUinRyusdD8IT611uvhFV4z7Tt/TwdIVtHPJmtTnzG8EGXMGT/LDmy7cztczSt/3/Jjugw/sCY1mjoDMt5V5Ah7LWp/QB61zf8kEzi/gipWng3eeTrUk7Hd7FEJByaAGKgohsNtS7ByhNr8fjvXror4JoQxXaug8M6TgMJPPMCzrUdzddqiJQ8eZvzgAGp5/kPvSIIT8@uvPv3z7@88wHlKe28yf3ZP687//@MndiGr8nn330rp9p6Dq8hjlcdOk1feN0H4J8mJMf/z48dNPGwUipKI/MwXC4A8KDB1OkHUwqxw8er6my8/B8jiVJPn5hLv2WViZGdlI28dy3AdBM8rNXsmxfC8hxK2MICC@qaAcixLXinAGg27dxFjaKCkANsDrAGwakJHjbAGcE0hJ9qoBdAK3g5QCK5IGnB4Ac96ZYgRGyDA5UiNOrR63BMXLvI@ee@89A8sCQqtlJLyFuprTACpg9M1WKo0UKDbGcN2Y93yaYCfpeZAgju0LgKXP8mk3KqP8HQayHXLbUhh9IGhAZ4AMj02FSlbIGTsQHjCigGiw803f@44erbpsgpIFWgh9Gd6ZVmLBDVxwqW27v4z49IEZJMFHl3SicyVxOc0HEYwG80Mc6iFFiDzlzr/bOg0fOjAqkp4gR05PEm4RWB9JcwSicK/kkrC6vkKdOYPaUljqokUcRYGuBbA7CFdwsaP6@F4zM6EV8I@z/s9z3/Lri3bHdGibhJ7p32EgV8qlPE@4Ruj/DvVkA3n637HetdVC2uZPAfRW/kPr3UCQbDArEfDTKb/s5PDsa4jh61ZA@v5Z6gZ4MK8LVWbL2X0VF3bJRbDIhl2qWuLcbUqbC1EOpBo/OtcmTOmqhJFh59uJlH5Gm6edR4YTE7QxWD6vUouJ3hu3emVHLEtbWOq312H5BdphaQ9JYAISgf5YeWNS@@Cc3vz4fb9@nQ7@slmpAjIN1C2nMEw5yQdZsjw5UHCSSB6cTHznCKYBrKB9gfwDjyl/DTBEs6zthG6TVHk2TSJnWfgqTyJMwRNnDmHOkgs5XUo6rpXOLcdp3uyK0IB9Kfqw9dWCcIxakYjR6DIhFRVf6zFqbEiBAy08ZIccP97WkVOkUi2w7IFYAWcf5v9LH5T0EwQyIoxP/FbCIjz8j75sl4YfLSpOUf@Qg7dvkXyA1ngj1bE5pMVJAOp61fWKOtXxWeM56t4NmntU/HTlQA3Fk/YOYYIkw/Zi@bOwNH/8imt9OTXhMLOHK3MobwhFDPkdZWf/6njmAUW6/k/QjG5LnXhLmz9vLkV/iEa0iYakw7MSeUAx/JGoR@dzshbGUoMAOw0Su7JYLjNDruLzsHt5@ejyMmOEVv/Uplu91YYuGwxLEJAYpeSBi1fnJl6J8Mma2uocOVZevKOpgCm5duzlmeF3UFBgYR/2Y1mOYrohItxZEQtatjqAVgGGAfQbMBWMthMyDsABc0F8TOSFyGarZixL0/vbAWz3/a2rdbDR5icyFAFGxCdEToiMWoVXQQGMD9A9YBoY3TDaZgQTcAkDyEbWslirWJBVBs5HlU04lc15TmbQDop@etOmf/yjNlmxEk0gHhZ85eBWz67IDLF0PnAE23XmvamAI7hEEWqH2m25CceaY/c7HAKegOHez2s/CwAmYC88H7znTwVV6IbZ6TpkF@gRyDcNf5LF6LGeH9ErGOMN/f61Uh/jVc63KN0mI3iC3VIFL3rfsbO2g/MekAmMu4asw2p/Vc3eVKuNWjTWZf3A/w@4T4o@qdI/A76n/8L3/naJ@E0rPqoqaLpdZsSEy5gI@OtSVG4Pgzy4Xi6HKZNC3iZ5df@cyiNx@FB@HqfR48SU/lDSYs5IL3R6ebet3ltT/xk82VPfIYOEj8vAQrE23bkfpfebpay3xD5ZO2H3jfQeEOkEFObmW9G2cOCWK86y6qNHIqEP/3w@LUdOo9tdd7KnX8P7GnjHj1XNphUS/IqYF3x6nlfVyjKrg0DCu3QoJfxa1l7TTmQXDwMvrA05YfQJ@8C82iicjhe2qO7gJTsJCmZeZ@1gra@bWmrVl02agNlFy4wkwB92Tsps6@cgBiuRLSkEhb7hvyN4OPkglpyLEGMQ6hQ7fMpZdYEGiK0e3sk2RpmNCcyDMRtPmEfWfLXVE6GQiNzb25sfLyBdZ4fijppQaNTBFGanf8P4vtkNC5CTyskjgXlPs2AfCu39cuTGD03t5wQ7k8M8d4ro10MGp1o8n7Pg@FKjddwxyWt7ts4KT7zW5kvUbgKQ5l2b8K3ZXlKdKvJ25Idze41P6bNrjwKJuzD2qDLvHL4sulsapFXXpXz76u5pTNV59@aH5fCIs7TpOpqe9mAjmJaJT9pzoaxwJyFe493rfDL@qZey3/4D" rel="nofollow noreferrer" title="Wolfram Language (Mathematica) – Try It Online">Try it online!</a> (Testcases are base64 encoded after running it through <a href="https://optipng.sourceforge.net/" rel="nofollow noreferrer">optipng</a>)</p>
</div>
<div id="pu1" class="pu"><h1>Python 2 + PIL, no error, <del>313</del> 307 bytes</h1>

<pre class="lang-py prettyprint-override"><code>from Image import*
I=open(sys.argv[1])
w,h=I.size;D=I.getdata()
B={i%w+i/w*1j for i in range(w*h)if D[i]!=D[0]}
n=d=1;o=v=q=p=max(B,key=abs)
while p-w:
 p+=d*1j;e=2*({p}&lt;B)+({p+d}&lt;B)
 if e!=2:e%=2;d*=1j-e*2j;p-=d/1j**e
 if abs(p-q)&gt;5:
    t=(q-v)*(p-q).conjugate();q=p;w=o
    if.98*abs(t)&gt;t.real:n+=1;v=p
print n
</code></pre>

<p>Takes an image file name on the command line, and prints the result to STDOUT.</p>

<p>Gives the correct result for all tests, and <em>n</em> = 28 for the circle.</p>

<h2>Explanation</h2>

<p>The algorithm works by walking along the perimeter of the polygon, and counting the number of encountered vertices (detected as changes in direction).
We start at the pixel farthest away from the origin, <code>o</code>, which is guaranteed to be a vertex, and therefore, to be adjacent to an edge (i.e., a boundary between a foreground pixel and a background pixel).
We keep track of our position, <code>p</code>, the most recent vertex, <code>v</code>, and the most recent "checkpoint", <code>q</code>, all of which are initially equal to <code>o</code>.
We also keep track of the direction of the edge, <code>d</code>, relative to the current pixel; <code>d</code> initially points east, which is a safe direction, since we know there's an edge to the east of <code>o</code>, or else it wouldn't be farthest from the origin.
We move along the edge, in a direction perpendicular to <code>d</code>, such that <code>d</code> points to our left, i.e., in a clockwise direction.
Whenever we "fall off the edge", i.e., in any situation where <code>p</code> is outside the polygon, or where the pixel to our left (i.e., in the direction of <code>d</code>) is inside the polygon, we adjust <code>p</code> and <code>d</code> accordingly before resuming.</p>

<p>Every time the distance between <code>p</code> and the last checkpoint, <code>q</code>, gets bigger than 5, we try to determine whether we passed over a vertex between <code>q</code> and <code>p</code>:
We compare the angle between <code>vq</code> (i.e., the vector from <code>v</code> to <code>q</code>), which is the general direction of the side of the polygon we were walking along when we reached the last checkpoint, and <code>qp</code>, the displacement between the last checkpoint and the current position.
If the angle is greater than about 10°, we conclude that we're walking along a different side of the polygon, increase the vertex count, and set <code>v</code>, the current vertex, to <code>p</code>.
At each checkpoint, regardless of whether we detected a vertex or not, we update <code>q</code>, the last checkpoint, to <code>p</code>.
We continue in this fashion until we arrive back at <code>o</code>, the starting point, and return the number of vertices found (note that the vertex count is initially 1, since the starting point, <code>o</code>, is itself a vertex.)</p>

<p>The images below show the detected vertices.
Note that taking <code>p</code>, the current position at each checkpoint, as the position of the new vertex is not optimal, since the real vertex is probably somewhere between the last checkpoint, <code>q</code>, and <code>p</code>, along the perimeter.
As you can see, all the vertices other than the first one (generally, the bottom-right vertex) are a little off.
Fixing this would cost more bytes, but this seems to be working well enough as it is.
That being said, it's a little hard not to overfit with only four test cases.</p>

<p><a href="https://i.stack.imgur.com/sEPfU.png" rel="noreferrer"><img src="https://i.stack.imgur.com/sEPfU.png" alt="n = 10"></a>
<a href="https://i.stack.imgur.com/UBQFC.png" rel="noreferrer"><img src="https://i.stack.imgur.com/UBQFC.png" alt="n = 36"></a>
<a href="https://i.stack.imgur.com/dGNhc.png" rel="noreferrer"><img src="https://i.stack.imgur.com/dGNhc.png" alt="n = 7"></a>
<a href="https://i.stack.imgur.com/IyS6A.png" rel="noreferrer"><img src="https://i.stack.imgur.com/IyS6A.png" alt="n = 5"></a>
<a href="https://i.stack.imgur.com/OJ4Sp.png" rel="noreferrer"><img src="https://i.stack.imgur.com/OJ4Sp.png" alt="Circle"></a></p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/65280/">65280</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




