<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::150775</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>177</td><td>Acc!!</td><td>240416T171208Z</td><td><a href="https://codegolf.stackexchange.com/questions/150775/parse-a-list-of-signed-unary-numbers/272625#272625">Mukundan</a></td></tr>
<tr d-ix="1"><td>227</td><td>sed</td><td>210323T064202Z</td><td><a href="https://codegolf.stackexchange.com/questions/150775/parse-a-list-of-signed-unary-numbers/221115#221115">user1004</a></td></tr>
<tr d-ix="2"><td>015</td><td>Jelly</td><td>210323T052855Z</td><td><a href="https://codegolf.stackexchange.com/questions/150775/parse-a-list-of-signed-unary-numbers/221111#221111">Unrelate</a></td></tr>
<tr d-ix="3"><td>086</td><td>QBasic</td><td>180605T220229Z</td><td><a href="https://codegolf.stackexchange.com/questions/150775/parse-a-list-of-signed-unary-numbers/166253#166253">DLosc</a></td></tr>
<tr d-ix="4"><td>070</td><td>Python 2</td><td>171216T225512Z</td><td><a href="https://codegolf.stackexchange.com/questions/150775/parse-a-list-of-signed-unary-numbers/150830#150830">mercator</a></td></tr>
<tr d-ix="5"><td>237</td><td>Acc!!</td><td>171216T213037Z</td><td><a href="https://codegolf.stackexchange.com/questions/150775/parse-a-list-of-signed-unary-numbers/150827#150827">DLosc</a></td></tr>
<tr d-ix="6"><td>021</td><td>Retina</td><td>171216T080951Z</td><td><a href="https://codegolf.stackexchange.com/questions/150775/parse-a-list-of-signed-unary-numbers/150782#150782">ovs</a></td></tr>
<tr d-ix="7"><td>058</td><td>Lua</td><td>171217T171938Z</td><td><a href="https://codegolf.stackexchange.com/questions/150775/parse-a-list-of-signed-unary-numbers/150914#150914">Jonathan</a></td></tr>
<tr d-ix="8"><td>018</td><td>Jelly</td><td>171217T164955Z</td><td><a href="https://codegolf.stackexchange.com/questions/150775/parse-a-list-of-signed-unary-numbers/150910#150910">Jonathan</a></td></tr>
<tr d-ix="9"><td>014</td><td>Husk</td><td>171217T072053Z</td><td><a href="https://codegolf.stackexchange.com/questions/150775/parse-a-list-of-signed-unary-numbers/150849#150849">Zgarb</a></td></tr>
<tr d-ix="10"><td>nan</td><td>Perl 5</td><td>171216T230107Z</td><td><a href="https://codegolf.stackexchange.com/questions/150775/parse-a-list-of-signed-unary-numbers/150833#150833">Xcali</a></td></tr>
<tr d-ix="11"><td>119</td><td>R</td><td>171216T230015Z</td><td><a href="https://codegolf.stackexchange.com/questions/150775/parse-a-list-of-signed-unary-numbers/150832#150832">NofP</a></td></tr>
<tr d-ix="12"><td>092</td><td>Python 2</td><td>171216T063121Z</td><td><a href="https://codegolf.stackexchange.com/questions/150775/parse-a-list-of-signed-unary-numbers/150776#150776">Chas Bro</a></td></tr>
<tr d-ix="13"><td>060</td><td>JavaScript ES6</td><td>171216T204603Z</td><td><a href="https://codegolf.stackexchange.com/questions/150775/parse-a-list-of-signed-unary-numbers/150824#150824">Arnauld</a></td></tr>
<tr d-ix="14"><td>066</td><td>Haskell</td><td>171216T091239Z</td><td><a href="https://codegolf.stackexchange.com/questions/150775/parse-a-list-of-signed-unary-numbers/150784#150784">Laikoni</a></td></tr>
<tr d-ix="15"><td>9470</td><td>BrainFlak</td><td>171216T101027Z</td><td><a href="https://codegolf.stackexchange.com/questions/150775/parse-a-list-of-signed-unary-numbers/150790#150790">DJMcMayh</a></td></tr>
<tr d-ix="16"><td>080</td><td>Wolfram Language Mathematica</td><td>171216T074239Z</td><td><a href="https://codegolf.stackexchange.com/questions/150775/parse-a-list-of-signed-unary-numbers/150779#150779">JungHwan</a></td></tr>
<tr d-ix="17"><td>056</td><td>Vim</td><td>171216T074543Z</td><td><a href="https://codegolf.stackexchange.com/questions/150775/parse-a-list-of-signed-unary-numbers/150780#150780">DJMcMayh</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><em><a href="https://github.com/dloscutoff/Esolangs/tree/master/Acc!!" rel="nofollow noreferrer">Acc!!</a></em>, 177 bytes</h1>
<pre><code>N
Count i while _%5 {
Count j while _%7 {
Write 45
0
}
Count j while 0^(_%7) {
_+N
}
Count j while 3-j {
Count k while 0^k*(_/4900+j/2) {
Write 48+_/4900%10
}
_*10
}
Write 9
N
}
</code></pre>
<p><a href="https://tio.run/##S0xOTkr6/9@Pyzm/NK9EIVOhPCMzJ1UhXtVUoRoqlgUXMweKhRdllqQqmJhyGXDVoikwiNMAqtEEKorX9sOQNdbNghuZDdeRraURr29iaWCgnaVvpIkw30IbIqxqCLInXgtMQeQsuYCG//9vYAgEYALMgLNgAoboAhgiuFTiBgA" rel="nofollow noreferrer" title="Acc!! – Try It Online">Try it online!</a></p>
<p>Uses <code>-0</code> to represent zeros and tabs as seperators.</p>
<h2>Commented</h2>
<pre><code>N                                 # Read char

Count i while _%5 {               # while _ % 5 != 0:
                                  #   ( _ here is the last read char; notice that EOF
                                  #     and newline are divisible by 5 while '0' and '1'
                                  #     are not )

                                  #   Handle potential leading '0'
Count j while _%7 {               #   if _ % 7 != 0:
                                  #     ( _ is same as above; notice that _ can only be
                                  #       '0' or '1' and additionally that only '0' is
                                  #       not divisible by 7 )
Write 45                          #     output '-'
0                                 #     _ = 0
}

                                  #   Read '1's (also consumes 1 char after stream of '1's)
Count j while 0^(_%7) {           #   while _ % 7 == 0:
                                  #     ( _ here represents sum of char values since last
                                  #       '1'; notice that it is a multiple of 7 when we
                                  #       read only '1's and would only longer be a multiple
                                  #       of 7 when we read a '0' or newline )
_+N                               #     _ = _ + N  # here N is a newly read char 
}

                                  #   Output number in decimal
Count j while 3-j {               #   for j in [0, 1, 2]:
Count k while 0^k*(_/4900+j/2) {  #     if _ / 4900 + j / 2 != 0:
                                  #       ( _ / 4900 represents the 100s place of the read
                                  #         number)
Write 48+_/4900%10                #       output _ / 4900 % 10 as a digit
}                                 #
_*10                              #     _ = _ * 10  (shifts number to prepare for next iteration)
}

Write 9                           #   Output tab as a seperator

N                                 #   Read char (preparation for the loop)
}
</code></pre>
</div>
<div id="pu1" class="pu"><h1><a href="https://www.gnu.org/software/sed/" rel="nofollow noreferrer">sed</a>, 227 bytes</h1>
<pre><code>s/^.o*/&lt;&amp;&gt;/
:a
s/&gt;z\(.o*\)/&gt;&lt;\1&gt;/
ta
:b
s/z&gt;/0&gt;/g
y/z/-/
s/oooooooooo/x/g
s/ooooooooo/m9/g
s/oooooooo/m8/g
s/ooooooo/m7/g
s/oooooo/m6/g
s/ooooo/m5/g
s/oooo/m4/g
s/ooo/m3/g
s/oo/m2/g
s/o/m1/g
s/x\([^xm]\)/x0\1/g
s/m//g
y/x/o/
tb
</code></pre>
<p><a href="https://tio.run/##tY47DsIwEET7PQgCpDCEPwj5IhikRCCqZYsEyezlg2MHCKAUFExhv3mewsXpmJwv16oqcBjJENueAW0yKmDU9r2xA5itTb0tM9rk/kENxgZnukGRwAt5Bs77lgCv3wR41e7gZauCF68Gnj8LePZg8LRB8CQSOA3gbH93cLz3H3ZjGx0j/NP5FZV5VQkpqQiJaDg0HBHDVbfIGiP1vp43UZX3fPbvReeyO/TD9i@hF94B" rel="nofollow noreferrer" title="sed – Try It Online">Try it online!</a></p>
<h2>Usage</h2>
<p>0 and 1 for input are replaced with z and o respectively.
Input is given from stdin, on every line.</p>
<h2>With comments</h2>
<pre><code># first integer
s/^.o*/&lt;&amp;&gt;/
# find each item
:a
s/&gt;z\(.o*\)/&gt;&lt;\1&gt;/
ta
# below: to decimal
:b
# to zero
s/z&gt;/0&gt;/g
# minus sign
y/z/-/
# to decimal others
# m letter indicates that converting a digit is done
s/oooooooooo/x/g
s/ooooooooo/m9/g
s/oooooooo/m8/g
s/ooooooo/m7/g
s/oooooo/m6/g
s/ooooo/m5/g
s/oooo/m4/g
s/ooo/m3/g
s/oo/m2/g
s/o/m1/g
# not converted yet? then to 0
s/x\([^xm]\)/x0\1/g
s/m//g
y/x/o/
# repeat until every unary is converted
tb
</code></pre>
</div>
<div id="pu2" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="nofollow noreferrer">Jelly</a>, 15 bytes</h1>
<pre><code>Ż¬&lt;\œp$ḊLCṛ¡ḢƊ€
</code></pre>
<p><a href="https://tio.run/##y0rNyan8///o7kNrbGKOTi5Qebijy8f54c7ZhxY@3LHoWNejpjX/bR81zDU83O6tAuRE/v@vZKiko2QAwoYglqGhAZQygFIwLpQBEoHxDCDAEKIbpBUKDOAsmIAhugCGCC6VuAHM2gEESgA" rel="nofollow noreferrer" title="Jelly – Try It Online">Try it online!</a></p>
<p>Although it's something of an improvement over the previous solution, this feels clumsy. (Though not as clumsy now that it doesn't use <code>k</code>.)</p>
<p>Input as a list of zeroes and ones.</p>
<pre><code>Ż                  Prepend a leading zero to the input.
 ¬                 Flip 0 &lt;-&gt; 1.
    œp$            Split that around the corresponding locations of truthy elements of
  &lt;\               it cumulatively reduced by greater than.
       Ḋ           Remove the leading empty slice,
             Ɗ€    then for each remaining slice:
        L          take the length,
         C         and subtract it from 1
           ¡       a number of times equal to
          ṛ Ḣ      the first element.
</code></pre>
</div>
<div id="pu3" class="pu"><h1>QBasic, <s>88</s> 86 bytes</h1>

<pre><code>1u$=INPUT$(1)
z=u$&lt;"1
IF n*z THEN?(1-2*s)*(n-s):s=0:n=0ELSE s=s-z:n=n+1
IF"!"&lt;u$GOTO 1
</code></pre>

<p>This was fun. Multiple revisions starting from a 107-byte version resulted in one of the most obfuscated bits of QBasic I think I've ever written. <em>(Edit: Oddly enough, I was able to golf 2 bytes by making the code clearer.)</em></p>

<p>Note: this program reads user input one character at a time without echoing it to the screen (a result of using <code>INPUT$(1)</code> instead of the usual <code>INPUT</code> statement). So as you're typing, you won't see the 1's and 0's, but the decimal numbers will appear as they are calculated. Make sure to hit <kbd>Enter</kbd> at the end of the input to see the last number and end the program.</p>

<h3>Ungolfed version</h3>

<pre><code>sign = 0
num = 0
DO
  digit$ = INPUT$(1)
  isZero = (digit$ &lt; "1")
  IF num &gt; 0 AND isZero THEN
    PRINT (1 - 2 * sign) * (num - sign)
    sign = 0
    num = 0
  ELSE
    IF isZero THEN sign = 1
    num = num + 1
  END IF
LOOP WHILE "!" &lt; digit$
</code></pre>

<h3>Explanation</h3>

<p>(AKA "What?? That still makes no sense!")</p>

<p>The base strategy is to run a loop that grabs one character from <code>INPUT$(1)</code> each time through, does stuff with it, and keeps looping as long as the character has an ASCII value greater than that of <code>!</code> (i.e., wasn't a newline).</p>

<p>We keep track of numbers-in-progress using two variables. <code>num</code> is the number of characters in the current signed unary number (including any leading zero). <code>sign</code> is <code>1</code> if the number had a leading zero, <code>0</code> if not. Both of these need to be initialized to <code>0</code>, which is great for the golfed version because numeric variables in QBasic are automatically initialized to <code>0</code>.</p>

<p>Whenever we read a character, the first thing is to determine whether it's <code>1</code> or <code>0</code>. We'll use this result twice, so we store it in <code>isZero</code>. Technically, that name is misleading, since the value will also be truthy if the character is a newline. Note that truthy in QBasic is <code>-1</code> and falsey is <code>0</code>.</p>

<p>Now, if we're in the middle of reading a number (<code>num &gt; 0</code>) and we hit a zero or end of input (<code>isZero</code>), we need to calculate which number we've finished reading.</p>

<ul>
<li><code>sign</code> stores <code>0</code> for positive, <code>1</code> for negative. To get <code>1</code> for positive and <code>-1</code> for negative, we need <code>1-2*sign</code>.</li>
<li><code>num</code> stores the correct magnitude for positives but one more than the magnitude for negatives (since it includes the sign marker). So we can use <code>num-sign</code> for the magnitude.</li>
</ul>

<p>Multiply these together and print; then reset <code>sign</code> and <code>num</code> to <code>0</code> in preparation for reading the next number.</p>

<p>Otherwise (if we haven't hit a zero, or if we've hit a zero at the beginning of a number), we update <code>sign</code> and <code>num</code> as follows:</p>

<ul>
<li><code>sign</code> becomes <code>1</code> if we're looking at a leading zero; otherwise, if we're looking at a one, it stays at whatever it already was. The golfed code is <code>s=s-z</code>, which amounts to the same thing:

<ul>
<li>If this is a leading zero, <code>z</code> is <code>-1</code>. Since <code>s</code> is guaranteed to be <code>0</code> (because this is the start of a new number), <code>s-z</code> will be <code>1</code>.</li>
<li>If this is a one, <code>z</code> is <code>0</code>. Then <code>s-z</code> stays at whatever value <code>s</code> had previously.</li>
</ul></li>
<li><code>num</code> is incremented.</li>
</ul>

<p>That's it!</p>
</div>
<div id="pu4" class="pu"><h1><a href="https://docs.python.org/2/" rel="nofollow noreferrer">Python 2</a>, <s>73</s> 70 bytes</h1>

<p>A function that takes a string as input and returns a string representation of a Python list. Zero can be represented both by <code>0</code> and <code>-0</code> (when it comes last):</p>



<pre class="lang-python prettyprint-override"><code>lambda s:`map(len,s.split('0'))`.replace('0, ','-').replace('--','0,')
</code></pre>

<h3>Explanation</h3>

<ol>
<li><a href="https://docs.python.org/2/library/stdtypes.html#str.split" rel="nofollow noreferrer"><code>split</code></a> the input string <code>s</code> on zeroes.</li>
<li>Take the <a href="https://docs.python.org/2/library/functions.html#len" rel="nofollow noreferrer">length</a> of each string in the resulting list (using <a href="https://docs.python.org/2/library/functions.html#map" rel="nofollow noreferrer"><code>map</code></a>).</li>
</ol>

<p>That takes us a long way. Zeroes were separators after all. And the numbers were unary, so <code>len</code> conveniently converts those to decimal. But now we've messed up all the non-separator uses of <code>0</code>. Luckily, all non-separator uses were leading zeroes so they came after a separator-zero and gave us zero-length strings (<code>'00'.split('0') == ['', '', '']</code>). Those zero-length strings then also became <code>0</code> because of the <code>len</code>.</p>

<ol start="3">
<li>Turn the list into a string (<a href="https://docs.python.org/2/library/functions.html#repr" rel="nofollow noreferrer">using "reverse quotes"</a>), so we can fix up the mess more easily.</li>
<li><a href="https://docs.python.org/2/library/string.html#string.replace" rel="nofollow noreferrer"><code>replace</code></a> each zero that precedes another number by a negative sign on that number instead. That fixes the use of <code>0</code> as a sign but it breaks the literal zeroes. Literal zeroes were also preceded by a separator, so they've now become pairs of extra dashes on the next number.</li>
<li><code>replace</code> each <code>--</code> back into a <code>0</code> element in the "list".</li>
</ol>
</div>
<div id="pu5" class="pu"><h1><a href="https://github.com/dloscutoff/Esolangs/tree/master/Acc!!" rel="nofollow noreferrer"><em>Acc!!</em></a>, <s>252</s> 237 bytes</h1>

<pre><code>N
Count i while _/48 {
Count n while 48/_ {
Write 45
50+N
}
_+49/_*50
Count u while _%50/49 {
_+100-_%50+N
}
_/50-1
Count h while _/200 {
Write _/200+48
_%200+1
}
Count t while _/20+_%2 {
Write _/20+48
_%20-_%2
}
Write _/2+48
Write 9
N
}
</code></pre>

<p>Uses <code>-0</code>. Outputs numbers separated by tab characters, with a trailing tab. <a href="https://tio.run/##VY4xC8MgEIV3f4VLlkrwGRR07p61ozShEKGkUAwdQn@7PauRdjnuvXvf3V3neZpSGtn5sa2RB/5awv3GvdSW79Vcq6mt9GReniGSMMxAjOzNvNBO@pNBjW/Hjs5AakeEFwrosy6ANOhVTS/t4gC07V8ltGW@y40iqsTjT1zQ8I84ADo1ENEG2S/CMXogJUAplQuoAB8" rel="nofollow noreferrer" title="Acc!! – Try It Online">Try it online!</a></p>

<p><sup>Amount of time writing the actual algorithm: 20 minutes. Amount of time debugging my decimal output code: 45 minutes. :^P</sup></p>

<h3>With comments</h3>

<p>I don't know if these comments explain the code very well--they're based on my notes to myself while I was writing it, so they assume some understanding of how <em>Acc!!</em> works. If anything needs more explanation, let me know and I'll try to make it clearer.</p>

<pre><code># We partition the accumulator _ as [number][flag][nextchar]
# [flag] is a 2-value slot and [nextchar] a 50-value slot
# So [nextchar] is _%50, [flag] is _/50%2, [number] is _/100
# [flag] is 1 if we're in the middle of reading a number, 0 if we're between numbers
# It is also used for outputting as decimal (see below)
# Possible input characters are 0, 1, and newline, so [nextchar] is 48, 49, or 10

# Read the first character
N
# Loop while the character we just read is 0 or 1 and not newline
Count i while _/48 {
  # What we do in the loop depends on the combination of [flag] and [nextchar]:
  # 0,48 (start of number, read 0) =&gt; write minus sign, [flag] = 1, read another char
  # _,49 (read 1) =&gt; increment [number], [flag] = 1, read another char
  # 1,48 (middle of number, read 0) =&gt; write/clear [number], status = 0, read another
  #      char
  # 1,10 (middle of number, read &lt;cr&gt;) =&gt; ditto; the next read will be 0 for eof, which
  #      means the acc will be less than 48 and exit the loop

  # Process leading 0, if any
  Count n while 48/_ {
    # acc is 48: i.e. [number] is 0, [flag] is 0, [nextchar] is 48 (representing a 0)
    # Output minus sign
    Write 45
    # Set [flag] to 1 (thereby exiting loop) and read [nextchar]
    50+N
  }
  # If number starts with 1, then we didn't do the previous loop and [flag] is not set
  # In this case, acc is 49, so we add (50 if acc &lt;= 49) to set [flag]
  _+49/_*50

  # Process a run of 1's
  Count u while _%50/49 {
    # [nextchar] is 49 (representing a 1)
    # Increment [number] and read another
    _+100-_%50+N
  }

  # At this stage, we know that we're at the end of a number, so write it as decimal
  # This is "easier" (ha) because the number has at most three digits
  # We shift our partitioning to [number][flag] and set [flag] to 0
  _/50-1

  # Output hundreds digit if nonzero
  # Since [number] is _/2, the hundreds digit is _/200
  Count h while _/200 {
    Write _/200+48
    # Mod 200 leaves only tens and units; also, set [flag] to 1
    _%200+1
  }
  # Output tens digit (_/20) if nonzero OR if there was a hundreds digit
  # In the latter case, [flag] is 1
  Count t while _/20+_%2 {
    Write _/20+48
    # Mod 20 leaves only units; clear [flag] if it was set
    _%20-_%2
  }
  # Write units unconditionally
  Write _/2+48

  # Write a tab for the separator
  Write 9
  # Read another character
  N
}
</code></pre>
</div>
<div id="pu6" class="pu"><h1><a href="https://github.com/m-ender/retina" rel="nofollow noreferrer">Retina</a>, <s>23</s> 21 bytes</h1>

<pre><code>(.)0
$1 
01
-1
1+
$.&amp;
</code></pre>

<p><a href="https://tio.run/##K0otycxL/P9fQ0/TgEvFUIHLwJBL15DLUJtLRU/t/39DLgOgCJBvaAAmDMAEhAmmQDwI2wACDEHqQcqhwADOggkYogtgiOBSiRsAAA" rel="nofollow noreferrer" title="Retina – Try It Online">Try it online!</a></p>

<p>The first stage <code>(.)0&lt;newline&gt;$1&lt;space&gt;</code> matches any character followed by a <code>0</code>. The match is replaced by the first character followed by a space. This splits the string in the individual numbers.</p>

<p>The second stage <code>01&lt;newline&gt;-1</code> replaces <code>0</code>'s before a block of <code>1</code>'s to to the <code>-</code> sign.</p>

<p>The last stage <code>1+&lt;newline&gt;$.&amp;</code> matches all blocks of <code>1</code>'s and replaces them with the length of the group.</p>

<p><a href="https://tio.run/##K0otycxL/P/fKkFDT9OAS8VQgcsqwcCQS9eQy1CbS0VP7f9/Q0NDAwMQNjAEAA" rel="nofollow noreferrer">Here</a> is an example with the output of the individual stages.</p>
</div>
<div id="pu7" class="pu"><h1><a href="https://www.lua.org" rel="nofollow noreferrer">Lua</a>, 58 bytes</h1>



<pre class="lang-lua prettyprint-override"><code>(...):gsub("(0?)(1*)0?",function(s,n)print(#n-2*#s*#n)end)
</code></pre>

<p><a href="https://tio.run/##yylN/P9fQ09PT9Mqvbg0SUNJw8BeU8NQS9PAXkknrTQvuSQzP0@jWCdPs6AoM69EQzlP10hLuVhLOU8zNS9F8////waGQAAmwAw4CyZgiC6AIYJLJW4AAA" rel="nofollow noreferrer" title="Lua – Try It Online">Try it online!</a></p>

<p>Full program, takes input from the command line and prints the numbers to stdout separated by newlines.</p>
</div>
<div id="pu8" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="nofollow noreferrer">Jelly</a>, <s> 19 </s> 18 <a href="https://github.com/DennisMitchell/jelly/wiki/Code-page" rel="nofollow noreferrer">bytes</a></h1>
<p><sup>There must be a better way...</sup></p>
<pre><code>®ḢN$Ḣ©?ṄEȧ
ṣ0L€ÇL¿
</code></pre>
<p>A full program printing each number followed by a linefeed.</p>
<p><strong><a href="https://tio.run/##y0rNyan8///Quoc7FvmpAIlDK@0f7mxxPbGc6@HOxQY@j5rWHG73ObT/////0QY6CoZICI2LJoVHFpcWQ9K1kKGLWrZTE8UCAA" rel="nofollow noreferrer" title="Jelly – Try It Online">Try it online!</a></strong></p>
<h3>How?</h3>
<pre><code>®ḢN$Ḣ©?ṄEȧ - Link 1, print first number and yield next input: list of numbers, X
           -                              e.g. [8,0,15,16,...] or [0,4,8,0,15,16,...]
      ?    - if...
    Ḣ      - condition: yield head and modify  8([0,15,16,...])   0([4,8,0,15,16,...])  
     ©     -            (copy to register)     8                  0
®          - then: recall from the register    8
   $       - else: last two links as a monad:
 Ḣ         -         yield head and modify                        4([8,0,15,16,...])
  N                  negate                                      -4
       Ṅ   - print that and yield it           8                 -4
        E  - all equal (to get 0 to be truthy) 1                  1
         ȧ - AND the (modified) input          [0,15,16,...]      [8,0,15,16,...]
           -   (ready to be the input for the next call to this link)

ṣ0L€ÇL¿ - Main link: list e.g. [0,1,0,0,0,0,1,1]
ṣ0      - split at zeros       [[],[1],[],[],[],[1,1]
  L€    - length of €ach       [0,1,0,0,0,2]
      ¿ - while...
     L  - condition: length                           1  1  1  0  ([0,1,0,0,0,2], [0,0,0,2], [0,2], [])
    Ç   - action: call the last link (1) as a monad  -1  0 -2     ( - 1            - 0        - 2)
</code></pre>
</div>
<div id="pu9" class="pu"><h1><a href="https://github.com/barbuz/Husk" rel="nofollow noreferrer">Husk</a>, <s>20 18 17 15</s> 14 bytes</h1>

<pre><code>Γ~:?Σṁ_Πȯ₀tΣġ/
</code></pre>

<p><a href="https://tio.run/##yygtzv7//9zkOiv7c4sf7myMP7fgxPpHTQ0l5xYfWaj/////aAMdQyhEsBAimGLoKgwJqiCshlQzyYCxAA" rel="nofollow noreferrer" title="Husk – Try It Online">Try it online!</a></p>

<h2>Explanation</h2>

<pre><code>Γ~:?Σṁ_Πȯ₀tΣġ/  Input is a list, say x = [0,1,1,0,0,0,1,1]
            ġ   Group by
             /  division.
                This splits x right before each 0: [[0,1,1],[0],[0],[0,1,1]]
Γ               Deconstruct into head y = [0,1,1] and tail z = [[0],[0],[0,1,1]]
   ?Σṁ_Π        Apply to y:
       Π         Product: 0
   ?Σ            If that is nonzero, take sum of y,
     ṁ_          else take sum of negated elements of y: u = -2
        ȯ₀tΣ    Apply to z:
           Σ     Concatenate: [0,0,0,1,1]
          t      Drop first element: [0,0,1,1]
         ₀       Recurse: [0,2]
 ~:             Tack u to the front: [-2,0,2]
</code></pre>

<p>The splitting works like this.
<code>ġ/</code> splits its argument between each pair of elements <code>a,b</code> for which <code>/a b</code> is falsy.
<code>/a b</code> is division with flipped arguments, so <code>b</code> divided by <code>a</code>.
The relevant values in this program are these:</p>

<ul>
<li><code>/1 1</code> gives <code>1</code> (truthy).</li>
<li><code>/1 0</code> gives <code>0</code> (falsy).</li>
<li><code>/0 1</code> gives <code>Inf</code> (positive infinity, truthy).</li>
<li><code>/0 0</code> gives <code>Any</code> (a special NaN-like value, falsy).</li>
</ul>
</div>
<div id="pu10" class="pu"><h1><a href="https://www.perl.org/" rel="nofollow noreferrer">Perl 5</a>, 40 + 1 (<code>-n</code>) = 41 bytes</h1>



<pre class="lang-perl prettyprint-override"><code>print'-'x/00/.y/1//.$"for"0$_"=~/00?1*/g
</code></pre>

<p><a href="https://tio.run/##K0gtyjH9/7@gKDOvRF1XvULfwEBfr1LfUF9fT0UpLb9IyUAlXsm2Dihsb6iln/7/v6GhoYEBCBsY/ssvKMnMzyv@r@trqmdgaPBfNw8A" rel="nofollow noreferrer" title="Perl 5 – Try It Online">Try it online!</a></p>
</div>
<div id="pu11" class="pu"><h1><a href="https://www.r-project.org/" rel="nofollow noreferrer">R</a>, 119 bytes</h1>



<pre class="lang-r prettyprint-override"><code>function(x){n=nchar
y=regmatches(x,regexec("(0?)(1*)0?([01]*)",x))[[1]]
cat((-1)^n(y[2])*n(y[3]),"")
if(y[4]&gt;0)f(y[4])}
</code></pre>

<p><a href="https://tio.run/##dY3BCgIhEIbvPsacZsRAq6vtg4iBiLZ7yMAMXKJnN9uoQ7H/Yeb7PwYmt6pBqp5lLPClj1C/4s@sXa4HWNQt3pIv0yVhpXvSyY8us1nncDq74sdwxSp6CTV4BJQDoeIkBzRSWU4gKpExylrmXUHcKDomnM3WEn/tnSUBQGyKveztQdIb6NFif9ie" rel="nofollow noreferrer" title="R – Try It Online">Try it online!</a></p>

<p>The code uses <a href="https://stackoverflow.com/a/16563900">this solution from stackoverflow</a> for a related problem (Thanks to jeales for the idea). The output is a space-separated string printed to stdout.</p>
</div>
<div id="pu12" class="pu"><h1><a href="https://docs.python.org/2/" rel="nofollow noreferrer">Python 2</a>, <s>96</s> 92 bytes</h1>



<pre class="lang-python prettyprint-override"><code>lambda s:[[len(t),-len(t)+1]['1'&gt;t]for t in s.replace('10','1 ').replace('00','0 ').split()]
</code></pre>

<p><a href="https://tio.run/##dcxBDoIwEAXQtZyiu2ljNTMuSWTJJZAFCo0ktTS0G09faUBKNMzm/7403779czCXoK63oJvXvW2Yy6tKd4Z7IU9zHqmugKDwtRpG5llvmDuPndXNo@NACBKIgUiEkTCSs7r3XNSh7RQruRN5drBjbzxzEq4FSDVZlpXTDIgYuAQtbyJMDVPbYOrRN4Dz0ToZx5bDtX2BfuFP9n7uH4jwAQ" rel="nofollow noreferrer" title="Python 2 – Try It Online">Try it online!</a></p>

<p>Thx to ovs and DLosc for 2 bytes each.</p>
</div>
<div id="pu13" class="pu"><h1>JavaScript (ES6), 60 bytes</h1>

<p>Returns a space-separated list of integers.</p>

<pre class="lang-js prettyprint-override"><code>s=&gt;(0+s).replace(/00?1*/g,s=&gt;(l=s.length,+s[1]?l-1:2-l)+' ')
</code></pre>

<h3>Test cases</h3>

<p><div class="snippet" data-lang="js" data-hide="true" data-console="true" data-babel="false">
<div class="snippet-code snippet-currently-hidden">
<pre class="snippet-code-js lang-js prettyprint-override"><code>let f =

s=&gt;(0+s).replace(/00?1*/g,s=&gt;(l=s.length,+s[1]?l-1:2-l)+' ')

console.log(f("1")) // 1
console.log(f("0")) // 0
console.log(f("011")) // -2
console.log(f("1101")) // 2,1
console.log(f("1100")) // 2,0
console.log(f("11001")) // 2,-1
console.log(f("110001")) // 2,0,1
console.log(f("11100110001")) // 3,-2,0,1
console.log(f("00000001")) // 0,0,0,-1
console.log(f("01111011111111001111111111111110111111111111111100111111111111111111111110111111111111111111111111111111111111111111")) // -4,8,-15,16,-23,42
console.log(f("01111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111")) // -127</code></pre>
</div>
</div>
</p>
</div>
<div id="pu14" class="pu"><h1><a href="https://www.haskell.org/" rel="noreferrer">Haskell</a>, <s>68</s> 66 bytes</h1>



<pre class="lang-hs prettyprint-override"><code>f(x:r)|(a,b)&lt;-span(&gt;0)r=([(0-),(1+)]!!x$sum a):[z|_:t&lt;-[b],z&lt;-f t]
</code></pre>

<p><a href="https://tio.run/##dUvLCoMwELz7FSv0kFAju1dRv6B/IFIija1UQ4gRRPz31EfbQ4sDOzs7M/uQ/VO1rfc1GxPLZyajiqeiN1KzHLnNWMFQ8IjRmZdhOJ76oQPJk2Kar4lLRVGV0ZSKGlzpO9loyOCu3KXRCvI8A2Mb7SCGeplOGmaVvMVmsIovMawPngIMkCggwo1wo11ua712jTto7a/1N/CrPgb9Gn/OUfMYLw" rel="noreferrer" title="Haskell – Try It Online">Try it online!</a> Takes input as a list of zeros and ones. Example usage: <code>f [0,0,0,1,1]</code> yields <code>[0,-2]</code>.</p>

<p><strong>Explanation:</strong></p>

<p>The pattern matching in <code>f(x:r)|(a,b)&lt;-span(&gt;0)r</code> binds <code>x</code> to the first element of the input, <code>a</code> to a (potentially empty) list of following <code>1</code>s, and <code>b</code> to the rest of the input. Given an input <code>[0,1,1,1,0,0,1]</code>, we get <code>x=0</code>, <code>a=[1,1,1]</code> and <code>b=[0,0,1]</code>. </p>

<p>The current number is then either the sum of <code>a</code> negated if <code>x=0</code>, or the sum of <code>a</code> plus one if <code>x=1</code>. This is achieved by indexing with <code>x</code> into a list containing a negation and increment function, and applying the resulting function to the sum of <code>a</code>: <code>[(0-),(1+)]!!x$sum a</code>.</p>

<p>The rest list <code>b</code> is either empty or contains a separating zero and the next number. The list comprehension <code>[z|_:t&lt;-[b],z&lt;-f t]</code> tries to match <code>b</code> on the pattern <code>_:t</code>, that is forget the head element and bind the rest of the list to <code>t</code>. If <code>b</code> is empty this match fails and the list comprehension evaluates to <code>[]</code>, which is the base case for the recursion. Otherwise the function <code>f</code> is recursively applied to <code>t</code> and the list comprehension evaluates to all elements <code>z</code> from the result of <code>f t</code>.</p>
</div>
<div id="pu15" class="pu"><h1><a href="https://github.com/DJMcMayhem/Brain-Flak" rel="nofollow noreferrer">Brain-Flak</a>, 94 (70?) bytes</h1>

<pre><code>([]){{}({(&lt;()&gt;)()}{}(&lt;&gt;)&lt;&gt;{&lt;([{}]&lt;&gt;{})&gt;&lt;&gt;})
{{}&lt;&gt;([{}])(&lt;&gt;)}{}{}([])}{}&lt;&gt;([]){{}({}&lt;&gt;)&lt;&gt;([])}&lt;&gt;
</code></pre>

<p><a href="https://tio.run/##nYwxCoAwDEWv4pgMgt1DLlI61EEQxcE15Ow1rYWCDkX5y8/j/cxnXI9x2eOWEviAIgoCBMgIqHYQI7EQeNFgRZGJNWvEhWE2TDTV5nrz@kfLuHDilKbB1bTWyJs9Ddc1@s7Xnz9yAQ" rel="nofollow noreferrer" title="Brain-Flak – Try It Online">Try it online!</a></p>

<p>This is actually surprisingly terse for brain-flak.</p>

<p>Here is a commented/readable version:</p>

<pre><code>([])

{

    #Pop the Stack height
    {}

    (
        #If there isn't a leading 0, evaluate to 1...
        {
            (&lt;()&gt;)

            ()
        }

        #Pop the 0
        {}

        #Push a 0 onto the alternate stack
        (&lt;&gt;)
        &lt;&gt;

        #Run of '1's
        {
            #Decrement the alternate stack
            &lt;([{}]&lt;&gt;{})&gt;
            &lt;&gt;
        }

        #And push it here
    )

    #Was there a not leading 0?

    {
        {}

        #Invert the value on the alternate stack
        &lt;&gt;([{}])(&lt;&gt;)
    }

    #Pop 2 zeros
    {}{}


    ([])

}{}&lt;&gt;

#Push stack height
([])

#Reverse the stack
{

    {}

    ({}&lt;&gt;)

    &lt;&gt;([])

}&lt;&gt;
</code></pre>

<p>If the output can be in reverse, we can do this for 70 instead:</p>

<pre><code>([]){{}({(&lt;()&gt;)()}{}(&lt;&gt;)&lt;&gt;{&lt;([{}]&lt;&gt;{})&gt;&lt;&gt;}){{}&lt;&gt;([{}])(&lt;&gt;)}{}{}([])}&lt;&gt;
</code></pre>

<p><a href="https://codegolf.stackexchange.com/a/146444/31716">This tip of mine</a> is <em>almost</em> perfect for this situation. But it doesn't quite work since we have to push a 0 before doing the operation (counting the '1's), and the operation happens in a loop. The shortest I could come up with utilizing this tip is:</p>

<pre><code>([]){{}({(&lt;()&gt;)()}{}(&lt;&gt;)&lt;&gt;{&lt;([{}]&lt;&gt;{})&gt;&lt;&gt;})
{{}&lt;&gt;([{}])(&lt;&gt;)}{}{}(&lt;&gt;())&lt;&gt;([])}{}&lt;&gt;{{}({}&lt;&gt;)&lt;&gt;}&lt;&gt;
</code></pre>

<p>which is also 94 bytes.</p>
</div>
<div id="pu16" class="pu"><h1><a href="https://www.wolfram.com/wolframscript/" rel="nofollow noreferrer">Wolfram Language (Mathematica)</a>, 80 bytes</h1>
<pre><code>StringCases[#&lt;&gt;&quot;0&quot;,x_~~Shortest@y___~~&quot;0&quot;:&gt;(If[x==&quot;0&quot;,-#,#+1]&amp;)@StringLength@y]&amp;
</code></pre>
<p><a href="https://tio.run/##y00syUjNTSzJTE78n2b7P7ikKDMv3TmxOLU4WtnGTslASacivq4uOCO/qCS1uMShMj4eyAUKW9lpeKZFV9jagpToKusoaxvGqmk6QPT7pOall2Q4VMaq/Q8A8ksctNL0Haq5uJQMlXS4QBqAhCGYbWhoAKMNYDRcAMYCicG5BhBgCDUEZAAUGMBZMAFDdAEMEVwqcQMlLq7a/wA" rel="nofollow noreferrer" title="Wolfram Language (Mathematica) – Try It Online">Try it online!</a></p>
<p>Abuses the mechanic of <code>StringCases</code>, since it does not check overlapping patterns. Since we search from left to right, without overlaps, we always get only the integers we need.</p>
<h2>Explanation</h2>
<pre><code>#&lt;&gt;&quot;0&quot;
</code></pre>
<p>Append a zero at the end</p>
<pre><code>StringCases
</code></pre>
<p>Find all of the following pattern...</p>
<pre><code>x_~~Shortest@y___~~&quot;0&quot;
</code></pre>
<p>A single character (call it <code>x</code>), followed by the shortest possible zero-length or longer string (call it <code>y</code>), followed by a zero.</p>
<pre><code>(If[x==&quot;0&quot;,-#,#+1]&amp;)@StringLength@y
</code></pre>
<p>Apply to matching pattern: take the length of <code>y</code>. If <code>x</code> is zero, then negate the value. Else, increment one.</p>
<p>This covers <code>00</code> as well, since <code>y</code> would be an empty string, and we would compute <code>-0</code> (<code> == 0</code>).</p>
</div>
<div id="pu17" class="pu"><h1>Vim, 56 bytes</h1>

<pre><code>:s/\v(0?1*)0?/\1\r/g|%s/0/-/|%s/1*$/\=len(submatch(0))
D
</code></pre>

<p><a href="https://tio.run/##K/v/36pYP6ZMw8DeUEvTwF4/xjCmSD@9RrVY30BfVx9EG2qp6MfY5qTmaRSXJuUmliRnaBhoanK5/P9vAAGGAA" rel="noreferrer" title="V – Try It Online">Try it online!</a></p>

<p>I haven't posted in vim in a while. I'm mostly using vim because V is a pain sometimes. Because the <code>count</code> command, which is perfect for getting the number of '1's on the line will overwrite any '0's on the line, so we can't negate it afterwards.</p>

<p>Explanation:</p>

<p>This is one byte shorter then the straightforward way:</p>

<pre><code>:s/\v(0?1*)0?/\1\r/g
:%s/0/-
:%s/1*$/\=len(submatch(0))
D
</code></pre>

<p>due to command chaining. Since that one separates the commands, I'll use it for the explanation.</p>

<pre><code>:s/                     " Substitute
                        " Search for...
   \v                   "   Enable 'magic'. This determines whether certain atoms require a backslash or not.
                        "   Without it we would have: '\(0\?1*\)0\?', which is 2 bytes longer
      0?                "   An optional 0
        1*              "   Followed by any number of '1's
     (    )             "   (call that group 1)
           0?           "   Followed by another optional 0
             /          " Replace it with...
              \1        "   Subgroup 1
                \r      "   A newline
                  /g    " Do this for every match on the current line.
</code></pre>

<p>Now, each signed unary number is on an individual line. Using '11100110001' as an example, at this point we'll have:</p>

<pre><code>111
011
0
1

:%s/0   " Replace every 0
     /- " With a dash  

:%s/1*$/                    " Replace every run of 1's at the end of a line
        \=len(submatch(0))  " With the length of said run
</code></pre>

<p>Since we added newlines at the end of each match, we had an empty line before running that. After running that, we'll have a '0' (because it matched a run of 0 '1's). So we just call <code>D</code> to delete this line, leaving it blank</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/150775/">150775</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




