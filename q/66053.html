<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::66053</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>186</td><td>Haskell + hgl</td><td>240404T012635Z</td><td><a href="https://codegolf.stackexchange.com/questions/66053/xu-ti-te-gismytermorna-is-it-a-valid-gismu/272315#272315">Wheat Wi</a></td></tr>
<tr d-ix="1"><td>240</td><td>Javascript ES6</td><td>160413T223843Z</td><td><a href="https://codegolf.stackexchange.com/questions/66053/xu-ti-te-gismytermorna-is-it-a-valid-gismu/77748#77748">Mama Fun</a></td></tr>
<tr d-ix="2"><td>252</td><td>Ruby</td><td>151209T110231Z</td><td><a href="https://codegolf.stackexchange.com/questions/66053/xu-ti-te-gismytermorna-is-it-a-valid-gismu/66109#66109">Level Ri</a></td></tr>
<tr d-ix="3"><td>352</td><td>JavaScript ES6</td><td>151209T020321Z</td><td><a href="https://codegolf.stackexchange.com/questions/66053/xu-ti-te-gismytermorna-is-it-a-valid-gismu/66094#66094">user8165</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://www.haskell.org" rel="nofollow noreferrer">Haskell</a> + <a href="https://gitlab.com/wheatwizard/haskell-golfing-library" rel="nofollow noreferrer">hgl</a>, 186 bytes</h1>
<pre class="lang-haskell prettyprint-override"><code>c=&quot;[^aeiou]&quot;
v=&quot;[aeiou]&quot;
</code></pre>
<pre><code>cP$rXw(yS hdS)$fo[&quot;([mpbkgfvcsx][lr]|[cs][mnptkf]|[jz][mbdgv]|t[csr]|d[jzr])&quot;,v,c,v,&quot;|&quot;,c,v,&quot;([cjsz]{2}|x[kc]|[kc]x|mz|/p)!([ptkfcsxlmnr]{2}|[bdgvjzlmnr]{2})&quot;,v]
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=XVBBTsMwEBTXvGKxemilVkicECIvQKoq9QKyjOQ6duskjo1jhxDCiWdw6QXxCV7AD8prcNsYEAfbM7PrGXtf3ze0LnhZbneXUhltHdx7WkoheQYLy0uf8WQoLJLZDObaga6AOp08LiEFsYLPlzfvxOxi98FShO8ol9oTlDSBRCxSthjZm4dxuLPJlpOR0BiNsTKrYi0aVrcEl5b0mNUEq8q4QgSSd4GssnVDehcqoZ4FzZIJmjZTFhbq0fEcY5bXHXk6f-5bXLBwN2xtr7r-zExOx3hvGEJKVdlDE9675l3ke0Ny_MPXybXjtbuFNAHAgNayVh4FPAXEhDQRW1q1csDKm0pHXao1H3Cn65YO2HlVH_pJkuwD5jGA55aqoamVTrsBZ-6PKaM2mprW59GUcdf434AuPugw9QEXlOW_j2iLHx9fVT8-jBYxq9TORd0EOXoW3Ds9fEBRWaWZDsRYGIGAKzgM7b8wP850uz2e3w" rel="nofollow noreferrer">Attempt This Online!</a></p>
<h1>Without regex, 189 bytes</h1>
<pre class="lang-haskell prettyprint-override"><code>y=jzW(p2**).*wR
v=xys W5
c=xys d
d=&quot;ptkfcsxlmnr bdgvjzlmnr&quot;
</code></pre>
<pre><code>cP$fo[asy$y&quot;mpbkgfvcsx cs jz t d&quot;&quot;lr mnptkf mbdgv csr jzr&quot;,v,c,v]++fo[c,v,asy$cX(y d d)$zW p2 d d&lt;&gt;y&quot;cjsz x kc m&quot;&quot;cjsz kc x z&quot;,v]
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=ZZDBjtMwEIbF1U8xsnrY7aZ7WAmJQ8KJG6iquBRU9eC1neIkjo09Dk5ehUsviMfgOZanwWnjXQQnf_5n_M8__v7zC_Ot7Lrzk1baGofwNbBO1UoK2DnZBSHJf4V3DNn9B-Uxl3Zks4GtQTA9MDQwSiTNtIcKmh7KsoRpT-wDRBiTdIjFePwRsN68efo1Vqnvxj6s17f3628fyVDF0cP-NeEXEERU1GJbcx873Tt4FKehmWakpK74blWbA_PjaqTaPranekiNwD00EyAISjsHup8NQM9PU8mlmqPFUPBiON7dpfcJitmDf7oZQYC4XaXoKW7C8u1IeeOnFL3loOn1kjDClDyWNX6_eo_S42eoCMAB6El5HWjiAiivlc3sWB_VwjrY3mRd6ZNceDI-soUxaH_pPxIyD9jmAbJxTC9NUaHBhQX-ZcqZy6Y2hiabcolDeBkw5UBMKpP1lvHmJURsn31C3z_7cNbmWZ1BzLpNcvZsZUCzLKCZ6ith0sU6WEENJVw-7V9he_3T8_l6_gE" rel="nofollow noreferrer">Attempt This Online!</a></p>
<h2>Explanation</h2>
<p>First we define some helpers. <code>y=jzW(p2**).*wR</code> is the most complex. It's a weird synthetic operation that happens to be useful in this usecase, so it doesn't really have a simple explanation. But you can break it down part by part:</p>
<ul>
<li><p><code>(p2**)</code> takes two lists of characters and creates all strings formed by taking one character from the first and one from the second, so</p>
<pre><code>&gt;&gt;&gt; (p2**) &quot;abc&quot; &quot;ae&quot;
[&quot;aa&quot;,&quot;ae&quot;,&quot;ba&quot;,&quot;be&quot;,&quot;ca&quot;,&quot;ce&quot;]
</code></pre>
</li>
<li><p><code>jzW</code> applies it pairwise to two lists. This allows us to get a bunch of pairs made from combinations of specific sets of characters.</p>
</li>
<li><p><code>(.*wR)</code> makes it so it takes the lists as space separated strings. This is just a denser format than lists of strings.</p>
</li>
</ul>
<p><code>v</code> is relatively simple. It's a parser that parses any vowel, <code>aeiou</code>. Similarly <code>c</code> parses any Lojban consonant (or a space). <code>d</code> is our list of all consonants, it contains a space and some repeats because this format is useful for other things. We can do this since <code>xys</code> basically treats its input as a set and we know the input will never have a space.</p>
<p>Specifically the string is <code>&lt;voiceless consonants&gt;&lt;sonorants&gt; &lt;voiced consonants&gt;&lt;sonorants&gt;</code>.</p>
<p>Now we get into the body, this has the form:</p>
<pre><code>cP$fo[??,v,c,v]++fo[c,v,??,v]
</code></pre>
<p>with the two <code>??</code>s each being replaced with the clustering rules.</p>
<h2>Reflection</h2>
<p>The non-regex answer is <em>so close</em> to beating the regex answer.  I have some improvements:</p>
<ul>
<li>While <code>jzW(p2**).*wR</code> is overly synthetic <code>jzW(p2**)</code> and <code>zW p2</code> are both probably useful.</li>
<li><code>&quot;[aeiou]&quot;</code> is shorter than <code>'[':W5&lt;&gt;&quot;]&quot;</code>. If there were a function, <code>ekQ</code>, to enclose a string in square brackets <code>ekQ W5</code> would be shorter than both.</li>
<li>There should probably be constants for consonants of the ISO alphabet as well as the ones for vowels.</li>
<li>Back-referencing would be useful in the regex answer. It's already a planned feature, there are just technical hurdles on the way to implementing it.</li>
<li>There could be more versatile ways to handle user input parsers. <code>v</code> and <code>c</code> could potentially have been user input parsers if there existed the ability to supply more than one.</li>
<li>Along the lines of that, I could make a way for the user to assign escape sequences in some sort of header string, like <code>rwh&quot;v[aeiou];c[^aeiou]&quot;&quot;/c/v/c/c/v&quot;</code>.</li>
</ul>
</div>
<div id="pu1" class="pu"><h1>Javascript ES6, 240 bytes</h1>
<pre><code>x=&gt;eval(`/${(c='[bcdfgjklmnprstvxz]')+c+(v='[aeiou]')+c+v}/${t='.test(x)'}?/^[bfgkmpvx][lr]|[cs][fklmnprt]|d[jrz]|[jz][bdgmv]/${t}:/${c+v+c+c+v}/${t}?!/^..((.)\\2|${V='[bdgvjz]'}${U='[ptkfcsx]'}|${U+V}|[cjsz][cjsz]|cx|kx|xc|xk|mz)/${t}:!1`)
</code></pre>
<p>I guess this is my work now.</p>
</div>
<div id="pu2" class="pu"><h1>Ruby, <s>302</s> 252 bytes</h1>
<pre><code>c='[cjsztdpbfvkgxmnlr]'
v=c+'[aeiou]'
z=!1
n=/#{c+v+v}/=~(s=gets.chop)*2
(n==0||n==2)&amp;&amp;289.times{|k|q=[i=k%17,j=k/17].max
z||=(x=s[n,2])==c[j+1]+c[i+1]&amp;&amp;['UeUeJOJOJOJOETJ
:'[i].ord-69&gt;&gt;j&amp;1-j/14&gt;0,i!=j&amp;&amp;q&gt;3&amp;&amp;(k%2&lt;1||q&gt;12)&amp;&amp;!'mzxcxkx'.index(x)][n/2]}
p z
</code></pre>
<p>A few more bytes could be saved as follows:</p>
<p>Initialize <code>z</code> to false using <code>z=!c='[cjsztdpbfvkgxmnlr]'</code>. This works but gives the warning <code>warning: found = in conditional, should be ==</code>.</p>
<p>Change from a program to a function (I left it as a program because according to the question, shortest &quot;program&quot; in bytes wins.)</p>
<p><strong>Summary of changes from first post</strong></p>
<p>Major overhaul of regex/matching part.</p>
<p>Constant 72 changed to 69 so that the lowest ASCII code in the magic string is 10 instead of 13. This enables a literal newline to be used in the golfed version instead of an escape sequence.</p>
<p>Magic string <code>'mzxcxkx'</code> replaces arithmetic rules for the 5 prohibited characters in the CVCCV type table.</p>
<p><strong>ungolfed version</strong></p>
<p>added whitespace and changed newline in magic string to a <code>\n</code></p>
<pre><code>c='[cjsztdpbfvkgxmnlr]'                                   #c=consonants
v=c+'[aeiou]'                                             #v=consonant+vowel
z=!1                                                      #Set z to false (everything is truthy in Ruby except nil and false.)
n=/#{c+v+v}/=~(s=gets.chop)*2                             #Get input and duplicate it. do regex match, n becomes the index of the double consonant. 
(n==0||n==2)&amp;&amp;                                            #If n==0 (ccvcv) or n==2 (cvccv) 
   289.times{|k|                                          #iterate 17*17 times
     q=[i=k%17,j=k/17].max                                #generate row and column, find their maximum.
     z||=                                                 #OR z with the following expression:
     (x=s[n,2])==c[j+1]+c[i+1]&amp;&amp;                          #double consonant == the pair corresponding to j,i AND either 
       [&quot;UeUeJOJOJOJOETJ\n:&quot;[i].ord-69&gt;&gt;j&amp;1-j/14&gt;0,       #this expression or
       i!=j&amp;&amp;q&gt;3&amp;&amp;(k%2&lt;1||q&gt;12)&amp;&amp;!'mzxcxkx'.index(x)][n/2]#this expresson, depending on the value of n/2
   }
p z                                                       #print output
</code></pre>
<p><strong>Explanation of matching</strong></p>
<p>The two characters in the input string <code>s[n,2]</code>are compared with the character pair of the iterating loop. If they match and the consonant-vowel regex pattern is correct, the row and column values <code>i,j</code> are checked for validity. Careful ordering of the consonants helps here.</p>
<p>For CVCCV:</p>
<pre><code>i!=j                        It is forbidden for both consonants to be the same
(k%2&lt;1||q&gt;12)               It is forbidden for one consonant to be voiced and the other unvoiced. The consonants “l”, “m”, “n”, and “r” are exempt from this restriction. As a result, “bf” is forbidden, and so is “sd”, but both “fl” and “vl”, and both “ls” and “lz”, are permitted.
q&gt;3                         It is forbidden for both consonants to be drawn from the set “c”, “j”, “s”, “z”.
!'mzxcxkx'.index(x)         The specific pairs “cx”, “kx”, “xc”, “xk”, and “mz” are forbidden.
</code></pre>
<p>For CCVCV</p>
<p>A bitmap for each column of the table below is encoded into the magic string, from which 69 is subtracted. For all columns except the last two, only 6 bits are required. For the last two, the higher order bits need to be 1, so a negative number is generated (characters <code>\n</code> and <code>:</code>) in order to have leading 1's instead of leading zeroes. We don't want to include the last three rows of the table though, so instead of rightshift and ANDing by 1, we rightshift and AND by <code>1-j/14</code> which normally evaluates to 1, but evaluates to 0 for the last 3 rows.</p>
<p>The following program (with the same expressions as the submission) was used to generate the tables below (uncomment whichever <code>if</code> line is required for the table you want.</p>
<pre><code>c='[cjsztdpbfvkgxmnlr]'
z=0
289.times{|k|
  q=[i=k%17,j=k/17].max
  r=c[j+1]+c[i+1]
  #if i!=j &amp;&amp; q&gt;3 &amp;&amp; (k%2&lt;1||q&gt;12) &amp;&amp; !'mzxcxkx'.index(r)
  #if &quot;UeUeJOJOJOJOETJ\n:&quot;[i].ord-69&gt;&gt;j&amp;1-j/14&gt;0
    print r,' '
    z+=1
  else
    print '   '
  end
  i==16&amp;&amp;puts 
}
puts z


            ct    cp    cf    ck       cm cn cl cr
               jd    jb    jv    jg    jm jn jl jr
            st    sp    sf    sk    sx sm sn sl sr
               zd    zb    zv    zg    zm zn zl zr
tc    ts          tp    tf    tk    tx tm tn tl tr
   dj    dz          db    dv    dg    dm dn dl dr
pc    ps    pt          pf    pk    px pm pn pl pr
   bj    bz    bd          bv    bg    bm bn bl br
fc    fs    ft    fp          fk    fx fm fn fl fr
   vj    vz    vd    vb          vg    vm vn vl vr
kc    ks    kt    kp    kf             km kn kl kr
   gj    gz    gd    gb    gv          gm gn gl gr
      xs    xt    xp    xf             xm xn xl xr
mc mj ms    mt md mp mb mf mv mk mg mx    mn ml mr
nc nj ns nz nt nd np nb nf nv nk ng nx nm    nl nr
lc lj ls lz lt ld lp lb lf lv lk lg lx lm ln    lr
rc rj rs rz rt rd rp rb rf rv rk rg rx rm rn rl 
179

            ct    cp    cf    ck       cm cn cl cr
               jd    jb    jv    jg    jm
            st    sp    sf    sk       sm sn sl sr
               zd    zb    zv    zg    zm
tc    ts                                        tr
   dj    dz                                     dr
                                             pl pr
                                             bl br
                                             fl fr
                                             vl vr
                                             kl kr
                                             gl gr
                                             xl xr
                                             ml mr


48
</code></pre>
</div>
<div id="pu3" class="pu"><h1>JavaScript (ES6), <s>366</s> 352 bytes</h1>

<pre class="lang-js prettyprint-override"><code>g=&gt;((q=3,w=2,r=0,f="mzcscjzjxcxkx",c="bdgvjzptkfcsxlmnr",d=[...c],v="aeiou")[m="match"](g[1])?d.map((a,i)=&gt;d.map((b,j)=&gt;a==b|(i&lt;6&amp;j&gt;5&amp;j&lt;13|j&lt;6&amp;i&gt;5&amp;i&lt;13)||f[m](a+b)||(p+=","+a+b)),p="",q=0,r=w--)&amp;&amp;p:"jbl,zbr,tstcl,cmr,cn,cr,jdr,cfl,sfr,jgl,zgr,zdjml,ckl,skr,cpl,spr,sl,sm,sn,sr,ctr,jvl,zvr,xl,xr,dzm")[m](g[r]+g[r+1])&amp;&amp;c[m](g[q])&amp;&amp;v[m](g[w])&amp;&amp;v[m](g[4])
</code></pre>

<h2>Explanation</h2>

<p>Returns an array containing the last letter (truthy) if it is a valid gismu or <code>null</code> if it is not.</p>

<p>A lot of the size comes from the hard-coded <code>CCVCV</code> pairs (even after condensing them). It might be possible to find a pattern to generate them but I've spent way too much time on this already! xD</p>

<pre class="lang-js prettyprint-override"><code>g=&gt;
  (
    // Save the positions to check for the consonant, vowel and pair respectively
    (q=3,w=2,r=0,                       // default = CCVCV format
    f="mzcscjzjxcxkx",                  // f = all forbidden pairs for CVCCV pairs
    c="bdgvjzptkfcsxlmnr",              // c = consonants
    d=[...c],                           // d = array of consonants
    v="aeiou")                          // v = vowels
    [m="match"](g[1])?                  // if the second character is a vowel

      // Generate CC pairs of CVCCV
      d.map((a,i)=&gt;                     // iterate over every possible pair of consonants
        d.map((b,j)=&gt;
          a==b|                         // rule 1: consonants cannot be the same
          (i&lt;6&amp;j&gt;5&amp;j&lt;13|j&lt;6&amp;i&gt;5&amp;i&lt;13)|| // rule 2: pair cannot be voiced and unvoiced
          f[m](a+b)||                   // rule 3 &amp; 4: certain pairs are forbidden
            (p+=","+a+b)                // if it follows all the rules add the pair
        ),
        p="",                           // p = comma-delimited valid CVCCV pairs
        q=0,r=w--                       // update the match positions to CVCCV format
      )&amp;&amp;p
    :
      // CC pairs of CCVCV (condensed so that valid pairs like "jb", "bl" and
      //     "zb" can be matched in this string but invalid pairs like "lz" cannot)
      "jbl,zbr,tstcl,cmr,cn,cr,jdr,cfl,sfr,jgl,zgr,zdjml,ckl,skr,cpl,spr,sl,sm,sn,sr,ctr,jvl,zvr,xl,xr,dzm"

  // Match the required format
  )[m](g[r]+g[r+1])&amp;&amp;c[m](g[q])&amp;&amp;v[m](g[w])&amp;&amp;v[m](g[4])
</code></pre>

<h2>Test</h2>

<p><div class="snippet" data-lang="js" data-hide="true">
<div class="snippet-code snippet-currently-hidden">
<pre class="snippet-code-js lang-js prettyprint-override"><code>var solution = g=&gt;((q=3,w=2,r=0,f="mzcscjzjxcxkx",c="bdgvjzptkfcsxlmnr",d=[...c],v="aeiou")[m="match"](g[1])?d.map((a,i)=&gt;d.map((b,j)=&gt;a==b|(i&lt;6&amp;j&gt;5&amp;j&lt;13|j&lt;6&amp;i&gt;5&amp;i&lt;13)||f[m](a+b)||(p+=","+a+b)),p="",q=0,r=w--)&amp;&amp;p:"jbl,zbr,tstcl,cmr,cn,cr,jdr,cfl,sfr,jgl,zgr,zdjml,ckl,skr,cpl,spr,sl,sm,sn,sr,ctr,jvl,zvr,xl,xr,dzm")[m](g[r]+g[r+1])&amp;&amp;c[m](g[q])&amp;&amp;v[m](g[w])&amp;&amp;v[m](g[4])</code></pre>
<pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;input type="text" id="input" value="gismu" /&gt;
&lt;button onclick="result.textContent=solution(input.value)"&gt;Go&lt;/button&gt;
&lt;pre id="result"&gt;&lt;/pre&gt;</code></pre>
</div>
</div>
</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/66053/">66053</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




