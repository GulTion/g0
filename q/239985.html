<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::239985</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>371</td><td>Python3</td><td>240808T165323Z</td><td><a href="https://codegolf.stackexchange.com/questions/239985/aocg2021-day-22-hyperbolic-rescue/274810#274810">Ajax1234</a></td></tr>
<tr d-ix="1"><td>082</td><td>Perl 5 p</td><td>211222T011921Z</td><td><a href="https://codegolf.stackexchange.com/questions/239985/aocg2021-day-22-hyperbolic-rescue/240010#240010">Anders K</a></td></tr>
<tr d-ix="2"><td>160</td><td>Pari/GP</td><td>211222T043532Z</td><td><a href="https://codegolf.stackexchange.com/questions/239985/aocg2021-day-22-hyperbolic-rescue/240020#240020">alephalp</a></td></tr>
<tr d-ix="3"><td>053</td><td>Retina 0.8.2</td><td>211222T143618Z</td><td><a href="https://codegolf.stackexchange.com/questions/239985/aocg2021-day-22-hyperbolic-rescue/240035#240035">Neil</a></td></tr>
<tr d-ix="4"><td>105</td><td>Wolfram Language Mathematica</td><td>211222T012013Z</td><td><a href="https://codegolf.stackexchange.com/questions/239985/aocg2021-day-22-hyperbolic-rescue/240011#240011">alephalp</a></td></tr>
<tr d-ix="5"><td>139</td><td>Charcoal</td><td>211222T182951Z</td><td><a href="https://codegolf.stackexchange.com/questions/239985/aocg2021-day-22-hyperbolic-rescue/240045#240045">Neil</a></td></tr>
<tr d-ix="6"><td>568</td><td>TypeScript Types</td><td>211222T181205Z</td><td><a href="https://codegolf.stackexchange.com/questions/239985/aocg2021-day-22-hyperbolic-rescue/240043#240043">tjjfvi</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>Python3, 371 bytes</h1>
<pre class="lang-py prettyprint-override"><code>def f(p):
 q,s=[p],[p]
 for i in q:
  for I,a in enumerate(i):
   t=0
   if I:
    if a==3:t=i[:-2]if I+1==len(i)else i[:I-1]+[(i[I-1]+3+i[I+1])%6]+i[I+2:]
    if a in[2,4]:
     U=[-1,1][a==2]
     t=i[:-2]+[(i[-2]+U)%6,[4,2][a==4]]if I+1==len(i)else i[:I-1]+[(i[I-1]+U)%6,[2,4][a==2],(i[I+1]+U)%6]+i[I+2:]
   if t!=0 and t not in s:q+=[t];s+=[t]
 return min(map(len,s))
</code></pre>
<p><a href="https://tio.run/##jVLBasMwDD0vX6EWRh2ijCTtRsnw7r3s1pPng0sdZkjdNHYH@/pMdpbSlR6GEZKs955k4e7bfx7tct31w7DXDTSsS@sETui46CSSJdAcezBgLJyoErMNqpBrez7oXnnNTCABeF4EZxrYxDxEivNl7bkRdV7JUMlKzlttiaNbp4EKm7yUmWBGxGCZUZCVMn18kTGsankRo7aiwpUc5WHLRV5iKQV1qUYUTL2iYvBbUkKxwirCVvJfU4yk0GrURjZOFQt/5iI1P@MFKLsHD/bow2pcfcq48PLVRZdAr/25t3Awlh1Ux6g1ujQdHHCYz@eJKDAeCfkbrBJqHE9Mi5AWeGXxep3Qmwq8sum6whJvLJaqwHjGG5tKd1gXZnGXeWEXYf6I/xULT7p8m8a0Xvfs/Wg1gntyXWs8W3zYRUq/5kEh7GgJYSn6S7UIZkIEKcIQxDnde/qbKuV8h8AU7tKk640llNfOO@gCZj9bpMMP" rel="nofollow noreferrer">Try it online!</a></p>
</div>
<div id="pu1" class="pu"><h1><a href="https://www.perl.org/" rel="nofollow noreferrer">Perl 5</a> <code>-p</code>, 82 bytes</h1>

<pre class="lang-perl prettyprint-override"><code>s/./&quot;bc&quot;x($&amp;+3).&quot;ab&quot;/ge;1while s/(.)\1//+s/(b|cac)a/a$1/+s/(cbcbca?)b/b$1/;$_=y;a;
</code></pre>
<p><a href="https://tio.run/##K0gtyjH9/79YX09fKSlZqUJDRU3bWFNPKTFJST891dqwPCMzJ1WhWF9DTzPGUF9fG8hKqklOTNZM1E9UMQTzk5OAMNFeM0k/CShirRJvW2mdaP3/v4GRodG//IKSzPy84v@6BQA" rel="nofollow noreferrer" title="Perl 5 – Try It Online">Try it online!</a></p>
<h3>How it works</h3>
<p>Draw right triangle <span class="math-container">\$ABC\$</span>, where <span class="math-container">\$A\$</span> is the center of your initial tile, <span class="math-container">\$B\$</span> is the vertex of the edge behind you on your right, and <span class="math-container">\$C\$</span> is the center of the edge behind you.  The group of symmetries of the tiling are generated by the reflections <span class="math-container">\$a, b, c\$</span> over the sides <span class="math-container">\$BC\$</span>, <span class="math-container">\$CA\$</span>, <span class="math-container">\$AB\$</span> of this triangle, which satisfy the equations</p>
<p><span class="math-container">$$a^2 = b^2 = c^2 = (bc)^6 = (ca)^4 = (ab)^2 = ε.$$</span></p>
<p>We can translate our path to a symmetry by applying <span class="math-container">\$(bc)^{n + 3}ab\$</span> for each step <span class="math-container">\$n\$</span>.  Conversely, any symmetry written as an even-length string of <span class="math-container">\$a, b, c\$</span> can be translated to a path whose length is the number of <span class="math-container">\$a\$</span>s.</p>
<p>With the <a href="https://en.wikipedia.org/wiki/Knuth%E2%80%93Bendix_completion_algorithm" rel="nofollow noreferrer">Knuth–Bendix algorithm</a>, we can <a href="https://sagecell.sagemath.org/?z=eJxz07NJ1EnSSbZTsFVwK0pNdS_KLy3Q0OTlcgcJKOgrRCdqaRnpKCSByWQwqZGklayppWUGZCVrJQJZJkBWolYSkGUUy8uVDdTprleUWl6UWZKZlx5fXFlckpoLMjNbLzcxOzU-OT8vLac0Na8ELAYAPO0ijQ==&amp;lang=sage&amp;interacts=eJyLjgUAARUAuQ==" rel="nofollow noreferrer">transform</a> the above equations to a rewriting system that produces a canonical representation for any symmetry:</p>
<p><span class="math-container">\begin{align*}
aa &amp;→ ε, \\
bb &amp;→ ε, \\
cc &amp;→ ε, \\
ba &amp;→ ab, \\
caca &amp;→ acac, \\
cbcbcb &amp;→ bcbcbc, \\
cbcbcab &amp;→ bcbcbca.
\end{align*}</span></p>
<p>Since these rules never increase the number of <span class="math-container">\$a\$</span>s, we are guaranteed that the canonical representation has the minimal number of <span class="math-container">\$a\$</span>s.</p>
</div>
<div id="pu2" class="pu"><h1><a href="http://pari.math.u-bordeaux.fr/" rel="nofollow noreferrer">Pari/GP</a>, 160 bytes</h1>
<pre><code>a-&gt;for(i=1,2*#p=Mod(Polrev(a)+y*x^#a,6),p=-if([[t=p%x^l+(3-s)*x^l--+(p\x^j+3)*x^j-=2|j&lt;-[i..#p],x^(k=j-i)+1+x^k++\(x-1)==s=p%x^j\x^l=i-1]|i&lt;-[2..#p]],t,p));#p-1
</code></pre>
<p><a href="https://tio.run/##fY/RasMwDEV/xTQU7FoqcbrtpXP/YLB31wbDlmLXLCINw4X@e@YkDLrBhrhwZd8jJPJ9wBONLdOjx0Pb9TxoBc2mIv3SvfHXLvXvn9wLed1kV3l4EkAaQ8uNGTSts0uS7/Aiym9ClJyO2UW5m/qIurnFZzRhu63IQnb8rCMGIZXM7izlkWdUQuvLPCgWMumAyt5CgZoZsjAACbGvCNXoidKVe4YHRn34GIpdTc2KtWVDAcyYGuayxTcw12JruNP09FDsnZZUOfynluQj/NIf6X@Ib6pectaK8Qs" rel="nofollow noreferrer" title="Pari/GP – Try It Online">Try it online!</a></p>
<p>Based on <a href="https://codegolf.stackexchange.com/a/240011/9288">my Mathematica answer</a>.</p>
</div>
<div id="pu3" class="pu"><h1><a href="https://github.com/m-ender/retina/wiki/The-Language/a950ad7d925ec9316e3e2fb2cf5d49fd15d23e3d" rel="nofollow noreferrer">Retina 0.8.2</a>, <s>55</s> 53 bytes</h1>
<pre><code>\d
$*____ab
_
bc
(.)\1

(b|cac)a
a$1
}`(cbcbc)b
b$1
a
</code></pre>
<p><a href="https://tio.run/##VYkxCoAwEAT7fUeEi4UkIb7BTwjmLlrYWIilvv08EEFnqp3dl2PdWBuioeg4w7WTwYIJUkGdHyNAclaunsEu4ipUxfQCscmqwUAykMIjcnhEiq/I/eun/ro9wdIN" rel="nofollow noreferrer" title="Retina 0.8.2 – Try It Online">Try it online!</a> Link includes test cases. Explanation: Another port of @AndersKaseorg's Perl answer. Edit: Saved 2 bytes using @alephalpha's observation.</p>
<pre><code>\d
$*____ab
_
bc
</code></pre>
<p>First expand each digit into <code>n+3</code> underscores followed by <code>ab</code>, then replace each underscore with <code>bc</code>.</p>
<pre><code>(.)\1

(b|cac)a
a$1
(cbcbc)b
b$1
</code></pre>
<p>Perform the simplifications.</p>
<pre><code>}`
</code></pre>
<p>Repeat until no more simplifications can be made.</p>
<pre><code>a
</code></pre>
<p>Count the remaining number of <code>a</code>s.</p>
</div>
<div id="pu4" class="pu"><h1><a href="https://www.wolfram.com/wolframscript/" rel="nofollow noreferrer">Wolfram Language (Mathematica)</a>, 105 bytes</h1>
<p>-7 bytes thanks to <a href="https://codegolf.stackexchange.com/users/81203/att">@att</a>.</p>
<pre><code>Count[Table[t=b.c,#+3].a.b&amp;/@#/.List-&gt;Dot//.{(n:a|b|c).n_:&gt;Dot[],(n:b|c.a.c).a:&gt;a.n,(n:c.t.t).b:&gt;b.n},a]&amp;
</code></pre>
<p><a href="https://tio.run/##jY1PC4JAEMXvfYoFQZLWWft3ERShjh06dJMlZhclIVeo7aR@dlsXjQqhYHjwfjPvTYn6kpWoC4ldTqJuVz2UTk8orlmqIwGSOos1BwThssRhcCju2o/3lWYM6rkKsRGN9ECdwx6mnBpmiAkYimGMoHokQYP2QISxANVS5G53vBXmk0P8mOSpwzlxCUtmdR1QMkxLZ6ReUTLMaANrP9SuNtZ@65ha2ssJHbNbez@hPxv@7HlrC17Btu2e" rel="nofollow noreferrer" title="Wolfram Language (Mathematica) – Try It Online">Try it online!</a></p>
<p>A port of <a href="https://codegolf.stackexchange.com/a/240010/9288">Anders Kaseorg's Perl answer</a>.</p>
<h3>A proof that the last rule in Anders Kaseorg's answer is not needed</h3>
<p>As I said in the comment, the last rule is needed for minimizing the length of the word, but we only need to minimize the number of <span class="math-container">\$a\$</span>s.</p>
<p>After applying the first 6 rules, there are only 6 possible cases between every two <span class="math-container">\$a\$</span>s: <span class="math-container">\$c\$</span>, <span class="math-container">\$bc\$</span>, <span class="math-container">\$cbc\$</span>, <span class="math-container">\$bcbc\$</span>, <span class="math-container">\$cbcbc\$</span>, <span class="math-container">\$bcbcbc\$</span>. Since there is no <span class="math-container">\$ba\$</span> or <span class="math-container">\$caca\$</span>, <span class="math-container">\$aca\$</span> can only appear at the beginning of the word.</p>
<p>Now let's apply the last rule <span class="math-container">\$cbcbcab\Rightarrow bcbcbca\$</span>, and see what will happen before and after the <span class="math-container">\$a\$</span> in <span class="math-container">\$cbcbcab\$</span>. Remember that the only way to decrease the number of <span class="math-container">\$a\$</span>s is applying the first rule: <span class="math-container">\$aa\Rightarrow \varepsilon\$</span>.</p>
<h4>Before the <span class="math-container">\$a\$</span></h4>
<p>If this is the first <span class="math-container">\$a\$</span> in the word, there isn't another <span class="math-container">\$a\$</span> for us to apply the first rule.</p>
<p>If it is not the first <span class="math-container">\$a\$</span>, the only two possible cases between this <span class="math-container">\$a\$</span> and the previous <span class="math-container">\$a\$</span> are <span class="math-container">\$cbcbc\$</span> and <span class="math-container">\$bcbcbc\$</span>, which will become <span class="math-container">\$bcbcbc\$</span> and <span class="math-container">\$cbcbc\$</span> respectively. So the number of <span class="math-container">\$a\$</span> will not decrease.</p>
<h4>After the <span class="math-container">\$a\$</span></h4>
<p>If this is the last <span class="math-container">\$a\$</span> in the word, there isn't another <span class="math-container">\$a\$</span> for us to apply the first rule.</p>
<p>If it is not the last <span class="math-container">\$a\$</span>, there are 3 possible cases between this <span class="math-container">\$a\$</span> and the next <span class="math-container">\$a\$</span>: <span class="math-container">\$bc\$</span>, <span class="math-container">\$bcbc\$</span>, <span class="math-container">\$bcbcbc\$</span>, which will become <span class="math-container">\$c\$</span>, <span class="math-container">\$cbc\$</span>, <span class="math-container">\$cbcbc\$</span> respectively. In the last two cases, nothing else will change.</p>
<p>But the first case will produce a new <span class="math-container">\$caca\$</span>: <span class="math-container">\$cbcbcabca\Rightarrow bcbcbcaca\$</span>. Applying the rule <span class="math-container">\$caca\Rightarrow acac\$</span>, this substring will become <span class="math-container">\$bcbcbacac\$</span>, and further become <span class="math-container">\$bcbcabcac\$</span> (by applying <span class="math-container">\$ba\Rightarrow ab\$</span>). Now the <span class="math-container">\$c\$</span> at the end of the substring might meet another <span class="math-container">\$c\$</span> and get eliminated. But there can't be another <span class="math-container">\$ca\$</span> right after the substring, so nothing else will change, and the number of <span class="math-container">\$a\$</span> won't decrease.</p>
<hr />
<h1><a href="https://www.wolfram.com/wolframscript/" rel="nofollow noreferrer">Wolfram Language (Mathematica)</a>, 133 bytes</h1>
<p>-10 bytes thanks to <a href="https://codegolf.stackexchange.com/users/81203/att">@att</a>.</p>
<pre><code>Length[##.E.E&amp;@@#//.{a_ . 3 .b_/;a&lt;6&gt;b:&gt;Mod[a+b+3,6],##&amp;@@(a_ .#2.(o:#...).#2.b_/;a&lt;6&gt;b:&gt;Dot@@Mod[-{-a-#,o,-b-#},6]&amp;@@@1?2@*5?4)}]-2&amp;
</code></pre>
<p><a href="https://tio.run/##jYxLC4JAFIX3/YoLF8Rq5mqmLnrYLGpX0F5Ext6LFGJ2w/x20yGjIig4HO7hnu9cpTofrlJddrI@wrxeH8qTOqeItKKVIwR6HmmZA8EYqMi9qZzFSTFJNtU@lcNiOGZxxhCbptu2MCC3miAR9dv7BVhWSoiW4ppLjqxivOBoGrxhxWgRiEG0CPsm44FTb2@XUqUIPIFjilkGDniip7XP4CHDeqADBg910bfxze0rtPHTO2pkm1@8YyPb/@I/F/7ceVnzn6Ax9R0" rel="nofollow noreferrer" title="Wolfram Language (Mathematica) – Try It Online">Try it online!</a></p>
<p>First appends two dummy variable <code>E</code>'s to the list, then repeatedly replaces:</p>
<ul>
<li><span class="math-container">\$a3b\Rightarrow\operatorname{mod}(a+b+3,6)\$</span></li>
<li><span class="math-container">\$a2\underbrace{1\cdots 1}_{n\ge0}2b\Rightarrow\operatorname{mod}(a+1,6)\underbrace{5\cdots 5}_{n}\operatorname{mod}(b+1,6)\$</span></li>
<li><span class="math-container">\$a4\underbrace{5\cdots 5}_{n\ge0}4b\Rightarrow\operatorname{mod}(a-1,6)\underbrace{1\cdots 1}_{n}\operatorname{mod}(b-1,6)\$</span></li>
</ul>
<p>And then takes the length of the result and minus 2.</p>
</div>
<div id="pu5" class="pu"><h1><a href="https://github.com/somebody1234/Charcoal" rel="nofollow noreferrer">Charcoal</a>, 139 bytes</h1>
<pre><code>≔⟦Ｅ⁶⊕ι⟧η⊞υ⮌ηＦ⁶⊞ηω≔⁰ζ≔⁰εＦＡ«≔§§ηζ⁺ειδＦ¬§ηδ«≔⟦⟧κＷＥΦ§υ±¹№μ⌕ηω⌕ημ«Ｆ¬›⌈λ⊕⌊λ≔⮌λλ⊞λ⊖ＬηＦ⁻⁶Ｌλ⊞λ⊖Ｌ⊞Ｏηω§≔η⌕ηωλ⊞κλ»§≔§κ⁰¦¹⊖Ｌη⊞υκ»≔⁺³⌕§ηδζε≔δζ»Ｉ⌕Ｅυ№ι§ηζ¹
</code></pre>
<p><a href="https://tio.run/##fVJNi8IwED23v2KOCWTB7oKXPYmLi7C6stfiIdjRBNNU0lRlF397N0kbtR4slDAf783Hm43gZlNx1baTupY7TfIFP5Axg7neGCxRWyyIpHTNQND3dNXUgjQMfvCIpkYiqHNuKwNkTCEEBYOT8/VsIwa/Awtj/lwfGksohb806cMTO9cFnq@v8GAGK9XUBBm4LhgUDp8EgmVl7zOLjipy5a7hvc9NTkIqBOLHmkll0VxRbo4l7rhFknnqadVoS0oGM6mLbg7vjlZJ@wq38p8GuSdc8LMsm5IoOtzbQure7z/oW4u789kqtJiEzSkGH3gDf6HeWeE33OWEqo7RLcPJ00c9MzxB@9D3AQ23lYkjdXRdM3cLvE09bGsfzUv6iIqvSxk5VPZ0gHg6QZXLVfSg7ltffqCnV592FxOTi@6cLunKSKfVlNeWBKBXt4kSSgaDE/Isme@ibfP8lWXs4V@v25ej@gc" rel="nofollow noreferrer" title="Charcoal – Try It Online">Try it online!</a> Link is to verbose version of code. Explanation: Works by mapping out the grid. The starting point is <code>0</code>, then the six adjacent hexagons are numbered <code>1-6</code>, then the 24 hexagons at a distance of <code>2</code> are numbered <code>7-30</code>, then the 90 hexagons at a distance of <code>3</code> are numbered <code>31-120</code>, and so on.</p>
<pre><code>≔⟦Ｅ⁶⊕ι⟧η
</code></pre>
<p>The edges of the starting hexagon take you to hexagons <code>1-6</code>.</p>
<pre><code>⊞υ⮌η
</code></pre>
<p>Save a copy as the list of hexagons at a distance of <code>0</code>.</p>
<pre><code>Ｆ⁶⊞ηω
</code></pre>
<p>Add six placeholders for the hexagons at a distance of <code>1</code>.</p>
<pre><code>≔⁰ζ≔⁰ε
</code></pre>
<p>Start at the origin facing direction <code>0</code>.</p>
<pre><code>ＦＡ«
</code></pre>
<p>Loop through the input steps.</p>
<pre><code>≔§§ηζ⁺ειδ
</code></pre>
<p>Take a step in the appropriate direction.</p>
<pre><code>Ｆ¬§ηδ«
</code></pre>
<p>If we have hit a placeholder, then...</p>
<pre><code>≔⟦⟧κ
</code></pre>
<p>Start collecting the hexagons at the next distance.</p>
<pre><code>ＷＥΦ§υ±¹№μ⌕ηω⌕ημ«
</code></pre>
<p>Until all of the placeholders at the next distance have been mapped, get the edge or edges of the next hexagon that step to a mapped hexagon.</p>
<pre><code>Ｆ¬›⌈λ⊕⌊λ≔⮌λλ
</code></pre>
<p>Ensure that the edges are listed in clockwise order. This usually needs to be descending, except for the very last hexagon to be mapped, which steps to the first and last hexagon to be mapped in the previous pass. For example, hexagon <code>10</code> steps back to hexagons <code>2</code> and <code>1</code>, <code>20</code> steps back to hexagon <code>4</code> and <code>30</code> steps back to hexagons <code>1</code> and <code>6</code>, in that order.</p>
<pre><code>⊞λ⊖Ｌη
</code></pre>
<p>The next edge from this hexagon goes to the same hexagon as the last edge from the previous hexagon.</p>
<pre><code>Ｆ⁻⁶Ｌλ⊞λ⊖Ｌ⊞Ｏηω
</code></pre>
<p>The remaining edges go to new unmapped hexagons that are further away.</p>
<pre><code>§≔η⌕ηωλ
</code></pre>
<p>Update the map with the edges of this hexagon.</p>
<pre><code>⊞κλ
</code></pre>
<p>Collect this hexagon in the list of hexagons at this distance.</p>
<pre><code>»§≔§κ⁰¦¹⊖Ｌη
</code></pre>
<p>Fix the second edge of the first hexagon, which needs to wrap around to the last unmapped hexagon.</p>
<pre><code>⊞υκ
</code></pre>
<p>Collect this list of hexagons in the list of hexagons for each distance.</p>
<pre><code>»≔⁺³⌕§ηδζε
</code></pre>
<p>Work out the direction we arrived at this hexagon from, and add 3 so that we're facing away from there.</p>
<pre><code>≔δζ
</code></pre>
<p>Actually move to this hexagon.</p>
<pre><code>»Ｉ⌕Ｅυ№ι§ηζ¹
</code></pre>
<p>Find out which list of hexagons we ended up in, which is our final distance.</p>
</div>
<div id="pu6" class="pu"><h1>TypeScript Types, 568 bytes</h1>
<pre><code>//@ts-ignore
type a&lt;N,P=[],A=[[0,1,2,3,4,5],[1,2,3,4,5,0],[2,3,4,5,0,1],[3,4,5,0,1,2],[4,5,0,1,2,3],[5,0,1,2,3,4]],I=A[1],D=A[5]&gt;=N extends[infer X,infer Y,infer Z,...infer R]?Y extends 3?a&lt;[A[3][A[X][Z]],...R],P&gt;:|a&lt;[Y,Z,...R],[...P,X]&gt;|(Y extends 2?a&lt;R,[...P,I[X],4,I[Z]]&gt;:Y extends 4?a&lt;R,[...P,D[X],2,D[Z]]&gt;:never):N extends[infer X,infer Y]?Y extends 3?P:Y extends 2?[...P,I[X],4]|[...P,X,Y]:Y extends 4?[...P,D[X],2]|[...P,X,Y]:[...P,X,Y]:[...P,...N];type b&lt;T,K=keyof T&gt;=T extends T?keyof T extends K?T:never:0;type M&lt;C,P=0&gt;=[C]extends[P]?b&lt;C&gt;[&quot;length&quot;]:M&lt;a&lt;C&gt;,C&gt;
</code></pre>
<p><a href="https://www.typescriptlang.org/play?#code/PTACBcGcFoEsHMB2B7ATgUwFDgJ4Ad0ACAQwB4A5AGgAUBeAbQF1KBBB+gBkoEZKAmSgGZKAFkoBWZvV4DhY8ZQ5TZoiYp5S5arjKnz1MoVIU7+Q0Y2YBJWi2nMAIrfqSAfLXKF0AD3DpEACaQ9LCIAGboqIQAGpShEVEAmnHhkYQAWpQAdDnxaQBKjAD8iV6+-kGEgkVk9HaCjHX00Y3pltk5hTSuAFwAPrXJmTlZXfQj1JQtrn0AFKU+foGQhHw1pPmU4zmTVs3MYnttjL0L5cuEIuub21mTDvtmD8e9iOgAbpEAlD2eixXBPJRWJAwiJYpnJaVarUHqQgGrIq3XaPESMPrIqaUcFwspQlZXTEPFr8dGY2I48nYxg9TEjciMADcuAIhAARqQACqUADStAA1ugcMgwoROe5OXiEZyioLhaLJf8Ljyipyem9PqgehxmfgiABZUgAYRotA47noRsYSqC9GoxQ5Rtc9AARAAbfzwcAACxdNMNZCdlCdmGwerFHEItEIhs46i4SlcmBAhFTAD0imHWZzuFGY6R6AIi6Skyn05mWUROXw87GBFx62YG4oTsngKnCBms1XBLWC2IuAPVIOW6X2+Xu2KRH3CzwzIYF-PW2XOxXw5zxDP9Nu1Du3G2O13K2KAGwzgSLi-z68X5fj1eTzkAdi3u7fCj3qn3K6P64AHDOza6GOh6ZkAA" rel="nofollow noreferrer">Try It Online!</a></p>
<h2>Ungolfed / Explanation</h2>
<pre><code>// Iterate over an array, applying equivalence rules where possible
type ApplyRules&lt;
  Next,
  Prev=[],
  // Modulo arithmetic addition table
  Add=[[0,1,2,3,4,5],[1,2,3,4,5,0],[2,3,4,5,0,1],[3,4,5,0,1,2],[4,5,0,1,2,3],[5,0,1,2,3,4]],
  Inc=Add[1],
  Dec=Add[5]
&gt; =
  // Get the first three elements of Next
  Next extends [infer X, infer Y, infer Z, ...infer Rest]
    ? Y extends 3
      // Apply the rule for 3
      ? ApplyRules&lt;[Add[3][Add[X][Z]], ...Rest], Prev&gt;
      // Return a union of:
      :
        // Applying no rule and stepping forward one step
        | ApplyRules&lt;[Y, Z, ...Rest], [...Prev, X]&gt;
        // If Y is 2 or 4, applying the 2/4 rule
        | (
          Y extends 2
            ? ApplyRules&lt;Rest, [...Prev, Inc[X], 4, Inc[Z]]&gt;
            : Y extends 4
              ? ApplyRules&lt;Rest, [...Prev, Dec[X], 2, Dec[Z]]&gt;
              : never
        )
    // Next has fewer than 3 elements. If it has exactly 2, store them in X and Y:
    : Next extends [infer X, infer Y]
      ? Y extends 3
        // If Y is 3, remove both X and Y from the end of the array by returning Prev
        ? Prev
        // If Y is 2 or 4, return the union of the current state and the state after applying the end-2/4 rule
        : Y extends 2
          ? [...Prev, Inc[X], 4] | [...Prev, X, Y]
          : Y extends 4
            ? [...Prev, Dec[X], 2] | [...Prev, X, Y]
            // Otherwise, just return the full array array
            : [...Prev, X, Y]
      // Next has fewer than 2 elements; return the full array
      : [...Prev, ...Next]

// Filter a union of tuples for those with the shortest length
type Shortest&lt;T, K=keyof T&gt; = T extends T ? keyof T extends K ? T : never : 0

// Continually apply rules until nothing changes, then return the shortest length in Cur
type Main&lt;Cur, Prev=0&gt; = [Cur] extends [Prev] ? Shortest&lt;Cur&gt;[&quot;length&quot;] : Main&lt;ApplyRules&lt;Cur&gt;, Cur&gt;
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/239985/">239985</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




