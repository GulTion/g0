<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::275165</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>159</td><td>Google Sheets</td><td>240826T231658Z</td><td><a href="https://codegolf.stackexchange.com/questions/275165/completely-introduce-your-friends/275173#275173">doubleun</a></td></tr>
<tr d-ix="1"><td>010</td><td>Jelly</td><td>240827T001136Z</td><td><a href="https://codegolf.stackexchange.com/questions/275165/completely-introduce-your-friends/275174#275174">Jonathan</a></td></tr>
<tr d-ix="2"><td>074</td><td>Python</td><td>240826T215815Z</td><td><a href="https://codegolf.stackexchange.com/questions/275165/completely-introduce-your-friends/275172#275172">shape wa</a></td></tr>
<tr d-ix="3"><td>078</td><td>JavaScript ES10</td><td>240826T210254Z</td><td><a href="https://codegolf.stackexchange.com/questions/275165/completely-introduce-your-friends/275167#275167">Arnauld</a></td></tr>
<tr d-ix="4"><td>009</td><td>Vyxal</td><td>240826T212519Z</td><td><a href="https://codegolf.stackexchange.com/questions/275165/completely-introduce-your-friends/275169#275169">emanresu</a></td></tr>
<tr d-ix="5"><td>018</td><td>Charcoal</td><td>240826T210607Z</td><td><a href="https://codegolf.stackexchange.com/questions/275165/completely-introduce-your-friends/275168#275168">Neil</a></td></tr>
<tr d-ix="6"><td>023</td><td>Jelly</td><td>240826T191846Z</td><td><a href="https://codegolf.stackexchange.com/questions/275165/completely-introduce-your-friends/275166#275166">hyper-ne</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>Google Sheets, 159 bytes</h1>
<pre><code>=let(a,1:1,s,&quot; &quot;,mid(trim(join(s,map(a,lambda(n,let(o,offset(n,,1,,99),r,ifna(filter(o,len(o))),join(s,sort(if(len(r),n&amp;s&amp;n&amp;s&amp;r&amp;s&amp;r,)))))))),2+len(a),9^9)&amp;s&amp;a)
</code></pre>
<p>Put the names in row <code>1</code> and the formula in cell <code>A2</code>.</p>
<p>The formula takes the first name and pairs it with every name that follows it, repeating each name twice every time. Does the same with remaining names, pairing each name with every name that follows it (but without pairing with preceding ones.) Finally, tidies up the head and tail with string manipulation.</p>
<p><img src="https://i.sstatic.net/F0BFCQnV.png" alt="screenshot" /></p>
<p>Ungolfed:</p>
<pre><code>=let(
  a, A1:1, 
  s, &quot; &quot;, 
  mid( 
    trim(join(s, 
      map(a, lambda(n, let( 
        o, offset(n, 0, 1, 1, 99), 
        r, ifna(filter(o, len(o))), 
        join(s, sort(if(len(r), n &amp; s &amp; n &amp; s &amp; r &amp; s &amp; r, iferror(ø)))) 
      ))) 
    )), 
    2 + len(choosecols(a, 1)), 9^9 
  ) &amp; s &amp; choosecols(a, 1) 
)
</code></pre>
<p>Pretty much the same in JavaScript (non-competing):</p>
<pre class="lang-js prettyprint-override"><code>f = a =&gt;
  a.slice(1)
    .map(n =&gt; ([a[0], a[0], n, n]).join())
    .join()
  + (a.length &gt; 1 ? ',' + f(a.slice(1)) : '')

g = A =&gt; f(A).slice(A[0].length + 1) + A[0]

console.log(g([&quot;Alice&quot;, &quot;Bob&quot;, &quot;Tom&quot;,]))
</code></pre>
</div>
<div id="pu1" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="nofollow noreferrer">Jelly</a>, 10 <a href="https://github.com/DennisMitchell/jelly/wiki/Code-page" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>JŒcẎṙ-ṁżƲị
</code></pre>
<p>A monadic Link that accepts a list of names (lists of characters) and yields a list of pairs of names.</p>
<p><strong><a href="https://tio.run/##y0rNyan8/9/r6KTkh7v6Hu6cqftwZ@PRPcc2Pdzd/f9wu/v//9FKjjmZyalKOgpKTvlJIMo5I7EoJxMs4pJYBqZdgVQsAA" rel="nofollow noreferrer" title="Jelly – Try It Online">Try it online!</a></strong></p>
<h4>How?</h4>
<pre><code>JŒcẎṙ-ṁżƲị - Link: Names
J          - indices -&gt; [1..#Names]
 Œc        - ordered pairs -&gt; [[1,2],[1,3],...,[1,#Names],[2,3],...]
        Ʋ  - last four links as a monad - f(OrderedIndexPairs):
   Ẏ       -   tighten {OrderedIndexPairs}
    ṙ-     -   rotate {that} one to the left
      ṁ    -   mould {that} like {OrderedIndexPairs}
       ż   -   zip {that} with {OrderedIndexPairs}
         ị - index into {Names}
</code></pre>
</div>
<div id="pu2" class="pu"><h1><a href="https://www.python.org" rel="nofollow noreferrer">Python</a>, <s>88</s> 74 bytes</h1>
<pre class="lang-python prettyprint-override"><code>lambda L:sum([[a,a,b,b]for i,b in enumerate(L)for a in L[:i]],L[-1:])[:-1]
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=JYxBCkIhFEW34kwFHfxZCG0g3MHrDZ59JSH9H9NBa2kiRC2jfbSbECfnwuFwn5_9Ua9b7q9wPL9bDfrwO90ouZWYNfeWBAApUk45DFthUTkWM_O5JV-oemHl0DSkBRMRlQW9GJRg9ILz8buXmKsIAjhxxbgbuAysHKWcUe9z_w" rel="nofollow noreferrer">Attempt This Online!</a></p>
<p>-14 bytes after incorporating an improvement by att, replacing a call to <code>itertools.combinations</code>. Outputs as a flattened list.</p>
<p>Ungolfed algorithm:</p>
<pre class="lang-python prettyprint-override"><code>from collections import deque

def two_element_combinations(L):
    for i, b in enumerate(L):
        for a in L[:i]:
            yield a, b

def f(L):
    result = deque(x for a, b in two_element_combinations(L) for x in [a, a, b, b])
    result.rotate()  # a b c d -&gt; d a b c
    return result
</code></pre>
<h2>Explanation</h2>
<p>If we imagine a directed graph where vertices represent friends and edges represent introductions, this challenge algorithmically boils down to finding an <a href="https://en.wikipedia.org/wiki/Eulerian_path" rel="nofollow noreferrer">Eulerian path</a> in a <a href="https://en.wikipedia.org/wiki/Complete_graph" rel="nofollow noreferrer">complete digraph</a>.</p>
<p>It turns out that (using example vertices A, B, C, D, E, F) the loop with the sequence of vertices<br />
<code>ABACBCADBDCDAEBECEDEAFBFCFDFEF</code> is a valid Eulerian path. Grouping the vertices (which gives the edges that appear at even-numbered positions under 0-indexing), we have<br />
<code>AB AC BC AD BD CD AE BE CE DE AF BF CF DF EF</code>, the two-element combinations of <code>ABCDEF</code> where the first element comes before the second. Rotating left by one yields<br />
<code>BACBCADBDCDAEBECEDEAFBFCFDFEFA</code>, and regrouping (which gives the edges that appear at odd-numbered positions under 0-indexing) gives us<br />
<code>BA CB CA DB DC DA EB EC ED EA FB FC FD FE FA</code>, the two-element combinations of <code>ABCDEF</code> where the first element comes after the second (in a slightly weird order -- combinations that end in A are moved to the end of their respective groups). Between these two groupings, every edge is accounted for exactly once in the entire path.</p>
<p>The output format in this challenge requires a sequence of edges, not vertices. The loop with vertices <code>A B C D</code> has the edges <code>AB BC CD DA</code>, or equivalently <code>DA AB BC CD</code>. The flattened form <code>DAABBCCD</code> can be produced from <code>ABCD</code> by doubling each vertex and rotating right by one.</p>
<p>In the actual code, we take the first list of two-element combinations, double both vertices in each combination, and then flatten and rotate the entire thing. For vertices A, B, C, D, the golfed code calculates <code>rotate_right(flatten([AABB, AACC, ..., CCDD]))</code> as<br />
<code>all_but_last(D + AABB + AACC + ... + CCDD)</code>.</p>
</div>
<div id="pu3" class="pu"><h1>JavaScript (ES10), 78 bytes</h1>
<p>Returns a flat array.</p>
<pre class="lang-javascript prettyprint-override"><code>f=([v,...a],b=v)=&gt;v?[a.map((p,i)=&gt;[v,p,p,a[i+1]?v:i?a[0]:b]),f(a,b)].flat(2):a
</code></pre>
<p><a href="https://tio.run/##ZYrNCsIwEITvPoXktMG4qMdCLf69gbeQw6Y2kpJ2g5W8flyPIsM3MMw3UqGlf8X83s78GGoNLdhiEJGc8W3R7bF0lnCiDJBNlC13lpCNm73rShM7sjvXeKdNADJeOwyJ3nDQDdWe54XTgImfEMCqU4r9oIw6s5e@86ScxpHjDGqttF79@V9XuAhX4fbr1w8" rel="nofollow noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a></p>
<p>Or <strong><a href="https://tio.run/##ZYrNCgIhFIX3PYarK2NSW8GkvzdoJy6upmE4ozTh69uddRy@A4fzvbHjGj65ffdLfcYxkgbbhZQSnfC6c33qBuWMDaCJTJPeRkGbp6MzXWWD9uCUd3yyIgEKz53CEeqy1hJlqS9IYNm55BCZYJfqqR91Zo7z3Z@1GcSVuBH3zRo/" rel="nofollow noreferrer">71 bytes (ES6)</a></strong> for a comma-separated string with some unsightly trailing commas.</p>
<h3>Method</h3>
<p>Given <span class="math-container">\$n\$</span> elements, we do <span class="math-container">\$n-1\$</span> iterations from <span class="math-container">\$j=0\$</span> to <span class="math-container">\$j=n-2\$</span>.</p>
<p>At each iteration, we generate:</p>
<ul>
<li>all the pairs of the form <span class="math-container">\$\color{blue}{(j,k)},\:j&lt;k&lt;n\$</span></li>
<li>interleaved with the pairs of the form <span class="math-container">\$\color{green}{(k,j)},\:j&lt;k&lt;n-1\$</span></li>
<li>followed by the pair <span class="math-container">\$\color{purple}{(n-1,j+1)}\$</span> if <span class="math-container">\$j&lt;n-2\$</span> or <span class="math-container">\$\color{red}{(n-1,0)}\$</span> otherwise</li>
</ul>
<p>With five elements, this gives:</p>
<p><span class="math-container">$$\begin{aligned}&amp;j=0:\color{blue}{(0,1)}\color{green}{(1,0)}\color{blue}{(0,2)}\color{green}{(2,0)}\color{blue}{(0,3)}\color{green}{(3,0)}\color{blue}{(0,4)}\color{purple}{(4,1)}\\
&amp;j=1:\color{blue}{(1,2)}\color{green}{(2,1)}\color{blue}{(1,3)}\color{green}{(3,1)}\color{blue}{(1,4)}\color{purple}{(4,2)}\\
&amp;j=2:\color{blue}{(2,3)}\color{green}{(3,2)}\color{blue}{(2,4)}\color{purple}{(4,3)}\\
&amp;j=3:\color{blue}{(3,4)}\color{red}{(4,0)}\end{aligned}$$</span></p>
<h3>Commented</h3>
<pre class="lang-javascript prettyprint-override"><code>f = (               // f is a recursive function taking:
  [ v,              //   v   = next element
       ...a ],      //   a[] = remaining elements
  b = v             //   b   = copy of the first element
) =&gt;                //
v ?                 // if v is defined:
  [                 //
    a.map((p, i) =&gt; //   for each element p at index i in a[]:
      [             //
        v, p,       //     insert the pair (v, p)
        p,          //     insert the pair (p, X), where ...
        a[i + 1] ?  //       if this is not the last element:
          v         //         X = v
        :           //       else:
          i ?       //         if i &gt; 0:
            a[0]    //           X = a[0]
          :         //         else (last iteration):
            b       //           X = b
      ]             //
    ),              //   end of map()
    f(a, b)         //   append the result of a recursive call
  ].flat(2)         //   flatten everything
:                   // else:
  a                 //   stop the recursion (a[] is empty)
</code></pre>
</div>
<div id="pu4" class="pu"><h1><a href="https://github.com/Vyxal/Vyxal/tree/version-2" rel="nofollow noreferrer">Vyxal</a>, 9 bytes</h1>
<pre><code>KƛZṫwẊ;fǓ
</code></pre>
<p><a href="https://vyxal.pythonanywhere.com/?v=2&amp;c=1#WyIiLCIiLCJLxpta4bmrd+G6ijtmx5MiLCIiLCJbXCJhXCIsXCJiXCIsXCJjXCIsXCJkXCIsXCJlXCJdIl0=" rel="nofollow noreferrer">Try it Online!</a>
Port of Neil's Charcoal answer.</p>
<pre><code>Kƛ    ;   # Over every prefix  
  Z       # Double each value
    wẊ    # Append the last value to
   ṫ      # The rest
       fǓ # Flatten and move the first character to the end.
</code></pre>
<h1><a href="https://github.com/Vyxal/Vyxal/tree/version-2" rel="nofollow noreferrer">Vyxal</a>, 14 bytes</h1>
<pre><code>₌ẊZFṖvf'zy∩≈;h
</code></pre>
<p><a href="https://vyxal.pythonanywhere.com/?v=2&amp;c=1#WyIiLCIiLCLigozhuopaRuG5lnZmJ3p54oip4omIO2giLCIiLCJbXCJhXCIsXCJiXCIsXCJjXCJdIl0=" rel="nofollow noreferrer">Try it Online!</a></p>
<p>Brute force answer. 12 bytes by removing the <code>;h</code> if we can output all solutions.</p>
<pre><code>    Ṗ          # Permutations
 Ẋ             # Of all pairs in the input
₌ ZF           # Aside from doubles of one item
     vf        # Flatten each
       '    ;h # Find one where
        zy     # Every other overlapping pair
          ∩≈   # Has all elements equal?
</code></pre>
</div>
<div id="pu5" class="pu"><h1><a href="https://github.com/somebody1234/Charcoal" rel="nofollow noreferrer">Charcoal</a>, 18 bytes</h1>
<pre><code>Φ⭆θ⭆…θκ⁺×²λ×²ικ§θ⁰
</code></pre>
<p><a href="https://tio.run/##S85ILErOT8z5/z@gKDOvRMMtM6cktUgjuATIS/dNLNAo1FFAcJwrk3NSnTPywcLZmjoKATmlxRohmbmpxRpGOgo5QBE4J1MTCECqNK25IGY7lnjmpaRWgPQaAEX//09MSk5J/a9blgMA" rel="nofollow noreferrer" title="Charcoal – Try It Online">Try it online!</a> Link is to verbose version of code. Explanation: <a href="https://oeis.org/A097285" rel="nofollow noreferrer">A097285</a> is almost the sequence of indices, with each element doubled, except that there is only one of the first element at the start, the second coming at the end.</p>
<pre><code>  θ                 Input list
 ⭆                  Map over letters and join
     θ              Input list
    …               Truncated to length
      κ             Current index
   ⭆                Map over letters and join
          λ         Inner letter
        ×²          Doubled
       ⁺            Concatenated with
             ι      Outer letter
           ×²       Doubled
Φ             κ§θ⁰  Remove the first element and append it to the end
</code></pre>
</div>
<div id="pu6" class="pu"><h1><a href="https://github.com/DennisMitchell/jellylanguage" rel="nofollow noreferrer">Jelly</a>, 23 bytes</h1>
<pre><code>2œṖ$ÐƤṖUp/€żUẎṖƲ€Ẏ;Uṡ2Ɗ
</code></pre>
<p><a href="https://jht.hyper-neutrino.xyz/tio#WyIiLCIyxZPhuZYkw5DGpOG5llVwL+KCrMW8VeG6juG5lsay4oKs4bqOO1XhuaEyxooiLCLDh8WS4bmYIiwiIixbIlwiYWJjZFwiIl1d" rel="nofollow noreferrer">Try It Online!</a></p>
<p>pretty horribly long but it is fairly efficient and i kinda like the idea of it which is basically this: starting from the first person counting forwards, we introduce them to everyone starting from the last person counting backwards and do this back and forth until the next person, then we do not introduce them back, and we repeat this until we've done all of the introductions except each person to the one before them which we do at the end to close the loop</p>
<h2>Explanation</h2>
<pre><code>2œṖ$ÐƤṖUp/€żUẎṖƲ€Ẏ;Uṡ2Ɗ    main link
    ÐƤ                     for each suffix of the list
2œṖ$                       - partition at index 2, so split the first element off
      Ṗ                    remove the last element (the single list)
       U                   reverse (vectorizing) to flip the targets around
           €               for each of these pairs
         p/                - take their cartesian product to get each intro pair
                Ʋ€          for each of these lists of intros
           żU              - interleave with the reverse
             Ẏ             - flatten by one level
              Ṗ            - remove the last element (the last back-intro)
                 Ẏ         flatten by one level
                  ;   Ɗ    append
                   Uṡ2     - each pair of [the original list reversed]
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/275165/">275165</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




