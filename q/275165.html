<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::275165</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>088</td><td>Python</td><td>240826T215815Z</td><td><a href="https://codegolf.stackexchange.com/questions/275165/completely-introduce-your-friends/275172#275172">shape wa</a></td></tr>
<tr d-ix="1"><td>078</td><td>JavaScript ES10</td><td>240826T210254Z</td><td><a href="https://codegolf.stackexchange.com/questions/275165/completely-introduce-your-friends/275167#275167">Arnauld</a></td></tr>
<tr d-ix="2"><td>009</td><td>Vyxal</td><td>240826T212519Z</td><td><a href="https://codegolf.stackexchange.com/questions/275165/completely-introduce-your-friends/275169#275169">emanresu</a></td></tr>
<tr d-ix="3"><td>018</td><td>Charcoal</td><td>240826T210607Z</td><td><a href="https://codegolf.stackexchange.com/questions/275165/completely-introduce-your-friends/275168#275168">Neil</a></td></tr>
<tr d-ix="4"><td>023</td><td>Jelly</td><td>240826T191846Z</td><td><a href="https://codegolf.stackexchange.com/questions/275165/completely-introduce-your-friends/275166#275166">hyper-ne</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://www.python.org" rel="nofollow noreferrer">Python</a>, 88 bytes</h1>
<pre class="lang-python prettyprint-override"><code>lambda L:sum([[a,a,b,b]for a,b in combinations(L,2)],L[-1:])[:-1]
from itertools import*
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=JYwxDsIgFIZ3T_E2wNChTobEG3AAE2SAViJJ4TX0dfAsLiRGj-E9vI02LN__DX--x3u-0w1zfYbT5bVS6I7f8-SSHx1otayJG-Okk156G7DA3yBmGDD5mB1FzAvX8iCs1KbrlRVGdb3dhYIJIl0LIU4LxDRjoX3rf-YSM_HADXNMAvMbhg0js0K0U61tfw" rel="nofollow noreferrer">Attempt This Online!</a></p>
<p>Outputs as a flattened list.</p>
<p>Ungolfed algorithm:</p>
<pre class="lang-python prettyprint-override"><code>from collections import deque
from itertools import combinations

def f(L):
    result = deque(x for a, b in combinations(L, 2) for x in [a, a, b, b])
    result.rotate()  # a b c d -&gt; d a b c
    return result
</code></pre>
<h2>Explanation</h2>
<p>If we imagine a directed graph where vertices represent friends and edges represent introductions, this challenge algorithmically boils down to finding an <a href="https://en.wikipedia.org/wiki/Eulerian_path" rel="nofollow noreferrer">Eulerian path</a> in a <a href="https://en.wikipedia.org/wiki/Complete_graph" rel="nofollow noreferrer">complete digraph</a>.</p>
<p>It turns out that (using example vertices A, B, C, D, E, F) the loop with the sequence of vertices<br />
<code>ABACADAEAFBCBDBEBFCDCECFDEDFEF</code> is a valid Eulerian path. Grouping the vertices (which gives the edges that appear at even-numbered positions under 0-indexing), we have<br />
<code>AB AC AD AE AF BC BD BE BF CD CE CF DE DF EF</code>, corresponding to<br />
<code>combinations('ABCDEF', 2)</code>. Rotating right by one yields<br />
<code>FABACADAEAFBCBDBEBFCDCECFDEDFE</code>, and regrouping (which gives the edges that appear at odd-numbered positions under 0-indexing) gives us<br />
<code>FA BA CA DA EA FB CB DB EB FC DC EC FD ED FE</code>, the reversed versions of the above combinations with some slight reordering (the combinations containing F are moved to the front of their respective groups). Between these two groupings, every edge is accounted for exactly once in the entire path.</p>
<p>The output format in this challenge requires a sequence of edges, not vertices. The loop with vertices <code>A B C D</code> has the edges <code>AB BC CD DA</code>, or equivalently <code>DA AB BC CD</code>. The flattened form <code>DAABBCCD</code> can be produced from <code>ABCD</code> by doubling each vertex and rotating right by one.</p>
<p>The actual code generates the vertex sequence with <code>combinations(L, 2)</code>, with each combination flattened and doubled, then the entire thing flattened and then rotated. In the golfed code, the flatten-rotate step for vertices A, B, C, D calculates <code>D + AABB + AACC + ... + CCDD</code>, and then removes the final element, yielding the final answer of <code>DAABBAACCAADDBBCCBBDDCCD</code>.</p>
</div>
<div id="pu1" class="pu"><h1>JavaScript (ES10), 78 bytes</h1>
<p>Returns a flat array.</p>
<pre class="lang-javascript prettyprint-override"><code>f=([v,...a],b=v)=&gt;v?[a.map((p,i)=&gt;[v,p,p,a[i+1]?v:i?a[0]:b]),f(a,b)].flat(2):a
</code></pre>
<p><a href="https://tio.run/##ZYrNCsIwEITvPoXktMG4qMdCLf69gbeQw6Y2kpJ2g5W8flyPIsM3MMw3UqGlf8X83s78GGoNLdhiEJGc8W3R7bF0lnCiDJBNlC13lpCNm73rShM7sjvXeKdNADJeOwyJ3nDQDdWe54XTgImfEMCqU4r9oIw6s5e@86ScxpHjDGqttF79@V9XuAhX4fbr1w8" rel="nofollow noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a></p>
<h3>Method</h3>
<p>Given <span class="math-container">\$n\$</span> elements, we do <span class="math-container">\$n-1\$</span> iterations from <span class="math-container">\$j=0\$</span> to <span class="math-container">\$j=n-2\$</span>.</p>
<p>At each iteration, we generate:</p>
<ul>
<li>all the pairs of the form <span class="math-container">\$(j,k),\:j&lt;k&lt;n\$</span></li>
<li>interleaved with the pairs of the form <span class="math-container">\$(k,j),\:j&lt;k&lt;n-1\$</span></li>
<li>followed by the pair <span class="math-container">\$(n,j+1)\$</span> if <span class="math-container">\$j&lt;n-2\$</span> or <span class="math-container">\$(n,0)\$</span> otherwise</li>
</ul>
<p>With five elements, this gives:</p>
<pre><code>j = 0: (0,1 / 1,0) / (0,2 / 2,0) / (0,3 / 3,0) / (0,4 / 4,1)
j = 1: (1,2 / 2,1) / (1,3 / 3,1) / (1,4 / 4,2)
j = 2: (2,3 / 3,2) / (2,4 / 4,3)
j = 3: (3,4 / 4,0)
</code></pre>
<h3>Commented</h3>
<pre class="lang-javascript prettyprint-override"><code>f = (               // f is a recursive function taking:
  [ v,              //   v   = next element
       ...a ],      //   a[] = remaining elements
  b = v             //   b   = copy of the first element
) =&gt;                //
v ?                 // if v is defined:
  [                 //
    a.map((p, i) =&gt; //   for each element p at index i in a[]:
      [             //
        v, p,       //     insert the pair (v, p)
        p,          //     insert the pair (p, X), where ...
        a[i + 1] ?  //       if this is not the last element:
          v         //         X = v
        :           //       else:
          i ?       //         if i &gt; 0:
            a[0]    //           X = a[0]
          :         //         else (last iteration):
            b       //           X = b
      ]             //
    ),              //   end of map()
    f(a, b)         //   append the result of a recursive call
  ].flat(2)         //   flatten everything
:                   // else:
  a                 //   stop the recursion (a[] is empty)
</code></pre>
</div>
<div id="pu2" class="pu"><h1><a href="https://github.com/Vyxal/Vyxal/tree/version-2" rel="nofollow noreferrer">Vyxal</a>, 9 bytes</h1>
<pre><code>KƛZṫwẊ;fǓ
</code></pre>
<p><a href="https://vyxal.pythonanywhere.com/?v=2&amp;c=1#WyIiLCIiLCJLxpta4bmrd+G6ijtmx5MiLCIiLCJbXCJhXCIsXCJiXCIsXCJjXCIsXCJkXCIsXCJlXCJdIl0=" rel="nofollow noreferrer">Try it Online!</a>
Port of Neil's Charcoal answer.</p>
<pre><code>Kƛ    ;   # Over every prefix  
  Z       # Double each value
    wẊ    # Append the last value to
   ṫ      # The rest
       fǓ # Flatten and move the first character to the end.
</code></pre>
<h1><a href="https://github.com/Vyxal/Vyxal/tree/version-2" rel="nofollow noreferrer">Vyxal</a>, 14 bytes</h1>
<pre><code>₌ẊZFṖvf'zy∩≈;h
</code></pre>
<p><a href="https://vyxal.pythonanywhere.com/?v=2&amp;c=1#WyIiLCIiLCLigozhuopaRuG5lnZmJ3p54oip4omIO2giLCIiLCJbXCJhXCIsXCJiXCIsXCJjXCJdIl0=" rel="nofollow noreferrer">Try it Online!</a></p>
<p>Brute force answer. 12 bytes by removing the <code>;h</code> if we can output all solutions.</p>
<pre><code>    Ṗ          # Permutations
 Ẋ             # Of all pairs in the input
₌ ZF           # Aside from doubles of one item
     vf        # Flatten each
       '    ;h # Find one where
        zy     # Every other overlapping pair
          ∩≈   # Has all elements equal?
</code></pre>
</div>
<div id="pu3" class="pu"><h1><a href="https://github.com/somebody1234/Charcoal" rel="nofollow noreferrer">Charcoal</a>, 18 bytes</h1>
<pre><code>Φ⭆θ⭆…θκ⁺×²λ×²ικ§θ⁰
</code></pre>
<p><a href="https://tio.run/##S85ILErOT8z5/z@gKDOvRMMtM6cktUgjuATIS/dNLNAo1FFAcJwrk3NSnTPywcLZmjoKATmlxRohmbmpxRpGOgo5QBE4J1MTCECqNK25IGY7lnjmpaRWgPQaAEX//09MSk5J/a9blgMA" rel="nofollow noreferrer" title="Charcoal – Try It Online">Try it online!</a> Link is to verbose version of code. Explanation: <a href="https://oeis.org/A097285" rel="nofollow noreferrer">A097285</a> is almost the sequence of indices, with each element doubled, except that there is only one of the first element at the start, the second coming at the end.</p>
<pre><code>  θ                 Input list
 ⭆                  Map over letters and join
     θ              Input list
    …               Truncated to length
      κ             Current index
   ⭆                Map over letters and join
          λ         Inner letter
        ×²          Doubled
       ⁺            Concatenated with
             ι      Outer letter
           ×²       Doubled
Φ             κ§θ⁰  Remove the first element and append it to the end
</code></pre>
</div>
<div id="pu4" class="pu"><h1><a href="https://github.com/DennisMitchell/jellylanguage" rel="nofollow noreferrer">Jelly</a>, 23 bytes</h1>
<pre><code>2œṖ$ÐƤṖUp/€żUẎṖƲ€Ẏ;Uṡ2Ɗ
</code></pre>
<p><a href="https://jht.hyper-neutrino.xyz/tio#WyIiLCIyxZPhuZYkw5DGpOG5llVwL+KCrMW8VeG6juG5lsay4oKs4bqOO1XhuaEyxooiLCLDh8WS4bmYIiwiIixbIlwiYWJjZFwiIl1d" rel="nofollow noreferrer">Try It Online!</a></p>
<p>pretty horribly long but it is fairly efficient and i kinda like the idea of it which is basically this: starting from the first person counting forwards, we introduce them to everyone starting from the last person counting backwards and do this back and forth until the next person, then we do not introduce them back, and we repeat this until we've done all of the introductions except each person to the one before them which we do at the end to close the loop</p>
<h2>Explanation</h2>
<pre><code>2œṖ$ÐƤṖUp/€żUẎṖƲ€Ẏ;Uṡ2Ɗ    main link
    ÐƤ                     for each suffix of the list
2œṖ$                       - partition at index 2, so split the first element off
      Ṗ                    remove the last element (the single list)
       U                   reverse (vectorizing) to flip the targets around
           €               for each of these pairs
         p/                - take their cartesian product to get each intro pair
                Ʋ€          for each of these lists of intros
           żU              - interleave with the reverse
             Ẏ             - flatten by one level
              Ṗ            - remove the last element (the last back-intro)
                 Ẏ         flatten by one level
                  ;   Ɗ    append
                   Uṡ2     - each pair of [the original list reversed]
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/275165/">275165</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




