<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::62886</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>6161</td><td>tinylisp</td><td>240821T061040Z</td><td><a href="https://codegolf.stackexchange.com/questions/62886/tiny-lisp-tiny-interpreter/275074#275074">Andrew B</a></td></tr>
<tr d-ix="1"><td>1800</td><td>JavaScript Node.js</td><td>240816T210842Z</td><td><a href="https://codegolf.stackexchange.com/questions/62886/tiny-lisp-tiny-interpreter/275020#275020">Andrew B</a></td></tr>
<tr d-ix="2"><td>9334</td><td>Acc!!</td><td>240803T000333Z</td><td><a href="https://codegolf.stackexchange.com/questions/62886/tiny-lisp-tiny-interpreter/274642#274642">emanresu</a></td></tr>
<tr d-ix="3"><td>1392</td><td>Setanta</td><td>240804T060806Z</td><td><a href="https://codegolf.stackexchange.com/questions/62886/tiny-lisp-tiny-interpreter/274664#274664">bb94</a></td></tr>
<tr d-ix="4"><td>2422</td><td>Ceylon</td><td>151108T230523Z</td><td><a href="https://codegolf.stackexchange.com/questions/62886/tiny-lisp-tiny-interpreter/63352#63352">Pa≈≠lo Eb</a></td></tr>
<tr d-ix="5"><td>nan</td><td>Python 2</td><td>151105T021914Z</td><td><a href="https://codegolf.stackexchange.com/questions/62886/tiny-lisp-tiny-interpreter/62975#62975">Ell</a></td></tr>
<tr d-ix="6"><td>1095</td><td>C GNU</td><td>151107T110750Z</td><td><a href="https://codegolf.stackexchange.com/questions/62886/tiny-lisp-tiny-interpreter/63204#63204">feersum</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://github.com/dloscutoff/Esolangs/tree/master/tinylisp" rel="nofollow noreferrer">tinylisp</a>, 6161 bytes</h1>
<pre><code>(d $__________________________________________________________________________________________________in(q((A B)(i(e B ())0(i(e A (h B))1
($__________________________________________________________________________________________________in A(t B)))))))
(d $__________________________________________________________________________________________________rev*
(q((A B)(i(e A ())B($__________________________________________________________________________________________________rev*(t A)(c(h A)B))))))
(d $__________________________________________________________________________________________________rev
(q((A)($__________________________________________________________________________________________________rev* A()))))
(d $__________________________________________________________________________________________________TOK(q((L$ A B)(i(e L$())(i(e A())B
(c($__________________________________________________________________________________________________rev A)B))(i
($__________________________________________________________________________________________________in(h L$)(q(40 41 32 10)))(i(e A())(i
($__________________________________________________________________________________________________in(h L$)(q(32 10)))
($__________________________________________________________________________________________________TOK(t L$)()B)
($__________________________________________________________________________________________________TOK(t L$)()(c(h L$)B)))(i
($__________________________________________________________________________________________________in (h L$)(q(32 10)))
($__________________________________________________________________________________________________TOK(t L$)()(c
($__________________________________________________________________________________________________rev A)B))
($__________________________________________________________________________________________________TOK(t L$)()(c(h L$)(c
($__________________________________________________________________________________________________rev A)B)))))
($__________________________________________________________________________________________________TOK(t L$)(c(h L$)A)B))))))(d
$__________________________________________________________________________________________________int?(q((L$)(i(e L$())1(i(l 47(h L$))(i(l(h L$)58)
($__________________________________________________________________________________________________int?(t L$))0)0)))))
(d $__________________________________________________________________________________________________times(q((X Y)(i(e Y 0)0(a X
($__________________________________________________________________________________________________times X(s Y 1)))))))
(d $__________________________________________________________________________________________________makeint(q((L$ X)(i(e L$())X
($__________________________________________________________________________________________________makeint(t L$)(a ($__________________________________________________________________________________________________times X 10)(s(h L$)48)))))))
(d $__________________________________________________________________________________________________CAT(q((L$)(i
($__________________________________________________________________________________________________int? L$)
($__________________________________________________________________________________________________makeint L$ 0)(string L$ )))))
(d $__________________________________________________________________________________________________PAREN*(q((L$ A)(i(e L$ ())A(i(e (h L$) 41)
($__________________________________________________________________________________________________PAREN*(t L$)(c()A))(i(e(h L$)40)
($__________________________________________________________________________________________________PAREN*(t L$)(c(c(h A)(h(t A)))(t(t A))))       
($__________________________________________________________________________________________________PAREN*(t L$)(c(c ($__________________________________________________________________________________________________CAT(h L$))(h A))(t A)))))))))(d 
$__________________________________________________________________________________________________PAREN(q((L$)(h(h 
($__________________________________________________________________________________________________PAREN* L$()))))))(d
$__________________________________________________________________________________________________READ(q((L$)
($__________________________________________________________________________________________________PAREN(c 41 ($__________________________________________________________________________________________________TOK L$()(q(40))))))))(d 
$__________________________________________________________________________________________________DISP(q((L$)(i(e L$())()(c(c(q disp)
(c(c(q q)(c(h L$)()))()))($__________________________________________________________________________________________________DISP (t L$)))))))
(d $__________________________________________________________________________________________________PRINT(q((L$)
($__________________________________________________________________________________________________DISP L$))))
(d $__________________________________________________________________________________________________SILENT(q((A)(string(q(32))))))
(d $__________________________________________________________________________________________________list(q(args args)))
(d $__________________________________________________________________________________________________MAP(q((X Y)(i(e Y())()(c(v ($__________________________________________________________________________________________________list X(h Y))) ($__________________________________________________________________________________________________MAP X(t Y)))))))
(d EXEC(q((L$)($__________________________________________________________________________________________________SILENT ($__________________________________________________________________________________________________MAP(q disp) ($__________________________________________________________________________________________________READ L$))))))
</code></pre>
<p><a href="https://tio.run/##3VlLb9s4EL77V/CQg9STKIm2dFoobQ7BZrtBmkN6WgRN0BibBk1sFNhfn53hkBIpUS8/xtg1/KBEama@eZPerl/@eV5vfr6/Rw/i7K@jv9Yv0WsUVeI8jtbRozgXURwneliJ6Alux3IRscghqmiL/PRrwYP@7fHXh4WngAoVcB4x8QbEVRx9A0VX8Tk3cgIec2EF@3ICvP3zd8R3dSZq216dgQRkZTTyAhTPg52sG62ZIgnc6eosBvR5InIpslTIJHaQ8wtiRWDhi5bfasagdW6OOphhdB4z6lmcXNHRtwVrLJ3KrNw4@U1pgNb1KHpYsPjw9jdK106qljB8FvmKJMKJZxqqImaKLJBKqyVO4oSzem3XPx43qJA78ZU08lWACNG9uGNBrvmLu2gDfCVvT/bj/u9HULwp3neOP/BAt/wpHO4Fo7oxd0cb8vG84FX7x@q2DkC24EKgnEYFfgJVvH1bv3zHC04NX1c3F58/2KbU@jXuNyo9JrtDx8ajEiOOzfqQ8bVIxvuSkwhBO6HoSe@LQJ6tGcSCXieRiSUDYPiZMocqiC1wU4PFggu4TQJPIAejuinDM3YcNxfVJ4OVDyY4E2zImBo6rVK9C2T2o0@XX647zVxE8f0qHtabn/HCXLw2nTXKhx8mAYVp7FgrwM3l51tOp9NACSUTxC@XVxeEsbJ1Vm9LWfX8vN5g/3j/9n0j8IuP8x/Vtd@1W8//xRL1CBy69idgDzUz4gEMDLeaobXwxd3FRxv/bC7HhdZmMBZ@WKTqLPUeoWIFaFbUB3sK3gkO4I6UmZ4o9YS@qySug7fUl/XbrIbRCg@MYF7m@jcrYaiEKkW5EqqAiwJHMoFhouAD9OEHyOm7pX4oX4oyM2QK8wsLpCiXMIJPAsQl3sVnMn2d5UQQp1NaghSBd57qHylJsrLUC40Q2ZJumNW5XpqRjMAT5ctIPmIGOArUQr00w3dQIXh0RjpptIP3Uqtr@EYHX3hm0BxpVW0Os7ym0pDAUcAUlkb4OftoM1vYG2HLGnKoRLSFtl3L7O3Jhk1ropf8aulThBHcymVDCi59fTmyJaUxvzEU2l05zpIbIRrMSo@KMa8m@kBLab@kBxzc0xmHWTiEQzFVtBflMqADwlJ6AUzSEAISIW0k1dfB0AsrwVHWbnQdX@6zIcSZC2HIHKuO17ddpzttglIz6dKuF6yk0aXKwsvCZhwSVu4hbFARDgnlaa4P2nSZV5R28mFE6dHUfwRE6RRE2RiiKcIHHvCzt4@tnq4z3AHQZjVaP84WbiJPTPG1yWwk@9XVWlJma@vGlk4sxYSxdSeXU1iUdYHFm/pqzCSDnlSLYfMQyaaTVEoLcHaIRhf4fmRnJw9ESxlXmqIidXbFRmZlW5ewnkIadWClsoY1qAFVe4DzRHC5cYayd7ZXqW4fkTkBg31dGhK3T2LPS0b1Zpcu53MZmHLDK6zWHs@Y4RbaA1PT0xq5ZztBU8vLsh20LRsNxlnRWL7VG3kcvC52im2G5emzz8z4SspamXsr8LRxFfCJrhEGQ3Ao3MYjrtFkL9v/YKQ5@Z4MpJr96wEDbl4RamJsOEamEvC9ZtqDTabujfNBvnahg2AGskMkANdf/YahZWmzjaUt0CA8/6iE9jJBOQcSUkqJMSnMFqvQJxgHT06kYpjDxGLONg6asHqQzE8Oh0hvHajTUt5A8ulQ3C8DLXS7HuzXdW2cYf6ByBmx7twn/eOBxFH23EZiitfIWWw8A48mk7Fu0jkAOQDVoanjlbI8O74ftRQVDtpc@R1jcfRuL7cnZObAL3UydM9RU571ZnT8zuYlddOoyObYm461lVhmOyV30ymjLSQdR2fOOdzE5rNZPS28TS10njMpuCvNSEwVo2lgUGO9bD03nCrojpFaHrXppGBQ9QkqoN6pD/BVYLZbdWSpmeYL@QPFyN6ku9RHXWAqy4mhMdU3e63T9TnHGWcIS@eAp3PLgaPDIPR9vHKip8mQcstdKuleRgwJ0IvgYLuTHmHn7UOoatF9JZt62LxnblT8v2eP7gYHKlcEdKz6dLAF@puW@BO6SGmSWJfiLMc6YV3yEPx/7D1gmR1tPeJBh7R3cfT00wsmkHqKcALCf1TT5q9VtbKZKNeX0qQntcQppewCabIV3rf/4tUl6v1f" rel="nofollow noreferrer" title="tinylisp ‚Äì Try It Online">Try it online!</a></p>
<p>The golfed version's TIO link includes the test cases in the footer.</p>
<p>Ungolfed, and without the long names ( also includes test cases ) :</p>
<pre><code>(d in
(q((A B)
  (i
    (e B ())
    0
    (i
      (e A (h B))
      1
      (in A (t B))
    )
  )
)))

(d rev*
(q((A B)
  (i
    (e A ())
    B
    (rev* (t A) (c (h A) B))
  )
)))

(d rev
(q((A)
  (rev* A ())
)))

(d TOK
(q((L$ A B)
  (i&#32;
    (e L$ ())
    (i&#32;
      (e A ())
      B
      (c (rev A) B)
    )
    (i
      (in (h L$) (q(40 41 32 10)))
      (i
        (e A ())
        (i&#32;
          (in (h L$) (q(32 10)))
          (TOK (t L$) () B)
          (TOK (t L$) () (c (h L$) B))
        )
        (i
          (in (h L$) (q(32 10)))
          (TOK (t L$) () (c (rev A) B))
          (TOK (t L$) () (c (h L$) (c (rev A) B)))
        )
      )
      (TOK (t L$) (c (h L$) A) B)&#32;
    )
  )
)))

(d int?
(q((L$)
  (i
    (e L$ ())
    1
    (i&#32;
      (l 47 (h L$))
      (i&#32;
        (l (h L$) 58)
        (int? (t L$))
        0
      )
      0
    )
  )
)))

(d times
(q((X Y)
  (i
    (e Y 0)
    0
    (a X (times X (s Y 1)))
  )
)))

(d makeint
(q((L$ X)
  (i&#32;
    (e L$ ())
    X
    (makeint (t L$) (a (times X 10) (s (h L$) 48) ))&#32;
  )&#32;
)))

(d CAT
(q((L$)
  (i
    (int? L$)
    (makeint L$ 0)
    (string L$ )
  )
)))

(d PAREN*
(q((L$ A)
  (i
    (e L$ ())
    A
    (i
      (e (h L$) 41)
      (PAREN* (t L$) (c () A))
      (i
        (e (h L$) 40)
        (PAREN* (t L$) (c (c (h A) (h (t A))) (t (t A)) ) )      &#32;
        (PAREN* (t L$) (c (c (CAT (h L$)) (h A)) (t A) ) )&#32;
      )
    )
  )
)))

(d PAREN
(q((L$)
  ( h( h (PAREN*  L$ () ) ) )
)))

(d READ
(q((L$)
  (PAREN (c 41 (TOK L$ () (q(40))) )  )
)))


(d DISP
(q((L$)
  (i
    (e L$ ())
    ()
    (c &#32;
       (c (q disp) (c (c (q q) (c (h L$)  ()) )()) )
       (DISP (t L$))
    )
  )
)))

(d PRINT
(q((L$)
  (DISP L$)
)))

(d SILENT
(q((A)
  (string (q (32)))
)))


(d list
(q(args
  args
)))


(d MAP
(q((X Y)
  (i&#32;
    (e Y ())
    ()
    (c (v (list X (h Y) )) (MAP X (t Y)))
  )
)))


(d EXEC
(q((L$)
   (SILENT (MAP (q disp) (READ L$) ) )&#32;
)))

</code></pre>
<p><a href="https://tio.run/##3RnJbtw29O6v4CEHKSdREmekUzFOfDDqpkaSg3M0EiMeNDFqexCgX@@@jZtEbbPAaBNZovj2lRRnt33458f2@e@Xl@yb2j6cZY9ZtlHn@ZlS2RZu8LhT5yrLc3opeIohBNuo7B7wc5nRFrJ9QNDOgfCen@XwdgaSnu5@vU3L2jhZ5zyFqMhok6vsKwqDATON2DE34kUUzMcifP7zd0K4eqOcRGVFwqSVaWc7qlhlFKkA/FkJZ1joEjAclLx6A@o@ZnWhaq2qUukid7wcbk9KqECfWYcNIYBh6BzCcColYew8fDkPWISSDxAcuWWWEjFFXyHnrJCBoyYqlUis7cPuN4l0nFdBkHU31D9UvRbOPkY@DgAXsaYJ/QWiRDM/W3TULxI67rY/755JyRv1JdbyiyqiQrtVNyAC8XHwDHCdd3L/5@1fd6CKTe@b4eS@4TkhcE699RIgyihFrK2bXOXkZbhZce82nxP@JV/wVCABZIs52fPuafvwHWdi7a83Hy8@vHW1ORizTa/xWCW1CxnzCpMFEyVddZa6CALap7f9Bu7UgcAb2U6GCv/zvwkW4DKbXcwvl36G/6N8SfgmdLa6h8sJYfcQE0/z8WLzPiQhXNQC2hCVEhNRa8rJCEuM1O8vP11PVU8mj6/ebjTyUX2DZcTZ/Kgew3pFapXTzRGhsKh@OtZ/vPwQpRrh49hifLq8uhAUThxJMhAOLSvPA8NgiaMKuX36/gyY9HDAPzbXcTUqX459q7Nf0BCAHRbkPVBgiWTAgioV3sPyRO4XNxfvAjNUxmozjXcbBo5cldtqe8mQFEOl3DJi4CpwADNaVwRoCUCzRiMeXJpe3SXYMFpjKwe4rulZtTA0yrSqXUN3g5cGR7qAYWHgD/jDA9jRbEtE9Uq1lbBp5AkIWrUrGMFfAcw1ziJNRe9VzQwRXDIKcgTZdUkPrVmztiVEUaJa8YRg14RasY4gE/WrWD8WBnY06AWHWuGVdAguauwT7x2cK62v4c6ZFoaBJDKWC4egOy6eBY4SobA80nSW1EMbO5GOrLBDJ2IsKHadsHeBXkwHMMh@vYo5wgimau1ZwWvsr0C3opXwS6Aw7iZIllqU8DYbGjVTWc38gZehvGSCwO75gtMiAsapmmq6SLVO@IBtaaMCZm3YAlah9JrSe7L00k4InLUf3yCXh2IIdRaaMBaOdS/ru6nTB0tRkpA@b4ew1uJLU6XR0mEcU1YfoGzSEQELE3luyLT5Oq@57dTjFpUnc/8JLCrnWFRNWTRH@QRB3L1j2xzYdbgjWFs5a@M6OwsbeSGLr21mE93PrdaaO1vXN3bpxKWYbezM1HqOiNYtsDhJb1MhGc0kp4btQ6wbNamSERA6xqNv@GFsFzcPtJY7rpZFRVN3xY3M2m5d0n5KeTQwq9TOrFEPGJcBAUUSXZKhHYQOOjXcR1RBweC@rkypO6RxlCWTfrOoq@VSRkBheaXdOpAZC9KCMrCUPa3ovTgJ/Frett2i7cRotM4aH/nO3iiSEO1i58RmXJ@h@Cysr6J1zjzYga9bV4mc6AdhtATHym264rwnB8X@Byst6PccIOO/X49YcMsWIV9j4zUyl0GcNfMIfacerPNRuRYxsGCBZcdoAGG@xhuGTqTlM5Y/gUbNi49K@FsmqedIQyq5MRaNfGI1dIJx9ObELgYYNhY52zhqwxqwZHlzOEZ765k6r@WNNJ8ex8M6kD3PS@zXaW1cEP6RypmI7lLK@HigCJy9dCMxJ2v0IjFRgCebydRuMjgAOQLXMdDplrK6On0edRyVLtraxDvG5uS7vdqekMmBXxl06IGjproa7Oh4r5Y1ddmoaH/szcfaRq2qvZq77JQxFpqPo6vgHG7m5tNjzytvWQsDOmnBfW0maqqZbAOjHhsUG6XhXEX3rNT2pJtOLgbjTlDB6r32AbEL5HPLVZZZGL5UPnCNHMy6z30yBeaKnFkac3NzMDr9nAuScYGyfA74emk5cnSYNP2QrJyZaTrl3HaflfSgIKYUGLTgaF8nA8ou@w7hVYvnjfbrob8WfqjEP8@ePA2OtFyxoVOrT8@2xP6mo/6MXaSWJtbnuCixXnFdiiz4/8R7JDJ7xnoig44Z7@bk7WfQmETradINCH9RLf1Pq2ZtO1FNr1rak1khyBiLoKVb4bz9Fc8vUS//Ag" rel="nofollow noreferrer" title="tinylisp ‚Äì Try It Online">Try it online!</a></p>
<h2>Note</h2>
<p>In what follows, I refer to the two tinylisps as tinylispI ( the implementation version where I wrote the interpreter) and tinylispT ( the target version where you write your own code). Note that the specs for each version are different.</p>
<h2>Limitations</h2>
<ol>
<li><p>There is no string support in tinylispI so to execute code you need to first translate that code into a list of char codes ( you can do that with <a href="https://tio.run/##bYwxDoMwDEV3n8Jb7KEZKjoGqepBIAqUBqUxwhHi9mnYO329p6e/@sNr2ONWblmmuVYte8zLUGQIH78PoUl16vogWSXNNslCqFa3FAsZw/brNzpdf9qrf7X8WYjZrhIzGTTMAP8@aQREIMXujt2DgSZ8izRiuBZgZKj1Bw" rel="nofollow noreferrer" title="JavaScript (Node.js) ‚Äì Try It Online">this JS script</a> ) then pass the list to EXEC.</p>
</li>
<li><p>There seems to be a limit on the length of char codes that I can pass in a list, so you may need to break your codes into sections.</p>
</li>
<li><p>Reserved Words. Because of my implementation approach, the additional functions that are available in tinylispI are also available in tinylispT which means you can use them also if you want, but you can't use their names. the (help) command shows these functions along with the ones defined in the tinylispT spec.</p>
</li>
</ol>
<h2>Approach</h2>
<p>My first step was to write a parser which take a list of char codes and transforms it into an S-expression. In the prototyping phase, I wrote code that takes this S-expression and evaluates it (using v), and prints the results (using disp). It may seem initially like that's all that's needed but it has this draw-back: names that the user uses could collide with names that are used in the interpreter implementation. I needed to fix that. I considered these 3 alternatives:</p>
<ol>
<li><p>Use globals and locals to store all names and values in S-expressions. Verdict? FAIL. Why? The tests take forever to run + there are some bugs that I couldn't resolve, the code is really complex. This is by far the coolest option, but it simply doesn't work!</p>
</li>
<li><p>Since names of 100 or more are illegal, use only names that are 100 or more chars for the implementation, especially globals. This prevents name collisions. Verdict? MAYBE - draw-backs: (a) There are still some names e.g. &quot;string&quot; that are built-ins in tinylispI but are not in the spec for tinylispT. User could use one of those names and get an error. We would have to add a &quot;limitation&quot; that lists a set of reserved words.</p>
</li>
<li><p>Transform the user's code so that all names have a pre-fix (e.g. '$'). Verdict? FAIL. Why? q for example needs to return its parameter un-evaluated. If that is a name, then it will have a $-prefix. This prefix will be displayed to the user. I don't see any work-around for q, and there may be other built-ins that have the same problem.</p>
</li>
</ol>
<p>I went with option #2. That's why, if you look at the code, you'll see really long global function names - they are all at least 100 chars long.</p>
</div>
<div id="pu1" class="pu"><h1><a href="https://nodejs.org" rel="nofollow noreferrer">JavaScript (Node.js)</a>, 1800 bytes</h1>

<pre class="lang-javascript prettyprint-override"><code>b=a=&gt;a.replace(/\(/g,' ( ').replace(/\)/g,' ) ').trim().split(/\s+/)
c=i=&gt;i.match(/^\d+$/)?parseInt(i):i=='nil'?null:i
d=(i,l)=&gt;l?(t=i.shift())?t=='('?[l.push(d(i,[])),d(i,l)][1]:t==')'?l:d(i,l.concat(c(t))):l.pop():d(i,[])
R=x=&gt;d(b(x))
function D(o,b,e){b=b||[]
e=e||[]
this.o=o
this.d={}
for(i=0;i&lt;b.length;i++)this.s(b[i],e[i])}
D.prototype.s=function(y,v){this.d[y]=v}
D.prototype.f=function(y){return y in this.d?this:this.o?this.o.f(y):null}
D.prototype.g=function(y){e=this.f(y);if(!e)throw &quot;not found: &quot;+y;return e.d[y]}
F=new D(null)
F.s('c',(a,b)=&gt;{r=b?b.slice():[];r.unshift(a);return r})
F.s('h',(a)=&gt;a?a.length?a[0]:null:null)
F.s('t',(a)=&gt;a?a.length&gt;1?a.slice(1):null:null)
F.s('s',(a,b)=&gt;a-b)
F.s('l',(a,b)=&gt;a&lt;b?1:0)
F.s('e',(a,b)=&gt;{q=(a,b)=&gt;{if(Array.isArray(a)){if(a.length!=b.length)return 0
e=1
for(i=0;i&lt;a.length;i++){e=e&amp;&amp;q(a[i],b[i])}
return e}else return a==b?1:0}
return q(a,b)})
G=(a,e)=&gt;Array.isArray(a)?a.map(k=&gt;E(k,e)):typeof a=='string'?e.g(a):a
E=(x,n)=&gt;{while(1){if(Array.isArray(x)){if(!x.length){return x}else{if(x[0]=='v'){x=E(x[1],n)} else if(x[0]=='d'){var y=x[1]
var v=E(x[2],n)
n.s(y, v)
return y}else if(x[0]=='i'){var t=E(x[1],n)
if(t!=null &amp;&amp; t!=false){x=x[2]}else{if(typeof x[3]=='undefined'){return null}else{x=x[3]}}} else if(x[0]=='q'){return x[1]}else{var
f=E(x[0],n)
if(typeof f=='function'){var e=G(x,n)
return e.shift().apply(null,e)}else if((f.length&gt;1)&amp;&amp;(f.length&lt;4)){
var m=f.length==3
var v=0
var b=m?f[1]:f[0]
if(!Array.isArray(b)){b=[b]
v=1}
var h=m?f[2]:f[1]
p=x.slice()
p.shift()
var g=m?p:G(p,n)
if(v){g=[g]}x=h
n=new D(F,b,g)}}}}else{return G(x,n)}}}
H=a=&gt;a==null?'nil':Array.isArray(a)?'('+a.map(H).join` `+')':typeof a=='function'?'&lt;function&gt;':a  
P=x=&gt;H(x)
X=x=&gt;{try{R('('+x+')').map(x=&gt;{console.log(P(E(x,F)))})}catch(e){console.log(e)}}
</code></pre>
<p><a href="https://tio.run/##rVdtc@JGEv6uXzHeTZmZGGQE9l4W71h1VVnbW7UfUsmXq2K5eJAGUCIkLAlWlMP99U33vIgRYF8qd3gXSdNvTz/d6hl@ExtRRkWyqnpZHstv36Zc8FvhF3KVikjSyy/0ct7tEEo6zFlkapHhYlUkS8r8cpUmFUjKi0vmRTzht4m/FFW0oJf//hJffHfJwpUoSvkpq2jCRgnnnSxJO2G2TtNR4sWcJt2U8ds0pBVP/HKRzCrKWFiBIu2E49RfrcsFjUFtPGGsGyv9yTiYjFCFdcJ0pNb8KM8iUdGIVoyxEdjlK8pGxtD7mdf8NqZTWjPmzdZZVCV5Rn6keXfalex5yqd//DGeeJJLda0WSennPNc3MX/eebO8oAnv3yQfpn4qs3m1uEkuLphSKOl0nEy6Er7YzvvRXxV5lVfblfRLboPRbXfDnrW/8XbCN23FmaPIngtZrYuMbEmSEW0S4mWkcYX64s9AdYRMtl3NW64kV9qoe5PM6JkEyEX@lbzJ8orM8nUWj8ibi@2NCSkVup13xzP5FQhC98y7gxQ7UadLRXcK1Xou@DSc@mWaQFuw0XhyU/jrTBdPMOuq2BnDBRqCmQiFoS4U4/5EQR85AaojvdsAbnWYgB3plw0g0ZuatXS/9mEaBqO@WZd78E/c3gEf/ywKsfWTUl0hOsNFG/6M21ozk1MfWiRwekG4vQBcy/PzJyqwGaa6GSytO5mWkpgnwbnC1oifFCLg6x6xScB2iAt4WIoV/Z3ffqS/gwYbYa3zGfrqlPA2ZvNOCLUH1ZHwPnJadzNM8esiSZG841xrnetZbVO0XVcrrCiroUrgftNhzzX/CI/BBLzuiMplL49BvhEF2XLU8PB2o9QHqO5lwP@2SzbMZrvdHThIjINqH8QDaXXGsdrk/JzA7UyAEQJBvw1Ew0I9HqIj6GY5SzKJiEww9X4obbQcTna7I/xPe22MrrUBjzdTePoNHh1rBib2DTPAJb9XhDfltpPMF6tVulVvERStyZvOmgZn5@fN04crqInib8ntGudDw2hfXad8Gc5w/s0AGKI6a5d1ynCcjadQBx7slMlCmQzQBMqz4rV9c72Vxan05qC3Gt3TlckX5tWcj@eTXc0XXmYGwh1MzDkDFjVNJmGdPix6D2on4apyoRr2o6NehtF@ofv5gfm/5Un2SB4vYJi7Pd0wHHY@2PvbzkgQ4v2Ew/wBGtj7F949V8X2@WeKTmv0wpRnFMCeUOap9NN8Tn@iUMvuHWwOO7aL1BYF3eRqQH123/abQ5z/WsmyolWXgCLxCHwaIUp@lbWMAIWR4cew4YJpZPhpkJHWcmOoQRJA2ZLvNEu08yXTDncefouoWouUcAdNxZQEZ5gRcmxGtUsra4ugNju467nJxGWl88s6imRZntlULi9dsQ5jQMGXagrtpuXlTiSpdfGyPeTlYTIlJPWodCkjVwNCn2hABmRoeKFP5EEWslPeiNFGpEncy8RS@hO5kdn4y2O1yNfzxZuk@s9ClN@XKxklIv0uWsBB5Fxk8dtsvZwOi/LszHgjT@iR1Ixo9giNSQ1hGS7Dam0Xt3qB4c2GbJldL2U6QxFeQYoXK/qM6/QztB353DhfJtm67ME@LCWhJenvE4tJb@j30cbRMUKUaK2NurdgExIgR83sU2QwK@sfCDCvBsjbQD2apztdYARs2o@@DWwn0nsSXJsHA6gxvD9hOGgMSwwTnDS9I@8aJw@vRn/FyYPj5NPeiWutn7Ggyg/cQT1Oe/uE3qw7GF/QgY33NCkr5VsU85LgF3OEYjmNhRO/iQ4nYLEsiaxXRbOmXB0LDpl9WueV7EkRLYxjHQWu27JqnCUEH@3IoFEzPKhF/ASpL5SWM1ro3juh1YG0uQEOvNbSAUS1wx2gwzmJ/GD4BuUGkCEWFLJWcKvJTkeAkXXK/1@kQOFTQS0dlgiHCQhhVP42D1DMCubMC0y0Cw8s2JydFQTKWjUzVNkVuAcz1/o0ZZgNNXgIzBfrQs1QcmVsLPBZnsbp9y8xDLtMtF6@xLO2bVN3gnLlwyG@IVUJXqW11wZmEt/DaS/gCuA4aL090NKVIqCGyL0qDuRTkuam/yrgi1cBK@eanx6@D/3Xm79Hgj65gqLZKX1hi0iu21WMk00SyzI8rCNssHkBvyPdVwWeXL5SXCBac89Df8@I9W10MAvH4pig4PUXBQ4eMjxsOHSIW3@vjUPjC06JlKyB5ii42bbyMJEVeMjBNQn@ZhrHWbjIpQoVHHXOERStxl4JiO@0Nmq/zOSaDIbQJfA5eK/xNPQ6vpN90HdeBeVCNy1aOpI8jsNj4H@VO7T@35DZ@EfAGsgvIev/F5KNA8Vx37AcXMHh5z0ZvLsekusf3v/jPRkOhj9cvQP3nvfoebCDy6iSMR5bYd@/GnjmvOr9X86pnjp2ejX8geutvqhTpvr67MEB03MOjJ46KrYX0AT@vdWF0Uc9fW670kv6/HWtvj@5ArvxNWPMOekcnE/2ZwG7Z7u7Iu0FpDeAsyvpXWnCna1Hz3k9PHXcQGNpDTZ3djgvIMVCBcR8a9/79m@6jWoV/R//AgbFa37o4Q@PLrG1hNJ@@xM" rel="nofollow noreferrer" title="JavaScript (Node.js) ‚Äì Try It Online">Try it online!</a></p>
<p>In this golfed version, the main function that executes code is called X. X takes a single argument - the tinylisp program - executes it and returns the results of execution.</p>
<p>The test cases use their own execute function which in turn uses R, E, P functions (Read, Evaluate, Print). The footer in the TIO link includes the test cases from the question. Expected output is &quot;Success!&quot;.</p>
<p>The following is an ungolfed version:</p>
<pre class="lang-javascript prettyprint-override"><code>  function READ(x){&#32;
 &#32;
    const tokenize = function(input) {
      return input.replace(/\(/g, ' ( ')
                  .replace(/\)/g, ' ) ')
                  .trim()
                  .split(/\s+/);
    }
    &#32;
    const categorize = function(input) {
      if (input.match(/^\d+$/)) {
        return parseInt(input);
      } else if(input == 'nil') {
        return null ;
      } else {
        return input ;
      }
    }
 &#32;
    const parenthesize = function(input, list) {
      if (list === undefined) {
        return parenthesize(input, []);
      } else {
        var token = input.shift();
        if (token === undefined) {
          return list.pop();
        } else if (token === "(") {
          list.push(parenthesize(input, []));
          return parenthesize(input, list);
        } else if (token === ")") {
          return list;
        } else {
          return parenthesize(input, list.concat(categorize(token)));
        }
      }
    }
 &#32;
    return parenthesize(tokenize(x))&#32;
  }
 &#32;
  function Env(outer, binds, exprs){
   &#32;
    if(typeof binds == 'undefined'){&#32;
      binds = []
    }
   &#32;
    if(typeof exprs == 'undefined'){&#32;
      exprs = []
    }
   &#32;
    this.outer = outer
   &#32;
    this.data = {}
   &#32;
    for(var i = 0; i &lt; binds.length; i++){&#32;
      this.set(binds[i], exprs[i])
    } &#32;
  }
 &#32;
  Env.prototype.set = function(symbol, value){&#32;
    this.data[symbol] = value
  }
 &#32;
  Env.prototype.find = function(symbol){&#32;
    if(symbol in this.data){&#32;
      return this
    }
    if(this.outer != null){&#32;
      return this.outer.find(symbol) &#32;
    }
    return null &#32;
  }
 &#32;
  Env.prototype.get = function(symbol){&#32;
    var env = this.find(symbol)
    if(env == null)
      throw "not found: " + symbol
    return env.data[symbol] &#32;
  }
 &#32;
  var repl_env = new Env(null)
 &#32;
  repl_env.set('c', (a, b) =&gt;{r=b?b.slice():[]; r.unshift(a); return r })   &#32;
  repl_env.set('h', (a) =&gt; a?a.length?a[0]:null:null)   &#32;
  repl_env.set('t', (a) =&gt; a?a.length&gt;1?a.slice(1):null:null)   &#32;
  repl_env.set('s', (a, b) =&gt; a - b)   &#32;
  repl_env.set('l', (a, b) =&gt; a &lt; b ? 1 : 0)
  repl_env.set('e', (a, b) =&gt; {&#32;
    eq=(a,b)=&gt;{&#32;
      if(Array.isArray(a)){&#32;
        if(a.length!=b.length) return 0
        e=1
        for(i=0;i&lt;a.length;i++){&#32;
          e=e&amp;&amp;eq(a[i],b[i])   &#32;
        }
        return e&#32;
      }
      else       &#32;
        return a==b ? 1 : 0
    }   &#32;
    return eq(a, b)
  })   &#32;
 &#32;
  function EVAL(x, env){&#32;
   &#32;
    function eval_ast(ast, env){&#32;

      if(Array.isArray(ast)){&#32;
        return ast.map(k =&gt; EVAL(k, env))
      } else if(typeof ast == 'string'){&#32;
        return env.get(ast)
      } else {&#32;
        return ast &#32;
      }
    }

  while(true){  &#32;
   &#32;
    if(Array.isArray(x)){&#32;
      if(x.length == 0){&#32;
        return x
      } else {&#32;
&#32;
          if(x[0] == 'v'){&#32;
            x = EVAL(x[1], env)&#32;

          } else if(x[0] == 'd'){&#32;
            var symbol = x[1]
            var value = EVAL(x[2], env)&#32;
            env.set(symbol, value)
            return symbol

          } else if(x[0] == 'i'){&#32;
            var test = EVAL(x[1], env)
            if(test != null &amp;&amp; test != false){&#32;
              x = x[2]
            } else {&#32;
              if(typeof x[3] == 'undefined'){&#32;
                return null
              } else {&#32;
                x = x[3]
              }
            }&#32;
   &#32;

          } else if(x[0] == 'q'){&#32;
            return x[1]
       &#32;
        } else {&#32;
          var first = EVAL(x[0],env)
         &#32;
          if(typeof first == 'function'){&#32;
            var e = eval_ast(x, env)
            var fn = e.shift()
            return fn.apply(null, e)
          }

          else if((first.length &gt; 1)&amp;&amp;(first.length &lt; 4 )){&#32;

            var m = first.length == 3

            var variablearity=false&#32;

            var binds = m ? first[1] : first[0]

            if(!Array.isArray(binds)){&#32;
              binds=[binds]
              variablearity=true&#32;
            }

            var body = m ? first[2] : first[1]

            p = x.slice()
            p.shift()

            var args = m ? p : eval_ast(p, env)
            if(variablearity){&#32;
              args=[args]
            }

            var newEnv= new Env(repl_env, binds, args)

            x = body
            env = newEnv
           &#32;
          }
        }&#32;
      }
    } else {&#32;
      return eval_ast(x, env)
    }
  }

  }
 &#32;
  function PRINT(x){&#32;
 &#32;
    function stringify(a){&#32;
      if(a == null){&#32;
        return 'nil'
      } else if(Array.isArray(a)){&#32;
        return '(' + a.map(stringify).join(' ') + ')'
      } else if(typeof a == 'function') {&#32;
        return '&lt;function&gt;'
      } else {&#32;
        return a
      }  &#32;
    } &#32;
 &#32;
    return stringify(x)
  }
 &#32;
  function exec(x){&#32;
    try{&#32;
      READ('('+x+')')
        .map(x=&gt;{&#32;
          console.log(PRINT(EVAL(x, repl_env)))
        })
    }catch(e){&#32;
      console.log(e)
    } &#32;
  }

</code></pre>
<h2>Approach</h2>
<p>The READ function is mostly copied from Mary Rose Cook's <a href="https://maryrosecook.com/blog/post/little-lisp-interpreter" rel="nofollow noreferrer">Little Lisp Interpreter</a>. For the rest of the code, my starting point was a JS LISP interpreter that I had already built by following <a href="https://github.com/kanaka/mal" rel="nofollow noreferrer">Make A Lisp</a>. I had to do quite a few modifications to get it to work with the specified constraints however.</p>
<p>First, I had used JS anonymous function for user defined functions. I had to change that since in tinylisp we only know if there is a user defined function by inspecting the length of the list at the first position in a list. Also, I had used functions for my special forms, but that had to change to get TCO to work. In the end EVAL is one long function which contains most of the tinylisp workings except for built-in functions which remained in their own JS functions.</p>
<p>When golfing my solution, I replaced all variable names with single-letter variable names. I also moved a few functions out to global scope, which enabled further shortenings. If you inspect the code you will see several occurrences of the var keyword. I haven't checked all of these are necessary, but I believe most of them are. Even with TCO in place EVAL still calls itself in some places, and so some variables need to be defined locally and not globally.</p>
<p>In the code there is one class (prototype based), which means in turn that I have a few places where I've used function keyword rather than ES6 arrow functions. Recall that ES6 arrow functions don't define this, and hence can't be used for class methods.</p>
</div>
<div id="pu2" class="pu"><h1><em><a href="https://github.com/dloscutoff/Esolangs/tree/master/Acc!!" rel="noreferrer">Acc!!</a></em>, <s>9450</s> 9334 bytes</h1>
<pre><code>Count h while h-10 {
_+(258+h*2^8+2^73+(882+h*24)*(2^80+0^0^(9-h)*(4^56+2^40))+(15*4^56+6*2^40)*0^0^(9-h)+257*4^72+(684743974900/20^h%20+99)*4^92)*256^(864+h*24)
}
_+1113*2^352+2^8833+69*2^292+2^262+69*2^516
Count h while _/2^320%2^32+0^h {
_+(N-_/2^320%2^8)*2^320
_+(1-3302829851648/2^(_/2^320%2^32)%2+2^32*0^(_/2^448%2^32)-_/4^64%2^64)*4^64
Count f while 0^(_/4^64%2^64)+0^(_/2^320%2^32-40)^2-f {
_+(1-_/2^64%2^64)*2^64
Count g while _/2^64%2^32*(_/2^448%2^32)*(g-_/256^(_/2^448%2^32+1)%2^32) {
_+(_/256^(_/2^448%2^32+g+5)%2^8-_/2^32%2^32)*2^32
_+(1023*2^48/2^(_/2^32%2^32)%2+2^32*(_/2^96%2^32*10+_/2^32%2^32-48)-_/2^64%2^64)*2^64
}
_+(_/2^96%2^32*2^8*256^(_/2^352%2^32)+(_/2^352%2^32-_/2^448%2^32)*2^448+5*2^352)*0^0^(_/2^64%2^32*(_/2^448%2^32))
_+(2+_/2^448%2^32*2^8)*2^(_/2^352%2^32*8)+(_/256^(_/2^256%2^32)%2^32-_/2^32%2^32)*2^32
_+(_/2^352%2^32-_/2^(_/2^256%2^32*8)%2^64)*2^(_/2^256%2^32*8)+_/2^352%2^32*256^((_/256^(_/2^256%2^32-4)%2^32-4)*0^(_/2^32%2^32)+_/2^32%2^32+5)+9*2^352
_+0^(_/2^448%2^32)*8^86-_/2^448%2^32*2^448
}
_+(256^(_/2^352%2^32)+(_/2^352%2^32-_/2^448%2^32)*2^448+5*2^352)*(_/4^80%2^32)*(_/4^64%2^32)
_+(_/2^320%2^32*256^(_/2^352%2^32)+2^352+256^(_/2^448%2^32+1))*(_/4^64%2^32)
_-0^(_/2^320%2^32-41)^2*(_/256^(_/2^256%2^32)%2^32*256^(_/2^256%2^32)+8^86)
}
Count d while _/256^(_/8^96%2^32+5)%2^32 {
_+(_/256^(_/8^96%2^32+5)%2^32-_/8^96%2^32)*8^96
_+(64-_/2^224%2^32)*2^224
_+(2+2^8*11+2^73+2^80*(_/256^(_/8^96%2^32+1)%2^32)-_/2^(_/2^352%2^32*8)%4^72)*2^(_/2^352%2^32*8)+((_/2^352%2^32+9)*(2^32+1)-9-_/2^(_/2^224%2^32*8)%2^64)*2^(_/2^224%2^32*8)+9*2^353
Count f while _/2^224%2^32/64 {
_+(_/2^(_/2^224%2^32*8)%2^64-_/4^80%2^64)*4^80
_+(_/256^(_/4^80%2^32+1)%2^64*0^0^(_/4^80%2^32)-_/2^32%2^64)*2^32
_+(((_/256^(_/2^32%2^32+5)%2^32-_/2^32%2^32)*0^0^(_/2^32%2^32/64)+2^32*(_/4^96%2^32))*256^(_/4^80%2^32+1)-_/256^(_/2^224%2^32+4)%2^32*256^(_/2^224%2^32+4))*0^0^(_/2^32%2^32*0^(_/2^64%2^32)*(0^(_/2^32%2^32-8)^2+0^(_/256^(_/2^32%2^32+1)%2^32)*(_/2^32%2^32/64)))+(_/4^96%2^32*256^(_/2^64%2^32+5)-_/256^(_/2^224%2^32+4)%2^32*256^(_/2^224%2^32+4))*0^(0^(_/2^64%2^32)+0^0^(_/2^64%2^32)*(_/256^(_/2^64%2^32+5)%2^32)+(_/2^32%2^32-9)^2)+(_/4^96%2^32*256^(_/4^80%2^32+5)+(_/256^(_/4^96%2^32+5)%2^32-_/256^(_/2^224%2^32+4)%2^32)*256^(_/2^224%2^32+4)-_/256^(_/4^96%2^32+5)%2^32*256^(_/4^96%2^32+5))*0^(_/2^32%2^32-10)^2*0^(_/2^64%2^32)
_+(_/2^(_/2^224%2^32*8)%2^64-_/4^80%2^64)*4^80
Count n while _/4^96%2^32*0^n {
_+(_/256^(_/4^96%2^32+1)%2^32-_/2^416%2^32)*2^416
Count p while 0^(1-_/256^(_/2^416%2^32)%2^8)^2*0^p {
Count e while (_/2^224%2^32-8*e)/72*0^(_/2^384%2^32)+0^e {
_+(_/256^(_/2^224%2^32-8*e-8)%2^64-_/2^96%2^64)*2^96
_+(_/2^96%2^32*0^0^(_/256^(_/2^96%2^32+1)%2^32/64*0^(_/4^64%2^32))-_/2^384%2^32)*2^384
}
_+(_/256^(_/256^(_/2^384%2^32+1)%2^32+1)%2^32+2^32*(_/256^(_/2^384%2^32+5)%2^32)-_/2^32%2^64)*2^32
_+((2+2^8*(_/2^32%2^32)+2^73+2^80*(_/2^64%2^32))*256^(_/2^352%2^32)+((_/2^352%2^32+9)*(2^32+1)-9-_/2^32%2^64)*2^32+9*2^353)*0^0^(2-_/2^(_/2^32%2^32*8)%2^8)
Count e while 0^(_/2^480%2^32)*(e-2)+0^e {
_+(873+2^32*864-_/2^32%2^64)*2^32*e
Count g while _/2^32%2^32 {
_+(_/256^(_/2^32%2^32+5)%2^32+2^32*(_/256^(_/2^64%2^32+5)%2^32)-_/2^32%2^64)*2^32*0^0^g
_-_/2^32%2^32*2^32*0^((_/256^(_/2^416%2^32+1)-_/256^(_/256^(_/2^32%2^32+1)%2^32+1))%256^(_/256^(_/2^416%2^32+1)%2^32+4))
}
_+(_/256^(_/2^64%2^32+1)%2^32-_/2^480%2^32)*2^480
}
}
_+(_/2^416%2^32-_/2^480%2^32)*0^(_/256^(_/2^416%2^32)%2^8)*2^480
Count p while (2-_/2^(_/2^416%2^32*8)%2^8)*0^p {
Count h while 0^0^(_/2^320%2^32)*(_/256^(_/2^320%2^32+5)%2^32)+0^h {
_+(_/256^(_/2^320%2^32+5)%2^32*0^0^h+_/4^80%2^32*0^h-_/2^320%2^32)*2^320
}
_+(2+_/2^480%2^32*2^8)*2^(_/2^352%2^32*8)+_/2^352%2^32*256^(_/2^320%2^32+5+(_/2^224%2^32-5)*0^(_/2^320%2^32))+9*2^352
_+(_/256^(_/4^96%2^32+5)%2^32-_/256^(_/2^224%2^32+4)%2^32)*256^(_/2^224%2^32+4)
}
_+(2^227+_/2^416%2^32*2^96*256^(_/2^224%2^32))*0^(2-_/2^(_/2^416%2^32*8)%2^8)
}
_+(_/2^(_/2^224%2^32*8)%2^64-_/2^32%2^64)*2^32
_+(_/256^(_/2^32%2^32+1)%2^64-_/2^96%2^64)*2^96
Count c while 0^(_/2^64%2^32+c) {
_+(_/256^(_/4^64%2^32+1)%2^32+2^32*(_/256^(_/256^(_/4^64%2^32+5)%2^32+1)%2^32)-_/4^80%2^64)*4^80
Count p while 0^(_/2^96%2^32-11)^2*0^p {
Write 40)*(0^(2-_/2^(_/4^80%2^32*8)%2^8)+0^(_/4^80%2^32)
_+(_/4^80%2^32-_/2^(_/2^352%2^32*8)%2^32)*2^(_/2^352%2^32*8)
_+(_/2^352%2^32+4-_/2^256%2^32)*2^256
Count h while _/2^256%2^32-_/2^352%2^32 {
_+(_/2^((_/2^256%2^32-4)*8)%2^32-_/2^320%2^32)*2^320
Count l while (2-_/2^(_/2^320%2^32*8)%2^8)*0^l {
Write 41)*0^(_/2^320%2^32
Count m while _/2^320%2^32*0^m {
Count j while _/2^(_/2^320%2^32*8)%2^8*0^j {
Count e while e-_/256^(_/2^320%2^32+1)%2^32 {
Write _/256^(_/2^320%2^32+e+5)%2^8
}
}
Count j while (1-_/2^(_/2^320%2^32*8)%2^8)*0^j {
_+(_/256^(_/2^320%2^32+1)%2^32%2^31+_/256^(_/2^320%2^32+1)%2^32/2^31-_/2^64%2^32)*2^64
Write 45)*(_/256^(_/2^320%2^32+1)%2^32/2^31
Count i while 10-i {
Write 48+_/2^64%2^32/10^(9-i)%10)*0^0^(_/2^64%2^32/10^(9-i)+0^(9-i)
}
}
}
_-_/2^(_/2^256%2^32*8)%2^32*2^(_/2^256%2^32*8)-8^86
Write 32)*0^0^(_/256^(_/2^256%2^32-4)%2^32
}
Count l while 0^(2-_/2^(_/2^320%2^32*8)%2^8)*0^l {
_+(_/256^(_/2^320%2^32+5)%2^32+2^32*(_/256^(_/2^320%2^32+1)%2^32)-_/2^((_/2^256%2^32-4)*8)%2^64)*256^(_/2^256%2^32-4)
Write 40)*0^((2-_/2^(_/256^(_/2^256%2^32)%2^32*8)%2^8)*(_/256^(_/2^256%2^32)%2^32)
_+8^86
}
}
Write 10
_-_/2^512%2^64*2^512-2^227
}
_+(_/256^(_/2^32%2^32+5)%2^32*256^(_/2^224%2^32+4)+(12-_/256^(_/2^32%2^32+1)%2^64)*256^(_/2^32%2^32+1))*0^(_/2^96%2^32-7)^2
Count p while 4479/2^(_/2^96%2^32)%2*0^p {
_+(2+_/4^80%2^64*2^8)*2^(_/2^352%2^32*8)
_+(12/2^(_/2^96%2^32)%2*(_/256^(_/4^80%2^32-7+4*(_/2^96%2^32))%2^32)+0^(_/2^96%2^32-1)^2*(_/2^352%2^32)-_/2^384%2^32)*2^384+9*2^352
Count r while 48/2^(_/2^96%2^32)%2*0^r {
_+(_/256^(_/4^80%2^32+1)%2^32+2^32*(_/256^(_/4^96%2^32+1)%2^32)-_/2^448%2^64)*2^448
_+(2^31+(_/2^448%2^32%2^31*(-1)^(_/2^448%2^32/2^31)-_/2^448%2^32/2^31)-(_/2^480%2^32%2^31*(-1)^(_/2^480%2^32/2^31)-_/2^480%2^32/2^31)-_/2^32%2^32)*2^32
_+(_/2^96%2^32/5*-(1/(3*(_/2^32%2^32-2^31)+2))+4/(_/2^96%2^32)*((_/2^32%2^32-2^31)*(-1)^(-(1/(3*(_/2^32%2^32-2^31)+2)))+(2^31-1)*-(1/(3*(_/2^32%2^32-2^31)+2))))*256^(_/2^352%2^32+1)
}
Count r while 0^(6-_/2^96%2^32)^2*0^r {
_+(_/2^352%2^32-_/2^256%2^32)*2^256
Count g while _/2^32%2^32*(_/2^256%2^32/(_/2^352%2^32)) {
_-0^(_/4^80%2^32-_/4^96%2^32)^2*(_/2^(_/2^256%2^32*8)%2^64*256^(_/2^256%2^32)+2^259)
Count k while (_/4^80%2^32-_/4^96%2^32)*0^k {
_+(0^(0^(_/4^80%2^32)+0^(_/4^96%2^32))*0^(_/256^(_/4^80%2^32)%2^8-_/256^(_/4^96%2^32)%2^8)^2-_/2^32%2^32)*2^32
Count l while _/2^32%2^32*0^l {
_+((0^(_/256^(_/4^80%2^32+1)%2^32-_/256^(_/4^96%2^32+1)%2^32)^2-_/2^32%2^32)*2^32-_/2^(_/2^256%2^32*8)%2^64*256^(_/2^256%2^32)-2^259)*0^(_/256^(_/4^80%2^32)%2^8)
Count m while 0^(_/256^(_/4^80%2^32)%2^8-1)^2*0^m {
_-_/2^(_/2^256%2^32*8)%2^64*2^(_/2^256%2^32*8)-2^259-0^0^((_/256^(_/4^80%2^32+1)-_/256^(_/4^96%2^32+1))%256^(_/256^(_/4^80%2^32+1)%2^32+4))*2^32
}
_+((_/256^(_/4^80%2^32+5)%2^32+2^32*(_/256^(_/4^96%2^32+5)%2^32)+2^64*(_/256^(_/4^80%2^32+1)%2^32)+2^96*(_/256^(_/4^96%2^32+1)%2^32)-_/2^(_/2^256%2^32*8)%4^64)*256^(_/2^256%2^32)+2^259)*0^(_/256^(_/4^80%2^32)%2^8-2)^2
}
}
_*0^0^(_/2^32%2^32)+_%256^(_/2^352%2^32)*0^(_/2^32%2^32)
_+(_/2^(_/2^256%2^32*8)%2^64-_/4^80%2^64)*4^80
}
_+0^0^(_/2^32%2^32)*256^(_/2^352%2^32+1)
}
_+(4352/2^(_/2^96%2^32)%2*(_/4^80%2^32)+112/2^(_/2^96%2^32)%2*(_/2^352%2^32))*2^384+5*2^352
Count e while _/256^(_/256^(_/2^224%2^32)%2^32+1)%2^32/64*0^(_/256^(_/2^224%2^32+4)%2^32)+0^e {
_-_/2^(_/2^224%2^32*8)%2^64*2^(_/2^224%2^32*8)-2^227
}
Count h while 0^0^(_/2^320%2^32)*(_/256^(_/2^320%2^32+5)%2^32)+0^h {
_+(_/256^(_/2^320%2^32+5)%2^32*0^0^h+_/256^(_/2^224%2^32)%2^32*0^h-_/2^320%2^32)*2^320
}
_+(2+_/2^384%2^32*2^8)*2^(_/2^352%2^32*8)+_/2^352%2^32*256^(_/2^320%2^32+5+(_/2^224%2^32-5)*0^(_/2^320%2^32))+9*2^352
_+(_/256^(_/256^(_/2^224%2^32+4)%2^32+5)%2^32-_/256^(_/2^224%2^32+4)%2^32)*256^(_/2^224%2^32+4)
}
Count p while 0^(_/2^96%2^32-9)^2*0^p {
_+(_/256^(_/256^(_/256^(_/4^64%2^32+5)%2^32+5)%2^32+1)%2^32-_/2^384%2^32)*2^384
_+(_/4^96%2^32-_/2^384%2^32)*0^0^(_/4^80%2^32*(_/256^(_/4^80%2^32)%2^40))*2^384
_+((_/2^(_/2^224%2^32*8)%2^64-_/256^(_/2^224%2^32-8)%4^64)*256^(_/2^224%2^32-8)-2^227)*0^(0^0^(_/256^(_/2^224%2^32-8)%2^32)*(_/256^(_/256^(_/2^224%2^32-8)%2^32+1)%2^32)-12)^2
_+(12-_/2^((_/2^32%2^32+1)*8)%2^64)*256^(_/2^32%2^32+1)+(2+_/2^384%2^32*2^8)*2^(_/2^352%2^32*8)+_/2^352%2^32*2^((_/2^224%2^32+4)*8)+9*2^352
}
Count s while 0^(_/2^96%2^32-10)^2*0^s {
Count h while _/256^(_/2^448%2^32+5)%2^32+0^h {
_+((_/256^(_/2^448%2^32+5)%2^32+2^32*(_/256^(_/2^480%2^32+5)%2^32))*0^0^h+3710851744617*0^h-_/2^448%2^64)*2^448
}
_+(2+2^8*(_/4^80%2^32)+2^73+2^80*(_/4^96%2^32)-_/2^(_/2^352%2^32*8)%4^72)*2^(_/2^352%2^32*8)+(_/2^352%2^32+9)*256^(_/2^480%2^32+5)+_/2^352%2^32*256^(_/2^448%2^32+5)+9*2^353
_+(12-_/256^(_/2^32%2^32+1)%2^32)*256^(_/2^32%2^32+1)-_/2^((_/4^64%2^32+5)*8)%2^32*2^((_/4^64%2^32+5)*8)
}
Count p while _/2^96%2^32/64*0^p {
_+((_/2^(_/2^224%2^32*8)%2^64-_/256^(_/2^224%2^32-16)%4^96)*256^(_/2^224%2^32-16)-2^228)*0^0^(0^0^(_/256^(_/2^224%2^32-16)%2^32)*(_/256^(_/256^(_/2^224%2^32-16)%2^32+1)%2^32)/64*0^(12-0^0^(_/256^(_/2^224%2^32-8)%2^32)*(_/256^(_/256^(_/2^224%2^32-8)%2^32+1)%2^32))^2)
_+(_/2^352%2^32+_/256^(_/2^96%2^32+5)%2^32*2^32)*256^(_/2^224%2^32+8)+(2+12*2^8)*2^(_/2^352%2^32*8)+(_/2^352%2^32-_/2^384%2^32)*2^384+9*2^352+2^227
}
}
</code></pre>
<p><a href="https://tio.run/##vVpLc9w2DL7vr9DFM6I4nBUpSqLOvffa23oce@N1YruO7bTpdPzbXfD9guQ6ySSHtUSCJAACHx7KxeXlhw@vr7/9@fX@uTk1f59ubo/NifG@@Xd3TlsxKnrqxEFRcZgH2iol9LskXQuDPe0P/aFd2Ane5WGcgEr2hNCWj515nzoz0gU6KsYZpmZB20nJWQ7LLJe@34v@cDoTPV0WAtOLIJ0Yp0OrJmnP270AO5zzATYcRgEHKTUMdFrgXSz6XUzCvo582uXynO9hkejP9C@wfLKy/c7iuCKdedTjnA1DL5RYFOwkFdC06QbkTJ82CJDJjEup7DhsJw@ThJdJaiEm6dj46NgwCyIJ7fONGSjqINhHyx033IXtRNzuOpHKzAMvOSdde61XawWm45QTO29PwCiu6ahplFON207/Gp56ofWf6iRXiRlcJssT72lCw6QiiEgvjpOwCg7vAl9w0/YAmr2yXFrzTEdrGc7W1pVDjF3TdKxzBpAd0imS6QgevLCehUpBFZPZStgxiF5O0Oxocyh2OJPE/@36/A5SZcMt0sXqA9gqDbVTBzWxQgHwaC/jx5RvLFz13g6DvcNbUJCzd@yanXMjllttxir34eA@3fqVdfU41ZrQ2GI96yp6liVV3iytWwyi8JxqniVjWs/LpOknaZQmhAxKg2drh9reObfwqiG1w3b3jhttKrHSMw2nuPlmI3QxqG22Y0tino6t2jzjhLOmoUC0lGo/yaAdfGMWbMMCpOozZQa7seJO0ntyNKjodZZN63WZp0QPQPw0QIMb2WsY9hghw8WRDmEpRVQvGZWVacWZ@rguBya4jnyeKbBg566lPN4EupJ/YvxTRgD1K90poInvYr0tmKUlrpLM1@JpGWg4wRYQDOczqngkmTHUnrUqA0GFYOubdchECaiQA2k8KWR@r4Fbf7kP/hLl7w/3BZrI0t8t1PIpQm1IbR5iTsGzWM8j5CnL/wMcYxcd3aKMeaa6I9nPQdJBxQs/VplCuopFsV38tl5pQS8N6t50/C6FnHvj6xm@O1dXETHhOWQLbp/gI47M7xf@hvBfUY5kE1EsLufxNYfoyCmarryFvNmRHl0dYiSpwyASA1OkuEcf2GO8PbL03pRhWC93l5Sd2h2RhNIdWN17Aau1Zqc3FWuEu4bAnQrmYbFFbDgH3RVA1KnBWUmT7BAgrTSewHHmbEGV5hnWhATV71nQ9ejBxNcUMmCA99j0ej25v9/MW0/hlotMJwfeUNgE5A0VzgaVuYwTTfAXRk4sP8aWRC9Jwuxp1xLmOovND6c5iIwJ6LpD08T1p4YDJwcMzTTTvYajeoWNBxt3FS1jLRYgwLJmxyiIWjO4zJ3dW@0lqaJHYdCVj5Z0I6mySzx8PeQsuKtgnMcA88fjzfOx0aV@m6otWpfTGi0yOitCeMcTXG@N5URZclGXZ48xYsIz0gwI5VS6Osley5rLM4H6h93@FnHvUOlE976NuuKV8but7pC2BZDeBWT4lBBgBwHxpyroHxkGBzzUNZYrjObomgIGDXMOXJtiTdpP6zjkDtY/nG4Q6KGkF2LVPkmvxHEFDNPVjucbxzPv2U28BUWTvffctKluyBnv60ZCmKXur1HIi4toSKlvwKUcZ7rmdKenNclaqR90fhu98G0b20Z/JDEqFOdKTdwRDEIh/CYooEN65HKlIPcsr5NoFzf60nq2u/PeKXzkFl1Ny08wg@xVkC/yFjQy0JYLto7MaYInYjuiAMMZsLCASynnxV/TEqRygOliagDctZBq@m4C2QYpnNlMZdaDIzElyJHbd0piyorl2yEUW7kevVwKleqxCkiq3wxIEu9v2KaPjYK6K2WiNoBE1hEyuNG1WpJs3Dg8YchQlipXy914urweQvt9Tob92LGW79shqxqYWUx1WiP3mcq6tqZzDG3uQ6w2gHD7PKwuAT0HNHmMaDKxlLFDfpd53w8PrUgB0WXOvM9tzaQuLM8EWNqA8daJtk@xPp5@Xnx59DmWufj2IOBnK6Bvc8SExCcosRfUHxCbDl3ywpR93Y3YS47ieVvIQXaLnpVWKGueg53I3qNCZlW4IS0p0pMNvbjE8M7c8wYXdXA0XDATE3FN4EooS8Aae3RTy4XTc4ruPb6FUqHAMsxvHKYpoKZ4E@kqrUg8tHr73jJFbQI2G6najlCWndU9ivL7QV7NFFeFlAYv5stCscka5sDeEkbwMJY4H18NdQl6uOA0ZsHpWPbu64oO7zmtl5G@kbLeKkc65SEP@ZVF/Iqs/6ek9yH/l5f0q3r/oRJ/s2BdYr2KcbJWHxd1MtqZPM@a2wVJ@R2jW/Fi/e087rfdW6gbsjV8xClrla6tj5s9U6Q2zDWiiGPcAM@5z6EPbZEoIxVDnPxOI/R1Sbz5@Ikq1ktPK10L19Z/qhpt2Adxf/fBHdstqqqskkVwcR@FTnSYea9GPks58Tn4aZn6vsRvhDlOZr3omHy89/tg2aTG@F4BgET28HHwfLOSysODSAO6udDU8dL6uZ6q/DzNww2uP8TLeocL8Ukra5kwH4I540TKufOqG@lN3vYjTxVU4@IR6O/nOqj@8Fb1yZBPMaFAXkFXZZyVb/9fibxYWKkmqY@QL6@v7VVzcXXVtF@atv3W/EOa9qn5pn96eNH/djsguT3edztDtGua9vbm6bm5uLz8ekf0603D7R89Dk9AYMj107MZJPblqeF2Z7vWjJof8w4PpOnhHSaIOzQ/05ym9zabRtqdHjSUvBHNYJjetUc30l6QRlc82ZsV63TxeP1kZSda6lPzzYlsZ76Y7eD1L0N02Yx@F0HMOYb2qRmgItd0PbzZESOm4HKGiUnOpOHkPw" rel="noreferrer" title="Acc!! ‚Äì Try It Online">Try it online!</a></p>
<p>It's done. I'm tired. This took four weeks.</p>
<p>On an older version of this, running the final test case in <em>optimised mode</em> (using a byte array instead of a massive int, see below) took 17 minutes 39 seconds and allocated 58MB of heap space (actually 486MB of RAM). I don't have the patience to run the unoptimised version, but as it has to perform arithmetic on 100-million-digit ints millions of times, I'd be surprised if it finished in under a year. Python already struggles to even <em>allocate</em> one of these values, let alone perform arithmetic on it.</p>
<h2>Acc++</h2>
<p>Writing this project purely in <em>Acc!!</em> would've been a nightmare, so I created a language called Acc++ that compiles to <em>Acc!!</em>. You can find the interpreter/compiler for it, alongside other test files, in <a href="https://github.com/chunkybanana/accpp-lisp/blob/master/accpp.py" rel="noreferrer">the github repository for this project</a>. Its main features are comments, a hacked-together macro system using the python <code>ast</code> module, and an <em>optimised mode</em> which uses a byte array instead of a massive int, speeding things up by many orders of magnitude.</p>
<p>This program basically treats the accumulator <code>_</code>, an arbitrarily large integer that's the only way to store data, as an arbitrarily long array of bytes. By dividing it by the appropriate power of 2 with <code>_/2^(x*8)%2^32</code>, I can fairly easily read bytes/32-bit words, and then multiply by said power of 2 again to write them with <code>_+(v-_/2^(x*8)%2^32)</code>. I can define macros <code>readWord</code>, <code>writeWord</code>, <code>readByte</code>, <code>writeByte</code> to do these. One nice consequence of this is that, as long as these are the only ways I'm interacting with memory, I can add a flag to replace these with custom functions that interact with a byte array, speeding things up a huge amount. I ended up adding a bunch more of these memory-access builtins for various purposes.</p>
<p>The program memory is split into three parts: 64 bytes of register space containing 16(ish) 4-bit registers, 800 bytes of stack space and an unbounded heap. While most of the registers are general-purpose, a few have specific purposes:</p>
<ul>
<li><code>hp</code> points to just after the end of the heap, and gets increased any time something's allocated.</li>
<li><code>sp</code> points to the top of the stack during evaluation.</li>
<li><code>sp2</code>, when in use, points to the top of the &quot;second stack&quot; - an extra stack allocated on top of the heap, used for printing and checking equality.</li>
<li><code>rf</code> stores the source code during evaluation.</li>
</ul>
<p>I also created a few useful macros. <em>Acc!!</em>'s while loop syntax increments a variable starting from <code>0</code> and loops while a certain expression is true:</p>
<pre class="lang-c prettyprint-override"><code>Count i while [expr] {
[code]
}
</code></pre>
<p>So I can make an if statement with:</p>
<pre class="lang-c prettyprint-override"><code>Count i while [expr]*0^i {
    [code]
}
</code></pre>
<p>(<code>0^i</code> is 1 if i is 0 and 0 otherwise. I've used it a lot). <em>Acc!!</em> doesn't allow nested while loops using the same variable, so I've defined <code>If</code>, <code>If2</code> ... <code>If10</code> all with different variables to get around this. I've also defined <code>While</code> through <code>While5</code> for similar reasons. The other utility macros I've defined are <code>conc</code>, which executes a sequence of statements, and <code>mov</code>, which is effectively a <code>writeWord(x, readWord(y))</code>.</p>
<p>You can find the Acc++ source for this project in <a href="https://github.com/chunkybanana/accpp-lisp/blob/master/def.acc" rel="noreferrer"><code>def.acc</code></a>, although be aware that it's a hacky mess and contains a ton of obsolete code. It's loosely commented, but probably not particularly readable, especially with all the golfing optimisations I've added.</p>
<h2>Storage</h2>
<p>Since tinylisp is a dynamically-typed language, values need to include their types. I ended up with the following format:</p>
<ul>
<li>Integers are stored as a <code>0x00</code> byte followed by a signed 32-bit int. The high bit of the int controls whether it's negative, so this supports signed ints between <code>-2^31</code> and <code>2^31-1</code>, which coincedentally is exactly what this challenge requires. Overflowing them will probably break things.</li>
<li>Strings (names) are stored as an <code>0x01</code> byte followed by a 4-byte length and the rest of the string. One nice thing about tinylisp is that strings are immutable, and furthermore all strings that'll ever be used at runtime are allocated during parsing.</li>
<li>Builtins are stored as register-space pointers (more on that later)</li>
<li>All lists are stored as linked lists - an <code>0x02</code> byte followed by a 32-bit head (first item) pointer and a 32-bit tail (rest of the list) pointer. There are several advantages to this:
<ul>
<li>Tinylisp inherently uses linked lists - the <code>h</code>ead and <code>t</code>ail operations correspond to the same parts of a linked list, and the <code>c</code>ons operation constructs a list with a given head and tail pointer.</li>
<li>Linked lists have to be (in most cases) immutable since one tail pointer can be pointed to by multiple head pointers. This means we never have to value about memory management, which is both a blessing and a curse - There are several places in this program where I allocate linked lists that are later impractical to clean up, and this results in slightly ridiculous memory usage. The tail of the last item of a list is a null pointer (see below) - for example, <code>(3 5 4)</code> is stored as <code>[3, [5, [4, NULL]]]</code>.</li>
<li>While initially I planned to use traditional arrays for this, they're extremely poorly suited to the task due to memory management being a pain.
One other decision I've made is that all empty lists <code>()</code> are referred to by the <code>NULL</code> pointer - a pointer to address 0. While this has quite a few advantages, primarily making it easy to check if a value is null, it does result in some weird shenaniganry any time I want to append to a list, which thankfully isn't particularly often.</li>
</ul>
</li>
</ul>
<h2>Evaluation</h2>
<p>Since, as before, we have no access to any sort of recursion, we have to emulate a call stack. Each stack frame is a pair of (pointers to) lists: A list of evaluated arguments, and a list of unevaluated arguments. When evaluating a list (S-expression), the evaluated arguments list starts at <code>()</code>, and the unevaluated arguments list starts with the list. One quirk of this is, as the call stack is set up to only evaluate lists, we can't directly evaluate non-list values, but I've found ways around that.</p>
<p>To evaluate a value from the arguments list:</p>
<ul>
<li>If it's an integer or <code>NULL</code>, it's passed as normal.</li>
<li>If it's a string, it's looked up, first in the local dictionary (obtained by looking upwards through the call stack until we hit a function), and then in the global dictionary. An undefined variable name will (probably) return null.</li>
<li>If it's a list, we push <code>()</code> and it onto the call stack.</li>
</ul>
<p>The first item of a list is the function to call, and is always evaluated. After that, we check if it's a macro (<code>q</code> or starts with an empty list), and if so push the rest of its arguments to the evaluated stack. While <code>i</code> and <code>d</code> are also macros, they need some special handling:</p>
<ul>
<li><code>i</code> needs to have its first argument, the condition, evaluated regardless, but once that's been evaluated we push the other two arguments to the evaluated stack.</li>
<li><code>d</code> needs to have its first argument (the name) left unevaluated, so we push that to the evaluated stack unchanged, but it does need the second argument (the value) evaluated, so we leave that alone.</li>
</ul>
<p>One trick I've used is to have builtins point to addresses in the register space: <code>c</code> points to address <code>1</code>, <code>h</code> to address <code>2</code>, etc. This makes it easy to distinguish builtins from regular functions, and also makes it very easy to concisely check what a builtin is.</p>
<p>Also, I mentioned before that I can't directly evaluate non-list values. To get around this, I've defined two builtins that are only accessible by the interpreter itself:</p>
<ul>
<li><code>print</code> (address <code>11</code>) is used at the top-level to print the result of an expression. It uses a fairly simple algorithm with the second stack to print a value. If given a builtin, it'll attempt to print the value at that index, which is undefined behaviour.</li>
<li><code>id</code> (address <code>12</code>) simply takes one argument and evaluates it. While this sounds useless, it's actually quite powerful: Certain builtins can rearrange the call stack to control what they evaluate, by replacing calls to themselves with a call to <code>id</code>. I'll explain this more shortly.</li>
</ul>
<p>Once a function call has had all its arguments evaluated (/ otherwise dealt with), we check what the first argument, the function, is. If it's a builtin:</p>
<ul>
<li><code>h</code>ead, <code>t</code>ail, and <code>c</code>ons correspond to getting the head/tail of a linked list and constructing a new list respectively, all of which are operations I've already defined.</li>
<li><code>s</code>ubtract and <code>l</code>essthan are also quite simple to implement. However, they share a lot of the same code: They both need to subtract their arguments, then <code>s</code> allocates a new int with that value, and <code>l</code> allocates a new int with whether that value is negative.</li>
<li>Since <code>e</code>qual has to perform a deep equality check, it uses the &quot;second stack&quot; allocated on top of the heap. For performance reasons and to catch nulls, it first checks if the pointers to two values are equal, meaning that checking two equivalent builtins for equality will actually work. Checking a builtin and any other value (including another builtin) could return 1, return 0, or crash depending on the exact values of certain registers at the time.</li>
<li><code>q</code> (and <code>id</code>) simply return their argument.</li>
</ul>
<p>If one of the above is called, its return value is pushed to the evaluated args list of the previous stack frame, and the expression itself is popped from the evaluated args list. The remainder of the builtins require special handling:</p>
<ul>
<li><code>d</code> needs to <em>not</em> be able to redefine existing values. As dictionary lookup starts from the beginning, prepending the given name and value to the global dictionary would actually succeed, so we instead append them, and then return the given name wrapped in <code>id</code>.</li>
<li><code>v</code> simply replaces itself with a call to <code>id</code>.</li>
<li><code>i</code> checks if its first argument is truthy (not NULL, not the integer 0), and replaces itself with a call to <code>id</code> containing either the second or third argument depending on the first. For TCO reasons (see below), if it's itself the result of a call to <code>id</code> we squash that call.</li>
</ul>
<p>Otherwise, the value is a function, and the eval'd stack is structured as <code>((names body) args)</code>. We push <code>body</code> to the stack wrapped in a call to <code>id</code>. When looking up the local dictionary, if <code>names</code> is a singleton list, we wrap it and <code>args</code> in a list to treat it as a single variable.</p>
<p>This makes TCO very easy - we can simply check if the item two steps back on the stack is a function call, <em>and</em> the item after that is a call to <code>id</code>, and if so we can simply remove both of those calls.</p>
<p>Then, to evaluate a piece of code, we simply parse it (the <a href="https://github.com/chunkybanana/accpp-lisp/blob/master/def.acc#L378" rel="noreferrer">parser</a> uses a simple one-pass algorithm) and evaluate+print all its expressions.</p>
<h2>Golfing</h2>
<p>It's difficult to portray just how much effort went into golfing this. The original compiled version was around 30KB, and I've spent over two weeks golfing it down to the 9.5KB version here. I'll list some of the tricks I used here.</p>
<p>Before I start, to put some sizes into context:</p>
<ul>
<li>Reading the cheapest register, <code>ra</code>, is 10 bytes: <code>_/2^32%2^32</code>. Some of the other registers are 11 bytes due to having a 3-digit address.</li>
<li>Writing to <code>ra</code> is 22 bytes: <code>_+(v-_/2^32%2^32)*2^32</code>. For the same reasons as above, some registers are 24 bytes.</li>
<li>An if statement has an overhead of 25 bytes: <code>Count v while (cond)*0^v {\ncode\n}</code></li>
</ul>
<p>Also, because I'm using a macro system, macros that use an argument multiple times will simply have that argument placed multiple times within their code. For example, I have the following macro <code>head_ll(x)</code> that gets the head pointer of a linked list:</p>
<pre class="lang-c prettyprint-override"><code>#defm head_ll(x) 0^0^x * readWord(x+1)
</code></pre>
<p>However, this specific macro is <em>null-safe</em>: The <code>0^0^x*</code> at the start ensures that the macro returns <code>0</code> when given <code>0</code> (which isn't guaranteed otherwise), but this comes at the cost of having to use <code>x</code> twice. If an already large expression is passed to <code>head_ll</code>, it'll double in length, and stacking <code>head_ll</code> multiple times blows up the size exponentially. There are two ways around this - one way is to, where possible, use the following <em>unsafe</em> version that only uses <code>x</code> once:</p>
<pre class="lang-c prettyprint-override"><code>#defm u_head_ll(x) readWord(x+1)
</code></pre>
<p>The other way is to extract expensive expressions into registers:</p>
<pre class="lang-c prettyprint-override"><code>writeWord(ra, [expensive expression])
head_ll(rax)
</code></pre>
<p>First, the code generated by Acc++ isn't particularly golfed, containing a ton of whitespace. Because of this, I wrote an intermediate <a href="https://github.com/chunkybanana/accpp-lisp/blob/master/accpp.py#L285" rel="noreferrer">compressor</a> that removes whitespace and replaces a few common patterns with shorter versions.</p>
<p>One important thing is that we're not limited to just 32-bit read/writes. By simply replacing <code>32</code> with <code>64</code> in read/write calls, I can read/write two words at once for almost the same byte count. When reading/writing to consecutive addresses, this both saves a ton of bytes and improves performance (since the overhead of interacting with a massive int is so large). For example, as the registers <code>ra</code> and <code>rb</code> are consecutive in memory, I can replace <code>writeWord(ra, 5) ; writeWord(rb, 6)</code> with <code>write_dword(ra, 5, 6)</code> and save a ton of bytes in the compiled result.</p>
<p>Perhaps unsurprisingly, though, the largest golfs came from logic optimisations. For example, I need to search through both the local and global dictionaries when looking up a variable name. Originally, this required two separate but almost-identical pieces of code to search through the dictionaries, but by looping twice, searching through the local dictionary on the first iteration and the global dictionary on the second iteration, I can remove almost half the code.</p>
<p>Another of these logic optimisations is initialising the global dictionary. It's stored as two linked lists: one of names and one of values. Initially, I had a ton of code to allocate linked lists, but by carefully constructing it with a for loop (see the first three lines) I've saved almost a kilobyte.</p>
<p>Another trick I used is something I call <em>parallel writes</em>. All calls involving writing memory amount to <code>_+[x]</code>. If I have multiple write calls in a row that don't rely on each other <code>_+[x], _+[y], _+[z]</code> I can merge them into <code>_+[x]+[y]+[z]</code>, saving two bytes per use. This doesn't sound like much, but it has another advantage.</p>
<p>As I mentioned before, an if statement has an overhead of 25 bytes. If I have a paralellised write call <code>_+[x]+[y]+[z]</code> wrapped in a conditional, I can remove the if statement entirely and replace it with <code>_+([x]+[y]+[z])*[cond]</code>. This saves 22 bytes - 20 if <code>cond</code> needs to be in brackets, and 16 if <code>cond</code> needs to be converted to <code>1</code> or <code>0</code>. (also, I randomly discovered <a href="https://codegolf.stackexchange.com/a/274676/100664">you can make write calls conditional</a> while messing around yesterday, which saved ~120 bytes)</p>
<p>One of the last things I did was switch to length-prefixed strings. With null-terminated strings, to check if two strings are equal you have to iterate through every character until you get to the end of one string. But with length-prefixed strings, I can simply read the entirety of the string as a massive int, and check if those are equal, saving several hundred bytes (since checking string equality is used twice, once in dict lookup and once in <code>e</code>qual).</p>
<p>Aside from that, there have been tons of microoptimisations - removing a byte or two from conditions, simplifying a write call, shortening mathematical expressions here and there, etc. At this point, although there are definitely a few more microoptimisations I haven't found, I'd say this is fairly well-golfed, and I doubt under 9KB is possible without significantly rewriting certain parts of the program.</p>
</div>
<div id="pu3" class="pu"><h1><a href="https://try-setanta.ie" rel="nofollow noreferrer">Setanta</a>, 1392 bytes</h1>
<p>Takes a long time for test #6, even with the CLI version of Setanta.</p>
<pre><code>gniomh(s){i:=0F:=fad@s
gniomh L(x){toradh go_teacs(x)[0]==&quot;[&quot;}gniomh p(){nuair-a i&lt;F&amp;s[i]&lt;&quot;!&quot; i+=1ma i&gt;=F toradh!1t:=&quot;&quot;ma s[i]==&quot;(&quot;{t=[]i+=1nuair-a 1{ma s[i]==&quot;)&quot;{i+=1toradh t}t+=[p()]nuair-a s[i]&lt;&quot;!&quot; i+=1}}nuair-a i&lt;F&amp;s[i]&gt;&quot; &quot;&amp;s[i]!=&quot;(&quot;&amp;s[i]!=&quot;)&quot;{t+=s[i]i+=1}le i idir(0,fad@t)ma aimsigh@(go_liosta@&quot;0123456789&quot;())(t[i])&lt;0 toradh t
toradh go_uimh(t)}G:=0gniomh e(x,l){nuair-a 1{ma!L(x){le j idir(0,2){le i idir(0,fad@l)ma l[i][0]==x toradh l[i][1]l=G}toradh x}ma x==[] toradh[]f:=e(x[0],l)ma f==!0{c:=e(x[1],l)x=x[(c!=[]&amp;c&amp;2)|3]}no{ma go_teacs(f)[0]==&quot;&lt;&quot; toradh f(x,l)A:=f[fad@f-2]m:=[]ma f[0]!=m{ma L(A) le i idir(0,fad@A)m+=[[A[i],e(x[i+1],l)]]no {le i idir(0,fad@x-1)m+=[e(x[i+1],l)]m=[[A,m]]}}no{ma L(A) le i idir(0,fad@A)m+=[[A[i],x[i+1]]]no m=[[A,cuid@x(1,fad@x)]]}x=f[fad@f-1]l=m}}}G=[[&quot;c&quot;,gniomh(x,l){toradh [e(x[1],l)]+e(x[2],l)}],[&quot;h&quot;,gniomh(x,l){x=e(x[1],l)ma fad@x toradh x[0]toradh[]}],[&quot;t&quot;,gniomh(x,l){x=e(x[1],l)toradh cuid@x(1,fad@x)}],[&quot;s&quot;,gniomh(x,l){toradh e(x[1],l)-e(x[2],l)}],[&quot;l&quot;,gniomh(x,l){toradh e(x[1],l)&lt;e(x[2],l)|0&amp;1}],[&quot;e&quot;,gniomh(x,l){toradh e(x[1],l)==e(x[2],l)|0&amp;1}],[&quot;v&quot;,gniomh(x,l){toradh e(e(x[1],l),l)}],[&quot;q&quot;,gniomh(x,l){toradh x[1]}],[&quot;i&quot;,!0],[&quot;d&quot;,gniomh(x,l){s:=x[1]le i idir(0,fad@G)ma G[i][0]==s 1/0G+=[[s,e(x[2],l)]]toradh s}]]gniomh h(x){toradh (go_teacs(x)[0]==&quot;[&quot;&amp;&quot;(&quot;+nasc@(thar(h,x))(&quot; &quot;)+&quot;)&quot;)|x}nuair-a 1{s:=p()ma!1==s bris scriobh(h(e(s,[])))}}
</code></pre>
<p><a href="https://try-setanta.ie/editor/EhEKBlNjcmlwdBCAgICwztCeCw" rel="nofollow noreferrer">try-setanta.ie link</a></p>
<p>Not-quite-golfed version:</p>
<pre><code>gniomh(s){
    i:=0 &gt;-- Position for parsing
    F:=fad@s &gt;-- Length of `s`
    gniomh L(x){toradh go_teacs(x)[0]==&quot;[&quot;} &gt;-- Returns whether x is a list
    gniomh p(){ &gt;-- Parse an expression
        nuair-a i&lt;F&amp;s[i]&lt;&quot;!&quot; i+=1 &gt;-- Skip whitespace
        ma i&gt;=F toradh!1 &gt;-- Return `br√©ag` if there‚Äôs no more code
        t:=&quot;&quot;
        ma s[i]==&quot;(&quot;{ &gt;-- Parse list
            t=[]
            i+=1
            nuair-a 1{
                ma s[i]==&quot;)&quot;{i+=1toradh t}
                t+=[p()]
                nuair-a s[i]&lt;&quot;!&quot; i+=1
            }
        }
        &gt;-- Parse atom
        nuair-a i&lt;F&amp;s[i]&gt;&quot; &quot;&amp;s[i]!=&quot;(&quot;&amp;s[i]!=&quot;)&quot;{t+=s[i]i+=1}
        le i idir(0,fad@t)ma aimsigh@(go_liosta@&quot;0123456789&quot;())(t[i])&lt;0 toradh t
        toradh go_uimh(t)
    }
    G:=0 &gt;-- List of globals, set later because we need `e`
    &gt;-- Lookup name (inlined in golfed version)
    gniomh a(l,s){le j idir(0,2){le i idir(0,fad@l)ma l[i][0]==s toradh l[i][1]l=G}toradh s}
    gniomh e(x,l){ &gt;-- Evaluate `x` with locals `l`
        nuair-a 1{ &gt;-- Loop for TCO
            ma!L(x) toradh a(l,x) &gt;-- Evaluate atom
            ma x==[] toradh[] &gt;-- Evaluate empty list
            f:=e(x[0],l) &gt;-- Evaluate function call
            ma f==!0{c:=e(x[1],l)x=x[(c!=[]&amp;c&amp;2)|3]} &gt;-- Case for `i`
            no{
                ma go_teacs(f)[0]==&quot;&lt;&quot; toradh f(x,l) &gt;-- Some other builtin
                A:=f[fad@f-2] &gt;-- User function or macro
                m:=[]
                ma f[0]!=m{ &gt;-- If first element is nil, then `f` is a func
                    ma L(A) le i idir(0,fad@A)m+=[[A[i],e(x[i+1],l)]]
                    no {le i idir(0,fad@x-1)m+=[e(x[i+1],l)]m=[[A,m]]}
                }no{ &gt;-- `f` is a macro
                    ma L(A) le i idir(0,fad@A)m+=[[A[i],x[i+1]]]
                    no m=[[A,cuid@x(1,fad@x)]]
                }
                x=f[fad@f-1] &gt;-- Tail call
                l=m
            }
        }
    }
    G=[ &gt;-- Populate list of globals
        [&quot;c&quot;,gniomh(x,l){toradh [e(x[1],l)]+e(x[2],l)}],
        [&quot;h&quot;,gniomh(x,l){x=e(x[1],l)ma fad@x toradh x[0]toradh[]}],
        [&quot;t&quot;,gniomh(x,l){x=e(x[1],l)toradh cuid@x(1,fad@x)}],
        [&quot;s&quot;,gniomh(x,l){toradh e(x[1],l)-e(x[2],l)}],
        [&quot;l&quot;,gniomh(x,l){toradh e(x[1],l)&lt;e(x[2],l)|0&amp;1}],
        [&quot;e&quot;,gniomh(x,l){toradh e(x[1],l)==e(x[2],l)|0&amp;1}],
        [&quot;v&quot;,gniomh(x,l){toradh e(e(x[1],l),l)}],
        [&quot;q&quot;,gniomh(x,l){toradh x[1]}],
        [&quot;i&quot;,!0], &gt;-- Special case for TCO
        &gt;-- Evaluate 1/0 to raise an error
        [&quot;d&quot;,gniomh(x,l){s:=x[1]le i idir(0,fad@G)ma G[i][0]==s 1/0G+=[[s,e(x[2],l)]]toradh s}]
    ]
    &gt;-- Stringify expression in desired format
    gniomh h(x){toradh (go_teacs(x)[0]==&quot;[&quot;&amp;&quot;(&quot;+nasc@(thar(h,x))(&quot; &quot;)+&quot;)&quot;)|x}
    nuair-a 1{ &gt;-- Parse and evaluate expressions in `s`
        s:=p()
        ma!1==s bris &gt;-- If the result is equal to `br√©ag`, then break
        scriobh(h(e(s,[])))
    }
}
</code></pre>
</div>
<div id="pu4" class="pu"><h1>Ceylon, 2422 bytes</h1>

<p>(I think this is my longest golfed program yet.)</p>

<pre class="lang-ceylon prettyprint-override"><code>import ceylon.language{sh=shared,va=variable,fo=formal,O=Object}import ceylon.language.meta.model{F=Function}interface X{sh fo V v(S t);sh fo G g;}class G(va Map&lt;S,V&gt;m)satisfies X{v(S t)=&gt;m[t]else nV;g=&gt;this;sh S d(S s,V v){assert(!s in m);m=map{s-&gt;v,*m};return s;}}V nV=&gt;nothing;class LC(G c,Map&lt;S,V&gt;m)satisfies X{g=&gt;c;v(S t)=&gt;m[t]else g.v(t);}alias C=&gt;V|Co;interface Co{sh fo C st();}interface V{sh fo C l(X c,V[]a);sh default Boolean b=&gt;0&lt;1;sh fo C vO(X c);sh default V vF(X c){va C v=vO(c);while(is Co n=v){v=n.st();}assert(is V r=v);return r;}}class L(sh V*i)satisfies V{vO(X c)=&gt;if(nonempty i)then i[0].vF(c).l(c,i.rest)else this;equals(O o)=&gt;if(is L o)then i==o.i else 1&lt;0;b=&gt;!i.empty;string=&gt;"(``" ".join(i)``)";hash=&gt;i.hash;sh actual C l(X c,V[]p){value[h,ns,x]=i.size&lt;3then[f,i[0],i[1]]else[m,i[1],i[2]];value n=if(is L ns)then[*ns.i.narrow&lt;S&gt;()]else ns;assert(is S|S[]n,is V x);V[]a=h(c,p);LC lC=if(is S n)then LC(c.g,map{n-&gt;L(*a)})else LC(c.g,map(zipEntries(n,a)));return object satisfies Co{st()=&gt;x.vO(lC);};}}class S(String n)satisfies V{vO(X c)=&gt;c.v(this);l(X c,V[]a)=&gt;nV;equals(O o)=&gt;if(is S o)then n==o.n else 1&lt;0;hash=&gt;n.hash;string=&gt;n;}class I(sh Integer i)satisfies V{vO(X c)=&gt;this;l(X c,V[]a)=&gt;nV;equals(O o)=&gt;if(is I o)then i==o.i else 1&lt;0;hash=&gt;i;b=&gt;!i.zero;string=&gt;i.string;}V[]f(X c,V[]a)=&gt;[for(v in a)v.vF(c)];V[]m(X c,V[]a)=&gt;a;L c(X c,V h,L t)=&gt;L(h,*t.i);V h(X c,L l)=&gt;l.i[0]else L();V t(X c,L l)=&gt;L(*l.i.rest);I s(X c,I f,I s)=&gt;I(f.i-s.i);I l(X c,I f,I s)=&gt;I(f.i&lt;s.i then 1else 0);I e(X c,V v1,V v2)=&gt;I(v1==v2then 1else 0);C v(X c,V v)=&gt;v.vO(c);V q(X c,V a)=&gt;a;C i(X c,V d,V t,V f)=&gt;d.vF(c).b then t.vO(c)else f.vO(c);S d(X c,S s,V x)=&gt;c.g.d(s,x.vF(c));class B&lt;A&gt;(F&lt;C,A&gt;nat,V[](X,V[])h=f)satisfies V given A satisfies[X,V+]{vO(X c)=&gt;nV;string=&gt;nat.declaration.name;l(X c,V[]a)=&gt;nat.apply(c,*h(c,a));}{&lt;S-&gt;V&gt;*}b=&gt;{S("c")-&gt;B(`c`),S("h")-&gt;B(`h`),S("t")-&gt;B(`t`),S("s")-&gt;B(`s`),S("l")-&gt;B(`l`),S("e")-&gt;B(`e`),S("v")-&gt;B(`v`),S("q")-&gt;B(`q`,m),S("i")-&gt;B(`i`,m),S("d")-&gt;B(`d`,m)};[V*]p(String inp){value ts=inp.split(" \n()".contains,1&lt;0,1&lt;0);va[[V*]*]s=[];va[V*]l=[];for(t in ts){if(t in" \n"){}else if(t=="("){s=[l,*s];l=[];}else if(t==")"){l=[L(*l.reversed),*(s[0]else[])];s=s.rest;}else if(exists i=parseInteger(t),i&gt;=0){l=[I(i),*l];}else{l=[S(t),*l];}}return l.reversed;}sh void run(){va value u="";while(exists l=process.readLine()){u=u+l+"\n";}V[]e=p(u);X c=G(map(b));for(v in e){print(v.vF(c));}}
</code></pre>

<p>I could have golfed some bytes more, as I used some two-letter identifiers in some places, but I've run out of somewhat meaningful single letters for those. Although even this way it doesn't look like Ceylon very much ...</p>

<p>This is an <strong>object-oriented</strong> implementation.</p>

<p>We have a value interface <code>V</code> with implementing classes <code>L</code> (list ‚Äì just a wrapper around a Ceylon sequential of <code>V</code>), <code>S</code> (symbol ‚Äì wrapper around a string), <code>I</code> (integer ‚Äì wrapper around a Ceylon integer) and <code>B</code> (builtin function or macro, a wrapper around a Ceylon function).</p>

<p>I use the standard Ceylon equality notation by implementing the <code>equals</code> method (and also the <code>hash</code> attribute, which is really only needed for symbols), and also the standard <code>string</code> attribute for output.</p>

<p>We have a Boolean attribute <code>b</code> (which is true by default, overridden in <code>I</code> and <code>L</code> to return false for empty lists), and two methods <code>l</code> (call, i.e. use this object as a function) and <code>vO</code> (evaluate one step). Both return either a value or a Continuation object which allows then evaluation for one more step, and <code>vF</code> (evaluate fully) loops until the result is not a continuation anymore.</p>

<p>A context interface allows access to variables. There are two implementations, <code>G</code> for the global context (which allows adding variables using the <code>d</code> builtin) and <code>LC</code> for a local context, which is active when evaluating the expression of a user function (it falls back to the global context).</p>

<p>Symbols evaluation accesses the context, lists (if non empty) evaluate by first evaluating their first element and then calling its call method. Call is implemented just by lists and builtins ‚Äì it first evaluates the argument (if a function, not if a macro) and then does the actual interesting stuff ‚Äì for builtins just what is hardcoded, for lists it creates a new local context and returns a continuation with that. </p>

<p>For the builtins I used a trick similar to what I used in my <a href="https://codegolf.stackexchange.com/a/61340/2338">Shift Interpreter</a>, which allows me to define them with the argument types they need, but call them with a generic sequence using reflection (the types will be checked at call time). This avoids type conversion/assertion hassle inside the functions/macros, but needs top-level functions so I can get their meta-model <code>Function</code> objects.</p>

<p>The <code>p</code> (parse) function splits the string at spaces, newlines and parentheses, then loops over the tokens and builds lists using a stack and a running list.</p>

<p>The interpreter (in the <code>run</code> method, which is the entry point) then takes this list of expressions (which are just values), evaluates each of them, and prints the result.</p>

<hr>

<p>Below is a version with comments and run through a formatter.</p>

<p>An earlier version before I started golfing (and still with some misunderstandings about list evaluation) is found at <a href="https://github.com/ePaul/ceylon-codegolf/blob/master/source/codegolf/tinylisp62886/expressions.ceylon" rel="nofollow noreferrer">my Github repository</a>, I'll put this one there soon (so make sure to look at <a href="https://github.com/ePaul/ceylon-codegolf/blob/4de5667509a34f402b88ea8cd616f2b333408897/source/codegolf/tinylisp62886/expressions.ceylon" rel="nofollow noreferrer">the first version</a> if you want the original).</p>

<pre class="lang-ceylon prettyprint-override"><code>//  Tiny Lisp, tiny interpreter
//
// An interpreter for a tiny subset of Lisp, from which most of the
// rest of the language can be bootstrapped.
//
// Question:   https://codegolf.stackexchange.com/q/62886/2338
// My answer:  https://codegolf.stackexchange.com/a/63352/2338
//
import ceylon.language {
    sh=shared,
    va=variable,
    fo=formal,
    O=Object
}
import ceylon.language.meta.model {
    F=Function
}

// context

interface X {
    sh fo V v(S t);
    sh fo G g;
}
// global (mutable) context, with the buildins 
class G(va Map&lt;S,V&gt; m) satisfies X {
    // get entry throws error on undefined variables. 
    v(S t) =&gt; m[t] else nV;
    g =&gt; this;
    sh S d(S s, V v) {
        // error when already defined
        assert (!s in m);
        // building a new map is cheaper (code-golf wise) than having a mutable one.
        m = map { s-&gt;v, *m };
        return s;
    }
}

// This is simply a shorter way of writing "this is not an allowed operation".
// It will throw an exception when trying to access it.
// nV stands for "no value".
V nV =&gt; nothing;

// local context
class LC(G c, Map&lt;S,V&gt; m) satisfies X {
    g =&gt; c;
    v(S t) =&gt; m[t] else g.v(t);
    // sh actual String string =&gt; "[local: ``m``, global: ``g``]";
}

// continuation or value
alias C =&gt; V|Co;

// continuation
interface Co {
    sh fo C st();
}

// value
interface V {
    // use this as a function and call with arguments.
    // will not work for all types of stuff.
    sh fo C l(X c, V[] a);
    // check the truthiness. Defaults to true, as
    // only lists and integers can be falsy.
    sh default Boolean b =&gt; 0 &lt; 1;
    // evaluate once (return either a value or a continuation).
    // will not work for all kinds of expression.
    sh fo C vO(X c);
    /// evaluate fully
    sh default V vF(X c) {
        va C v = vO(c);
        while (is Co n = v) {
            v = n.st();
        }
        assert (is V r = v);
        return r;
    }
}
class L(sh V* i) satisfies V {

    vO(X c) =&gt; if (nonempty i) then i[0].vF(c).l(c, i.rest) else this;
    equals(O o) =&gt; if (is L o) then i == o.i else 1 &lt; 0;
    b =&gt; !i.empty;
    string =&gt; "(``" ".join(i)``)";
    hash =&gt; i.hash;

    sh actual C l(X c, V[] p) {
        value [h, ns, x] =
                i.size &lt; 3
                then [f, i[0], i[1]]
                else [m, i[1], i[2]];
        // parameter names ‚Äì either a single symbol, or a list of symbols.
        // If it is a list, we filter it to throw out any non-symbols.
        // Should throw an error if there are any, but this is harder.
        value n = if (is L ns) then [*ns.i.narrow&lt;S&gt;()] else ns;
        assert (is S|S[] n, is V x);
        V[] a = h(c, p);

        // local context
        LC lC = if (is S n) then
            LC(c.g, map { n -&gt; L(*a) })
        else
            LC(c.g, map(zipEntries(n, a)));
        // return a continuation instead of actually
        // calling it here, to allow stack unwinding.
        return object satisfies Co {
            st() =&gt; x.vO(lC);
        };
    }
}

// symbol
class S(String n) satisfies V {
    // evaluate: resolve
    vO(X c) =&gt; c.v(this);
    // call is not allowed
    l(X c, V[] a) =&gt; nV;
    // equal if name is equal
    equals(O o) =&gt; if (is S o) then n == o.n else 1 &lt; 0;
    hash =&gt; n.hash;
    string =&gt; n;
}

// integer
class I(sh Integer i) satisfies V {

    vO(X c) =&gt; this;
    l(X c, V[] a) =&gt; nV;
    equals(O o) =&gt; if (is I o) then i == o.i else 1 &lt; 0;
    hash =&gt; i;
    b =&gt; !i.zero;
    string =&gt; i.string;
}

// argument handlers for functions or macros
V[] f(X c, V[] a) =&gt; [for (v in a) v.vF(c)];
V[] m(X c, V[] a) =&gt; a;

// build-in functions
// construct
L c(X c, V h, L t) =&gt; L(h, *t.i);
// head
V h(X c, L l) =&gt; l.i[0] else L();
// tail
V t(X c, L l) =&gt; L(*l.i.rest);
// subtract
I s(X c, I f, I s) =&gt; I(f.i - s.i);
// lessThan
I l(X c, I f, I s) =&gt; I(f.i &lt; s.i then 1 else 0);
// equal
I e(X c, V v1, V v2) =&gt; I(v1 == v2 then 1 else 0);
// eval (returns potentially a continuation)
C v(X c, V v) =&gt; v.vO(c);

// build-in macros
// quote
V q(X c, V a) =&gt; a;
// if (also returns potentially a continuation)
C i(X c, V d, V t, V f) =&gt; d.vF(c).b then t.vO(c) else f.vO(c);
// define symbol in global context
S d(X c, S s, V x) =&gt; c.g.d(s, x.vF(c));

// buildin function or macro, made from a native function and an argument handler
class B&lt;A&gt;(F&lt;C,A&gt; nat, V[](X, V[]) h = f)
        satisfies V
        given A satisfies [X, V+] {
    vO(X c) =&gt; nV;
    string =&gt; nat.declaration.name;
    // this "apply" is a hack which breaks type safety ...
    // but it will be checked at runtime.
    l(X c, V[] a) =&gt; nat.apply(c, *h(c, a));
}

// define buildins
{&lt;S-&gt;V&gt;*} b =&gt; {
    S("c") -&gt; B(`c`),
    S("h") -&gt; B(`h`),
    S("t") -&gt; B(`t`),
    S("s") -&gt; B(`s`),
    S("l") -&gt; B(`l`),
    S("e") -&gt; B(`e`),
    S("v") -&gt; B(`v`),
    S("q") -&gt; B(`q`, m),
    S("i") -&gt; B(`i`, m),
    S("d") -&gt; B(`d`, m)
};

// parses a string into a list of expressions.
[V*] p(String inp) {
    // split string into tokens (retain separators, don't group them ‚Äì
    // whitespace and empty strings will be sorted out later in the loop)
    value ts = inp.split(" \n()".contains, 1 &lt; 0, 1 &lt; 0);
    // stack of not yet finished nested lists, outer most at bottom
    va [[V*]*] s = [];
    // current list, in reverse order (because appending at the start is shorter)
    va [V*] l = [];
    for (t in ts) {
        if (t in " \n") {
            // do nothing for empty tokens
        } else if (t == "(") {
            // push the current list onto the stack, open a new list.
            s = [l, *s];
            l = [];
        } else if (t == ")") {
            // build a lisp list from the current list,
            // pop the latest list from the stack, append the created lisp list. 
            l = [L(*l.reversed), *(s[0] else [])];
            s = s.rest;
        } else if (exists i = parseInteger(t), i &gt;= 0) {
            // append an integer to the current list.
            l = [I(i), *l];
        } else {
            // append a symbol to the current list.
            l = [S(t), *l];
        }
    }
    return l.reversed;
}

// Runs the interpreter.
// This handles input and output, calls the parser and evaluates the expressions.
sh void run() {
    va value u = "";
    while (exists l = process.readLine()) {
        u = u + l + "\n";
    }
    V[] e = p(u);
    // create global context
    X c = G(map(b));
    // iterate over the expressions, ...
    for (v in e) {
        // print("  '``v``' ‚Üí ...");
        // ... evaluate each (fully) and print the result.
        print(v.vF(c));
    }
}
</code></pre>
</div>
<div id="pu5" class="pu"><h1>Python 2, <del>685</del> <del>675</del> <del>660</del> <del>657</del> <del>646</del> <del>642</del> 640 bytes</h1>

<pre class="lang-py prettyprint-override"><code>import sys,re
E=[]
G=zip("chtsle",[eval("lambda x,y=0:"+f)for f
in"[x]+y (x+[E])[0] x[1:] x-y +(x&lt;y) +(x==y)".split()])
def V(e,L=E):
 while 1:
    try:return e and int("0%s"%e)
    except:A=e[1:]
    if""&lt;e:return dict(G+L).get(e,e)
    f=V(e[0],L)
    if""&lt;f:
     if f in"iv":t=V(A[0],L);e=(e[~bool(t)],t)[f&gt;"u"];continue
     if"e"&gt;f:G[:]+=(A[0],V(A[1],L)),
     return A[0]
    if[]&gt;f or f[0]:A=[V(a,L)for a in A]
    if[]&gt;f:return f(*A)
    P,e=f[-2:];L=([(P,A)],zip(P,A))[P&lt;""]
F=lambda x:V&lt;x&lt;""and"(%s)"%" ".join(map(F,x))or"%s"%x
for t in re.sub("([()])"," \\1 ",sys.stdin.read()).split():
 if")"==t:t=E.pop()
 if"("==t:E+=[],
 elif E:E[-1]+=t,
 else:print F(V(t))
</code></pre>

<p>Reads input from STDIN and writes output to STDOUT.</p>

<p>Although not strictly required, the interpreter supports nullary functions and macros, and optimizes tail calls executed through <code>v</code>.</p>

<h2>Explanation</h2>

<p><strong>Parsing</strong></p>

<p>To parse the input, we first surround each occurence of <code>(</code> and <code>)</code> with spaces, and split the resulting string into words; this gives us the list of tokens.
We maintain an expression stack <code>E</code>, which is initially empty.
We scan the tokens, in order:</p>

<ul>
<li>if we encounter a <code>(</code>, we push an empty list at the top of the expression stack;</li>
<li>if we encounter a <code>)</code>, we pop the value at the top of the expression stack, and append it to the list that was previously below it on the stack;</li>
<li>otherwise, we append the current token, as a string, to the list at the top of the expression stack (we keep integers as strings at this stage, and parse them during evaluation.)</li>
</ul>

<p>If, when processsing an ordinary token, or after popping an expression from the stack due to <code>)</code>, the expression stack is empty, we're at a top-level expression, and we evaluate the value we'd otherwise have appended, using <code>V()</code>, and print its result, formatted appropriately using <code>F()</code>.</p>

<p><strong>Evaluation</strong></p>

<p>We maintain the global scope, <code>G</code>, as a list of key/value pairs.
Initially, it contains only the builtin functions (but not the macros, and not <code>v</code>, which we treat as a macro), which are implemented as lambdas.</p>

<p>Evaluation happens inside <code>V()</code>, which takes the expression to evaluate, <code>e</code>, and the local scope, <code>L</code>, which is, too, a list of key/value pairs (when evaluating a top-level expression, the local scope is empty.)
The guts of <code>V()</code> live inside an infinite loop, which is how we perform tail-call optimization (TCO), as explained later.</p>

<p>We process <code>e</code> according to its type:</p>

<ul>
<li><p>if it's the empty list, or a string convertible to an int, we return it immediately (possibly after conversion to int); otherwise,</p></li>
<li><p>if it's a string, we look it up in a dictionary constructed from the concatenation of the global and local scopes.
If we find an associated value, we return it; otherwise, <code>e</code> must be the name of a builtin macro (i.e. <code>q</code>, <code>i</code>, <code>d</code> or <code>v</code>), and we return it unchanged.
Otherwise, if <code>e</code> is not a string,</p></li>
<li><p><code>e</code> is a (nonempty) list, i.e., a function call.
We evaluate the first element of the list, i.e., the function expression, by calling <code>V()</code> recursively (using the current local scope); we call the result <code>f</code>.
The rest of the list, <code>A</code>, is the list of arguments.
<code>f</code> can only be a string, in which case it's a builtin macro (or the function <code>v</code>), a lambda, in which case it's a builtin function, or a list, in which case it's a user-defined function or macro.</p>

<p>If <code>f</code> is a a string, i.e., a builtin macro, we handle it in-place.
If it's the macro <code>i</code> or <code>v</code>, we evaluate its first operand, and either select the second or third operand accordingly, in the case of <code>i</code>, or use the result of the first operand, in the case of <code>v</code>;
instead of evaluating the selected expression recursively, which would defeat TCO, we simply replace <code>e</code> with the said expression, and jump to the beginning of the loop.
If <code>f</code> is the macro <code>d</code>, we append a pair, whose first element is the first operand, and whose second element is the result of evaluating the second operand, to the global scope, <code>G</code>, and return the first operand.
Otherwise, <code>f</code> is the macro <code>q</code>, in which case we simply return its operand directly.</p>

<p>Othrtwise, if <code>f</code> is a lambda, or a list whose first element is not <code>()</code>, then it's a non-nullary function, not a macro, in which case we evaluate its arguments, i.e., the elements of <code>A</code>, and replace <code>A</code> with the result.</p>

<p>If <code>f</code> is a lambda, we call it, passing it the unpacked arguments in <code>A</code>, and return the result.</p>

<p>Otherwise, <code>f</code> is a list, i.e., a user-defined function or macro; its parameter list is the second-to-last element, and its body is the last element.
Like in the case of the macros <code>i</code> and <code>v</code>, in order to perform TCO, we don't evaluate the body recursively, but rather replace <code>e</code> with the body and continue to the next iteration.
Unlike <code>i</code> and <code>v</code>, however, we also replace the local scope, <code>L</code>, with the new local scope of the function.
If the parameter list, <code>P</code>, is, in fact, a list, the new local scope is constructed by zipping the parameter list, <code>P</code>, with the argument list, <code>A</code>;
otherwise, we're dealing with a variadic function, in which case the new local scope has only one element, the pair <code>(P, A)</code>.</p></li>
</ul>

<h2>REPL</h2>

<p>If you want to play with it, here's a REPL version of the interpreter.
It supports redefining symbols, and importing files through either the command line arguments, or the <code>(import &lt;filename&gt;)</code> macro.
To exit the interpreter, terminate the input (usually, Ctrl+D or Ctrl+Z).</p>

<p><div class="snippet" data-lang="js" data-hide="true">
<div class="snippet-code snippet-currently-hidden">
<pre class="snippet-code-js lang-js prettyprint-override"><code>try:import sys,re,readline
except:0
E=[];G=zip("chtsle",[eval("lambda x,y=0:"+f)for f
in"[x]+y (x+[E])[0] x[1:] x-y +(x&lt;y) +(x==y)".split()])
def V(e,L=E):
 while 1:
    try:return e and int("0%s"%e)
    except:A=e[1:]
    if""&lt;e:return dict(G+L).get(e,e)
    f=V(e[0],L)
    if""&lt;f:
     if f in"iv":t=V(A[0],L);e=(e[~bool(t)],t)[f&gt;"u"];continue
     if"e"&gt;f:G[:]+=(A[0],V(A[1],L)),
     elif"j"&gt;f:X(open(str(A[0])).read())
     return A[0]
    if[]&gt;f or f[0]:A=[V(a,L)for a in A]
    if[]&gt;f:return f(*A)
    P,e=f[-2:];L=([(P,A)],zip(P,A))[P&lt;""]
F=lambda x:V&lt;x&lt;""and"(%s)"%" ".join(map(F,x))or"%s"%x
def X(s,v=0):
 for t in re.sub("([()])"," \\1 ",s).split():
    if")"==t:t=E.pop()
    if"("==t:E[:]+=[],
    elif E:E[-1]+=t,
    else:
     x=V(t)
     if v:print F(x)
for f in sys.argv[1:]:X("(g %s)"%f)
while 1:
 try:X(raw_input("&gt;."[[]&lt;E]*3+" "),1)
 except EOFError:break
 except KeyboardInterrupt:E=[];print
 except Exception as e:print"Error: "+e.message</code></pre>
</div>
</div>
</p>

<p>And here's an example session, implementing merge sort:</p>

<p><div class="snippet" data-lang="js" data-hide="true">
<div class="snippet-code snippet-currently-hidden">
<pre class="snippet-code-js lang-js prettyprint-override"><code>&gt;&gt;&gt; (d let d) (d if i) (d head h) (d tail t) (d prepend c) (d less l)
let
if
head
tail
prepend
less
&gt;&gt;&gt;
&gt;&gt;&gt; (let list (q (x... x...)))
list
&gt;&gt;&gt; (let lambda (q (() (params body) (list params body))))
lambda
&gt;&gt;&gt; (let def (q (() (name params body) (
...     v (list (q let) name (list (q lambda) params body))
... ))))
def
&gt;&gt;&gt;
&gt;&gt;&gt; (def else(body) body)
else
&gt;&gt;&gt; (def or(x y) ( if x x y ))
or
&gt;&gt;&gt; (def and(x y) ( if x y x ))
and
&gt;&gt;&gt;
&gt;&gt;&gt; (def front-half(L) ( front-half/impl L L ))
front-half
&gt;&gt;&gt; (def front-half/impl(L M) (
...     if M (
...         prepend (head L)
...                 (front-half/impl (tail L) (tail (tail M)))
...     ) (else
...         ()
...     )
... ))
front-half/impl
&gt;&gt;&gt;
&gt;&gt;&gt; (def back-half(L) ( back-half/impl L L ))
back-half
&gt;&gt;&gt; (def back-half/impl(L M) (
...     if M (
...         back-half/impl (tail L) (tail (tail M))
...     ) (else
...         L
...     )
... ))
back-half/impl
&gt;&gt;&gt;
&gt;&gt;&gt; (def merge(L M comp) (
...     if (and L M) (
...         if (comp (head M) (head L)) (
...             prepend (head M) (merge L (tail M) comp)
...         ) (else (
...             prepend (head L) (merge (tail L) M comp)
...         ))
...     ) (else (
...         or L M
...     ))
... ))
merge
&gt;&gt;&gt;
&gt;&gt;&gt; (def sort(L comp) (
...     if (and L (tail L)) (
...         merge (sort (front-half L) comp)
...               (sort (back-half L) comp)
...               comp
...     ) (else
...         L
...     )
... ))
sort
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; (let my-list (list 4 7 2 5 9 1 6 10 8 3))
my-list
&gt;&gt;&gt; my-list
(4 7 2 5 9 1 6 10 8 3)
&gt;&gt;&gt; (sort my-list less)
(1 2 3 4 5 6 7 8 9 10)
&gt;&gt;&gt; (sort my-list (lambda(x y) ( less y x )))
(10 9 8 7 6 5 4 3 2 1)</code></pre>
</div>
</div>
</p>
</div>
<div id="pu6" class="pu"><h1>C (GNU), 1095 bytes</h1>
<p>Much of the action takes place in the giant <code>v</code> function. Instead of implementing tail recursion explicitly, <code>v</code> is structured so that many of the calls from <code>v</code> to <code>v</code> will be handled by gcc's tail recursion optimization. There is no garbage collection.</p>
<p>This makes heavy use of GCC extensions, so it could only be compiled with gcc (use the command <code>gcc -w -Os tl.c</code>). It also uses some <code>scanf</code> extensions which were not available on Windows, which I usually use. The prospect of writing the parser with standard <code>scanf</code> was so awful that I used a Linux VM to test the program instead. Parsing without <code>scanf</code> character classes probably would have added 100+ bytes.</p>
<pre><code>#define O(...)({o*_=malloc(32);*_=(o){__VA_ARGS__};_;})
#define P printf
#define F(I,B)({for(I;x-&gt;c;x=x-&gt;l)B;})
#define Z return
typedef struct o{struct o*n,*l,*c;int i,t;}o;E(o a,o b){Z
a.n?!strcmp(a.n,b.n):a.c?b.c&amp;&amp;E(*a.c,*b.c)&amp;E(*a.l,*b.l):!b.c&amp;a.i==b.i;}p(o*x){x-&gt;t?P(&quot;%d &quot;,x-&gt;i):x-&gt;n?P(&quot;%s &quot;,x-&gt;n):F(P(&quot;(&quot;),p(x-&gt;c);P(&quot;)&quot;));}o*x,G,N;*C(o*h,o*t){Z
O(c:h,l:t);}o*v(o*x,o*e){o*W(o*l,o*e){Z
l-&gt;c?C(v(l-&gt;c,e),W(l-&gt;l,e)):&amp;N;}o*y,*a,*f;int t;Z
x-&gt;c?y=v(x-&gt;c,e),x=x-&gt;l,t=y-&gt;i,t?9/t?a=v(x-&gt;c,e),t&gt;7?(t&gt;8?a-&gt;c:a-&gt;l)?:a:t&gt;6?v(a,e):t&lt;6?x=v(x-&gt;l-&gt;c,e),t&gt;4?C(a,x):O(t:1,i:t&gt;3?E(*a,*x):t&gt;2?a-&gt;i&lt;x-&gt;i:a-&gt;i-x-&gt;i):v((a-&amp;N&amp;&amp;!a-&gt;t|a-&gt;i?x:x-&gt;l)-&gt;l-&gt;c,e):(t&amp;1&amp;&amp;d(x-&gt;c-&gt;n,v(x-&gt;l-&gt;c,e)),x-&gt;c):(y-&gt;l-&gt;l-&gt;l?y=y-&gt;l:(x=W(x,e)),a=y-&gt;c,v(y-&gt;l-&gt;c,a-&gt;n?O(n:a-&gt;n,c:x,l:&amp;G):F(f=&amp;G,(f=O(n:a-&gt;c-&gt;n,c:x-&gt;c,l:f),a=a-&gt;l);f))):x-&gt;n?e-&gt;n?strcmp(x-&gt;n,e-&gt;n)?v(x,e-&gt;l):e-&gt;c:e:x;}d(o*n,o*x){*v(O(n:&quot;&quot;),&amp;G)=(o){n:n,c:x,l:O()};}*R(h){char*z,*q;Z
scanf(&quot; %m[^ \n()]&quot;,&amp;q)&gt;0?h=strtoul(q,&amp;z,10),C(*z?O(n:q):O(t:1,i:h),R()):~getchar()&amp;1?q=R(),C(q,R()):&amp;N;}main(i){for(;++i&lt;12;)d(strndup(&quot;slecivthqd&quot;+i-2,1),O(i:i));F(x=R(),p(v(x-&gt;c,&amp;G)));}
</code></pre>
<p><strong>Semi-ungolfed</strong></p>
<pre><code>typedef struct o o;
struct o {
    char* n;
    o* l, //next in this list
     * c; 
    int i,
        t;
} ;



#define O(...)({o*_=malloc(32);*_=(o){__VA_ARGS__};_;})

E(o a, o b) { //tests equality 
    return
        a.n ? !strcmp(a.n,b.n) :
        a.t ? a.i==b.i :
        a.c ? b.c &amp;&amp; E(*a.c,*b.c)&amp;E(*a.l,*b.l) :
        !b.c
    ;
}

#define P printf


p(o*x){
    x-&gt;t?P(&quot;%d &quot;,x-&gt;i):x-&gt;n?P(&quot;%s &quot;,x-&gt;n):({for(P(&quot;(&quot;);x-&gt;c;x=x-&gt;l)p(x-&gt;c);P(&quot;)&quot;);});
}


o*_,G,N; //N = nil



o*C(o*h,o*t){return O(c:h,l:t);}


/*
        2 3 4 5 6 7 8 9 10 11
        s l e c i v t h d  q
    */


o* v(o* x, o* e) { //takes list, int, or name
    o*W(o* l, o* e) { //eval each item in list
        return l-&gt;c ? C(v(l-&gt;c ,e), W(l-&gt;l, e)) : &amp;N;
    }

    o*y,*a,*f;int t;
    return x-&gt;c ? //nonempty list = function/macro call
        y = v(x-&gt;c,e), //evals to function/macro
        x = x-&gt;l,   //list position of first arg (if it exists)
        (t=y-&gt;t)?   //builtin no., if any
             t&gt;9 ?
              t&amp;1 ? x-&gt;c // 11 = q
                : //10 = d
                (d(x-&gt;c,v(x-&gt;l-&gt;c,e)),x-&gt;c)
           : (a = v(x-&gt;c,e), //eval'd first arg
             t)&gt;7 ? // t/h
                (t &gt; 8 ? a-&gt;c : a-&gt;l) ?: a
           : t&gt;6 ? //v
                v(a,e)
           : (x = x-&gt;l, //position of 2nd arg in list
             t)&gt;5 ? //i
                v( (a-&gt;n||a-&gt;l||a-&gt;i|a-&gt;t&gt;1 ? x : x-&gt;l)-&gt;c, e)
           : (x = v(x-&gt;c,e), //evaluated 2nd arg
             t)&gt;4 ? // c
                C(a,x)
           : O(t:1,i:
                t&gt;3 ? E(*a,*x) :  //e
                t&gt;2 ? a-&gt;i&lt;x-&gt;i : //l
                      a-&gt;i-x-&gt;i   //s
              )
        :
        (
            y-&gt;l-&gt;l-&gt;l ? //whether this is macro
                y = y-&gt;l :
                (x = W(x,e)),  //eval args
            a = y-&gt;c,  //a = arg list
            //a = a-&gt;n ? x=C(x, &amp;N), C(a, &amp;N) : a, //transform variadic style to normal
            v(y-&gt;l-&gt;c,
               a-&gt;n ? //variadic
                O(n:a-&gt;n,c:x,l:&amp;G)
              : ({
                   for(f=&amp;G; a-&gt;c; a=a-&gt;l,x=x-&gt;l)
                      f=O(n:a-&gt;c-&gt;n, c: x-&gt;c, l:f);
                   f;
                })
            )
        )
    :
    x-&gt;n ? // name
        e-&gt;n ?
            strcmp(x-&gt;n,e-&gt;n) ?
                v(x,e-&gt;l)
            : e-&gt;c
        : e
     : x; //int or nil
}

d(o*n,o*x){
    * v(O(n:&quot;&quot;),&amp;G) =
        (o){n:n-&gt;n,c:x,l:O()};
}


;
o*R(){
    char*z,*q;int h;
return scanf(&quot; %m[^ \n()]&quot;,&amp;q)&gt;0?
    h=strtoul(q,&amp;z,10),
    C(*z ? O(n:q) : O(t:1,i:h), R())
: getchar()&amp;1?&amp;N:(q=R(),C(q,R()));
}
main(i) {

    for(;++i&lt;12;) d(O(n:strndup(&quot;slecivthdq&quot;+i-2,1)),O(t:i));

    o *q;
    for(q=R(); q-&gt;c; q=q-&gt;l) p(v(q-&gt;c,&amp;G));

}
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/62886/">62886</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




