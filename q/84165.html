<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::QNNN</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
  <!-- TXXX -->
<tr d-ix="0"><td>117</td><td>Scala</td><td>230905T024841Z</td><td><a href="https://codegolf.stackexchange.com/questions/84165/calculate-the-partitions-of-n/264904#264904">138 Aspe</a></td></tr>
<tr d-ix="1"><td>044</td><td>Curry PAKCS</td><td>220806T005047Z</td><td><a href="https://codegolf.stackexchange.com/questions/84165/calculate-the-partitions-of-n/250742#250742">alephalp</a></td></tr>
<tr d-ix="2"><td>007</td><td>Vyxal</td><td>220805T230749Z</td><td><a href="https://codegolf.stackexchange.com/questions/84165/calculate-the-partitions-of-n/250741#250741">naffetS</a></td></tr>
<tr d-ix="3"><td>008</td><td>05AB1E</td><td>220805T140636Z</td><td><a href="https://codegolf.stackexchange.com/questions/84165/calculate-the-partitions-of-n/250729#250729">Kevin Cr</a></td></tr>
<tr d-ix="4"><td>065</td><td>JavaScript  ES6</td><td>160701T084621Z</td><td><a href="https://codegolf.stackexchange.com/questions/84165/calculate-the-partitions-of-n/84197#84197">Neil</a></td></tr>
<tr d-ix="5"><td>054</td><td>Mathematica</td><td>160701T003906Z</td><td><a href="https://codegolf.stackexchange.com/questions/84165/calculate-the-partitions-of-n/84177#84177">miles</a></td></tr>
<tr d-ix="6"><td>032</td><td>J</td><td>160701T031028Z</td><td><a href="https://codegolf.stackexchange.com/questions/84165/calculate-the-partitions-of-n/84186#84186">miles</a></td></tr>
<tr d-ix="7"><td>009</td><td>Pyth</td><td>160701T024536Z</td><td><a href="https://codegolf.stackexchange.com/questions/84165/calculate-the-partitions-of-n/84184#84184">busukxua</a></td></tr>
<tr d-ix="8"><td>033</td><td>Brachylog</td><td>160701T092710Z</td><td><a href="https://codegolf.stackexchange.com/questions/84165/calculate-the-partitions-of-n/84200#84200">Fatalize</a></td></tr>
<tr d-ix="9"><td>044</td><td>Haskell</td><td>160701T092013Z</td><td><a href="https://codegolf.stackexchange.com/questions/84165/calculate-the-partitions-of-n/84199#84199">xnor</a></td></tr>
<tr d-ix="10"><td>039</td><td>J</td><td>160701T083026Z</td><td><a href="https://codegolf.stackexchange.com/questions/84165/calculate-the-partitions-of-n/84193#84193">Zgarb</a></td></tr>
<tr d-ix="11"><td>065</td><td>Python</td><td>160701T075114Z</td><td><a href="https://codegolf.stackexchange.com/questions/84165/calculate-the-partitions-of-n/84192#84192">xnor</a></td></tr>
<tr d-ix="12"><td>009</td><td>Jelly</td><td>160701T064730Z</td><td><a href="https://codegolf.stackexchange.com/questions/84165/calculate-the-partitions-of-n/84189#84189">Dennis</a></td></tr>
<tr d-ix="13"><td>072</td><td>Python 3.5</td><td>160701T044641Z</td><td><a href="https://codegolf.stackexchange.com/questions/84165/calculate-the-partitions-of-n/84187#84187">Dennis</a></td></tr>
<tr d-ix="14"><td>017</td><td>Pyth</td><td>160701T030448Z</td><td><a href="https://codegolf.stackexchange.com/questions/84165/calculate-the-partitions-of-n/84185#84185">Anders K</a></td></tr>
<tr d-ix="15"><td>053</td><td>Haskell</td><td>160701T021925Z</td><td><a href="https://codegolf.stackexchange.com/questions/84165/calculate-the-partitions-of-n/84183#84183">Anders K</a></td></tr>
<tr d-ix="16"><td>018</td><td>Pyth</td><td>160701T002320Z</td><td><a href="https://codegolf.stackexchange.com/questions/84165/calculate-the-partitions-of-n/84176#84176">Leaky Nu</a></td></tr>
<tr d-ix="17"><td>020</td><td>MATL</td><td>160630T234434Z</td><td><a href="https://codegolf.stackexchange.com/questions/84165/calculate-the-partitions-of-n/84169#84169">Luis Men</a></td></tr>
<tr d-ix="18"><td>194</td><td>Javascript</td><td>160701T001010Z</td><td><a href="https://codegolf.stackexchange.com/questions/84165/calculate-the-partitions-of-n/84172#84172">Nick</a></td></tr>
</table>
<div id="pu0" class="pu"><h2><a href="http://www.scala-lang.org/" rel="nofollow noreferrer">Scala</a>, 117 bytes</h2>
<p>Port of <a href="https://codegolf.stackexchange.com/a/84187/110802">@Dennis's Python answer</a> in Scala.</p>
<hr />
<p>Golfed version. <a href="https://tio.run/##NYwxC8IwEEZ3f8WNOYqBDC6VCI4OnTqWIrG9QCRe0@YEQfztMQ5u33t8vDy56Mpyu9Mk0LnAQC8hnjOcU3pDmcmDV9xeWLDtSYae1qHCONpQvbUGq1XVKoNIMZMy8GQJERi1j046l1Swp3reB9SPSte2@S@dl01oRtSy1E7z6zAWgLQFlsjKK3NAPO4@5Qs" rel="nofollow noreferrer">Try it online!</a></p>
<pre class="lang-scala prettyprint-override"><code>def f(n:Int):Set[Seq[Int]]=if(n==1)Set(Seq(1))else(1 until n).flatMap(i=&gt;f(n-i).map(_:+i).map(_.sorted)).toSet+Seq(n)
</code></pre>
<p>Ungolfed version. <a href="https://tio.run/##TY6xCoMwEIZ3n@IfE6RChi4WCx0LdeooDqkmkJKewVyhID67VSvS4eDuvo@7Pzba62nqHk/TMErtCObDhtqISwgDEqA1FlZQjiuxzHE3XN1c5Goe6xoFhtkBnIUgFAWU3DZYVLGoQkm5rkYYH83OhcKb2HmQzKzXXOqAAQ7FeROwPMYBTmavlYV/Nh8IyNOFxq5n0@5k3Lox424OgRRrDNpSJL8KvSP2JKxQRylPyThNXw" rel="nofollow noreferrer">Try it online!</a></p>
<pre class="lang-scala prettyprint-override"><code>object Main extends App{ 
  def f(n: Int): Set[List[Int]] = {
    if (n == 1) {
      Set(List(1))
    } else {
      (1 until n).flatMap { i =&gt;
        f(n - i).map { p =&gt;
          (p :+ i).sorted
        }
      }.toSet + List(n)
    }
  }
  println(f(15));
}
</code></pre>
</div>
<div id="pu1" class="pu"><h1><a href="https://www.informatik.uni-kiel.de/%7Epakcs/" rel="nofollow noreferrer">Curry (PAKCS)</a>, 44 bytes</h1>
<pre><code>(1!)
_!0=[]
a!n=anyOf[a ..n]#n
a#n=a:a!(n-a)
</code></pre>
<p><a href="https://tio.run/##Sy4tKqrULUjMTi7@/z/NVsNQUZMrXtHANjqWK1ExzzYxr9I/LTpRQU8vL1Y5jytRGShklaiokaebqPk/NzEzT8FWIU3B9D8A" rel="nofollow noreferrer" title="Curry (PAKCS) – Try It Online">Try it online!</a></p>
</div>
<div id="pu2" class="pu"><h1><a href="https://github.com/Vyxal/Vyxal" rel="nofollow noreferrer">Vyxal</a>, 7 bytes</h1>
<pre><code>ɾÞ×'∑?=
</code></pre>
<p><a href="https://vyxal.pythonanywhere.com/#WyIiLCIiLCLJvsOew5cn4oiRPz0iLCIiLCI1Il0=" rel="nofollow noreferrer">Try it Online!</a></p>
<pre><code>ɾÞ×'∑?=
ɾ       # Get a list in the range [1, input]
 Þ×     # Get all combinations (with replacement) of all lengths
   '    # Filter for:
    ∑?= #  Sum equals the input
</code></pre>
</div>
<div id="pu3" class="pu"><h1><a href="https://github.com/Adriandmen/05AB1E/wiki/Commands" rel="nofollow noreferrer">05AB1E</a>, 8 <a href="https://github.com/Adriandmen/05AB1E/wiki/Codepage" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>Å1.œO€{ê
</code></pre>
<p>Outputs as a list of lists, from <code>n</code> amount of 1s to <code>[n]</code>, where each inner list is sorted (I know the rules allow them to be unsorted, but it's necessary for the uniquify of lists).</p>
<p><a href="https://tio.run/##yy9OTMpM/f//cKuh3tHJ/o@a1lQfXvX/v6EpAA" rel="nofollow noreferrer">Try it online</a> or <a href="https://tio.run/##yy9OTMpM/W9o6qrkmVdQWmKloGTvp8Ol5F9aAuHp@P0/3Gqod3Sy/6OmNdWHV/3XObTN/j8A" rel="nofollow noreferrer">verify the first 15 result</a>.</p>
<p>If builtins were allowed, this would be <strong>2 <a href="https://github.com/Adriandmen/05AB1E/wiki/Codepage" rel="nofollow noreferrer">bytes</a></strong> instead (with the same exact results):<br />
<code>Åœ</code> - <a href="https://tio.run/##yy9OTMpM/f//cOvRyf//G5oCAA" rel="nofollow noreferrer">Try it online</a> or <a href="https://tio.run/##yy9OTMpM/W9o6qrkmVdQWmKloGTvp8Ol5F9aAuHp@P0/3Hp08n@dQ9vs/wMA" rel="nofollow noreferrer">verify the first 15 results</a>.</p>
<p><strong>Explanation:</strong></p>

<pre class="lang-python prettyprint-override"><code>Å1        # Push a list with the (implicit) input amount of 1s
  .œ      # Get all partitions of this list
    O     # Sum each inner-most list
     €{   # Sort each inner list
       ê  # Sorted uniquify the list of lists
          # (after which the result is output implicitly)
</code></pre>
<p>Minor note: <code>ê</code> (sorted uniquify) could also just be <code>Ù</code> (uniquify) for the same result, but with the added sort it's a lot faster in this case.</p>
</div>
<div id="pu4" class="pu"><h2>JavaScript <s>(Firefox 30-57) 79</s> ES6, 65 bytes</h2>

<pre><code>f=(n,m=1,a=[])=&gt;n?m&gt;n?[]:[...f(n-m,m,[...a,m]),...f(n,m+1,a)]:[a]
</code></pre>

<p>Port of @xnor's Python solution. (If only I'd noticed that you could recurse over <code>m</code> as well as <code>n</code>...)</p>
</div>
<div id="pu5" class="pu"><h1>Mathematica, <s>62</s> 54 bytes</h1>

<pre><code>Inner[#2~Table~#&amp;,FrobeniusSolve[r=Range@#,#],r,Join]&amp;
</code></pre>

<p>The partitions of an integer <em>n</em> can be found by solving for <em>n</em>-tuples of non-negative integers (<em>c</em><sub>1</sub>, <em>c</em><sub>2</sub>, ..., <em>c</em><sub><em>n</em></sub>) such that <em>c</em><sub>1</sub> + 2 <em>c</em><sub>2</sub> + ... + <em>n</em> <em>c</em><sub><em>n</em></sub> = <em>n</em>. <code>FrobeniusSolve</code> is able to find all solutions to this equation which are used to create that many copies of their respective values in order to find all integer partitions of <em>n</em>.</p>
</div>
<div id="pu6" class="pu"><h1>J, <s>49</s> <s>42</s> <s>36</s> <s>35</s> 32 bytes</h1>

<pre><code>a:1&amp;([:~.@,(,;}./:~@,(+{.))&amp;&gt;)~]
</code></pre>

<p>It's tacit now!</p>

<p>Builds the integer partition of <em>n</em> by constructing the integer partitions from 1 to <em>n</em>. Computes the result for <em>n</em> = 15 in a millisecond.</p>

<p>Starting with the initial integer partition <code>[[1]]</code> which corresponds to <em>n</em> = 1, construct the next integer partition by joining the results from two operations: appending a 1 to each partition; incrementing the smallest value by 1 in each partition. Of course, duplicate partitions will be removed. To get the integer partition <em>n</em> = 2 and onwards,</p>

<pre><code>Partition for n = 1
[[1]]

Partition for n = 2
[[1, 1]] join [[2]]
= [[1, 1], [2]]

Partition for n = 3
[[1, 2], [1, 1, 1]] join [[3], [1, 2]]
= [[3], [1, 2], [1, 1, 1]]

... and so on
</code></pre>

<h2>Usage</h2>

<pre><code>   f =: a:1&amp;([:~.@,(,;}./:~@,(+{.))&amp;&gt;)~]
   f 1
┌─┐
│1│
└─┘
   f 2
┌───┬─┐
│1 1│2│
└───┴─┘
   f 3
┌─────┬───┬─┐
│1 1 1│1 2│3│
└─────┴───┴─┘
   f 5
┌─────────┬───────┬─────┬───┬─────┬───┬─┐
│1 1 1 1 1│1 1 1 2│1 2 2│2 3│1 1 3│1 4│5│
└─────────┴───────┴─────┴───┴─────┴───┴─┘
   # f 15
176
</code></pre>

<h2>Explanation</h2>

<p>Since J does not support ragged arrays, each partition has to be boxed so they they won't be zero padded when appended to other partitions.</p>

<pre><code>a:1&amp;([:~.@,(,;}./:~@,(+{.))&amp;&gt;)~]  Input: n
a:                                The empty box
                               ]  Get the input n
  1&amp;(                        )~   Repeat n times with an initial array of one empty box
           (              )&amp;&gt;       Operate on each partition
                     (   )            Hook a partition
                       {.               Get its head (the smallest value)
  1                   +                 Add 1 to it
  1           }.                      Drop the first value in each partition
                    ,                 Join the previous two results
                /:~@                  Sort it
  1         ,                         Prepend a 1 to the initial partition
             ;                        Box the last two results and join them
     [:   ,                         Flatten the pairs of boxes
       ~.@                          Remove duplicates and return
                                  Return the final result where each box
                                  is a partition of n
</code></pre>
</div>
<div id="pu7" class="pu"><h2>Pyth, <s>10</s> 9 bytes</h2>

<pre><code>{SMlMM./U
</code></pre>

<p>Not too sure if this isn't cheating, but the rules only said one cannot use <strong>integer</strong> partition (it's not stated clearly in the question itself, but a comment by OP in the question says integer partition). I'm using <s>string</s> <strong>list</strong> partition, which makes slices of the list that concatenate up to the "mother" list. I believe I have to thank @Maltysen for the idea of using lists rather than strings.</p>

<p>n=15 takes less than one second on my machine.</p>

<p>In dataflow pseudocode:</p>

<pre><code>              input       // initial data
        U     range       // makes a list of length equal to input
      ./      partition   // partitions string
   lMM        length      // length of each substring in each way to partition
 SM           sort        // sort each way to partition
{             deduplicate // removes all duplicate after sorting
              print       // implicit, output final result
</code></pre>

<p><a href="http://pyth.herokuapp.com/?code=%7BSMlMM.%2FU&amp;input=4&amp;test_suite=1&amp;test_suite_input=1%0A2%0A3%0A4%0A5%0A7%0A10%0A15&amp;debug=0" rel="nofollow">Try it online here.</a></p>
</div>
<div id="pu8" class="pu"><h1><a href="https://github.com/JCumin/Brachylog" rel="nofollow">Brachylog</a>, 33 bytes (Non-competing)</h1>

<pre><code>:1f:oad.
:1eI,.##lI,.:{.&gt;0}a+?,.=
</code></pre>

<p>This is non-competing because of a bug fix.</p>

<p>This takes about 1 second for <code>15</code> on my machine. For <code>20</code> and greater this crashes with an <code>Out of global stack</code> exception.</p>

<h3>Explanation</h3>

<p>This uses no partitioning built-in of any kind, and instead uses the fact that <code>+</code> works both ways through constraints propagation.</p>

<ul>
<li><p>Main predicate:</p>

<pre><code>:1f                       Find the list of all valid outputs of predicate 1
   :oa                    Sort each element of that list
      d.                  Output is that list of sorted lists minus all duplicates
</code></pre></li>
<li><p>Predicate 1:</p>

<pre><code>:1eI                      I is an integer between Input and 1
    .##lI,                Output is a list of length I
          .:{.&gt;0}a        Elements of Output are integers greater than 0
                  +?,     The sum of the elements of Output is Input
                     .=   Assign values to the elements of Output
</code></pre></li>
</ul>
</div>
<div id="pu9" class="pu"><h2>Haskell, 44 bytes</h2>

<pre class="lang-haskell prettyprint-override"><code>0%m=[[]]
n%m=[j:r|j&lt;-[m..n],r&lt;-(n-j)%j]
(%1)
</code></pre>
<p>The auxiliary function <code>n%m</code> gives the partitions of <code>n</code> into parts <code>≥m</code>, with the main function using <code>m=1</code>. It branches of each first entry <code>j</code> with <code>m≤j≤n</code>, recursing on the remaining partition of <code>n-j</code> into parts that are at least <code>j</code>. The base case <code>n==0</code> gives just the empty partition.</p>
</div>
<div id="pu10" class="pu"><h2>J, 39 bytes</h2>

<pre><code>[:~.i.&lt;@\:~@(#;.1~"1 0)1,@{@;(&lt;1 0)#~&lt;:
</code></pre>

<p>This is a monadic verb that takes an integer and returns an array of boxed arrays. <a href="http://tryj.tk/" rel="nofollow noreferrer">Try it here.</a> Usage:</p>

<pre><code>   p =: [:~.i.&lt;@\:~@(#;.1~"1 0)1,@{@;(&lt;1 0)#~&lt;:
   p 3
+-----+---+-+
|1 1 1|2 1|3|
+-----+---+-+
</code></pre>

<p>On input 15, it runs for about a second on my machine.</p>

<h2>Explanation</h2>

<p>This challenge immediately looked like a job for Catalogue (<code>{</code>) and Cut (<code>;.</code>).
The outline of the algorithm is:</p>

<ul>
<li>Produce all 0-1 arrays of length <code>n</code>.</li>
<li>For each of them, cut a dummy length-<code>n</code> array along the 1s, and list the lengths of each part.</li>
<li>Sort the lengths, and remove duplicate arrays from the result.</li>
</ul>

<p>Apparently, Luis Mendo had the <a href="https://codegolf.stackexchange.com/a/84169/32014">same idea</a> too.</p>

<p>Explanation of code:</p>

<pre><code>[:~.i.&lt;@\:~@(#;.1~"1 0)1,@{@;(&lt;1 0)#~&lt;:   Input is n.
                                     &lt;:   n-1
                                   #~     copies of
                             (&lt;1 0)       the boxed array [1 0].
                       1    ;             Prepend the boxed array [1].
                          {@              Catalog: produces all combinations of taking one
                                          item from each box, in a high-dimensional matrix.
                        ,@                Flatten the matrix. This results in a list of all
                                          boxed 0-1 arrays of length n that begin with a 1.
    i.                                    The array A =: 0, 1, ..., n-1.
            (     "1 0)                   For each of the boxed arrays B:
              ;.1~                          cut A along the occurrences of 1s in B,
             #                              take the length of each part,
        \:~@                                sort the lengths,
      &lt;@                                    and put the result in a box.
[:~.                                      Remove duplicate boxes.
</code></pre>
</div>
<div id="pu11" class="pu"><h2>Python, 65 bytes</h2>

<p><strong>Python 3</strong></p>
<pre class="lang-python prettyprint-override"><code>def f(n,i=1,l=[]):n or print(l);i&gt;n or[f(n-i,i,[i]+l),f(n,i+1,l)]
</code></pre>
<p>This function accumulates a partition and prints the outputs, branching on choices. It decides how many 1's to put in the partition, how many 2's, and so on. For each value <code>i</code>, it either</p>
<ul>
<li>Adds a part of size <code>i</code>, and decreases <code>n</code> to <code>n-i</code>, or</li>
<li>Moves on to <code>i+1</code></li>
</ul>
<p>If <code>i&gt;n</code>, then no more parts can be made, so it stops. If <code>n</code> falls to <code>0</code>, the partition is successful and so is printed.</p>
<p><strong>Python 2</strong></p>
<pre class="lang-python prettyprint-override"><code>f=lambda n,i=1:n/i and[l+[i]for l in f(n-i,i)]+f(n,i+1)or[[]][n:]
</code></pre>
<p>A recursive method that outputs a list of partitions. As with the Python 3 code, it counts up the part size <code>i</code> and decides at each step whether to add another part of size <code>i</code> or stop.</p>
<p>Both of these do <code>n=15</code> almost instantly.</p>
</div>
<div id="pu12" class="pu"><h1><a href="http://github.com/DennisMitchell/jelly" rel="nofollow">Jelly</a>, 9 <a href="https://github.com/DennisMitchell/jelly/wiki/Code-page" rel="nofollow">bytes</a></h1>

<pre><code>b1ŒṖḅ1Ṣ€Q
</code></pre>

<p><a href="http://jelly.tryitonline.net/#code=YjHFkuG5luG4hTHhuaLigqxR&amp;input=&amp;args=MTU" rel="nofollow">Try it online!</a></p>

<h3>How it works</h3>

<pre><code>b1ŒṖḅ1Ṣ€Q  Main link. Argument: n (integer)

b1         Convert n to unary, i.e., a list A of n 1's.
  ŒṖ       Generate all partitions of the list A.
    ḅ1     Convert each flat list from unary to integer.
      Ṣ€   Sort each resulting list.
        Q  Unique; deduplicate the lists.
</code></pre>
</div>
<div id="pu13" class="pu"><h1>Python 3.5, <s>82</s> 72 bytes</h1>



<pre class="lang-python prettyprint-override"><code>f=lambda n:{(*sorted([*p,i]),)for i in range(1,n)for p in f(n-i)}|{(n,)}
</code></pre>

<p>Returns a set of tuples. <strong>n = 15</strong> finishes instantly.</p>

<p>Test it on <a href="https://repl.it/C7rf/3" rel="nofollow">repl.it</a>.</p>
</div>
<div id="pu14" class="pu"><h1>Pyth, 17 bytes</h1>

<pre><code>L|{SMs+LVrb0yMb]Y
</code></pre>

<p>Defines a function named <code>y</code>.  <a href="https://pyth.herokuapp.com/?code=L%7C%7BSMs%2BLVrb0yMb%5DYy&amp;input=5&amp;test_suite_input=5" rel="nofollow">Try it online</a>.</p>
</div>
<div id="pu15" class="pu"><h1>Haskell, 53 bytes</h1>

<pre class="lang-hs prettyprint-override"><code>p=[[]]:[map(1:)q++[a+1:b|a:b&lt;-q,all(a&lt;)b]|q&lt;-p]
(p!!)
</code></pre>
</div>
<div id="pu16" class="pu"><h1>Pyth, 18 bytes</h1>

<pre><code>L?b{SM+R-bsdsyMb]Y
</code></pre>

<p><a href="http://pyth.herokuapp.com/?code=L%3Fb%7BSM%2BR-bsdsyMb%5DYy&amp;input=15&amp;debug=0">Try it online!</a> (The <code>y</code> at the end is used to call the function)</p>

<p>This is fairly quick.</p>

<p>This uses recursion. If the input is <code>b</code>, my method will generate the partitions from <code>0</code> to <code>b-1</code>, and then generate the correct partitions from each.</p>

<p>For example, when <code>b=4</code>:</p>

<ul>
<li><code>b=0</code> gives <code>[[]]</code></li>
<li><code>b=1</code> gives <code>[[1]]</code></li>
<li><code>b=2</code> gives <code>[[2], [1, 1]]</code></li>
<li><code>b=3</code> gives <code>[[3], [1, 2], [1, 1, 1]]</code></li>
</ul>

<p>Then, to each partition in <code>b=0</code>, append <code>4</code> (to make the sum 4); to each partition in <code>b=1</code>, append <code>3</code> (to make the sum <code>4</code>); etc.</p>

<p>This is mainly how it works.</p>

<pre><code>L?b{SM+R-bsdsyMb]Y

L                    define a function called "y" which takes an argument: "b"
 ?b                  test for truthiness of b (in this case, test if b&gt;0).


   {SM+R-bsdsyMb     if truthy:

             yMb         call this function from 0 to b-1.
            s            unpack each list of partitions, generating only partitions.
      +R                 to each partition (d), append:
        -                    the difference of
         b                   b (the argument) and
          sd                 the sum of d (the partition).
    SM                   sort each partition.
   {                     remove duplicates.


                ]Y   if falsey:

                 Y       yield [].
                ]        yield [[]].
</code></pre>
</div>
<div id="pu17" class="pu"><h1><a href="https://github.com/lmendo/MATL" rel="nofollow noreferrer">MATL</a>, 20 bytes</h1>
<pre><code>:&quot;0Gq:@XNG3$Yc!dS!Xu
</code></pre>
<p><a href="http://matl.tryitonline.net/#code=OiIwR3E6QFhORzMkWWMhZFMhWHU&amp;input=NQ" rel="nofollow noreferrer"><strong>Try it online!</strong></a></p>
<p>For input <code>15</code> it takes about 2 seconds in the online compiler.</p>
<h3>Explanation</h3>
<p>This works by generating partition <em>points</em> and then converting to partition <em>lengths</em>. What I mean by this is the following. Given input <em>N</em> = 5, a possible partition is [2 2 1]. This is represented by partition points [0 2 4 5], such that <em>consecutive differences</em> (or lengths) of the partition points give the resulting partition of the input number.</p>
<p>All arrays of partition points start with 0 and end with <em>N</em>. The number <em>k</em> of intermediate points  varies from 0 to <em>N</em>-1. For <em>N</em> and <em>k</em> given, the intermediate points can be generated as a combination of the numbers [1, 2, ..., <em>N</em>-1] taken <em>k</em> at a time.</p>
<p>Several arrays of partition points may give rise to the same result in a different order. For example, partition points [0 1 3 5] would give the partition lengths [1 2 2], i.e. the same as the previous [2 2 1] only in a different order. This has to be taken into account by <em>sorting</em> each array of partition lengths and <em>removing duplicates</em>.</p>
<pre><code>:        % Implicitly input N. Push [1 2 ... N]. These are the possible values of k,
         % except with N instead of 0
&quot;        % For each
  0      %   Push 0
  Gq:    %   Push [1 ... N-1]. These the possible intermediate points
  @XN    %   Push k and produce the combinations. Each k produces a 2D array with
         %   each combination on a row. The value k=N produces an empty array
  G      %   Push N
  3$Yc   %   Prepend a column of zeros and append a column of N to the array
  !d     %   Transpose. Consecutive differences of each column
  S!     %   Sort each column. Transpose
  Xu     %   Keep only unique rows
         % Implicitly end for and display all arrays in the stack
</code></pre>
</div>
<div id="pu18" class="pu"><h2>Javascript, 194 bytes</h2>
<pre><code>p=n=&gt;{var a=[];for(var i=1;i&lt;=n-i;i+=1){for(v of p(n-i)){v.push(i);a.push(v.sort())}}a.push([n]);return a};n=5;s=p(n).map(v=&gt;JSON.stringify(v));s=s.filter((v,i)=&gt;s.indexOf(v)==i);console.log(s);
</code></pre>
<p><strong>Non-minified</strong></p>
<p>Finding uniques by sorting and comparing to a string is quite a hack, but probably saves space.</p>
<pre><code>p = n =&gt; {
    var a = [];
    
    for (var i = 1; i &lt;= n-i; i++)
    {
        for (v of p(n-i)) {
            v.push(i);
            a.push(v.sort());
        }
    }

    a.push([n]);

    return a;
}

n = 5;
s = p(n).map(v =&gt;  JSON.stringify(v));
s = s.filter((v,i) =&gt; s.indexOf(v) == i);
console.log(s);
</code></pre>
</div>
<!-- TYYY -->

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/QNNN/">QNNN</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




