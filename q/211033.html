<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::211033</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>618</td><td>Python3</td><td>240428T015037Z</td><td><a href="https://codegolf.stackexchange.com/questions/211033/wait-which-tetromino-was-that/272863#272863">Ajax1234</a></td></tr>
<tr d-ix="1"><td>282</td><td>JavaScript ES10</td><td>200914T051614Z</td><td><a href="https://codegolf.stackexchange.com/questions/211033/wait-which-tetromino-was-that/211052#211052">Arnauld</a></td></tr>
<tr d-ix="2"><td>nan</td><td>Brachylog</td><td>200914T021834Z</td><td><a href="https://codegolf.stackexchange.com/questions/211033/wait-which-tetromino-was-that/211043#211043">xash</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>Python3, 618 bytes</h1>
<pre class="lang-py prettyprint-override"><code>E=enumerate
V=lambda u,I,x:I&lt;0 or I&gt;=len(u[0])or u[x][I]
def J(x,y,B,U):
 u=eval(str(U))
 for X,r in E(B):
  for Y,v in E(r):
   if x+X&gt;=len(u)or y+Y&gt;=len(u[0])or(u[x+X][y+Y]and int(v)):return
   u[x+X][y+Y]=[u[x+X][y+Y],1][int(v)]
 return u
O=lambda v,n:[v]+O([*zip(*v)],n-1)+O(v[::-1],n-1)if n else[]
def f(b,B):
 for P,S in E([['11','11'],['100','111'],['001','111'],['011','110'],['010','111'],['110','011'],['1111']]):
  for x,r in E(b):
   for y,v in E(r):
    for W in O(S,4):
     if(U:=J(x,y,W,b)):
      j,k=[],[]
      for i in U:
       if all(i):j+=[[0]*len(i)]
       else:k+=[i]
      if j+k==B:return P
</code></pre>
<p><a href="https://tio.run/##dZRLb@IwEMfPm0/hkkNscFHMS6tovQekHtjDUqli28proSASbSANKC9BvzzrcRxCoHCIM//5zcMzEftj/m@XDL/v09PpiQdJ8RGkfh5Yf3jsf6zWPirojB682Q8X7VI0@8njIMGFcCVRZiEOUsyktQ5C9Asf6JFO6YJ4Fip4UPoxzvIULwixUKjgN5qiKEFPeAqElt5pWUmpllAUokPvzdSAAsfee6uiOhUghdKln6xVcI5LQrw0yIs0gRQXABcXBmVSVLS0UIWjwprXtyxp4olS9uZYdD@jPe4qjiaPjCilFJ73yCpTdZigIM4CUd06xCuq7wPXeaYv1XWEcBhzKDwkVe@uq43Kcl12aRnQNdYlybTlni14kefhHep5rqrhgXa8GqgWX0Ga4xc6MqKaM154vNrYK12RWkcbuuVCFZPGhvAIwhc1ATvy4xhHxNv0uFBr6cJ@IlKH6Ol4W@WLakmFbHpbzqdmT@j5BLPLd8vVzk/XOFP1vxmX0FvaPHCn7xAov4HykTx3EkZxHqT49y4JaNbP9nGUY@dv4hDVgZUxxFGn07H6@lcfoGRs2ThtWzv1AYqVDRqXbUMcHHZl6fDBkn2Vut8gVjZsqreynJtQyE0a@4YZmTTQHvhah0GWVzdVSQzUtDNu8tTx5t34W720nhUwqWtAdt2jbfzmXet6PJN2Q1ch9lkBYp/CjkPcfACM0IvPQW2KqH@NW2zQwgb3sGELG97DRi1sdA8bt7DxPWzSwiYaO/0H" rel="nofollow noreferrer">Try it online!</a></p>
</div>
<div id="pu1" class="pu"><h1>JavaScript (ES10), <s> 286 </s> 282 bytes</h1>
<p>Expects <code>(a)(b)</code>, where <span class="math-container">\$a\$</span> and <span class="math-container">\$b\$</span> are 2 lists of binary strings. Returns an integer between <span class="math-container">\$0\$</span> and <span class="math-container">\$6\$</span> for <code>JLTIOZS</code>, or <span class="math-container">\$-1\$</span> if there's no solution (but we're not supposed to support that).</p>
<pre class="lang-javascript prettyprint-override"><code>a=&gt;b=&gt;&quot;0NF71ZMA13FM000F1F1F1IFL2R8I38LT357N368H&quot;.match(/../g).findIndex(p=&gt;b.some((r,y)=&gt;[...r].some((_,x)=&gt;!b.some((s,i)=&gt;[...a.map(B=r=&gt;'0b'+r),~0].flatMap(t=(r,Y,a)=&gt;~(q=((parseInt(p,36)||4369)&gt;&gt;(Y-y)*4&amp;15)&lt;&lt;x,t|=q&amp;a[Y+1],q|=q&amp;r?~0:r)+2**s.length?q:(i--,[]))[i]^B(s)|!t))))%14&gt;&gt;1
</code></pre>
<p><a href="https://tio.run/##bVBhb9owEP3eX5ESrbHBMUlDKevqVKs0NCbopNEvNGSTCYZmSp1gexNojL/O7MxMZe1Zytnv3nt3ue/0J5WZyCvl83LO9guypySekbgR3PUvw4fR@zDqj4Ig6IfmDPrD8y@9QdQb3kcXl3dRt/exgZ@oyh5BG@P2EuJFzucDPmdrUGkfLMsnBoBAG0jiBGMsUgt9Q2sNnR4YEuWWQbVfBW6JILEXzLyWgGgXpHhRUDXSBUW02wRRzd6BFQGgokKyAVegQlEXbredqPsWxjGY@BvY7JyFF/D6eo3UlqzOaDJphSlambu42QVXArbOm02JC8aX6vFmdQVy30dJCmGSp19vgYTbUwV1vAk7cRzuBVv9yAUD3kJ6EAtG5/28YOMNz0AAsSrHSuR8CSCWVZEr0J5yvzXlbb2VUnygeknSIbHz68RxEoqcWeoQR1quN@VTrk3Nz9esZwULCwML3bYqaMb0wttL5GQGbAGdiOO5nhn2nfbPSi7LguGiXILGp@H94PPDuJEsAIVgBlNN@Q33uI4Tm3R23fpZJ/@/qHHXNWyT3L@vk2MPy3lFi4@0h4bPRRZ9oTXTmPJROmi10KKv9v1XxZZjhUffl9Ma13oe11LsvcYP2iOSe0D@AA" rel="nofollow noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a></p>
<h2>How?</h2>
<h3>Shape encoding</h3>
<p>Each shape is encoded with 2 digits in base 36, which allows to store:</p>
<p><span class="math-container">$$\lfloor 2\times\log_2 36\rfloor=10\text{ bits}$$</span></p>
<p>The bits are arranged in a <span class="math-container">\$4\times 4\$</span> matrix, with the piece wedged in the upper right corner. The least significant bit is mapped to the top-right cell and there are 6 implicit leading zeros.</p>
<p>Examples:</p>
<ul>
<li><p>The 1<sup>st</sup> entry is <code>0N</code> in base 36, which is <span class="math-container">\$23\$</span> in decimal and <span class="math-container">\$0000010111\$</span> in binary. This is a <code>J</code>.</p>
</li>
<li><p>The 6<sup>th</sup> entry is <code>FM</code> in base 36, which is <span class="math-container">\$562\$</span> in decimal and <span class="math-container">\$1000110010\$</span> in binary. This is a <code>T</code>.</p>
</li>
</ul>
<p><a href="https://i.stack.imgur.com/Ex28K.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/Ex28K.png" alt="examples" /></a></p>
<p>All shapes can be encoded that way, except the vertical <code>I</code>. This one is encoded as <code>00</code> and its actual value (<span class="math-container">\$4369\$</span> in decimal) is hard-coded separately.</p>
<h3>Main algorithm</h3>
<p>The main algorithm consists of 5 nested loops where we try to put each shape <span class="math-container">\$p\$</span> at each possible position <span class="math-container">\$(x,y)\$</span> in the grid <span class="math-container">\$a\$</span> and figure out which one leads to the grid <span class="math-container">\$b\$</span>.</p>
<p>Whenever a row is completed, we yield an empty array so that <code>.flatMap()</code> deletes this row and we decrement the index <span class="math-container">\$i\$</span> of the entry that needs to be read in the resulting array to account for the row shift.</p>
<p>We may end up with a negative <span class="math-container">\$i\$</span>. But because we use a XOR for the comparison, undefined rows behave like they were set to <span class="math-container">\$0\$</span>, which is what we want.</p>
<pre class="lang-javascript prettyprint-override"><code>&quot;...&quot;.match(/../g)              // list of shapes
.findIndex(p =&gt;                 // for each shape p:
  b.some((r, y) =&gt;              //   for each y:
    [...r].some((_, x) =&gt;       //     for each x:
      !b.some((s, i)=&gt;          //       for each row s at position i in b:
        [ ...a.map(             //         using the helper function B, decode a[] by
            B = r =&gt; '0b' + r   //         converting each binary string to an integer
          ), ~0                 //         and append a full line at the bottom
        ].flatMap(t =           //         initialize t to a non-numeric value
        (r, Y, a) =&gt;            //         for each row r at position Y in this array:
          ~(                    //
            q = (               //           q is the 4-bit mask of the shape
              ( parseInt(p, 36) //           decoded from the base-36 value p,
                || 4369 )       //
              &gt;&gt; (Y - y) * 4    //           keeping only the bits for this row
              &amp; 15              //
            ) &lt;&lt; x,             //           and left-shifting by x
            t |= q &amp; a[Y + 1],  //           update the 'touching' mask
            q |= q &amp; r ? ~0     //           invalidate the row if q overlaps r
                       : r      //           otherwise, merge q and r
          ) + 2 ** s.length ?   //           if the resulting line is not full:
            q                   //             yield q
          :                     //           else:
            (i--, [])           //             decrement i and yield an empty array,
                                //             which results in the deletion of this
                                //             line by flatMap()
        )[i]                    //         end of flatMap(); extract the i-th row
        ^ B(s)                  //         the test fails if this row is not equal to s
        | !t                    //         or the shape is floating in the air
      )                         //       end of some()
    )                           //     end of some()
  )                             //   end of some()
)                               // end of findIndex()
</code></pre>
<h3>Final result</h3>
<p>The shapes are stored in the following order:</p>
<pre><code>0N F7 1Z MA 13 FM 00 0F 1F 1F 1I FL 2R 8I 38 LT 35 7N 36 8H
0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18 19
<b>J</b>  <b>J</b>  <b>L</b>  <b>L</b>  <b>T</b>  <b>T</b>  <b>I</b>  <b>I</b>  <b>O</b>  <b>O</b>  <b>Z</b>  <b>Z</b>  <b>S</b>  <b>S</b>  <b>J</b>  <b>J</b>  <b>L</b>  <b>L</b>  <b>T</b>  <b>T</b></code></pre>
<p>which is why the final result is the value returned by <code>.findIndex()</code> modulo <span class="math-container">\$14\$</span>, divided by <span class="math-container">\$2\$</span> and rounded towards <span class="math-container">\$0\$</span>.</p>
<p>(NB: The shape <code>O</code> is stored twice so that it doesn't break the pattern.)</p>
</div>
<div id="pu2" class="pu"><h1><a href="https://github.com/JCumin/Brachylog" rel="nofollow noreferrer">Brachylog</a>, <sup>156</sup> 124 bytes</h1>
<p>Takes two matrices, <code>1</code> indicating an empty tile, <code>2</code> indicating a tile with a piece. Maps <code>O =&gt; 15, I =&gt; 1, J =&gt; 57, L =&gt; 60, S =&gt; 30, T =&gt; 23, Z =&gt; 51</code>.</p>
<pre><code>hI{∧Ḋ}ᵐ²O;I{zzᵐ+ᵐ²};21ẹᵗ↔c{≡ᵛ²h|∧1}ᵍbᵐ{-₁ᵐ²}ʰc~t?&amp;h{{∧2}ᵐ}ʰ↺₁;O↰₂c∋3∧O{{¬=₀&amp;}ˢ\}↰₇{\↔ᵐ|}{↔↔ᵐ|}{l₂ccẹ~ḃ{15|23|30|51|57|60}}|1
</code></pre>
<p><a href="https://tio.run/##SypKTM6ozMlPN/r/P8Oz@lHH8oc7umofbp1waJO/tWd1VRWQqQ3m1lobGT7ctfPh1umP2qYkVz/qXPhw6@xDmzJqgHoMgTp6k4DKqnUfNTVClJ/akFxXYq@WUQ0y1AhkJFDoUdsuoAJr/0dtGx41NSU/6ug2Bsr6V1cfWmP7qKlBrfb0ophasGR7dQzQHqCumtpqIAPOzgHpSwY6pO7hjuZqQ9MaI@MaY4MaU8MaU/MaM4Pa2hrD//@jo6MNdUDQCARjddB4RjqGMBgL5EYbIvEhao2wq439HwUA" rel="nofollow noreferrer">Try it online!</a> or <a href="https://tio.run/##VVAxS8NAFN79FeUdZLENJqV2KOpcETLoZNvBBjVgQVCh2LsrGiG2iuAgiDjpooNDKRTajh31V9z9kfjuLmmTDPe@@9733fde2hdHfnDdOT914wLtQqG0XYCuRcXsvn1GwQY5@HIYEFVdLibPi7E6ZTSS0VuFOhXkwQPmqFoHVqkqsAtsc0OBPWBlDfaBuWUFDlCjxYdgcTEfysE3nBx1Lo9twJt6Ow7qFAVi@mDyvFqd9noI1018zXXEfCYmrzJ68akcfojJ@2IcMDUpOp7aKKMlGd4a@e/I71/tWAGl6QpIyWiOgppn9qj6cvCopvMoXfxsyfDG4n@fTW66jkubGIVGximCJe7IMPR9nKUvpnf4K3BD3BbXw7@A@3POnDhuNGDN1l9aoKgYQjSjC7SKDcMRolSqEHMz4qw9kaUeO@fJBGTFaUN7VKTiciXjQUPSWOUsKTtprAy5M5lKPaFDScInWPMZZ05Hlgy0Wv8" rel="nofollow noreferrer">try all test cases (with nicer I/O)!</a> (Byte count is a bit longer because the header increases the predicate numbers.)</p>
<h3>How it works</h3>
<p>We search for a matrix <code>O</code> so that the input plus <code>O</code> after the removal rules will be equal to the output. We then trim <code>O</code> to contain a submatrix, bounded by the tetromino. Trying all orientations, it either fits in a 2 by x matrix – then we can convert it from base 2. Otherwise it is the <code>I</code> piece.</p>
<pre><code>h{∧Ḋ}ᵐ²O
</code></pre>
<p>Before this challenge, I would have created a matrix of the same dimension by taking the input length, mapping the rows length over it, and say every element should be a number … but this is much neater: <code>O</code> is the input, but every element in it is just any number. This is much neater!</p>
<pre><code>;I{zzᵐ+ᵐ²}
</code></pre>
<p><code>O</code> + Input</p>
<pre><code>;21ẹᵗ↔c{≡ᵛ²h|∧1}ᵍbᵐ
</code></pre>
<p>This is a very convoluted way to split in the rows into ((contains only 2s), (doesn't contain only 2s)). There are technically shorter versions, but all my attempts forced labelization of the numbers, slowing the program down to pure brute force. (This was really frustrating finding a version that works at all.)</p>
<pre><code> {-₁ᵐ²}ʰc~t?
</code></pre>
<p>Subtract 1 from the removed rows, and join ((contained only 2s, now only 1s), (rest)) back together. This should be equal to the second input matrix.</p>
<pre><code> &amp;h{{∧2}ᵐ}ʰ↺₁;O↰₃c∋3
</code></pre>
<p>If we take the input matrix, set the top row to only 2s, rotate it up, and after adding <code>O</code> there should be a 3: then the tetromino wasn't floating.</p>
<pre><code>∧O{{¬=₀&amp;}ˢ\}↰₅
</code></pre>
<p>Trim <code>O</code> so it only contains the tetromino. It would be nice if this could end here. However, <code>O</code> isn't guaranteed to be a tetromino by now and could be some disconnected 1s. So …</p>
<pre><code>{\↔ᵐ|}{↔↔ᵐ|}{l₂ccẹ~ḃ{15|23|30|51|57|60}}|1
</code></pre>
<p>Check all rotations, and if it is a 2 by x matrix, convert to base 2 and check if one of the numbers matches. If nothing matches, it is the I piece.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/211033/">211033</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




