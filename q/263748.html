<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::263748</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>003</td><td>Rust + numbigint or dashu</td><td>230807T000749Z</td><td><a href="https://codegolf.stackexchange.com/questions/263748/compute-convolution-quickly-and-accurately/263803#263803">Bubbler</a></td></tr>
<tr d-ix="1"><td>003</td><td>C++ gcc</td><td>230806T221955Z</td><td><a href="https://codegolf.stackexchange.com/questions/263748/compute-convolution-quickly-and-accurately/263798#263798">dingledo</a></td></tr>
<tr d-ix="2"><td>003</td><td>Python 3</td><td>230805T155641Z</td><td><a href="https://codegolf.stackexchange.com/questions/263748/compute-convolution-quickly-and-accurately/263749#263749">l4m2</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>Rust + <a href="https://github.com/rust-num/num-bigint/tree/master" rel="nofollow noreferrer">num-bigint</a> or <a href="https://github.com/cmpute/dashu/tree/master" rel="nofollow noreferrer">dashu</a>, ~0.3 seconds locally</h1>
<pre class="lang-rust prettyprint-override"><code>use num_bigint::BigUint;
use dashu::integer::UBig;
use std::time::Instant;

fn solve_num(input: &amp;[u64]) -&gt; Vec&lt;u64&gt; {
    let mut num = Vec::with_capacity(input.len() * 2);
    for &amp;x in input {
        num.push(x as u32);
        num.push(0);
    }
    let big = BigUint::from_slice(&amp;num);
    let big2 = &amp;big * &amp;big;
    big2.to_u64_digits()
}

fn solve_dashu(input: &amp;[u64]) -&gt; Vec&lt;u64&gt; {
    let big = UBig::from_words(input);
    big.square().as_words().to_vec()
}

fn main() {
    let input = (
        vec![10_000_000u64; 100_000],
        vec![1; 5]
    ).0;

    let instant = Instant::now();
    let result = solve_num(&amp;input);
    let elapsed = instant.elapsed().as_micros();
    println!(&quot;elapsed: {}.{:06}&quot;, elapsed / 1000000, elapsed % 1000000);
    eprintln!(&quot;{:?}&quot;, result);

    let instant = Instant::now();
    let result = solve_dashu(&amp;input);
    let elapsed = instant.elapsed().as_micros();
    println!(&quot;elapsed: {}.{:06}&quot;, elapsed / 1000000, elapsed % 1000000);
    eprintln!(&quot;{:?}&quot;, result);
}
</code></pre>
<p>Instructions to run:</p>
<ul>
<li>Create a cargo project with <code>cargo new cg263748</code></li>
<li>Add dependencies in <code>Cargo.toml</code>:
<pre><code>[dependencies]
num-bigint = &quot;0.4&quot;
dashu = &quot;0.3&quot;
</code></pre>
</li>
<li>Replace the content of <code>src/main.rs</code> with the source above</li>
<li>Run with <code>cargo run --release 2&gt;/dev/null</code></li>
</ul>
<p>Both num-bigint and dashu seem to use &quot;naive/Karatsuba/Toom-3 combo&quot; for inputs with different sizes. For the largest sizes, the main algorithm used is Toom-3. For an input vector of size <code>10^5</code>, num-bigint takes ~0.31s and dashu takes ~0.27s.</p>
<p>I do have an NTT source code for personal use, but I highly doubt it will be competitive given that a term can go up to <code>10^19</code>, which means I have to either use 128-bit multiplication and division in the main algorithm, or convolve twice using two (or maybe three) different modulos and combine them using Chinese Remainder Theorem.</p>
</div>
<div id="pu1" class="pu"><h1><a href="https://gcc.gnu.org/" rel="nofollow noreferrer">C++ (gcc)</a>, ~0.03s</h1>

<pre class="lang-cpp prettyprint-override"><code>#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;cstdint&gt;
#include &lt;cstdio&gt;
#include &lt;ctime&gt;

struct C {
    double x, y;
    C() : x(0), y(0) {}
    C(double x, double y) : x(x), y(y) {}
    inline C operator+ (const C &amp;c) const { return C(x + c.x, y + c.y); }
    inline C operator- (const C &amp;c) const { return C(x - c.x, y - c.y); }
    inline C operator* (const C &amp;c) const { return C(x * c.x - y * c.y, x * c.y + y * c.x); }
    inline C conj() const { return C(x, -y); }
};

constexpr double PI = acos(-1);
constexpr int SIZE = 100000, B = 32 - __builtin_clz(SIZE * 2 - 1), N = 1 &lt;&lt; B;

C w[N], f0[N], f1[N];
int rev[N];

void init_roots() {
    w[1] = C(1, 0);
    for (int len = 2; len &lt; N; len &lt;&lt;= 1) {
        C wn(cos(PI / len), sin(PI / len));
        for (int i = len; i &lt; len &lt;&lt; 1; i++)
            w[i] = i &amp; 1 ? w[i &gt;&gt; 1] * wn : w[i &gt;&gt; 1];
    }
    for (int i = 0; i &lt; N; i++)
        rev[i] = (rev[i &gt;&gt; 1] | (i &amp; 1) &lt;&lt; B) &gt;&gt; 1;
}

void fft(C *f) {
    for (int i = 0; i &lt; N; i++)
        if (i &lt; rev[i]) std::swap(f[i], f[rev[i]]);
    for (int len = 1; len &lt; N; len &lt;&lt;= 1) {
        for (int i = 0; i &lt; N; i += len &lt;&lt; 1) {
            for (int j = 0; j &lt; len; j++) {
                C u = f[i + j], v = f[i + j + len] * w[j + len];
                f[i + j] = u + v;
                f[i + j + len] = u - v;
            }
        }
    }
}

void convolve(uint64_t *a) {
    init_roots();
    for (int i = 0; i &lt; SIZE; i++)
        f0[i] = C(a[i] &amp; 4095, a[i] &gt;&gt; 12);
    fft(f0);
    for (int i = 0; i &lt;= N &gt;&gt; 1; i++) {
        int j = -i &amp; (N - 1);
        C c0 = (f0[i] + f0[j].conj());
        C c1 = (f0[i] - f0[j].conj()) * C(0, -1);
        f0[i] = c0 * c0 + (c0 * c1) * C(0, 1);
        f0[j] = (c0 * c0).conj() + (c0 * c1).conj() * C(0, 1);
        f1[i] = c1 * c1;
        f1[j] = (c1 * c1).conj();
    }
    fft(f0); fft(f1);
    for (int i = 0; i &lt; SIZE * 2 - 1; i++) {
        int j = -i &amp; (N - 1);
        uint64_t c0 = llround(f0[j].x / (N &lt;&lt; 2));
        uint64_t c1 = llround(f0[j].y / (N &lt;&lt; 2));
        uint64_t c2 = llround(f1[j].x / (N &lt;&lt; 2));
        a[i] = c0 + (c1 &lt;&lt; 13) + (c2 &lt;&lt; 24);
    }
}

uint64_t A[SIZE * 2 - 1];

int main() {
    for (int i = 0; i &lt; SIZE; i++) A[i] = 1e7;
    clock_t start = clock();
    convolve(A);
    clock_t end = clock();
    uint64_t checksum = 0;
    for (int i = 0; i &lt; SIZE * 2 - 1; i++) checksum ^= A[i];
    printf("checksum: %llu\n", checksum);
    printf("cpu time: %.3fs\n", (double) (end - start) / CLOCKS_PER_SEC);
    return 0;
}

</code></pre>
<p><a href="https://tio.run/##lVZtc5pAEP7Or9hJp5lDJeVM2k7FpJMy@ZBpx2Sab7XWIQgJBsGBw2hT/3rt7h0gaIwNM@re3rPP7u3LiTudGneuu1q9CSI3zEYedJ3wLk4CcT8509ZKd@KI@5oiFaMgEluquKYRwcQ707RUJJkrwIYnDfAZxdlt6MG8BQtLKmymQwfmzNRRhd/wtMz1a2guLRRyLpGLEhlEYRB56CGeeokj4qQJzI2jlJweujoo@QkST2RJhMRzaIJ7RCFIYaFbsIPJ2MtkFEzGy0yNvUwNYkKahZQWLVAqilGp5tvsSDNmz7G1wFDBLC1Nk9vefJoUiby@hFNw3DhlBtetyj5WFW4uf1zgNjfpacEXlI/bGNdweJsFoQiioRv@ZhLVANrgWI8eWUC3C1/Qnw2P/d6gBb6pfjj@WBpxJ95MytosDkboLRDDJI5FimdQ7fHY5wOkshlvgamrDvHjBBhZh16Ee21LCl3o5UIXXRf2snPgMWJ0ODzmO4JgfGkQrZc5b407QGbcs1Do5rTAcdVs6iVYBRhQgAEc4nk/0xLOzgCDbqBXbM9SoXwstS0vpvLR2yCn1EhqJqWc9Q/akStd5laXWktb5gn0fcFsaPjF6f/HT@ATZTf3pwMObqeTPjpT5uMaq9VXO4Pns8/3ZX9XDNA8LfNaxddsxspmrGqAAka@gVUVzhCI8eJsjDHm2XqFH7SU5egXC2uLoDBFuwyF2U5EQUc4YxO31OrSsiwMTtQsDmcey/BUH06GAhpOcZBq11s7y0bztVE5HKdADYdDwiGcmJ/et0AuqC/aBR12hW/u5j7FaZV9JOkr6S0qYFDLsZ4cbasyVq5J7anCaFI448GRuoHqML6GGXUYlsVmeKkYVeLiXEjfoC@6vqXIS/wGXBYuB5l6Tl61K1TPmfPcG5fQ2kbOy2sktUHOU6sEvqd@xf34ykSXPSPzHYZJnEUjpvI4xysMDXCI2vqzJnzLZLHPpF014S94cco6NWWWaJSPVd7bEnxSJgsHoXRw3q8mg25/Ov/EwSv5pYtrPQHIIB1z76Pid8PYfUDmVDiJoIhoXVSqnL1zvY72otEmdp2Ee899SLOJdP@aopaGv05lmMp4mqClzw6K3Q68DcPsZ3TQKg30DeQ0A3pjQuTRsZ9KaP4GpAOj0A11XB1rY3@7sr/eDK8vvg9vLuycKf/zN@nvYbX66/qhc5eujCvfScU/" rel="nofollow noreferrer" title="C++ (gcc) – Try It Online">Try it online!</a></p>
<p>Run with <code>-O3</code> or <code>-Ofast</code> enabled for best performance.</p>
<p>Uses a standard floating-point FFT. Each input integer is split into two 12-bit chunks to avoid precision loss. Since the input comprises of only real numbers, we can get away with doing just a single FFT by using <code>a&amp;4095</code> as the real part and <code>a&gt;&gt;12</code> as the imaginary part. Upon converting back we still need two FFTs as the output space is twice as large.</p>
</div>
<div id="pu2" class="pu"><h1><a href="https://docs.python.org/3/" rel="noreferrer">Python 3</a>, 3 seconds</h1>

<pre class="lang-python prettyprint-override"><code>R = &quot;&quot;.join(&quot;%028o&quot;%x for x in A)
B = int(R,8)**2 | (1 &lt;&lt; 599997*28)
t = oct(B)
G = [int(t[3+i*28:31+i*28],8) for i in range(199999)]
</code></pre>
<p><a href="https://tio.run/##XU09C4MwEN3zK46AkKSlJEppLHbQxd1VMpTSj3RIRDJY6H9Pc0JBfcvdu/dxwye8vCtiDRfolRFKImKXKKWHt7eO0Uzm2tNsgocfYQLroOakSQ7rAuv2mguRwxeYgqqCY5lwErnmJCSLvwXWcNJiPdpDX@xsUs@FmqdJ8bnXYu94dc87U1hRchOHESNtLw0n/10t95UgN2xLl3z@sNVXATTodIg/" rel="noreferrer" title="Python 3 – Try It Online">Try it online!</a></p>
<p>Was a golfing solution somewhere else but also mine</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/263748/">263748</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




