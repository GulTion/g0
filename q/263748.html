<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::263748</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>002</td><td>C++ gcc</td><td>230806T221955Z</td><td><a href="https://codegolf.stackexchange.com/questions/263748/compute-convolution-quickly-and-accurately/263798#263798">dingledo</a></td></tr>
<tr d-ix="1"><td>2401</td><td>Julia</td><td>230809T135724Z</td><td><a href="https://codegolf.stackexchange.com/questions/263748/compute-convolution-quickly-and-accurately/263934#263934">Ashlin H</a></td></tr>
<tr d-ix="2"><td>003</td><td>Rust + numbigint or dashu</td><td>230807T000749Z</td><td><a href="https://codegolf.stackexchange.com/questions/263748/compute-convolution-quickly-and-accurately/263803#263803">Bubbler</a></td></tr>
<tr d-ix="3"><td>003</td><td>Python 3</td><td>230805T155641Z</td><td><a href="https://codegolf.stackexchange.com/questions/263748/compute-convolution-quickly-and-accurately/263749#263749">l4m2</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://gcc.gnu.org/" rel="nofollow noreferrer">C++ (gcc)</a>, ~0.02s</h1>

<pre class="lang-cpp prettyprint-override"><code>#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;cstdint&gt;
#include &lt;cstdio&gt;
#include &lt;ctime&gt;

struct C {
    double x, y;
    C() : x(0), y(0) {}
    C(double x, double y) : x(x), y(y) {}
    inline C operator+ (const C &amp;c) const { return C(x + c.x, y + c.y); }
    inline C operator- (const C &amp;c) const { return C(x - c.x, y - c.y); }
    inline C operator* (const C &amp;c) const { return C(x * c.x - y * c.y, x * c.y + y * c.x); }
    inline C conj() const { return C(x, -y); }
};

constexpr double PI = acos(-1);
constexpr int SIZE = 100000, B = 32 - __builtin_clz(SIZE * 2 - 1), N = 1 &lt;&lt; B;

C w[N], f0[N], f1[N];
int rev[N];

void init_roots() {
    w[0] = C(1, 0);
    for (int len = 1; len &lt; N; len &lt;&lt;= 1) {
        C wn(cos(PI / (len &lt;&lt; 2)), sin(PI / (len &lt;&lt; 2)));
        for (int i = len; i &lt; len &lt;&lt; 1; i++)
            w[i] = w[i - len] * wn;
    }
}

void fft(C *f) {
    for (int len = N &gt;&gt; 2; len; len &gt;&gt;= 2) {
        for (int i = 0, m = 0; i &lt; N; i += len &lt;&lt; 2, m++) {
            C w1 = w[m], w2 = w1 * w1, w3 = w1 * w2;
            for (int j = i; j &lt; i + len; j++) {
                C c0 = f[j + len * 0], c1 = f[j + len * 1] * w1,
                  c2 = f[j + len * 2] * w2, c3 = f[j + len * 3] * w3;
                C a02 = c0 + c2, a13 = c1 + c3,
                  s02 = c0 - c2, s13 = (c1 - c3) * C(0, 1);
                f[j + len * 0] = a02 + a13, f[j + len * 1] = a02 - a13;
                f[j + len * 2] = s02 + s13, f[j + len * 3] = s02 - s13;
            }
        }
    }
}

void ifft(C *f) {
    for (int len = 1; len &lt; N; len &lt;&lt;= 2) {
        for (int i = 0, m = 0; i &lt; N; i += len &lt;&lt; 2, m++) {
            C w1 = w[m], w2 = w1 * w1, w3 = w1 * w2;
            for (int j = i; j &lt; i + len; j++) {
                C c0 = f[j + len * 0], c1 = f[j + len * 1],
                  c2 = f[j + len * 2], c3 = f[j + len * 3];
                C a02 = c0 + c1, a13 = c2 + c3,
                  s02 = c0 - c1, s13 = (c2 - c3) * C(0, 1);
                f[j + len * 0] = a02 + a13, f[j + len * 2] = (a02 - a13) * w2;
                f[j + len * 1] = (s02 + s13) * w1, f[j + len * 3] = (s02 - s13) * w3;
            }
        }
    }
}

void convolve(uint64_t *a) {
    init_roots();
    for (int i = 0; i &lt; SIZE; i++)
        f0[i] = C(a[i] &amp; 4095, a[i] &gt;&gt; 12);
    fft(f0);

    f1[0] = C(4 * f0[0].y * f0[0].y, 0);
    f1[1] = C(4 * f0[1].y * f0[1].y, 0);
    f0[0] = C(4 * f0[0].x * f0[0].x, 4 * f0[0].x * f0[0].y);
    f0[1] = C(4 * f0[1].x * f0[1].x, 4 * f0[1].x * f0[1].y);

    for (int i = 2, msk = 0; i &lt; N; i += 2) {
        msk |= i &gt;&gt; 1;
        int j = i ^ msk;
        C c0 = f0[i] + f0[j].conj();
        C c1 = (f0[i] - f0[j].conj()) * C(0, -1);
        C c00 = c0 * c0, c01 = c0 * c1, c11 = c1 * c1;
        f0[i] = c00.conj() + c01.conj() * C(0, 1), f0[j] = c00 + c01 * C(0, 1);
        f1[i] = c11.conj(), f1[j] = c11;
    }

    ifft(f0); ifft(f1);
    for (int i = 0; i &lt; SIZE * 2 - 1; i++) {
        uint64_t c0 = llround(f0[i].x / (N &lt;&lt; 2));
        uint64_t c1 = llround(f0[i].y / (N &lt;&lt; 2));
        uint64_t c2 = llround(f1[i].x / (N &lt;&lt; 2));
        a[i] = c0 + (c1 &lt;&lt; 13) + (c2 &lt;&lt; 24);
    }
}

uint64_t A[SIZE * 2 - 1];

int main() {
    for (int i = 1; i &lt; SIZE; i++) A[i] = 1e7;
    clock_t start = clock();
    convolve(A);
    clock_t end = clock();
    uint64_t checksum = 0;
    for (int i = 0; i &lt; SIZE * 2 - 1; i++) checksum ^= A[i];
    printf("checksum: %llu\n", checksum);
    printf("cpu time: %.3fs\n", (double) (end - start) / CLOCKS_PER_SEC);
    return 0;
}

</code></pre>
<p><a href="https://tio.run/##3VdLb9tGEL7zVwxSNFhKpMsl3RYNZQGJ4EOQQgnqW1VFYCjSpkyRAh@WWNd/ve7MLt9krBToqT54Z2e/@WZ2doa7cg8H/dZ1n5@/CyI3zLcezJzwNk6C7G4/Vxqlu3eyu44izbZBlA1UcUeTBXtvrihpluRuBgt4VAD/tnH@JfTgpEFhC8WCqfAGTsxQUYX/4fGp1DfQUiok8iSQRY0MojCIPPQQH7zEyeJkCsyNo5ScvnZVkPIjJF6WJxESn2AK7gWFIIRCteErTPpZJr1i0l9mmpxlmhAT0hRCKjSQKopRqk5DdqTZsTE2DXQZzJOtKGLZOx2SKpGf3sMVOG6cMp2rdmsdTxVu3v9@jcvcoD8N3qFsmRjXZvMlD8IsiDZu@CcTqAnQAsfzWJIFzGbwDv0t4LharjXwDTlwHGyFuBPvQcjKQxxs0VuQbZI4zlLcgyyP48pYI9WCcQ0MVVaIHyfAyDr0InJjC2EGy1KYoa6yF5UDx4jR5nCbPwCTGDBVDDMNooG29NLxFKAfRNgozEon5DeYTtUaLMMNKFwcMA@IW2NKjpEkxNyX@/T9jC1g4ldB9ja0hPkcTFs6JNV8foWBtXbUiQvPZE@DDG5Jw/SqCtLERQyyZVtmhIsw93gcR5NETpFiko9WPTPtjlHtdIeIwMZhRq5kmLuhE@nINRDtr3YSiLQGunR5T8nX0v2AAMA1e1hTYHFjrtVbscSKZY@E4RhEg8Fgg6Opw8kWw8CpNeY1rfC6wKcCz9AA55aKbhYM887Voa/uXqmvkGpKHrX@luWaTmsv85iETQVP2uexqjWd1ro8T0pXakowOFODY031fy/Bb6y@0cI7V3O8rjnzm2qONzVn/nc1J@qI1UWnjqS4TyfKlNW1p5ZnNKhAVpegOtKEXy9EvGse4vDBYzme60@XmwwmTnWM7fug9@kPmnKjm6f3KcaLJpDXhkPCa7g0fvkRT4Am@G3lZkWHTeDTtSJnvLpsLnELyGGsL4pGal1AfMU7QF4DeRdoDBlPjaTBmLpojAdeTo1UG3fURb2ZdqaoBdP7YYd2OpoQf2FbiQw1x1e3G3wmiK30G0vkekrjbn0hHyAdEDUakyi9g6pLWuddC8OQfYCPHFx1DV5POTUul59umtqDI0fjkp76zODVpO4eTcYgoRIz1lp4xpKPVxTi4bIrddWVLuu0qqNS4meqtXonyaptHUHdAyKzYZjEebSVucMzxlfKsnyj2CMmfGBSnDMx2yb8BS9OlVyYiluQnj@WKiamAF@qrUdO7eDtqr1deudRNvYOvroG904gb51uRyODcMy9nyW/G8buPTKnmZNkFBHNq4KrvyVv1S7ai7Z9bJOEO8@9T3N5f/2bY6sNP1@JMKXxIUFLn72qVt/A92GY/xG90moDtYc85EC/jRB5YfmpgJa/dVRgFLout6vi2Sx@/bj4cLP5dP3b5uZ6UTKVz3wM/0l5fv7b9UPnNn3WP/pOmv0D" rel="nofollow noreferrer" title="C++ (gcc) – Try It Online">Try it online!</a></p>
<p>Run with <code>-O3</code> or <code>-Ofast</code> enabled for best performance.</p>
<p>Uses a standard floating-point radix-4 FFT. Each input integer is split into two 12-bit chunks to avoid precision loss. Since the input comprises of only real numbers, we can get away with doing just a single FFT by using <code>a&amp;4095</code> as the real part and <code>a&gt;&gt;12</code> as the imaginary part. Upon converting back we still need two FFTs as the output space is twice as large.</p>
<p><strong>Update:</strong></p>
<ul>
<li>I realized that the bit reversal was unusually time consuming, so I got rid of it using a DIF-DIT scheme. DIF takes the input in normal order and outputs in bit-reversed order, while DIT takes a bit-reversed input and outputs in normal order. Thus, they magically cancel out :)</li>
</ul>
</div>
<div id="pu1" class="pu"><h1>Julia, 2.4 ± 0.1 ms</h1>
<pre><code>using DSP
using BenchmarkTools

A = rand(1:10^7, 10^5)

@btime conv(A,A)
</code></pre>
<p>Local system information:</p>
<pre><code>julia&gt; versioninfo()
Julia Version 1.9.2
Commit e4ee485e909 (2023-07-05 09:39 UTC)
Platform Info:
  OS: macOS (arm64-apple-darwin22.4.0)
  CPU: 12 × Apple M2 Max
  WORD_SIZE: 64
  LIBM: libopenlibm
  LLVM: libLLVM-14.0.6 (ORCJIT, apple-m1)
  Threads: 1 on 8 virtual cores
</code></pre>
</div>
<div id="pu2" class="pu"><h1>Rust + <a href="https://github.com/rust-num/num-bigint/tree/master" rel="nofollow noreferrer">num-bigint</a> or <a href="https://github.com/cmpute/dashu/tree/master" rel="nofollow noreferrer">dashu</a>, ~0.3 seconds locally</h1>
<pre class="lang-rust prettyprint-override"><code>use num_bigint::BigUint;
use dashu::integer::UBig;
use std::time::Instant;

fn solve_num(input: &amp;[u64]) -&gt; (Vec&lt;u64&gt;, u128) {
    let mut num = Vec::with_capacity(input.len() * 2);
    for &amp;x in input {
        num.push(x as u32);
        num.push(0);
    }
    let big = BigUint::from_slice(&amp;num);
    let instant = Instant::now();
    let big2 = &amp;big * &amp;big;
    let elapsed = instant.elapsed().as_micros();
    (big2.to_u64_digits(), elapsed)
}

fn solve_dashu(input: &amp;[u64]) -&gt; (Vec&lt;u64&gt;, u128) {
    let big = UBig::from_words(input);
    let instant = Instant::now();
    let square = big.square();
    let elapsed = instant.elapsed().as_micros();
    (square.as_words().to_vec(), elapsed)
}

fn main() {
    let input = (
        vec![10_000_000u64; 100_000],
        vec![1; 5]
    ).0;

    let (result, elapsed) = solve_num(&amp;input);
    println!(&quot;elapsed: {}.{:06}&quot;, elapsed / 1000000, elapsed % 1000000);
    eprintln!(&quot;{:?}&quot;, result);

    let (result, elapsed) = solve_dashu(&amp;input);
    println!(&quot;elapsed: {}.{:06}&quot;, elapsed / 1000000, elapsed % 1000000);
    eprintln!(&quot;{:?}&quot;, result);
}
</code></pre>
<p>Instructions to run:</p>
<ul>
<li>Create a cargo project with <code>cargo new cg263748</code></li>
<li>Add dependencies in <code>Cargo.toml</code>:
<pre><code>[dependencies]
num-bigint = &quot;0.4&quot;
dashu = &quot;0.3&quot;
</code></pre>
</li>
<li>Replace the content of <code>src/main.rs</code> with the source above</li>
<li>Run with <code>cargo run --release 2&gt;/dev/null</code></li>
</ul>
<p>Both num-bigint and dashu seem to use &quot;naive/Karatsuba/Toom-3 combo&quot; for inputs with different sizes. For the largest sizes, the main algorithm used is Toom-3. For an input vector of size <code>10^5</code>, num-bigint takes ~0.31s and dashu takes ~0.27s.</p>
<hr />
<p>I do have an NTT source code for personal use, but I highly doubt it will be competitive given that a term can go up to <code>10^19</code>, which means I have to either use 128-bit multiplication and division in the main algorithm, or convolve twice using two (or maybe three) different modulos and combine them using Chinese Remainder Theorem.</p>
<p>EDIT: Apparently it is possible to do a single NTT with a prime very close to 2^64, using one of the algorithms described <a href="https://www.sciencedirect.com/science/article/pii/S0747717113001181" rel="nofollow noreferrer">in this paper</a>. e.g. one could choose <code>p = 10485760000033554433</code>, where <code>5</code> is a primitive root. Unfortunately the faster ones won't work because the prime must be under 2^63 for them.</p>
<p>EDIT 2: I'm working on the NTT implementation on the paper. I realized I need to do elementwise <code>a * b % P</code> anyway, so I came up with a &quot;u128 division&quot;-less algorithm (<a href="https://godbolt.org/z/snafEn73z" rel="nofollow noreferrer">godbolt</a>) for a specific P = <code>71 * 2^57 + 1</code> = <code>10232178353385766913</code>. This is three times as fast as naive <code>(a as u128 * b as u128 % P as u128) as u64</code>:</p>
<pre><code>slow mulmod             time:   [21.182 ns 21.185 ns 21.188 ns]
fast mulmod             time:   [7.0764 ns 7.1222 ns 7.1864 ns]
</code></pre>
</div>
<div id="pu3" class="pu"><h1><a href="https://docs.python.org/3/" rel="noreferrer">Python 3</a>, 3 seconds</h1>

<pre class="lang-python prettyprint-override"><code>R = &quot;&quot;.join(&quot;%028o&quot;%x for x in A)
B = int(R,8)**2 | (1 &lt;&lt; 599997*28)
t = oct(B)
G = [int(t[3+i*28:31+i*28],8) for i in range(199999)]
</code></pre>
<p><a href="https://tio.run/##XU09C4MwEN3zK46AkKSlJEppLHbQxd1VMpTSj3RIRDJY6H9Pc0JBfcvdu/dxwye8vCtiDRfolRFKImKXKKWHt7eO0Uzm2tNsgocfYQLroOakSQ7rAuv2mguRwxeYgqqCY5lwErnmJCSLvwXWcNJiPdpDX@xsUs@FmqdJ8bnXYu94dc87U1hRchOHESNtLw0n/10t95UgN2xLl3z@sNVXATTodIg/" rel="noreferrer" title="Python 3 – Try It Online">Try it online!</a></p>
<p>Was a golfing solution somewhere else but also mine</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/263748/">263748</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




