<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::70280</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>560</td><td>Python3</td><td>240625T232500Z</td><td><a href="https://codegolf.stackexchange.com/questions/70280/a-peak-experience-quickly-visit-all-the-peaks/273811#273811">Ajax1234</a></td></tr>
<tr d-ix="1"><td>092</td><td>Pyth</td><td>160712T095407Z</td><td><a href="https://codegolf.stackexchange.com/questions/70280/a-peak-experience-quickly-visit-all-the-peaks/85224#85224">Anders K</a></td></tr>
<tr d-ix="2"><td>681</td><td>Mathematica</td><td>160710T200508Z</td><td><a href="https://codegolf.stackexchange.com/questions/70280/a-peak-experience-quickly-visit-all-the-peaks/85072#85072">DavidC</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>Python3, 560 bytes</h1>
<pre class="lang-py prettyprint-override"><code>E=enumerate
M=[(0,1),(0,-1),(1,0),(-1,0)]
def f(b):
 d={(x,y):v for x,r in E(b)for y,v in E(r)}
 p=[(x,y)for x,y in d if all(d.get((x+X,y+Y),0)&lt;d[(x,y)]for X,Y in M)]
 q,s=[(0,0,{},[],0)],[]
 for x,y,D,P,t in q:
  if(x,y)==(0,0)and all(i in P for i in p):s+=[t];continue
  elif(x,y)==(0,0)and P:continue
  if s and t&gt;=min(s):continue
  for X,Y in M:
   v=(x+X,y+Y)
   if v in d and v not in(U:=D.get((x,y),[])):
    J,K=d[v],d[(x,y)]
    if abs(J-K)&lt;2:
     if J==K:T=3
     elif J&gt;K:T=11
     else:T=2
     q+=[(*v,{**D,(x,y):U+[v]},P+[v],t+T)]
 return min(s)
</code></pre>
<p><a href="https://tio.run/##bVLBbptAED13v2LlS3btcWTADi7N5uRcbKXyIZESUVThsrRIeMGwRkaWv92dAae1lFx2mTdv5r2ZpWztn8J487I6nx@VNvutrmKr2ZMKxQQcCXiO6XJggueYroglOuWp2MiA8UQdxQFaGTQ8LSp@gIpnhj9iksIWmj6s5InxEpsStye2lEl4lvI4z0Vy@1tbIQ6jV2hHbxJl7pOeHRH9Fd6I/oTifAd1524CxxOEETnCi130W1jAGiyxd@gP@3ddlKIKGZukk8sov@5Kus9SBvVIhTb69qswNjN7jaU6/1i8Dq4I6L3mhNoHtc2MqOV19to3OeGN@jcfhVjd9DugFg03BbkWL4FaXJaB0jiZlF01X8JKJWETwftiOpT2t6nFcryS925PJGyp1Cp4Vl4P0CR8@UCI47xDtcbQ7aMdDi@GDRyHwwX0D/oyQq0TrOkCO3omvUrbfWV4P@u5drjig8GAee50OmOeN/WmzHWcmcccFwNGudq9kO78ue/7czbD887/2iW7P8kWPzdFXCW0PvblIhGGw21cisxY4Fn/D3QPlWa51ZX4XhgNvL6tyzyz4uaHuZHoj5UVFohU/G/pSCk/gV2Ez38B" rel="nofollow noreferrer">Try it online!</a></p>
</div>
<div id="pu1" class="pu"><h1>Pyth, 92 bytes</h1>

<pre><code>hSms@Lu.dm,bhS,@Gb+@G,hbH@G,HebG[FQ.dm,(Fb?|tsaMCb&gt;.aJ-F@LQb1.n4@[3hT2)J*QQC.&lt;B+]hSQd1.p.M@Q
</code></pre>

<p>The input format is a dict mapping coordinates to heights: <code>{(0, 0): 3, (0, 1): 2, (0, 2): 4, …}</code>.  This finds the fastest paths between all pairs of points using the <a href="https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm" rel="nofollow">Floyd–Warshall algorithm</a>, then minimizes the total time of the desired cycle over all permutations of peaks.</p>

<p><a href="https://pyth.herokuapp.com/?code=hSms%40Lu.dm%2CbhS%2C%40Gb%2B%40G%2ChbH%40G%2CHebG%5BFQ.dm%2C%28Fb%3F%7CtsaMCb%3E.aJ-F%40LQb1.n4%40%5B3hT2%29J%2aQQC.%3CB%2B%5DhSQd1.p.M%40Q&amp;test_suite=1&amp;test_suite_input=%7B%280%2C0%29%3A3%2C%280%2C1%29%3A2%2C%280%2C2%29%3A4%2C%280%2C3%29%3A4%2C%280%2C4%29%3A5%2C%281%2C0%29%3A3%2C%281%2C1%29%3A3%2C%281%2C2%29%3A4%2C%281%2C3%29%3A3%2C%281%2C4%29%3A4%2C%282%2C0%29%3A2%2C%282%2C1%29%3A1%2C%282%2C2%29%3A1%2C%282%2C3%29%3A5%2C%282%2C4%29%3A3%2C%283%2C0%29%3A1%2C%283%2C1%29%3A2%2C%283%2C2%29%3A3%2C%283%2C3%29%3A4%2C%283%2C4%29%3A3%7D%0A%7B%280%2C0%29%3A6%2C%280%2C1%29%3A7%2C%280%2C2%29%3A8%2C%280%2C3%29%3A7%2C%280%2C4%29%3A7%2C%280%2C5%29%3A7%2C%280%2C6%29%3A8%2C%281%2C0%29%3A5%2C%281%2C1%29%3A7%2C%281%2C2%29%3A7%2C%281%2C3%29%3A7%2C%281%2C4%29%3A6%2C%281%2C5%29%3A7%2C%281%2C6%29%3A9%7D" rel="nofollow">Try it online</a></p>
</div>
<div id="pu2" class="pu"><h1>Mathematica <s>745</s> 681 bytes</h1>

<p>The basic idea is to make a weighted graph of possible moves. Weights are the time it takes to move from one place to the next.  The path with the least weight will be the quickest. </p>

<p>The input digits are placed in an r by c (rows by columns) rectangular array and then three distinct representations come into play: (1) an r by c grid graph, where each vertex corresponds to a cell in the array, (2) (r<em>c) by (r</em>c) weighted adjacency matrix that holds weights corresponding to the time it takes (2, 3, or 11 minutes) to move from one location (in the grid graph) to another, and (3) a directed, weighted adjacency graph constructed from the matrix.</p>

<p>The grid graph helps determine which cells (i.e. which vertices) are possibly reachable from each vertex--"possibly reachable" because a neighboring cell must not only be right, left, above or below a given cell.  It's value must also be within 1 unit of distance from the neighbor (e.g., a 3 does not connect to a  neighboring 5 or a 1).  If vertex <code>a</code> is not connected to vertex <code>b</code> then the adjacency matrix cells {a,b} and {b,a} will have a value of ∞.  Accordingly, the weighted adjacency graph will not have an edge from a to b, nor from b to a.</p>

<p>The weighted adjacency graph serves to determine the minimum distance (<code>GraphDistance</code>) and shortest route between any vertices.  The optimal path must begin with 1, touch each of the peaks, and return to 1.  In this case, "shortest route" is not necessarily the one with the fewest moves.  It is the one with the shortest overall time, measured in edge weights.</p>

<hr>

<h2>Golfed</h2>

<pre><code>o=Sequence;v[a_&lt;-&gt;b_,z_]:=(m_~u~q_:={Quotient[m-1,q[[2]]]+1,1+Mod[m-1, q[[2]]]};j=z[[o@@u[a,i=Dimensions@z]]];k=z[[o@@u[b,i]]];Which[j==k,{{a,b}-&gt;3,{b,a}-&gt;3},j==k-1,{{a,b}-&gt;11,{b,a}-&gt;2},j==k+1,{{a,b}-&gt;2,{b,a}-&gt;11},2&lt;4,{{a,b}-&gt;∞, {b, a}-&gt;∞}]);w@e_:=Module[{d,x,l,y},x=Map[ToExpression,Characters/@Drop[StringSplit@e,2],{2}];d_~l~c_:=d[[2]](c[[1]]-1)+c[[2]];g_~y~p_:=(Min[Plus@@(GraphDistance[g,#,#2]&amp;@@@#)&amp;/@(Partition[#,2,1]&amp;/@({1,o@@#,1}&amp;/@Permutations@p))]);y[WeightedAdjacencyGraph[ReplacePart[ConstantArray[∞,{t=Times@@(d=Dimensions@x),t}],Flatten[#~v~x &amp;/@Union@Flatten[EdgeList[GridGraph@Reverse@d,#&lt;-&gt;_]&amp;/@Range@(Times@@d),1],1]]], l[Dimensions@x, #] &amp; /@ Position[x, Max@x]]
</code></pre>

<hr>

<h2>Longer, more readable form</h2>

<pre><code>(*determines a weight (number of minutes) to go from vertex a to b and from b to a*)
weight[a_ &lt;-&gt; b_, dat_]:= 
  Module[{cellA,cellB,dim,valA,valB,vertexToCell},

  (*Convert graph vertex index to cell location*)
  vertexToCell[m_,dimen_]:={Quotient[m-1,dim[[2]]]+1,1+Mod[m-1,dimen[[2]]]};
     dim=Dimensions[dat];
     cellA = vertexToCell[a,dim];
     cellB = vertexToCell[b,dim];
     valA=dat[[Sequence@@cellA]];
     valB=dat[[Sequence@@cellB]];
     Which[
       valA==valB,{{a,b}-&gt; 3,{b,a}-&gt; 3},
       valA==valB-1,{{a,b}-&gt; 11,{b,a}-&gt; 2},
       valA==valB+1,{{a,b}-&gt; 2,{b,a}-&gt; 11},
       2&lt;4,{{a,b}-&gt;∞,{b,a}-&gt;∞}]];

(* weights[] determines the edge weights (times to get from one position to the next), makes a graph and infers the shortest distance 
from vertex 1 to each peak and back.  It tries out all permutations of peaks and 
selects the shortest one. Finally, it returns the length (in minutes) of the shortest trip. *)

weights[str_]:=
  Module[{d,dat,neighbors,cellToVertex,peaks,z,gd},
  dat=Map[ToExpression,Characters/@Drop[StringSplit[str],2],{2}];
  cellToVertex[dim_,cell_]:=dim[[2]] (cell[[1]]-1)+cell[[2]];
  peaks[dat_]:= cellToVertex[Dimensions[dat],#]&amp;/@Position[dat,peak =Max[dat]];

     (* to which cells should each cell be compared? neighbors[] is a function defined within weights[]. It returns a graph, g, from which graph distances will be derived in the function gd[] *)
  neighbors[dim_]:=
  Union@Flatten[EdgeList[GridGraph[Reverse@dim],#&lt;-&gt;_]&amp;/@Range@(Times@@dim),1];
    d=Dimensions[dat];
    m=ReplacePart[ConstantArray[∞,{t=Times@@d,t}], 
     (*substitutions=*)
    Flatten[weight[#,dat]&amp;/@neighbors[d],1]];
    g=WeightedAdjacencyGraph[m,VertexLabels-&gt;"Name",ImageSize-&gt;Full,GraphLayout-&gt;"SpringEmbedding"];

    (* finds shortest path.  gd[] is also defined within weights[] *)
  gd[g3_,ps_]:=
    Module[{lists,pairs},
    pairs=Partition[#,2,1]&amp;/@({1,Sequence@@#,1}&amp;/@Permutations@ps);
    Min[Plus@@(GraphDistance[g3,#,#2]&amp;@@@#)&amp;/@pairs]]; 

  gd[g,peaks[dat]]]
</code></pre>

<hr>

<h2>Tests</h2>

<pre><code>weights["4 5
 32445
 33434
 21153
 12343"]
</code></pre>

<p>96.</p>

<hr>

<pre><code>weights@"2 7
 6787778
 5777679"
</code></pre>

<p>75.</p>

<hr>

<pre><code>weights@"3 4
 1132
 2221
 1230"
</code></pre>

<p>51.</p>

<hr>

<h2>Explanation</h2>

<p>Think of lines 2-5 of the  following input </p>

<pre><code>"4 5
 32445
 33434
 21153
 12343"
</code></pre>

<p>as representing an array with 4 rows and 5 columns:</p>

<p><a href="https://i.sstatic.net/TgFyk.png" rel="nofollow noreferrer"><img src="https://i.sstatic.net/TgFyk.png" alt="gridgraph"></a></p>

<p>where each vertex corresponds to a digit from the input array: 3 is at vertex 1, 2 is at vertex 2, 4 is at vertex 3, another 4 at vertex 4, 5 at vertex 5, etc. The grid graph is only a rough approximation of the graph we are aiming for. It is undirected. Furthermore, some of the edges will be unavailable. (Remember: we cannot move from a position to another that is more than 1 height unit above or below the current one.)  But the grid graph let's us easily find those vertices that are next to any chosen vertex.  This reduces the number of edges we need to consider, in the first example (a 4 by 5 grid), from 400 (20 * 20) to 62 (31 *2 is the number of edges in the grid graph).  In the same example, only 48 of the edges are operative;  14 are not.</p>

<p>The following 20 by 20 weighted adjacency matrix represents the distance between all pairs of vertices from the grid graph.</p>

<p>The key code which decides on which number to assign is below.</p>

<pre><code>Which[
      valA==valB,{{a,b}-&gt; 3,{b,a}-&gt; 3},
      valA==valB-1,{{a,b}-&gt; 11,{b,a}-&gt; 2},
      valA==valB+1,{{a,b}-&gt; 2,{b,a}-&gt; 11},
      2&lt;4,{{a,b}-&gt;∞,{b,a}-&gt;∞}]
</code></pre>

<p>Cell {1,2}--in one-indexing-- contains the value 2 because the move from vertex 1 to vertex 2 is downhill.
Cell {2,1} contains 11 because the move from vertex 2 to vertex 1 is uphill.
The 3's in cells {1,6} and {6,1} signify that the movement is neither up nor down.
Cell {1,1} contains ∞ because it is not connected to itself.</p>

<p><a href="https://i.sstatic.net/ftNYH.png" rel="nofollow noreferrer"><img src="https://i.sstatic.net/ftNYH.png" alt="weights"></a></p>

<p>The following graph shows the structure underlying the above input.  The colored arrows show the optimal path from vertex 1 to the peaks (at 5 and 14) and back to 1.  Blue arrows correspond to moves at the same level (3 min); red arrows mean ascent (11 min.) and green arrows indicate descent (2 min). </p>

<p><a href="https://i.sstatic.net/pqnk0.png" rel="nofollow noreferrer"><img src="https://i.sstatic.net/pqnk0.png" alt="graph2"></a></p>

<p>The path from vertex 1 (cell {1,1} to the two peaks and back to vertex 1:</p>

<pre><code>3 + 3 + 11 + 3 + 3 + 11 + 2 + 2 + 3 + 11 + 11 + 2 + 2 + 2 + 2 + 11 + 11 + 3
</code></pre>

<p>96</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/70280/">70280</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




