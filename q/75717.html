<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::75717</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>030</td><td>vemf</td><td>240610T211201Z</td><td><a href="https://codegolf.stackexchange.com/questions/75717/roman-numeral-line-segments/273602#273602">taswelll</a></td></tr>
<tr d-ix="1"><td>062</td><td>R</td><td>240608T070703Z</td><td><a href="https://codegolf.stackexchange.com/questions/75717/roman-numeral-line-segments/273524#273524">int 21h </a></td></tr>
<tr d-ix="2"><td>079</td><td>JavaScript ES6</td><td>160412T100041Z</td><td><a href="https://codegolf.stackexchange.com/questions/75717/roman-numeral-line-segments/77668#77668">Neil</a></td></tr>
<tr d-ix="3"><td>095</td><td>Python 3</td><td>160320T003352Z</td><td><a href="https://codegolf.stackexchange.com/questions/75717/roman-numeral-line-segments/75836#75836">lynn</a></td></tr>
<tr d-ix="4"><td>070</td><td>Pyth</td><td>160317T211734Z</td><td><a href="https://codegolf.stackexchange.com/questions/75717/roman-numeral-line-segments/75725#75725">Denker</a></td></tr>
<tr d-ix="5"><td>129</td><td>C</td><td>160318T170446Z</td><td><a href="https://codegolf.stackexchange.com/questions/75717/roman-numeral-line-segments/75777#75777">STDQ</a></td></tr>
<tr d-ix="6"><td>152</td><td>Java</td><td>160318T174710Z</td><td><a href="https://codegolf.stackexchange.com/questions/75717/roman-numeral-line-segments/75778#75778">CAD97</a></td></tr>
<tr d-ix="7"><td>128</td><td>Retina</td><td>160317T214348Z</td><td><a href="https://codegolf.stackexchange.com/questions/75717/roman-numeral-line-segments/75728#75728">daavko</a></td></tr>
<tr d-ix="8"><td>072</td><td>Mathematica</td><td>160317T210837Z</td><td><a href="https://codegolf.stackexchange.com/questions/75717/roman-numeral-line-segments/75723#75723">LegionMa</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://github.com/selaere/vemf" rel="nofollow noreferrer">vemf</a>, 30 bytes</h1>
<pre><code>éΦ╒¡(4↕;æ1╘*1214╛+╞405‼╕,335)+
</code></pre>
<p>Function that takes an integer.</p>
<p>The goal of the big parenthesis is to generate the table digit-&gt;segment. For every position, there are three symbols that we need to account for. We are going to try to generate the digits 0-8, and leave 9 until the end.</p>
<p>Notice the amount of &quot;I&quot;s:</p>
<pre><code>   _ I II III IV V VI VII VIII
=&gt; 0 1 2  3   1  0 1  2   3
</code></pre>
<p>which is <code>0 1 2 3</code>, or <code>4↕</code>, joined to itself <code>;</code> with a one <code>1</code>. This pattern follows with M, C, V, I with <code>4 1 2 1</code> segments respectively. We only need the first 4 elements for M, but we will keep them there.</p>
<pre><code>    )9 4↕;æ1╘*1214
((0 1 2  3 1 0 1 2  3)
 (0 2 4  6 2 0 2 4  6)
 (0 1 2  3 1 0 1 2  3)
 (0 4 8 12 4 0 4 8 12))
</code></pre>
<p>Accounting for V, L, D is easy because all of them have 2 segments:</p>
<pre><code>   _ I II III IV V VI VII VIII
=&gt; 0 0 0  0   2  2 2  2   2
</code></pre>
<p>Easy! Just add <code>405‼</code>. Or <code>45‼¼</code> or even doing it like <code>╒+├≥4¼</code> works. (That Each Trim should probably not be necessary, but whatever.)</p>
<p>For the 9s places I had a very nice solution at first where the next digit would add to the earlier list with some fill magic but it turns out that just adding the segment counts for IX, XC and CM manually is much easier. The null at the end is outside of the domain of the problem.</p>
<pre><code>    )9 4↕;æ1╘*1214╛+╞405‼╕,335
((0 1 2  3 3 2 3  4  5 3)
 (0 2 4  6 4 2 4  6  8 3)
 (0 1 2  3 3 2 3  4  5 5)
 (0 4 8 12 6 2 6 10 14 ■))
</code></pre>
<p>The reason we found this table in reverse order is because <code>éΦ</code> conveniently returns the elements in little-endian order, so the digits are in the right place no matter how many digits the number has. this means that we can just each index to get the results (<code>╕¡</code> happens to work as well because of fill, but <code>╒¡</code> does less work. also I kind of like that I managed to fit all the <code>╒╕╘╛</code> glyphs once). The <code>+</code> at the end sums the digits.</p>
<p><a href="https://selaere.github.io/vemf/wasm/index.html?code=OjEyMzQggujVrSg0EjuRMdQqMTIxNL4rxjQwNRO4LDMzNSkr" rel="nofollow noreferrer">Try it online</a></p>
</div>
<div id="pu1" class="pu"><h1><a href="https://www.r-project.org" rel="nofollow noreferrer">R</a>, 62 bytes</h1>
<pre class="lang-r prettyprint-override"><code>\(x)sum(utf8ToInt(chartr(&quot;MXVDLIC&quot;,&quot;4222211&quot;,as.roman(x)))-48)
</code></pre>
<p><a href="https://ato.pxeger.com/run?1=m72waMGiNNulpSVpuhY37WI0KjSLS3M1gFyLkHzPvBKN5IzEopIiDSXfiDAXH09nJR0lEyMgMDRU0kks1ivKz03MA-rR1NQ1sdCEmqKfpmFoZGyiyVWekZmcoZebWKHhm1igkaZjaGVsaWmpqckF12lsYQHTtmABhAYA" rel="nofollow noreferrer">Attempt This Online!</a></p>
<p>This is code-golf, and here is the shortest answer (as for today).</p>
<p>A function which inputs a number and outputs the total number of segments.</p>
<p>This solution is based on the builtin function <code>as.roman</code>, the roman digits are replaced with the respective number of the lines and the total sum of lines is output.</p>
<p>The number with the most lines (30) is <code>MMMDCCCLXXXVIII</code> or <code>3888</code>.</p>
</div>
<div id="pu2" class="pu"><h2>JavaScript (ES6), 79 bytes</h2>

<pre><code>n=&gt;"0123323453"[[,a,b,c,d]=1e4+n+'',d]-(-"0246424683"[c]-"0123323455"[b])+a*4
</code></pre>

<p>The strings represent the number of line segments for the units, tens and hundreds digits. (Thousands is simply four times the thousands digit.) This method seems to be shorter than other options such as the algorithm suggested in the question.</p>

<p>Edit: Saved 2 bytes thanks to @user81655.</p>
</div>
<div id="pu3" class="pu"><h1>Python 3, 95 bytes</h1>

<pre><code>def f(a,b=0):
 for e in'᝴ᔝ஺ॣəȟĮô&gt;9 ':e=ord(e);d=e//6;b+=a//d*(e%6);a%=d
 return b
</code></pre>

<p>The Unicode string consists of the code points:</p>

<pre><code>6004 5405 3002 2403 601 543 302 244 62 57 32 27 7
</code></pre>
</div>
<div id="pu4" class="pu"><h1>Pyth, <s>92</s> <s>76</s> 70 bytes</h1>

<pre><code>KsMc."/9hæ²z³Þ§ªW×Oû[Tnè,O¤"\/WQ=Q-Q=Nef!&gt;TQ%2K aY@KhxKN;sY
</code></pre>

<p><a href="http://pyth.herokuapp.com/?code=KsMc.%22%2F9h%C3%A6%10%C2%B2z%C2%B3%C3%9E%C2%A7%C2%9D%1D%C2%AA%C2%8D%C2%93W%C3%97%0BO%C2%81%C2%95%C3%BB[%05T%0En%19%C3%A8%2CO%C2%A4%22%5C%2FWQ%3DQ-Q%3DNef!%3ETQ%252K+aY%40KhxKN%3BsY&amp;input=1234&amp;debug=0" rel="nofollow">Try it here!</a></p>

<p>Thanks to @FryAmTheEggman for some string packing suggestions which saved me some bytes!</p>

<p>I am still wondering if there is a mathematical way of encoding this list. Will try to figure something out.</p>

<h1>Explanation</h1>

<p>This uses the given algorithm. <code>K</code> contains the given list with the numbers and the corrosponding number of line segments in alternation. This list gets constructed by splitting a packed string, which gets decoded to <code>0/0/1/1/4/3/5/2/9/3/10/2/40/4/50/2/90/3/100/1/400/3/500/2/900/5/1000/4</code>, on <code>/</code> and mapping each element to an integer.</p>

<pre>
KsMc."..."\/WQ=Q-Q=Nef!>TQ%2K aY@KhxKN;sY    # Q = input

   c."..."\/                                 # split the string on /
KsM                                          # map every number to int and assign to K
            WQ                               # while Q != 0
                     f    %2K                # only take every 2nd element of K and filter with T
                      !>TQ                   # T &lt;= Q
                  =Ne                        # Take the last element of that and assign that to N
              =Q-Q                           # Q = Q - N
                                   xKN       # index of the first occurence of N in K
                                  h          # increment that index because we want the line segments
                              aA@K           # get the line segment from that index and append that to Y
                                      ;sY    # end the loop and print the sum of all line segments in Y
</pre>
</div>
<div id="pu5" class="pu"><p><strong>C, <s>148</s> 129 chars</strong></p>

<pre><code>d,x,n[]={1000,900,500,400,100,90,50,40,10,9,5,4,1,4,5,2,3,1,3,2,4,2,3,2,3,1};f(c){while(d+=(c/n[x])*n[x+13],c%=n[x++]);return d;}
</code></pre>

<p>My first code-golf :^). Since the question states I can use a function, I have changed main to a function to trim some chars (most importantly: pass c as parameter rather scanf)</p>

<p>unpacked</p>

<pre><code>d,x,n[]={1000,900,500,400,100,90,50,40,10,9,5,4,1,4,5,2,3,1,3,2,4,2,3,2,3,1};
f(c){
  while(d+=(c/n[x])*n[x+13],
        c%=n[x++]);
  return d;
}
</code></pre>
</div>
<div id="pu6" class="pu"><h2>Java, 152 bytes</h2>

<p><a href="http://meta.codegolf.stackexchange.com/a/5829">Because, ya know, Java.</a></p>



<pre class="lang-java prettyprint-override"><code>n-&gt;{int c=0;int[]r={999,4,899,5,499,2,399,3,99,1,89,3,49,2,39,4,9,2,8,3,4,2,3,3,0,1};for(int i=0;i&lt;26;i+=2)while(n&gt;r[i]){n-=r[i]+1;c+=r[i+1];}return c;}
</code></pre>

<p>Simple literal implementation of the given algorithm. Array packs the transform information: even indexes are one less than the roman numeral and odd indexes are the count for that numeral.</p>

<p>This is a lambda that takes and returns an <code>int</code>/<code>Integer</code>. This includes <code>IntUnaryOperator</code> or <code>UnaryOperator&lt;Integer&gt;</code>.</p>
</div>
<div id="pu7" class="pu"><h1>Retina, 128 bytes</h1>

<pre>.+
$*
1{1000}
t'
1{900}
td
1{500}
d
1{400}
t
1{100}
'
1{90}
t
1{50}
d
1{40}
t'
1{10}
d
1{9}
t
1{5}
d
1{4}
t
1
'
t
d'
d
''
'+
$.0</pre>

<p>Simple replacing until there's nothing left to replace. Then the apostrophes are counted and that's our number of line segments.</p>

<p>If input and output in unary are allowed, it's 115 bytes (although who would want to type 1234 ones?).</p>

<p><a href="http://retina.tryitonline.net/#code=LisKJCoKMXsxMDAwfQp0JwoxezkwMH0KdGQKMXs1MDB9CmQKMXs0MDB9CnQKMXsxMDB9CicKMXs5MH0KdAoxezUwfQpkCjF7NDB9CnQnCjF7MTB9CmQKMXs5fQp0CjF7NX0KZAoxezR9CnQKMQonCnQKZCcKZAonJwonKwokLjA&amp;input=MTIzNA" rel="nofollow">Try it online!</a><br>
<a href="http://retina.tryitonline.net/#code=MXsxMDAwfQp0JwoxezkwMH0KdGQKMXs1MDB9CmQKMXs0MDB9CnQKMXsxMDB9CicKMXs5MH0KdAoxezUwfQpkCjF7NDB9CnQnCjF7MTB9CmQKMXs5fQp0CjF7NX0KZAoxezR9CnQKMQonCnQKZCcKZAonJw&amp;input=MTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMQ" rel="nofollow">Try it online! (unary IO)</a></p>
</div>
<div id="pu8" class="pu"><h1>Mathematica, <s>80</s> 72 bytes</h1>

<pre><code>Tr[Characters[#~IntegerString~"Roman"]/.{"I"|"C"-&gt;1,"M"-&gt;4,_String-&gt;2}]&amp;
</code></pre>

<p>Anonymous function that just converts numbers to Roman numerals, replaces each character with its number of segments, and takes the total.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/75717/">75717</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




