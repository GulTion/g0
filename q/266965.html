<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::266965</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>nan</td><td></td><td>231122T010637Z</td><td><a href="https://codegolf.stackexchange.com/questions/266965/shortest-algorithm-that-generates-a-harlequin-pattern/266973#266973">Jonathan</a></td></tr>
<tr d-ix="1"><td>015</td><td>While I was was sieving through hundreds of patterns</td><td>231121T210034Z</td><td><a href="https://codegolf.stackexchange.com/questions/266965/shortest-algorithm-that-generates-a-harlequin-pattern/266966#266966">q-l-p</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>Seven Face Turns</h1>
<pre><code>U D2 F2 B2 R L U'
</code></pre>
<p>With yellow (Y) at the top, red (R) at the front and green (G) at the right (with their opposites white (W), orange (O), and blue (B) respectively) that produces the net:</p>
<pre><code>      O R G
      W Y W
      B O R
W R Y O G B W O Y R B G
G B R Y R W B G O Y O W
O G B W G Y R B G W B Y
      O Y B
      R W O
      G Y R
</code></pre>
<p>Here is Python code that finds this solution.</p>
<p><strong><a href="https://tio.run/##nVhtb9s2EP6uX8EpGCotbhrJclIIy7A0ibEArT0kTr8YhkDbVKxWEl2KSuoN@@3ZkZQtUaIbb/6QWtTdc3cP761eb/iK5v33a/byEjOaoSXmeJHioiAFSrI1Zbw@sizrCH2iTwTFZb7gCc0L5OSUI74iKE8WpICvFDGCl2heyuMNWlL5@gudu9aSxOjBKTjmxA0tBB9GeMlyNJUP4iNfTk9n07Nwho7rx/Bs1msJ@XDar4W82bQfdoQCXcg3CvU7JwNdLTCqebrQoCE0A65EtMMDow0DDccPB1r050bjTYo8I0WSx3MtfA/EmtCBmdmz8L2mFnr1Y38P0yYSfU2tRdegTdfdoXT5WuRtugbmu9J90ZQ8o5Kvc@wbOe7ryIGuE3SoM9iR1zDQlNrX5IcmfnX2rg9jz0SNnn5BM2c8Y/r5upLXUvKNSn2dm76Rz0BH9lvIgRF5oCsFLaVBQ2nL1odD2PK7yWVsBCZ69HRr0zMw0tO6iCZbg04mnRvbXTv7jF3Bb1ViO93AeZ2tj4ewFbTy@LQFHJjz@FSPzOu6c2ZKQFMe6wRpMJ4RJuhcVDtDPc3/gTH32vd01mDvCI1wBtOUxnIQZvr8xHN47qE4YTA8cc6TRUoXX5@TgiDMaJkvEc0JWlCWE4beoofhHQACTi7@JAzR9ZoWSf6IYgzzFzkddWFTCfEtjgtA1x8@WsPLq5t7dIFsQIVn2xpF4ij68/L2TpynJHekjIvevUO@ZX0af76Jhg@jq8nteCQkpuQJp07sopgyFKMkR1Iewr4bTy6FVHQ7ur69upyMJaJj2z1k@@LPG9vdCYlXvFynpHY/@lZixgkrJHT3uAfGlskCc3gLZkleZoQB/Y7BcE/cDOMXnuta1hBim8g476PJOJo83I2EY/LgBDDJd8d@sN2ei9CR4n5FYbVB5VrsNsUmywhnG@RgNk84w2zjWvc3V@PR9SuY14CJtJOh7Uoj/JlWRoqOFeHA9vZ60h28/AI3nXMI5X788fPNdXQPAd@Iy5gmM/QLei8ZSwQrDOePxKmv0d1W8xbEEVkTeT2ZPZGvV7d6h35GWlr8dFEJt14A8u@7TdFxLfmv3BYVqFAKwSmuTFCoFSgAdaKceiR5JKojKsi3kuRAh7Mka76qvEpiJB/Rb@g03JWgiFVTEnHvQ4K899xat0IV/GjSLpjwdLFtBIW417hO9w7DHa2mpViwp5mavvVmJwJ4vx6GInZMmv5rmvIDnu5u22y6twfYfQX5B@@7r0RGRQWnayCwr70lqfkOLi5@dAmmmvtPRguyH9zQI36I7WtvZXJglYkS0WAIRGSNgciuCU7DHeYsNHK7SUi6bKX7MZqKInPUTQoEqPJuiEp1OtvVGo/kuGqxrhSeBMGN5mLtKk04rGnoldjoOtnJtsZbFSfA9UEyzWS@zZwnt9l/nipf1wx6hF7PRq@lnPMGvTn5QpOqIKdCUKEDU4bZoAS2rooGMdv1lE6wYn5Il5IiWmGWwjEYai5Gzbvv9IaahyMk6pGJgZzSEqyVMP3F/6Tn0OBhmi0fiYRJCa9ErGYbqQyofUMGB6sOrDE60RWNQwyJ0LC87QZgL39buVHZKmpHVhjiF7tDAcuLwQecbxwsanQuY8Y9@AIu/ZWsnYZbvZaP9ZakTmC5ct2DvJYxS@@kZzhNK6cKq9XKC8KbLogCkV9g2P7aWGkOsjqiKCdkKWbyYkUWX9UGh78nWZmBzprwRK1xIBAn1baldjn7j22C2CjhqCAkg6VF/CwCfsLBM2GkmRDy1xcIKSXVZlj9@nIFWxwsPEJE5iRYEk0HtsmMLsu06S0Ag29OpaFIqMM/gVWthEnoivHmN00bCagOJqwkVdJnGJK94k2NU@jQ8ul5laREndW4qhxjuyCYLVZiRcUc/S2FLv6x3f83wbvTWyvFfW3N7fbT17tKR2XOCP5q7R8hipTjLSvbz4LCWp@X9U0pHMsC76Moh/qKIlFJdhQJiqPIVrCKb@vl5V8" rel="nofollow noreferrer" title="Python 3.8 – Try It Online">Try it online!</a></strong></p>

<pre class="lang-python prettyprint-override"><code>from dataclasses import dataclass


# Move functions (not the nicest to read but they do the job)
def U(state):
    return [
        state[0][6:] + state[0][:6],
        state[2][:3] + state[1][3:],
        state[4][:3] + state[2][3:],
        state[3],
        state[5][:3] + state[4][3:],
        state[1][:3] + state[5][3:],
    ]


def F(state):
    return [
        state[0][:4] + state[5][2:5] + state[0][7:],
        state[1][6:] + state[1][:6],
        state[0][6:7] + state[2][1:6] + state[0][4:6],
        state[2][6:8] + state[2][:1] + state[3][3:],
        state[4],
        state[5][:2] + state[3][:3] + state[5][5:],
    ]


def R(state):
    return [
        state[0][:2] + state[1][2:5] + state[0][5:],
        state[1][:2] + state[3][2:5] + state[1][5:],
        state[2][6:] + state[2][:6],
        state[3][:2] + state[4][6:] + state[4][:1] + state[3][5:],
        state[0][4:5] + state[4][1:6] + state[0][2:4],
        state[5],
    ]


def D(state):
    return [
        state[0],
        state[1][:4] + state[5][4:7] + state[1][7:],
        state[2][:4] + state[1][4:7] + state[2][7:],
        state[3][6:] + state[3][:6],
        state[4][:4] + state[2][4:7] + state[4][7:],
        state[5][:4] + state[4][4:7] + state[5][7:],
    ]


def B(state):
    return [
        state[2][2:5] + state[0][3:],
        state[1],
        state[2][:2] + state[3][4:7] + state[2][5:],
        state[3][:4] + state[5][6:] + state[5][:1] + state[3][7:],
        state[4][6:] + state[4][:6],
        state[0][2:3] + state[5][1:6] + state[0][:2],
    ]


def L(state):
    return [
        state[4][4:5] + state[0][1:6] + state[4][2:4],
        state[0][:1] + state[1][1:6] + state[0][6:],
        state[2],
        state[1][:1] + state[3][1:6] + state[1][6:],
        state[4][:2] + state[3][6:] + state[3][:1] + state[4][5:],
        state[5][6:] + state[5][:6],
    ]


# Names of the move functions above, first anticlockwise around one corner - UFR
# then their opposing faces (clockwise around the opposite corner) - DBL
FACES = &quot;UFRDBL&quot;
N_FACE_PAIRS = len(FACES) // 2

MOVE_FUNCTIONS = [eval(f) for f in FACES]

ROTATION_INDICATORS = (&quot;&quot;, &quot;2&quot;, &quot;'&quot;)
ROTATIONS = tuple(clockwise_quarters for clockwise_quarters, indicator in enumerate(ROTATION_INDICATORS, start=1))

FIRST_FACES_TO_TURN = (FACES.index(&quot;U&quot;),)  # one choice up to symmetry (arbitrary)
SECOND_FACES_TO_TURN = (FACES.index(&quot;D&quot;), FACES.index(&quot;F&quot;))  # two choices up to symmetry (one opposite, one adjacent)

SOLVED_STATE = [[i] * 8 for i in range(len(FACES))]


def adjacent(face_1, face_2):
    return face_1 % N_FACE_PAIRS != face_2 % N_FACE_PAIRS


@dataclass()
class Move:
    face: int
    rotation: int


def gen_move_sequences(depth):
    if depth &gt; 0:
        for move_sequence in gen_move_sequences(depth - 1):
            if len(move_sequence) &gt; 1:
                faces = (f for f in range(len(FACES))
                         if f != move_sequence[-1].face
                         and (f != move_sequence[-2].face
                              or adjacent(move_sequence[-1].face, move_sequence[-2].face)
                              )
                         )
                turn_stop = 3
            elif len(move_sequence) == 1:
                faces = SECOND_FACES_TO_TURN
                turn_stop = 3
            else:
                faces = FIRST_FACES_TO_TURN
                turn_stop = 2
            for face in faces:
                for turn in ROTATIONS[:turn_stop]:
                    yield move_sequence + [Move(face, turn)]
    else:
        yield []


def get_state(move_sequence):
    v = SOLVED_STATE
    for m in move_sequence:
        for i in range(m.rotation):
            v = MOVE_FUNCTIONS[m.face](v)
    return v


def print_move_sequence(move_sequence):
    print(' '.join(FACES[move.face] + ROTATION_INDICATORS[move.rotation - 1] for move in move_sequence))


def is_harlequin(state):
    for face in range(len(FACES)):
        # centre colour must not be an edge facelet colour
        if face in state[face][1::2]:
            return False
        # adjacent non-centre facelets must not have the same colour
        if any(a == b for a, b in zip(state[face], state[face][1:] + state[face][:1])):
            return False
        # face must have all colours
        if len(set(state[face] + [face])) &lt; len(FACES):
            return False
        # No need to check the maximum repetitions to find the first &quot;Harlequin&quot; it seems, but if it were:
        # from collections import Counter  # move to top of module
        # if max(Counter(state + [face]).values()) &gt; 2:
        #     return False
    return True


def main():
    depth = 1
    while depth:
        print(f&quot;searching at {depth=}&quot;)
        for move_sequence in gen_move_sequences(depth):
            if is_harlequin(get_state(move_sequence)):
                print_move_sequence(move_sequence)
                break
        else:
            depth += 1
            continue
        break


if __name__ == &quot;__main__&quot;:
    main()
</code></pre>
</div>
<div id="pu1" class="pu"><p>While I was was sieving through hundreds of patterns, using Herbert Kociemba's <a href="http://kociemba.org/cube.htm" rel="nofollow noreferrer">Cube Explorer</a>, I stumbled upon a pattern, shown in the animation* below, that can be generated by a 15-move algorithm. But I don't know if this is the shortest algorithm which generates a harlequin pattern.</p>
<p><a href="https://i.stack.imgur.com/xR5h4.gif" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/xR5h4.gif" alt="Harlequin pattern on a rotating Rubik's Cube" /></a><br />
D' F L2 D F U2 B U' R' L F B L2 D L'</p>
<hr />
<p><strong>UPDATE – I found another one!</strong><br />
F R B D B F2 R2 U2 L' F' L D2 B R2 U</p>
<p>Today I decided to systematically search for the shortest harlequin algorithm using Kociemba's program. I started by manually counting the number of harlequin search patterns to be used in the Pattern Editor. There are 7 ways to arrange the first 2 facelets of the 1st color (excluding rotation symmetry):<br />
<a href="https://i.stack.imgur.com/cGZ58.jpg" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/cGZ58.jpg" alt="enter image description here" /></a></p>
<p>For patterns 1 and 5 there are only 13 ways to arrange the next 2 facelets of the 2nd color:<br />
<a href="https://i.stack.imgur.com/tUGRr.jpg" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/tUGRr.jpg" alt="enter image description here" /></a></p>
<p>For patterns 2, 6 and 7 there are 15 ways to arrange the 2nd color facelet pair. For patterns 3 and 4 there are 14 ways.</p>
<p>So, there are 99 ways in which the first 4 facelets can be arranged.
For pattern 1 I counted 80 ways in which the 3rd color facelet pair can be placed. Because the colors of the search pattern only tell the program the structure of the pattern and not the actual colors to be searched, it doesn't matter how we color the last 3 facelets as long as each has a unique color. So there are 80 search patterns that begin with pattern 1. Pattern 2 is the starting point for 110 search patterns. Pattern 3 generates 94 search patterns. But I ran into a roadblock. Some search patterns produce 7 results, some 164 and some... OVER 9000!!</p>
<p><a href="https://i.stack.imgur.com/sEB7d.jpg" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/sEB7d.jpg" alt="" /></a>
I had to stop the program after letting it run for more than 24 hours. It was still searching for patterns.</p>
<p>Obviously, it is unfeasible to manually search for the shortest harlequin generator. I hope someone will find a better way to answer this question. I understand that the number of harlequin patterns may be so large that it renders such patterns as... not so special to worth the effort of investigating. I don't know enough math to go any further.</p>
<p>I am still interested in a mathematical solution to this puzzle.</p>
<hr />
<p><sub>* GIF created using <a href="http://iamthecu.be/" rel="nofollow noreferrer">Rubik's Cube Explorer</a> and <a href="http://www.virtualdub.org/" rel="nofollow noreferrer">VirtualDub</a>.</p>
</sub>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/266965/">266965</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




