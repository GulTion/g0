<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::266965</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>nan</td><td></td><td>231122T010637Z</td><td><a href="https://codegolf.stackexchange.com/questions/266965/shortest-algorithm-that-generates-a-harlequin-pattern/266973#266973">Jonathan</a></td></tr>
<tr d-ix="1"><td>015</td><td>While I was was sieving through hundreds of patterns</td><td>231121T210034Z</td><td><a href="https://codegolf.stackexchange.com/questions/266965/shortest-algorithm-that-generates-a-harlequin-pattern/266966#266966">q-l-p</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>Seven Face Turns</h1>
<pre><code>U D2 F2 B2 R L U'
</code></pre>
<p>With yellow (Y) at the top, red (R) at the front and green (G) at the right (with their opposites white (W), orange (O), and blue (B) respectively) that produces the net:</p>
<pre><code>      O R G
      W Y W
      B O R
W R Y O G B W O Y R B G
G B R Y R W B G O Y O W
O G B W G Y R B G W B Y
      O Y B
      R W O
      G Y R
</code></pre>
<p>Here is Python code that finds this solution.</p>
<p><strong><a href="https://tio.run/##xVfdb6NGEH/3XzF1VAXuSGS@nBNq@pAmlirlLlLukheEEIZNvCksLgvupf98urtgw8DmaqkP9YPtnZ2P3/xmdha2r/WmZO7b2wl8LncEnhqW1rRkHAxW1lBvCDCaEi7@llCRJIN1o8SvkJVq@6Vcm7OMPMGDweukJmYwA/GpSN1UDEK1kB@1GS6icBlE8LFfBsvIGik5Qur2SnYUusFEycNKjlbJnUh8bOZpzWys5A@UotlMZbs6MtvAQ36cwEfZX2iDDymytRQpHi9Q@rZQG7r29Mwug0/ILLD7pfsO0zoSHWQ2ossf03V/LF0OynxMl6@vFcaCjGytkYM5drQcu9izh228CXWaOKoMPjIal8kJdPxi9q6PY09HDW4/b9gztrb9HGxkj4wcrZGLuXG1fHrYszPy7Gk9@9jIGxn5A6M9W1fHsOVMm0s7CHT04HYb0@Nr6RkVYsiWP@mkC@24G3efdio4o5M4bjcBHrN1ewxb3qiPFyPHnr6PFzgzewpnqWtAXR9jgpAbW@vGmxRq3KE2wu9re29cp@WAvc93jzdf4RLmD6v766vbuRLEq4cvv337/e6L3AkfLFhZcG/BtQVXFtxGs693t48313IvpBF8gE/wVFZAgTKoEvZMjKUpfZ/AY5LTLJF3sSrTTi5RqSZ2wQH@CaSE1RWBtMzLpoKiERe4vM/XBBIGJHsWN32SkpzUncrBlD61TtuUqaRa0Ni7HjTJKsk5GcRMspdExhWR2FkHoIvCewibRDxmyAcHnhQHgMPwCXs1Eri8hLVKMbHEHwHob7o19qCsIby@QFQV1TSPQiuRtagUIk6/d2D4EExOmMFJfYgsYolv04RfYPkvYTrBt6ohqqCMfK9hW3JO17mILJ62uKqslMdqaaRN1YHvQkuBpGLRx3qlJM9AbEgoxsICWzTMu5vOjzbdbpPko3B2H06WgNOMyBIYroyG08ZOpSZG9J6Oc4QOwie2wjNx1BcR/Awu/HTZSpy9BENm@oPRUcsO5soh3p@iYdOUtErOMUp9Upz8B8zimGQDmfO/5CHbWr02cPJnQ5h4T4Ckhoxs6w20Y@uZsK63lbTv7lbp12FnSw6yQpIwsoKzSdspXUXY4PhkhfkeBRnTkN5uhW0eN2LCNmreQimGkDqgh7wgEZm1UwaMhos8C/S21L4BEeGig6K@OzQFT8W8V5IwCET5lHQnZO1loJZ/baicCjzt4RXSiqfn23JrmIilwdgvxPU3ylp6xldRWIjuiIydORxMu@4BYFtRVmtgK7lxCqfnLyVlhrrtQjk15RCcAzin81A64mLqql9Zpkjhk1oWtEKBtPVqdvGKRHjrYhxoFwznedcUtiXvBzaQOOfn523jiNTsAV@0z3wPV3oNTi2gmLKC48ai0xPWXrHDInJT01CIL25O9tfiNfmPgxR3XJvDx30S@09aspqypr@eWh@zmUAVx0xclHEs5/I8jiV7cTzvOktR@fb2Dw" rel="nofollow noreferrer" title="Python 3 – Try It Online">Try it online!</a></strong> (Should complete in just under a minute)</p>

<pre class="lang-python prettyprint-override"><code># Move functions (not the nicest to read but they do the job)
def U(state):
    return [
        state[0][6:] + state[0][:6],
        state[2][:3] + state[1][3:],
        state[4][:3] + state[2][3:],
        state[3],
        state[5][:3] + state[4][3:],
        state[1][:3] + state[5][3:],
    ]


def F(state):
    return [
        state[0][:4] + state[5][2:5] + state[0][7:],
        state[1][6:] + state[1][:6],
        state[0][6:7] + state[2][1:6] + state[0][4:6],
        state[2][6:8] + state[2][:1] + state[3][3:],
        state[4],
        state[5][:2] + state[3][:3] + state[5][5:],
    ]


def R(state):
    return [
        state[0][:2] + state[1][2:5] + state[0][5:],
        state[1][:2] + state[3][2:5] + state[1][5:],
        state[2][6:] + state[2][:6],
        state[3][:2] + state[4][6:] + state[4][:1] + state[3][5:],
        state[0][4:5] + state[4][1:6] + state[0][2:4],
        state[5],
    ]


def D(state):
    return [
        state[0],
        state[1][:4] + state[5][4:7] + state[1][7:],
        state[2][:4] + state[1][4:7] + state[2][7:],
        state[3][6:] + state[3][:6],
        state[4][:4] + state[2][4:7] + state[4][7:],
        state[5][:4] + state[4][4:7] + state[5][7:],
    ]


def B(state):
    return [
        state[2][2:5] + state[0][3:],
        state[1],
        state[2][:2] + state[3][4:7] + state[2][5:],
        state[3][:4] + state[5][6:] + state[5][:1] + state[3][7:],
        state[4][6:] + state[4][:6],
        state[0][2:3] + state[5][1:6] + state[0][:2],
    ]


def L(state):
    return [
        state[4][4:5] + state[0][1:6] + state[4][2:4],
        state[0][:1] + state[1][1:6] + state[0][6:],
        state[2],
        state[1][:1] + state[3][1:6] + state[1][6:],
        state[4][:2] + state[3][6:] + state[3][:1] + state[4][5:],
        state[5][6:] + state[5][:6],
    ]


MOVES = &quot;UFRDBL&quot;
MOVE_FUNCTIONS = [U, F, R, D, B, L]
SOLVED = [[i] * 8 for i in range(6)]


# Validation
def valid(state):
    for i in range(6):
        # centre colour must not be an edge facelet colour
        if i in state[i][1::2]:
            return False
        # adjacent non-centre facelets must not have the same colour 
        if any(a == b for a, b in zip(state[i], state[i][1:] + state[i][:1])):
            return False
        # face must have six colours
        if len(set(state[i] + [i])) &lt; 6:
            return False
    return True


# next possible moves
def next_moves(cur):
    if len(cur) == 0:
        yield cur + [(0, 1)]
        yield cur + [(0, 2)]
        yield cur + [(0, 3)]
    elif len(cur) == 1:
        for side in (3, 1):
            yield cur + [(side, 1)]
            yield cur + [(side, 2)]
            yield cur + [(side, 3)]
    elif cur[-1][0] % 3 != cur[-2][0] % 3:
        for n in range(6):
            if n != cur[-1][0]:
                yield cur + [(n, 1)]
                yield cur + [(n, 2)]
                yield cur + [(n, 3)]
    else:
        for n in range(6):
            if n != cur[-1][0] and n != cur[-2][0]:
                yield cur + [(n, 1)]
                yield cur + [(n, 2)]
                yield cur + [(n, 3)]


# Move sequences at depth n
def gen_moves(depth):
    if depth &gt; 0:
        for dm in gen_moves(depth - 1):
            for dn in next_moves(dm):
                yield dn
    else:
        yield []


# Evaluation of a move sequence as a state (uses move functions)
def eval_moves(moves):
    msc = moves[::-1]
    v = SOLVED
    while msc:
        m = msc.pop()
        for i in range(m[1]):
            v = MOVE_FUNCTIONS[m[0]](v)
    return v


def print_moves(moves):
    print(' '.join(MOVES[face] + &quot;  2'&quot;[turns][:turns - 1] for face, turns in moves))


def main():
    # Evaluate all depth 1, then all depth 2...
    i = 1
    while i:
        print('    #:', i)
        for ms in gen_moves(i):
            if valid(eval_moves(ms)):
                print_moves(ms)
                break
        else:
            i += 1
            continue
        break


if __name__ == &quot;__main__&quot;:
    main()
</code></pre>
</div>
<div id="pu1" class="pu"><p>While I was was sieving through hundreds of patterns, using Herbert Kociemba's <a href="http://kociemba.org/cube.htm" rel="nofollow noreferrer">Cube Explorer</a>, I stumbled upon a pattern, shown in the animation* below, that can be generated by a 15-move algorithm. But I don't know if this is the shortest algorithm which generates a harlequin pattern.</p>
<p><a href="https://i.stack.imgur.com/xR5h4.gif" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/xR5h4.gif" alt="Harlequin pattern on a rotating Rubik's Cube" /></a><br />
D' F L2 D F U2 B U' R' L F B L2 D L'</p>
<hr />
<p><strong>UPDATE – I found another one!</strong><br />
F R B D B F2 R2 U2 L' F' L D2 B R2 U</p>
<p>Today I decided to systematically search for the shortest harlequin algorithm using Kociemba's program. I started by manually counting the number of harlequin search patterns to be used in the Pattern Editor. There are 7 ways to arrange the first 2 facelets of the 1st color (excluding rotation symmetry):<br />
<a href="https://i.stack.imgur.com/cGZ58.jpg" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/cGZ58.jpg" alt="enter image description here" /></a></p>
<p>For patterns 1 and 5 there are only 13 ways to arrange the next 2 facelets of the 2nd color:<br />
<a href="https://i.stack.imgur.com/tUGRr.jpg" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/tUGRr.jpg" alt="enter image description here" /></a></p>
<p>For patterns 2, 6 and 7 there are 15 ways to arrange the 2nd color facelet pair. For patterns 3 and 4 there are 14 ways.</p>
<p>So, there are 99 ways in which the first 4 facelets can be arranged.
For pattern 1 I counted 80 ways in which the 3rd color facelet pair can be placed. Because the colors of the search pattern only tell the program the structure of the pattern and not the actual colors to be searched, it doesn't matter how we color the last 3 facelets as long as each has a unique color. So there are 80 search patterns that begin with pattern 1. Pattern 2 is the starting point for 110 search patterns. Pattern 3 generates 94 search patterns. But I ran into a roadblock. Some search patterns produce 7 results, some 164 and some... OVER 9000!!</p>
<p><a href="https://i.stack.imgur.com/sEB7d.jpg" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/sEB7d.jpg" alt="" /></a>
I had to stop the program after letting it run for more than 24 hours. It was still searching for patterns.</p>
<p>Obviously, it is unfeasible to manually search for the shortest harlequin generator. I hope someone will find a better way to answer this question. I understand that the number of harlequin patterns may be so large that it renders such patterns as... not so special to worth the effort of investigating. I don't know enough math to go any further.</p>
<p>I am still interested in a mathematical solution to this puzzle.</p>
<hr />
<p><sub>* GIF created using <a href="http://iamthecu.be/" rel="nofollow noreferrer">Rubik's Cube Explorer</a> and <a href="http://www.virtualdub.org/" rel="nofollow noreferrer">VirtualDub</a>.</p>
</sub>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/266965/">266965</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




