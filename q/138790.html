<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::138790</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>005</td><td>Vyxal 3 g</td><td>240305T163452Z</td><td><a href="https://codegolf.stackexchange.com/questions/138790/no-co-prime-neighbors/271553#271553">pacman25</a></td></tr>
<tr d-ix="1"><td>015</td><td>Pyth</td><td>170813T160401Z</td><td><a href="https://codegolf.stackexchange.com/questions/138790/no-co-prime-neighbors/138809#138809">Erik the</a></td></tr>
<tr d-ix="2"><td>100</td><td>Haskell</td><td>170814T040946Z</td><td><a href="https://codegolf.stackexchange.com/questions/138790/no-co-prime-neighbors/138912#138912">&#216;rj</a></td></tr>
<tr d-ix="3"><td>038</td><td>TIBASIC</td><td>170814T225944Z</td><td><a href="https://codegolf.stackexchange.com/questions/138790/no-co-prime-neighbors/139076#139076">calc84ma</a></td></tr>
<tr d-ix="4"><td>009</td><td>Jelly</td><td>170813T134403Z</td><td><a href="https://codegolf.stackexchange.com/questions/138790/no-co-prime-neighbors/138800#138800">miles</a></td></tr>
<tr d-ix="5"><td>007</td><td>Japt</td><td>170813T124208Z</td><td><a href="https://codegolf.stackexchange.com/questions/138790/no-co-prime-neighbors/138791#138791">ETHprodu</a></td></tr>
<tr d-ix="6"><td>008</td><td>Husk</td><td>170813T124755Z</td><td><a href="https://codegolf.stackexchange.com/questions/138790/no-co-prime-neighbors/138792#138792">H.PWiz</a></td></tr>
<tr d-ix="7"><td>008</td><td>05AB1E</td><td>170813T135440Z</td><td><a href="https://codegolf.stackexchange.com/questions/138790/no-co-prime-neighbors/138802#138802">Adnan</a></td></tr>
<tr d-ix="8"><td>014</td><td>MATL</td><td>170813T131039Z</td><td><a href="https://codegolf.stackexchange.com/questions/138790/no-co-prime-neighbors/138795#138795">Luis Men</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://github.com/Vyxal/Vyxal/tree/version-3" rel="nofollow noreferrer">Vyxal 3</a> <code>g</code>, 5 bytes</h1>
<pre><code>ϩĠ∑ȧv
</code></pre>
<p><a href="https://vyxal.github.io/latest.html#WyJnIiwiIiwiz6nEoOKIkcindiIsIiIsIlsyOCwxMzMsMTkwLDE0OCwxMThdIiwiMy40LjIiXQ==" rel="nofollow noreferrer">Try it Online!</a></p>
<p>I could save a byte with codepoint zero... Outputs 0 if falsy, any other number is truthy in vyxal</p>
</div>
<div id="pu1" class="pu"><h1><a href="https://pyth.readthedocs.io" rel="nofollow noreferrer">Pyth</a>, 15 bytes</h1>
<pre><code>&amp;F.bPiFNP.TtBQQ
</code></pre>
<p><strong><a href="http://pyth.herokuapp.com/?code=%26F.bPiFNP.TtBQQ&amp;input=%5B38%2C+70%2C+46%2C+98%2C+80%2C+105%2C+70%2C+78%2C+80%2C+46%2C+84%2C+116%2C+66%2C+81%2C+81%5D&amp;debug=0" rel="nofollow noreferrer">Try it here</a></strong> or <strong><a href="http://pyth.herokuapp.com/?code=%26F.bPiFNP.TtBQQ&amp;input=%5B6%2C21%5D%0A%5B502%2C230%2C524%2C618%2C996%5D%0A%5B314%2C+112%2C938%2C+792%2C+309%5D%0A%5B666%2C+642%2C+658%2C+642%2C+849%2C+675%2C+910%2C+328%2C+320%5D%0A%5B922%2C+614%2C+530%2C+660%2C+438%2C+854%2C+861%2C+357%2C+477%5D&amp;test_suite=1&amp;test_suite_input=%5B6%2C21%5D%0A%5B502%2C230%2C524%2C618%2C996%5D%0A%5B314%2C+112%2C938%2C+792%2C+309%5D%0A%5B666%2C+642%2C+658%2C+642%2C+849%2C+675%2C+910%2C+328%2C+320%5D%0A%5B922%2C+614%2C+530%2C+660%2C+438%2C+854%2C+861%2C+357%2C+477%5D%0A%5B6%2C+7%5D%0A%5B629%2C+474%2C+502%2C+133%2C+138%5D%0A%5B420%2C+679%2C+719%2C+475%2C+624%5D%0A%5B515%2C+850%2C+726%2C+324%2C+764%2C+555%2C+752%2C+888%2C+467%5D%0A%5B946%2C+423%2C+427%2C+507%2C+899%2C+812%2C+786%2C+576%2C+844%5D&amp;debug=0" rel="nofollow noreferrer">Check out Test Suite.</a></strong></p>
<p>This is a collaborative effort between <a href="https://codegolf.stackexchange.com/users/41024/erik-the-outgolfer">Erik the Outgolfer</a> and <a href="https://codegolf.stackexchange.com/users/59487/mr-xcoder">Mr. Xcoder</a>. Returns an inconsistent value (non-empty list) for truthy, and the empty list for falsy.</p>
<hr />
<h2>ASCII-values</h2>
<pre><code>[38, 70, 46, 98, 80, 105, 70, 78, 80, 46, 84, 116, 66, 81, 81]
</code></pre>
<p>Which share the following factors:</p>
<pre><code>[2, 2, 2, 2, 5, 35, 2, 2, 2, 2, 4, 2, 3, 81]
</code></pre>
<hr />
<h1>Explanation</h1>
<pre><code>&amp;F.bPiFNP.TtBQQ
           tBQ   Return [Q, Q[1:]] (Q = eval first line of input)
         .T      Transpose ^ without cropping absences
        P        Remove last element of ^
  .b          Q  Map in parallel on ^ (N) and Q (Y, ignored)
     iFN           GCD of N
    P              Prime factors of ^ (P(1) = [])
&amp;F               Left fold (reduce) the result of the map with Logical AND (short-circuiting)
</code></pre>
<hr />
<p>Without the <a href="/questions/tagged/restricted-source" class="post-tag" title="show questions tagged &#39;restricted-source&#39;" rel="tag">restricted-source</a> requirement, this would've been a <s>7</s> 5-byte version accomplishing the same task (-2 thanks to <a href="https://codegolf.stackexchange.com/users/31625/fryamtheeggman">FryAmTheEggman</a>):</p>
<pre><code>-1iVt
</code></pre>
<hr />
<h1>Explanation</h1>
<pre><code>-1iVtQQ  Implicit QQ at the end
    tQ   Return Q[1:]
  iV  Q  Vectorized GCD on ^ and Q
-1       Remove every element of ^ from [1] (implicit singleton)
</code></pre>
</div>
<div id="pu2" class="pu"><h1><a href="https://www.haskell.org/" rel="noreferrer">Haskell</a>, <s>103</s> 100 bytes</h1>

<p>EDIT:</p>

<ul>
<li>-3 bytes: Used a <code>d&lt;-fz</code> guard to merge and shorten the last two lines.</li>
</ul>

<p><code>f</code> is the main function, which takes a list of integers and returns a <code>Bool</code>.</p>

<p>Note that the first two <code>ԁ</code>s (only) are Cyrillic (Komi) Unicode characters, and there's a tab character before the first one.</p>



<pre class="lang-hs prettyprint-override"><code>f&#9;ԁ=zb[ԁ]id
zb[h:p:l]fz=z h p&&zb[p:l]fz
zb l fz=z 0 2
z 0z=z>z^0
z f fz|f&lt;fz=z fz f|d&lt;-fz=z d$f-d
</code></pre>

<p><a href="https://tio.run/##LU9tasJAFPxdT7EUEcVEsl9vd0W9iLUQmywJXVNRSyH4xzt6n3ReWgiT2Zn3Znab8vpZpzScyrbbtt2tvpQft@l3l9quvq5O5Xk@f0v57tp8/YgklkvxKvIdAIy1eRRpsVhd6rJarMadIb48H9v@uH8@Dm01AWnW53U6xH7bi0acZzNIfwJMZI5GIdQECLrr3wvQCP0eN6MZ8d2rTT4eqmnMq2HYUyaUPEz2tlBgusiEVSYTJH0mQiA4WuIsJeygIboAposAhwjbZHAm6/@ZNwHMWUxLhGnlGQpMB8WDHGa5hghgONFbaJ4kBq2D5hxno4l/KrDCS3xBqTWDh2MUhzjYTo4zqCRl@CnScihsp4jbse2IIywMZ/mWHr2GuCEYzBilGRzXAHxAoucnOw/XOuKHIfsX" rel="noreferrer" title="Haskell – Try It Online">Try it online!</a>
or <a href="https://tio.run/##y0gszk7Nyfmfm5iZZ5uZV5JalJhcolKckV@ul6aXm1igkFaUn@uaV5r7P43zSqNtVVL0lcbYzBQuICPDqsAqJzatyrZKIUOhQE0NKAQRAEoq5CiAJQwUjLiAJJBpVxVnAGSmAcVr0mzAkmlAVJNiowvmpKik6ab8p4stAA" rel="noreferrer" title="Haskell – Try It Online">test it on itself.</a></p>

<h1>How it works</h1>

<ul>
<li><code>f</code> is the main function. All it does is wrap its argument <code>ԁ</code> in a singleton list (because the prime ASCII value of <code>)</code> makes parentheses much more awkward to use than square brackets) and call <code>zb</code> with that and a dummy argument (the Haskell function <code>id</code> happens to have just the right characters to fit here).

<ul>
<li>Getting the same character to fit besides both of <code>=]</code> is impossible with plain ASCII, so the argument is named with the 2-byte Unicode character <code>CYRILLIC SMALL LETTER KOMI DE (ԁ)</code>, codepoint value <code>3*7*61=U+0501</code>, which fits with all of those and <code>[</code>.

<ul>
<li>Since the codepoint is not even (the smallest option that is a legal identifier and also even uses three bytes), this required using a tab character instead of a space before it.</li>
<li>A seven bytes longer plain ASCII option is to rename the argument: <code>f fz|bf&lt;-fz=zb[bf]fz</code>.</li>
</ul></li>
</ul></li>
<li><code>zb</code> takes two arguments, a singleton list whose element is the real list of numbers being recursed on, and a dummy argument <code>fz</code> needed only to get a <code>z</code> before the function's <code>=</code>s.

<ul>
<li>When the inner list has at least two elements, the function <code>z</code> is called with the first two (named <code>h</code> and <code>p</code>), and if that returns <code>True</code>, <code>zb</code> recurses on the tail <code>p:l</code> of the list.</li>
<li>If the inner list has fewer than two elements, <code>zb</code> returns <code>True</code>. Since <code>=</code> needs to be followed by the character <code>z</code>, the simplest way to do this is to use a call of the <code>z</code> function that itself is known to return <code>True</code>.</li>
</ul></li>
<li><code>z</code> takes two arguments and recursively calculates their greatest common divisor using subtraction (every other relevant integer division or gcd function is unavailable), returning <code>True</code> if it's greater than one.

<ul>
<li>The recursion ends when the first argument is <code>0</code>, with the second argument being the gcd. On this line the second argument is also named <code>z</code>. The character <code>1</code> is awkward here so <code>z^0</code> is used to get the number one.</li>
<li>Otherwise, if the first argument <code>f</code> is smaller than the second <code>fz</code>, they are swapped and <code>z</code> recurses.</li>
<li>Otherwise, the smaller argument is subtracted from the larger, then <code>z</code> recurses (also swapping the arguments, although that's just to avoid parentheses.)</li>
</ul></li>
</ul>
</div>
<div id="pu3" class="pu"><h1>TI-BASIC, 38 bytes</h1>

<pre><code>Input L1:ΔList(cumSum(L1:augment(Ans+V,V+{0:2&gt;sum(AnsL1=lcm(Ans+V,V+L1
</code></pre>

<p>TI-BASIC is tokenized into one- or two-byte tokens, as listed <a href="http://tibasicdev.wikidot.com/tokens" rel="noreferrer">here</a>.</p>

<p>The trickiest parts of this solution were:</p>

<ol>
<li><p>The comma token is a prime number (43), forcing me to surround it with multiples of 43 (in this case the V token, which is 86).</p></li>
<li><p>The gcd( token is a large prime number (47881), which means it couldn't be used at all.</p></li>
</ol>

<p>The tokens for this program come out to:</p>

<pre><code>token     hex     dec
Input     0xDC    220
L1        0x5D00  23808
:         0x3E    62
ΔList(    0xBB2C  47916
cumSum(   0xBB29  47913
L1        0x5D00  23808
:         0x3E    62
augment(  0x14    20
Ans       0x72    114
+         0x70    112
V         0x56    86
,         0x2B    43
V         0x56    86
+         0x70    112
{         0x08    8
0         0x30    48
:         0x3E    62
2         0x32    50
&gt;         0x6C    106
sum(      0xB6    182
Ans       0x72    114
L1        0x5D00  23808
=         0x6A    106
lcm(      0xBB08  47880
Ans       0x72    114
+         0x70    112
V         0x56    86
,         0x2B    43
V         0x56    86
+         0x70    112
L1        0x5D00  23808
</code></pre>

<h1>Explanation</h1>

<pre><code>Input L1:                   Prompt the user to input L1.

ΔList(cumSum(L1:            Take the differences of the prefix sum of L1,
                            which in effect removes the first element (result in Ans).

augment(Ans+V,V+{0:         Append a 0 to the end of Ans.
                            V defaults to 0, so adding it is a no-op.
                            Ans now holds L1 shifted to the left by one element,
                            with a 0 shifted in.

      AnsL1=lcm(Ans+V,V+L1  Take the least common multiple of each corresponding element
                            of Ans and L1, and check if each is equal to their product.
                            This returns a list of booleans, each 1 corresponding to
                            a co-prime pair. The last element (having been paired with 0)
                            will always be 1.

2&gt;sum(                      Returns 1 if there is at most one 1 in the list, else 0.
                            Since the last element is always 1, this means
                            we return 1 only if there are no co-prime pairs.
</code></pre>
</div>
<div id="pu4" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="nofollow noreferrer">Jelly</a>, <s>11</s> 9 bytes</h1>

<pre><code>,Pnælð2\P
</code></pre>

<p>Saved 2 bytes thanks to @<a href="https://codegolf.stackexchange.com/users/53748/jonathan-allan">Jonathan Allan</a>.</p>

<p><a href="https://tio.run/##HYwhFgIxDAU9p8gBIppsk6a3WF8qMby@9Wsx3ASF4A69CRcJKeabmfn32xinO@7HfI354evu8/l9vN1bk8QIvCUE4YygZAi1ascLNCFBMAlWWBG2JRSNEQlQJEqz8LOWv58DWdhEMRyUUtBVrY@69NT7Dw" rel="nofollow noreferrer">Try it online!</a></p>

<p>Jelly has its own <a href="https://github.com/DennisMitchell/jelly/wiki/Code-page" rel="nofollow noreferrer">code-page</a> and the codepoints of each character are</p>

<pre><code>Chr Hex Dec
,   2c   44
P   50   80
n   6e  110
æ   16   22
l   6c  108
ð   18   24
2   32   50
\   5c   92
P   50   80
</code></pre>

<p>This tests for non-coprime numbers by checking if <code>lcm(a, b) != a*b</code>. There might be a shorter solution as I just filtered for characters with even codepoints.</p>

<h2>Explanation</h2>

<pre><code>,Pnælð2\P  Input: array A
      2\   For each overlapping sublist of size 2
     ð       Reduce it using this dyad
,              Pair
 P             Product
  n            Not equals, 1 if true else 0
   æl          LCM
        P  Product
</code></pre>
</div>
<div id="pu5" class="pu"><h1><a href="https://github.com/ETHproductions/japt" rel="noreferrer">Japt</a>, <s>8</s> 7 bytes</h1>

<pre><code>äj d¹¥Z
</code></pre>

<p><a href="http://ethproductions.github.io/japt/?v=1.4.5&amp;code=5GogZLmlWg==&amp;input=WzIyOCwxMDYsMzIsMTAwLDE4NSwxNjUsOTBd" rel="noreferrer">Test it online!</a></p>

<p>Code points:</p>

<pre><code>Char    ä   j       d   ¹   ¥   Z
Hex    e4  6a  20  64  b9  a5  5a
Dec   228 106  32 100 185 165  90
</code></pre>

<h3>Explanation</h3>

<pre><code> äj d¹ ¥ Z
Uäj d) ==Z
             Implicit: U = input array, Z = 0
Uä           For each pair of items in the array:
  j            Return whether the two items are coprime.
    d)       Return true if any items are truthy, false otherwise.
       ==Z   Return whether this is equal to 0 (false -&gt; true, true -&gt; false).
             Implicit: output result of last expression
</code></pre>
</div>
<div id="pu6" class="pu"><h1><a href="https://github.com/barbuz/Husk" rel="noreferrer">Husk</a>, 8 bytes</h1>

<p>For Truthy inputs it returns a positive integer, for Falsy it returns 0</p>

<pre><code>←▼`Ṡt(ż⌋
</code></pre>

<p><a href="https://tio.run/##AT8AwP9odXNr///ihpDilrxg4bmgdCjFvOKMi////1s1MTUsODUwLDcyNiwzMjQsNzY0LDU1NSw3NTIsODg4LDQ2N10" rel="noreferrer" title="Husk – Try It Online">Try it online!</a> and <a href="https://tio.run/##ATcAyP9odXNr///ihpDilrxg4bmgdCjFvOKMi////1s2LDE4OSw5NiwyMDgsMTE2LDQwLDIzNSwxNDFd" rel="noreferrer">Tested on its own codepoints</a></p>

<p>Uses Husk's <a href="https://github.com/barbuz/Husk/wiki/Codepage" rel="noreferrer">codepage</a></p>

<pre><code>Source -- [ ←  , ▼  , `  , Ṡ  , t  , (  , ż  , ⌋  ]
Hex    -- [0x06,0xbd,0x60,0xd0,0x74,0x28,0xeb,0x8d]
Dec    -- [6   ,189 ,96  ,208 ,116 ,40  ,235 ,141]
</code></pre>

<h3>Explanation</h3>

<pre><code>          -- implicit input, e.g                                  [63,36,18,3]
  `       -- flip the args of the next function
   Ṡ      -- some combinator (Ṡ f g x = f (g x) x)
    t     -- tail                                                 [36,18,3]
      ż   -- zipWith (note, keeps trailing elems of longer list)  [(63,36),(36,18),(18,3),(3)]
       ⌋  -- gcd                                                  [9,9,3,3]
     (    -- used just to match restricted source criteria
 ▼        -- minimum of the list                                    3
←         -- minus 1                                                2
</code></pre>
</div>
<div id="pu7" class="pu"><h1><a href="https://github.com/Adriandmen/05AB1E" rel="noreferrer">05AB1E</a>, 8 bytes</h1>
<h3>Code</h3>
<pre><code>ü‚ÒüÃP≠P
</code></pre>
<p>Uses the <a href="https://github.com/Adriandmen/05AB1E/blob/master/docs/code-page.md" rel="noreferrer"><strong>05AB1E</strong> encoding</a>, which gives us the following list of code points:</p>
<pre><code>hex: [0xFC, 0x82, 0xD2, 0xFC, 0xC3, 0x50, 0x16, 0x50]
dec: [252,  130,  210,  252,  195,  80,   22,   80]
</code></pre>
<p><a href="https://tio.run/##MzBNTDJM/f//8J5HDbMOTzq853BzwKPOBQH//0ebmZnpKJiZGAEJUwsoy8LEEsgyN9VRsDQ00FEwNrIAEQaxAA" rel="noreferrer" title="05AB1E – Try It Online">Try it online!</a> or <a href="https://tio.run/##MzBNTDJM/f//8J5HDbMOTzq853BzwKPOBQH//0cbVLg56ygYVFgYgUgXMAkRcTYGkaYGINLQDMKOBQA" rel="noreferrer" title="05AB1E – Try It Online">Verify the source code!</a></p>
<h3>Explanation</h3>
<p>Since the gcd operator (<code>¿</code>) has a prime code point I had to look for other ways to check coprimality:</p>
<pre><code>ü‚          # Get an array of adjacent pairs of the input
  Ò         # Factorize both elements of each pair in the array
   üÃ       # For each pair, get the intersection of both prime factorization lists
     P      # Product of each intersection (this leaves 1 when there is no intersection)
      ≠     # Check for each element whether it does not equal 1
       P    # Product of the booleans
</code></pre>
</div>
<div id="pu8" class="pu"><h1><a href="https://github.com/lmendo/MATL" rel="noreferrer">MATL</a>, 14 bytes</h1>

<pre><code>!TM1*Zdl2$Xdl-
</code></pre>

<p>This outputs a non-empty column vector of nonzero numbers as truthy, or a vector containing at least a zero entry as falsy.</p>

<ul>
<li><p><a href="https://tio.run/##y00syfn/XzHE11ArKiXHSCUiJUf3//9oSyMjBTNDEwVTYwMFMzMDBRNjCwULUxMFCzNDBWNTcwUTc/NYAA" rel="noreferrer">Try it online!</a></p></li>
<li><p><a href="https://tio.run/##XY/BasMwEETv/ooptAQKDdJqtZJOvfTaWw6lIdCA7Vqg2iF2KDn02911oGAqWAmt3syOvo5TmT/wtx5QD9vt9rvLpZnvdq/28b0udP9Wl6f5eUXlttpM58vUXTfL9XQZO4zTOfef1c8Ka8rYVJv2WMaF@wce1mBfVy/rFHk8leO12q16N60ObdAOZ@S@zX2eGpRhOM17AdlDtfeGQM7AE0NsREqiXWcZ1hKSiwiJ4EzSrohAmCA@3s7ICRI8kjVwFLWMUomUUL1XVxEDVo/oGVEsnA/gEBYv3HZKeldWU1jntKJ2mVQZEoJdXj2EeElqvfoYBBKdxAiiOu8RvCaJESyLY2IBk9MK6hoQU0LUn4Qo8EE0Mx/wCw" rel="noreferrer">Verify all test cases</a>. The footer code contains an <code>if</code> branch to test truthyness/falsyness.</p></li>
<li><p>Since MATL uses ASCII, the source code is encoded as</p>

<pre><code>[33 84 77 49 42 90 100 108 50 36 88 100 108 45]
</code></pre>

<p>which <a href="https://tio.run/##y00syfn/XzHE11ArKiXHSCUiJUf3//9oY2MFCxMFc3MFE0sFEyMFSwMFQwMQtlAwNVAwNlOwsIALmJjGAgA" rel="noreferrer">satisfies the requirement</a>.</p></li>
</ul>

<h3>Explanation</h3>

<pre><code>!     % Implicit input. Transpose
TM    % Push input to latest function again
1*    % Multiply by 1 (does nothing, but matches factors)
Zd    % Compute gcd with broadcast: matrix of gcd of all pairs
l     % Push 1
2$    % The next function will use 2 inputs
Xd    % Extract diagonal 1 (i.e. that below the main diagonal) from the matrix
l-    % Subtract 1 from each entry. Implicitly display
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/138790/">138790</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




