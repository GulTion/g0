<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::190325</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>2341</td><td>Birb</td><td>231018T102121Z</td><td><a href="https://codegolf.stackexchange.com/questions/190325/church-booleans/266078#266078">Legendar</a></td></tr>
<tr d-ix="1"><td>033</td><td>SKIcalculus + C combinator</td><td>190820T210005Z</td><td><a href="https://codegolf.stackexchange.com/questions/190325/church-booleans/190480#190480">Neil</a></td></tr>
<tr d-ix="2"><td>122</td><td>Forth gforth</td><td>190821T152504Z</td><td><a href="https://codegolf.stackexchange.com/questions/190325/church-booleans/190540#190540">reffu</a></td></tr>
<tr d-ix="3"><td>065</td><td>Befunge98</td><td>190824T182441Z</td><td><a href="https://codegolf.stackexchange.com/questions/190325/church-booleans/190810#190810">Quuxplus</a></td></tr>
<tr d-ix="4"><td>034</td><td>Stax</td><td>190824T170438Z</td><td><a href="https://codegolf.stackexchange.com/questions/190325/church-booleans/190805#190805">Khuldrae</a></td></tr>
<tr d-ix="5"><td>052</td><td>Underload</td><td>190822T033353Z</td><td><a href="https://codegolf.stackexchange.com/questions/190325/church-booleans/190573#190573">ais523</a></td></tr>
<tr d-ix="6"><td>nan</td><td>Wolfram Language Mathematica</td><td>190820T091517Z</td><td><a href="https://codegolf.stackexchange.com/questions/190325/church-booleans/190398#190398">Roman</a></td></tr>
<tr d-ix="7"><td>nan</td><td>C++17</td><td>190820T151440Z</td><td><a href="https://codegolf.stackexchange.com/questions/190325/church-booleans/190444#190444">Quuxplus</a></td></tr>
<tr d-ix="8"><td>nan</td><td>C++17</td><td>190820T062437Z</td><td><a href="https://codegolf.stackexchange.com/questions/190325/church-booleans/190384#190384">Quuxplus</a></td></tr>
<tr d-ix="9"><td>101</td><td>Perl 6</td><td>190820T123009Z</td><td><a href="https://codegolf.stackexchange.com/questions/190325/church-booleans/190410#190410">nwellnho</a></td></tr>
<tr d-ix="10"><td>nan</td><td>Binary Lambda Calculus</td><td>190820T125011Z</td><td><a href="https://codegolf.stackexchange.com/questions/190325/church-booleans/190414#190414">Pavel Po</a></td></tr>
<tr d-ix="11"><td>036</td><td>Julia 1.0</td><td>190821T103448Z</td><td><a href="https://codegolf.stackexchange.com/questions/190325/church-booleans/190521#190521">Simeon S</a></td></tr>
<tr d-ix="12"><td>047</td><td>APL dzaima/APL</td><td>190821T090417Z</td><td><a href="https://codegolf.stackexchange.com/questions/190325/church-booleans/190512#190512">Ad&#225;</a></td></tr>
<tr d-ix="13"><td>nan</td><td>Java 8</td><td>190820T115820Z</td><td><a href="https://codegolf.stackexchange.com/questions/190325/church-booleans/190407#190407">Kevin Cr</a></td></tr>
<tr d-ix="14"><td>395</td><td>Python 2</td><td>190819T220549Z</td><td><a href="https://codegolf.stackexchange.com/questions/190325/church-booleans/190361#190361">Jonathan</a></td></tr>
<tr d-ix="15"><td>nan</td><td>Ruby</td><td>190820T110003Z</td><td><a href="https://codegolf.stackexchange.com/questions/190325/church-booleans/190404#190404">G B</a></td></tr>
<tr d-ix="16"><td>nan</td><td>JavaScript Node.js</td><td>190819T202414Z</td><td><a href="https://codegolf.stackexchange.com/questions/190325/church-booleans/190355#190355">Neil</a></td></tr>
<tr d-ix="17"><td>nan</td><td>Haskell</td><td>190819T203512Z</td><td><a href="https://codegolf.stackexchange.com/questions/190325/church-booleans/190357#190357">Nitrodon</a></td></tr>
<tr d-ix="18"><td>094</td><td>Python 2</td><td>190819T191428Z</td><td><a href="https://codegolf.stackexchange.com/questions/190325/church-booleans/190347#190347">Chas Bro</a></td></tr>
<tr d-ix="19"><td>nan</td><td>J</td><td>190820T015743Z</td><td><a href="https://codegolf.stackexchange.com/questions/190325/church-booleans/190379#190379">Jonah</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://esolangs.org/wiki/Birb" rel="nofollow noreferrer">Birb</a>, 23 (or 41?) bytes</h1>
<pre><code>true: 🐦🐥
false: 🐥🐦
not: 🐥🦩🕊
and: 🐦🦩🦜🐥🦢
or: 🐧🐦🦜
xor: 🦩🦩🦩🐦🦩
implies: 🦜🦩🐥
</code></pre>
<p>It works a bit like @Neil's answer, but Birb's alternating associative order changes things a bit. Here are the respective parentheses to indicate the associativity:</p>
<pre><code>true: (🐦🐥)
false: (🐥🐦)
not: ((🐥🦩)🕊)
and: ((🐦((🦩🦜)🐥))🦢)
or: ((🐧🐦)🦜)
xor: ((🦩((🦩🦩)🐦))🦩)
implies: ((🦜🦩)🐥)
</code></pre>
<p>You may realize that several programs could be significantly shorter (e.g. <code>true: 🐥</code>, <code>not: 🦩</code>, <code>or: 🦜</code>, or <code>and: 🦩🦢🦢🐥</code>. However, to have a uniform way of application (due to Birb's alternating associativity), <code>true</code> and <code>false</code> need to have the same length and all other functions need an odd length &gt;2. I also tried to use a variety of birbs :)</p>
<p>Example applications:</p>
<pre><code>not true
~&gt; 🐦🐧 🐥🦩🕊 🐦🐥
~&gt; [🐦] (false)

xor true false
~&gt; 🐦🐧 🐦🐧 🦩🦩🦩🐦🦩 🐦🐥 🐥🐦
~&gt; 🐥 (true)
</code></pre>
<p>I'm unsure whether to count the additional 🐦🐧.. If not, the sum of the length of all Birb functions is 23 bytes. If yes, <code>2+l(not) + 4+l(and) + 4+l(or) + 4+l(xor) + 4+l(implies) = 41</code> bytes.</p>
</div>
<div id="pu1" class="pu"><h2>SKI-calculus + C combinator, <s>36</s> 33 bytes</h2>
<pre><code>true=K
false=SK
not=C
and=SCI
or=SII
xor=C(CIC)I
implies=CCK
</code></pre>
<p>I don't actually know of any interpreter that allows you to define additional combinators in terms of previous ones, so I had to test this using <a href="http://ski.aditsu.net/" rel="nofollow noreferrer">http://ski.aditsu.net/</a> by pasting in the desired combinators e.g. <code>CCKK(SK)pq</code> outputs <code>q</code>, showing that <code>K</code> does not imply <code>SK</code>.</p>
<p>Edit: Saved 3 bytes thanks to @Bubbler.</p>
</div>
<div id="pu2" class="pu"><h1><a href="http://www.complang.tuwien.ac.at/forth/gforth/Docs-html/" rel="nofollow noreferrer">Forth (gforth)</a>, <strike>133 </strike> bytes - 7 = <strike>126</strike> 122</h1>

<pre class="lang-forth prettyprint-override"><code>: j execute ;
: t drop ;
: f nip ;
: n ['] f ['] t rot j ;
: a dup j ;
: o over j ;
: x 2dup a n -rot o a ;
: m over n -rot a o ;
</code></pre>
<p><a href="https://tio.run/##hY/NDsIgEITvPsXcsEm9eNRHUQ/Egta0bIPUtE9flz@jtlEOMAzf7C6arLtuLtof07TDDWpQ594p7Fc7OFSWuiA1TB2VwUGc@O53B0uOQ96XqPouaQI9lE2XAVv/Ijm58Tix9H4boeRK9vc8gXpNoNra4WyZFQPEyM2yE9YRzvZqPZQYi0Tob0LL5v6JCC5juAkyYsitfaFihgmuRxE9gmygylhyGZYZlqb6T5vIv9N@lphYjrS5Qd12Ta3uv5rokJolAlvi7cfTEw" rel="nofollow noreferrer" title="Forth (gforth) – Try It Online">Try it online!</a></p>
<p>-4 bytes thanks to Quuxplusone</p>
<p>Initially I significantly overthought this, considering things like macros and literals, but then I realized that if I define things in terms of true and false (like I should have done in the first place), it gets much simpler.</p>
<h3>Code explanation</h3>
<pre class="lang-forth prettyprint-override"><code>\ Helper function to save some bytes
: j        \ define a new word
  execute  \ execute the word at the provided address
;          \ end word definition

\ True
: t        \ define a new word
  drop     \ drop the second argument
;          \ end the word

\ False
: f        \ define a new word
  nip      \ drop the first argument
;          \ end the word

\ Not - The &quot;hardest&quot; one because we have to reference true and false directly
: n        \ define a new word
  ['] f    \ get address of false
  ['] t    \ get the address of true
  rot      \ stick the input boolean back on the top of the stack
  j        \ call the input boolean, which will select the boolean to return
;          \ end the word

\ And 
: a        \ define a new word
  dup      \ duplicate the 2nd input value
  j        \ call the 2nd input on the first and second input
;          \ end the word

\ Or
: o        \ define a new word
  over     \ duplicate the 1st input value
  j        \ call the 1st input on the first and second input
;          \ end the word

\ Xor
: x        \ define a new word
  2dup     \ duplicate both of the inputs
  a n      \ call and, then not the result (nand)
  -rot     \ move the result behind the copied inputs
  o a      \ call or on the original inputs, then call and on the two results
;          \ end the word

\ Implies
: m        \ define a new word
  over     \ duplicate the 1st input value
  n        \ call not on the 1st input value
  -rot     \ move results below inputs
  a o      \ call and on the two inputs, then call or on the two results
;          \ end the word
</code></pre>
</div>
<div id="pu3" class="pu"><h1><a href="https://github.com/catseye/Funge-98/blob/master/doc/funge98.markdown#funge-98-final-specification" rel="nofollow noreferrer">Befunge-98</a>, <s>105</s> <s>77</s> 65 bytes</h1>

<p>Playing further with the notion of "function" in languages without functions... here's a Befunge-98 version of Church booleans!</p>

<p>In this constrained dialect of Befunge-98, a program consists of a series of "lines" or "functions," each of which begins with a <code>&gt;</code>(Go Right) instruction in column x=0. Each "function" can be identified with its line number (y-coordinate). Functions can take input via Befunge's <em>stack</em>, as usual.</p>

<p>Line 0 is special, because (0,0) is the starting IP. To make a program that executes line L, just place instructions on line 0 that, when executed, fly the instruction pointer to (x=L, y=0).</p>

<p>The magic happens on line 1. Line 1, when executed, pops a number <code>L</code> from the stack and jumps to line number <code>L</code>. (This line had previously been <code>&gt; &gt;&gt;0{{2u2}2}$-073*-\x</code>, which can "absolute jump" to any line; but I just realized that since I know this line is pegged to line 1, we can "relative jump" <code>L-1</code> lines in a heck of a lot less code.)</p>

<p>Line 2 represents Church <code>FALSE</code>. When executed, it pops two numbers <code>t</code> and <code>f</code> from the stack and then flies to line number <code>f</code>.</p>

<p>Line 3 represents Church <code>TRUE</code>. When executed, it pops two numbers <code>t</code> and <code>f</code> from the stack and then flies to line number <code>t</code>.</p>

<p>Line 6, representing Church <code>XOR</code>, is innovative. When executed, it pops two numbers <code>a</code> and <code>b</code> from the stack, and then flies to line <code>a</code> with stack input <code>NOT EXEC b</code>. So, if <code>a</code> represents Church <code>TRUE</code>, the result of <code>a NOT EXEC b</code> will be <code>NOT b</code>; and if <code>a</code> represents Church <code>FALSE</code>, the result of <code>a NOT EXEC b</code> will be <code>EXEC b</code>.</p>

<hr>

<p>Here's the ungolfed version with test harness. On line 0, set up the stack with your input. For example, <code>338</code> means <code>IMPLIES TRUE TRUE</code>. Make sure the closing <code>x</code> appears at exactly (x,y)=(0,15) or else nothing will work! Also make sure your stack setup begins with <code>ba</code>, so that the program will actually terminate with some output.</p>

<p><a href="https://tio.run/##dZBda4MwFIbv9yteSi8iNGLUrl1wobJZKNgP1EIvRGhBy27aXSgoY7/daVaDY3rIRd4Dz5Nzckmz4nZN6cuSflbyWtcCuJxhWTZgZJSVTwJCMGqcaVyiX/7HLQXj8E7eGyk1ouu6hldc7/kdLTVNHDh9wFGUybF2/dAjuUYyRUrRIzZ8PE3wvyRvcUTBcQjPFW7Fo7jNsQ/akau/cNNptaovLeaAR1rmHLt91Nu8c8jVOtXDw@L5mOeZ4zQ2TvOARtqgRKYw7a@YFe0xLFp8J0q04HB378OiSo3VLTb0O7@eJcdme/A3Xjjq6u3WuCbeMYgms6ZWMoW@u5ZxtqrrHw" rel="nofollow noreferrer">Try it online!</a></p>

<pre><code>&gt;  ba 334  0f-1x
&gt; &gt;&gt;1-0a-\x             Line 1: EXEC(x)(...) = goto x
&gt; $^&lt; &lt;            &lt;    Line 2: FALSE(t)(f)(...) = EXEC(f)(...)
&gt; \$^                   Line 3: TRUE(t)(f)(...) = EXEC(t)(...)
&gt; 3\^                   Line 4: OR(x)(y)(...) = EXEC(x)(TRUE)(y)(...)
&gt; 3\2\^                 Line 5: NOT(x)(...) = EXEC(x)(FALSE)(TRUE)(...)
&gt; 1\5\^                 Line 6: XOR(x)(y)(...) = EXEC(x)(NOT)(EXEC)(...)
&gt; 2&gt;24{\1u\1u\03-u}^    Line 7: AND(x)(y)(...) = EXEC(x)(y)(FALSE)(...)
&gt; 3^                    Line 8: IMPLIES(x)(y)(...) = EXEC(x)(y)(TRUE)(...)

&gt; "EURT",,,,@
&gt; "ESLAF",,,,,@
</code></pre>

<hr>

<p>Here's the version whose bytes I counted.</p>

<pre><code>&gt;&gt;&gt;1-0a-\x
&gt;$^&lt;&lt; }u-30\&lt;
&gt;\$^
&gt;3\^\
&gt;3\2^
&gt;1\5^
&gt;2&gt;24{\1u\1u^
&gt;3^
</code></pre>

<p>Notice that to define a function in this dialect you don't mention its name at all; its "name" is determined by its source location. To call a function, you do mention its "name"; for example, <code>XOR</code> (<code>6</code>) is defined in terms of <code>NOT</code> and <code>EXEC</code> (<code>5</code> and <code>1</code>). But all my "function names" already take only one byte to represent. So this solution gets no scoring adjustments.</p>
</div>
<div id="pu4" class="pu"><h1><a href="https://github.com/tomtheisen/stax" rel="nofollow noreferrer">Stax</a>, 34 <a href="https://github.com/tomtheisen/stax/blob/master/docs/packed.md#packed-stax" rel="nofollow noreferrer">bytes</a></h1>

<pre><code>¿S£↓♣└²≡é♫Jíg░EèΩRΦ♂°┤rà╝¶πï╡^O|Θà
</code></pre>

<p><a href="https://staxlang.xyz/#p=a8539c1905c0fdf0820e4aa167b0458aea52e80bf8b47285bc14e38bb55e4f7ce985&amp;i=" rel="nofollow noreferrer">Run and debug it at staxlang.xyz!</a></p>

<p>Pushes a bunch of blocks to the stack. Each block expects its last argument atop the stack, followed in reverse order by the rest.</p>

<h3>Unpacked (41 bytes):</h3>

<pre><code>{sd}Y{d}{y{d}a!}X{ya!}{b!}{cx!sa!}{sx!b!}
</code></pre>

<p>Each pair of <code>{ }</code> is a block. I used the two registers X and Y to hold <code>true</code> and <code>not</code> so I could access 'em easily later. Unfortunately, <code>false</code> couldn't simply be a no-op, as that would leave the stack cluttered and mess up a single XOR case.</p>

<p><a href="https://staxlang.xyz/#c=%7Bsd%7DY%09%09false%0A%7Bd%7D%09%09true%0A%7By%7Bd%7Da%21%7DX%09not%0A%7Bya%21%7D%09%09and%0A%7Bb%21%7D%09%09or%0A%7Bcx%21sa%21%7D%09xor%0A%7Bsx%21b%21%7D%09%09implies%0A%0ALr%7E%09%09Put+in+a+list+in+the+input+stack%0A%0A%22false%3A+%22p%0A%3B0%40%09%09Push+false%0AOZ%21P%09%09Apply+to+1+and+0%3B+print%0ALrh%7E%09%09Clean+up+the+stack%0A%0A%22true%3A+%22p%0A%3B1%40%09%09Push+true%0AOZ%21P%09%09Apply+to+1+and+0%3B+print%0ALrh%7E%09%09Clean+up%0A%0A%22not%3A+%22p%0A%3B0%40%09%09Push+false%0A%3B2%40%21%09%09Apply+not%0AOZ%21p%09%09Apply+to+1+and+0%3B+print%0A%3B1%40%09%09Push+true%0A%3B2%40%21%09%09Apply+not%0AOZ%21P%09%09Apply+to+1+and+0%3B+print%0A%0A%22and%3A+%22p%0A%3B0%40%3B0%40%09%09Push+false+and+false%0A%3B3%40%21%09%09Apply+and%0AOZ%21p%09%09Apply+to+1+and+0%3B+print%0A%3B0%40%3B1%40%09%09Push+false+and+true%0A%3B3%40%21%09%09Apply+and%0AOZ%21p%09%09Apply+to+1+and+0%3B+print%0A%3B1%40%3B0%40%09%09Push+true+and+false%0A%3B3%40%21%09%09Apply+and%0AOZ%21p%09%09Apply+to+1+and+0%3B+print%0A%3B1%40%3B1%40%09%09Push+true+and+true%0A%3B3%40%21%09%09Apply+and%0AOZ%21P%09%09Apply+to+1+and+0%3B+print%0A%0A%22or%3A+%22p%0A%3B0%40%3B0%40%09%09Push+false+and+false%0A%3B4%40%21%09%09Apply+or%0AOZ%21p%09%09Apply+to+1+and+0%3B+print%0A%3B0%40%3B1%40%09%09Push+false+and+true%0A%3B4%40%21%09%09Apply+or%0AOZ%21p%09%09Apply+to+1+and+0%3B+print%0A%3B1%40%3B0%40%09%09Push+true+and+false%0A%3B4%40%21%09%09Apply+or%0AOZ%21p%09%09Apply+to+1+and+0%3B+print%0A%3B1%40%3B1%40%09%09Push+true+and+true%0A%3B4%40%21%09%09Apply+or%0AOZ%21P%09%09Apply+to+1+and+0%3B+print%0A%0A%22xor%3A+%22p%0A%3B0%40%3B0%40%09%09Push+false+and+false%0A%3B5%40%21%09%09Apply+xor%0AOZ%21p%09%09Apply+to+1+and+0%3B+print%0A%3B0%40%3B1%40%09%09Push+false+and+true%0A%3B5%40%21%09%09Apply+xor%0AOZ%21p%09%09Apply+to+1+and+0%3B+print%0A%3B1%40%3B0%40%09%09Push+true+and+false%0A%3B5%40%21%09%09Apply+xor%0AOZ%21p%09%09Apply+to+1+and+0%3B+print%0A%3B1%40%3B1%40%09%09Push+true+and+true%0A%3B5%40%21%09%09Apply+xor%0AOZ%21P%09%09Apply+to+1+and+0%3B+print%0A%0A%22implies%3A+%22p%0A%3B0%40%3B0%40%09%09Push+false+and+false%0A%3B6%40%21%09%09Apply+implies%0AOZ%21p%09%09Apply+to+1+and+0%3B+print%0A%3B0%40%3B1%40%09%09Push+false+and+true%0A%3B6%40%21%09%09Apply+implies%0AOZ%21p%09%09Apply+to+1+and+0%3B+print%0A%3B1%40%3B0%40%09%09Push+true+and+false%0A%3B6%40%21%09%09Apply+implies%0AOZ%21p%09%09Apply+to+1+and+0%3B+print%0A%3B1%40%3B1%40%09%09Push+true+and+true%0A%3B6%40%21%09%09Apply+implies%0AOZ%21P%09%09Apply+to+1+and+0%3B+print&amp;i=&amp;a=1" rel="nofollow noreferrer">Test suite, commented</a></p>

<pre><code>false
{sd}    stack:   x y
 s      swap:    y x
  d     discard: y

true
{d}    stack:   x y
 d     discard: x

not
{y{d}a!}    stack:  p
 y{d}       push:   p f t
     a      rotate: f t p
      !     apply:  p(f,t)

and
{ya!}    stack:  p q
 y       push:   p q f
  a      rotate: q f p
   !     apply:  p(q,f)

or
{b!}    stack:  p q
 b      copies: p q p q
  !     apply:  p q(q,p)

xor
{cx!sa!}    stack:  p q
 c          copy:   p q q
  x!        not:    p q nq
    s       swap:   p nq q
     a      rotate: nq q p
      !     apply:  p(nq,q)

implies
{sx!b!}    stack:  p q
 s         swap:   q p
  x!       not:    q np
    b      copies: q np q np
     !     apply:  q np(np,q)
</code></pre>
</div>
<div id="pu5" class="pu"><h1><a href="https://github.com/catseye/stringie" rel="nofollow noreferrer">Underload</a>, <s>56</s> 52 bytes</h1>

<pre><code>(~!)(!)((~)~*):((!)~^)*(:^)(~(!)~^(~)~*)(()~(~)~^~*)
</code></pre>

<p><a href="https://tio.run/##zZK9CsMgEMd3n8JuZ6DQdvQ1sguCtgSsFpNAp3t1m1y0ZGjqqpv@P@6HOntjowvapAR4Evy74HLW8cGnOFspesYkB37XbrQCgU4Fqh7YKsE@V4LkrSYBBXYlDVdK@jCV3EKE6ld8ETkciVu3BDKIbuu@Ubf2Zt9dH/DXQeIxR@mokYJU@QoyZYgNQiIZ8oNl0OH5coMdG6SFdc6yp9@Vad8N3mtKHw" rel="nofollow noreferrer" title="Underload – Try It Online">Try it online!</a> (includes a testsuite and text identifying parts of the program)</p>

<p>This scores surprisingly well for a very low-level esolang. (Church numerals, Church booleans, etc. are very commonly used in Underload for this reason; the language doesn't have numbers and booleans built in, and this is one of the easier ways to simulate them. That said, it's also common to encode booleans as the Church numerals 0 and 1.)</p>

<p>For anyone who's confused: Underload lets you define reusable functions, but doesn't let you name them in the normal way, they just sort of float around on the argument stack (so if you define five functions and then want to call the first one you defined, you need to write a new function that takes five arguments and calls the fifth of them, then call it with insufficiently many arguments so that it looks for spare arguments to use). Calling them destroys them by default but you can modify the call to make it non-destructive (in simple cases, you just need to add a colon to the call, although the complex cases are more common because you need to make sure that the copies on the stack don't get in your way), so Underload's function support has all the requirements we'd need from the question.</p>

<h2>Explanation</h2>

<h3>true</h3>

<pre><code>(~!)
(  )  Define function:
 ~      Swap arguments
  !     Delete new first argument (original second argument)
</code></pre>

<p>This one's fairly straightforward; we get rid of the argument we don't want and the argument we do want just stays there, serving as the return value.</p>

<h3>false</h3>

<pre><code>(!)
( )   Define function:
 !      Delete first argument
</code></pre>

<p>This one's even more straightforward.</p>

<h3>not</h3>

<pre><code>((~)~*)
(     )  Define function:
    ~*     Modify first argument by pre-composing it with:
 (~)         Swap arguments
</code></pre>

<p>This one's fun: <code>not</code> doesn't call its argument at all, it just uses a function composition. This is a common trick in Underload, in which you don't inspect your data at all, you just change how it functions by pre- and post-composing things with it. In this case, we modify the function to swap its arguments before running, which clearly negates a Church numeral.</p>

<h3>and</h3>

<pre><code>:((!)~^)*
 (     )   Define function:
     ~^      Execute its first argument with:
  (!)          false
               {and implicitly, our second argument}
        *  Edit the newly defined function by pre-composing it with:
:            {the most recently defined function}, without destroying it
</code></pre>

<p>The question permits defining functions in terms of other functions. We define "and" next because the more recently "not" has been defined, the easier it is to use it. (This doesn't subtract from our score, because we aren't naming "not" at all, but it saves bytes over writing the definition out again. This is the only time that one function refers to another, because referring to any function but the most recently defined would cost too many bytes.)</p>

<p>The definition here is <code>and x y = (not x) false y</code>. In other words, if <code>not x</code>, then we return <code>false</code>; otherwise, we return <code>y</code>.</p>

<h3>or</h3>

<pre><code>(:^)
(  )  Define function:
 :      Copy the first argument
  ^     Execute the copy, with arguments
          {implicitly, the original first argument}
          {and implicitly, our second argument}
</code></pre>

<p>@Nitrodon pointed out in the comments that <code>or x y = x x y</code> is normally shorter than <code>or x y = x true y</code>, and that turns out to be correct in Underload as well. A naive implementation of that would be <code>(:~^)</code>, but we can golf off an additional byte by noting that it doesn't matter whether we run the original first argument or the copy of it, the result is the same either way.</p>

<p>Underload doesn't actually support currying in the usual sense, but definitions like this make it look like it does! (The trick is that non-consumed arguments just stick around, so the function you call will interpret them as its own arguments.)</p>

<h3>implies</h3>

<pre><code>(~(!)~^(~)~*)
(           )  Define function:
 ~               Swap arguments
     ~^          Execute the new first (original second) argument, with argument:
  (!)              false
                   {and implicitly, our second argument}
       (~)~*     Run "not" on the result
</code></pre>

<p>The definition used here is <code>implies x y = not (y false x)</code>. If y is true, this simplifies to <code>not false</code>, i.e. <code>true</code>. If y is false, this simplifies to <code>not x</code>, thus giving us the truth table we want.</p>

<p>In this case, we're using <code>not</code> again, this time by rewriting its code rather than referencing it. It's just written directly as <code>(~)~*</code> without parentheses around it, so it gets called rather than defined.</p>

<h3>xor</h3>

<pre><code>(()~(~)~^~*)
(          )  Define function:
   ~   ~^       Execute the first argument, with arguments:
    (~)           "swap arguments"
 ()               identity function
         ~*     Precompose the second argument with {the result}
</code></pre>

<p>This time, we're evaluating only one of our two arguments, and using it to determine what to compose onto the second argument. Underload lets you play fast and loose with arity, so we're using the first argument to choose between two two-argument two-return functions; the argument swap that returns them both but in the opposite order, and the identity function that returns them both in the same order.</p>

<p>When the first argument is true, we therefore produce an edited version of the second argument that swaps its arguments before running, i.e. precompose with "swap arguments", i.e. <code>not</code>. So a true first argument means we return <code>not</code> the second argument. On the other hand, a false first argument means we compose with the identity function, i.e. do nothing. The result is an implementation of <code>xor</code>.</p>
</div>
<div id="pu6" class="pu"><h1><a href="https://www.wolfram.com/wolframscript/" rel="nofollow noreferrer">Wolfram Language (Mathematica)</a>, 61-7=54 bytes</h1>

<pre><code>t=#&amp;
f=#2&amp;
a=#2~#~f&amp;
o=t~#~#2&amp;
n=f~#~t&amp;
x=n@#~#2~#&amp;
i=#2~#~t&amp;
</code></pre>

<p><a href="https://tio.run/##VcyxCsMgEAbg3aeQBJwc2o4BoUufQhwkreQGvVJuEEp9daOEJpfluPvv54uellf0BLOvlcyoRDDjTQnfZhlLUAINtaVnyYS2kRLZpHuPSqvDViRVH/OC9utt0MHZq744LftBx0H8Q//PT8vBp@ckByc2A7mB3EBu4NnAzyQPI3MjcyNzI5@N3JHdAG4AN4AbcDYgvpmR7N5LlrUSUm/VFQ" rel="nofollow noreferrer" title="Wolfram Language (Mathematica) – Try It Online">Try it online!</a></p>

<p>un-golfed: inspired by <a href="https://en.wikipedia.org/wiki/Church_encoding#Church_Booleans" rel="nofollow noreferrer">Wikipedia</a>,</p>

<pre><code>t[x_, y_] := x
f[x_, y_] := y
and[x_, y_] := x[y, f]
or[x_, y_] := x[t, y]
not[x_] := x[f, t]
xor[x_, y_] := y[not[x], x]
imply[x_, y_] := x[y, t]
</code></pre>
</div>
<div id="pu7" class="pu"><h1>C++17, <s>202&minus;49=153</s> 193 &minus; 58 = 135 bytes</h1>

<p>Inspired by the comment-discussion of what counts as a 2-ary function anyway, here's a <a href="https://en.wikipedia.org/wiki/Currying" rel="nofollow noreferrer">curried</a> version of my previous C++17 solution. It's actually shorter because we can use the same macro to define <code>not_</code> as to define all the other functions!</p>

<pre><code>#define D(v,p)auto v=[](auto x){return[=](auto y){return p;};};
D(true_,x)
D(false_,y)
D(not_,x(false_)(true_)(y))
D(and_,x(y)(false_))
D(or_,x(true_)(y))
D(xor_,x(not_(y))(y))
D(implies,x(y)(true_))
</code></pre>

<p><a href="https://tio.run/##nZNBj4MgEIXv/RUke5BJ28Oe9tB489iT16ZpCGJDYtEINpimf31ZEE271u2i8YJv3pvhA6VVtaUFEWdjPjKWc8FQgq@bCkijSnSND0fcrTTcaqaaWhziXmkHBVW7u31WCVZ1w04bDQnOSSHtsrVLUSqr9Qp4D@AWbImIzJVaGKpWK2snPbu0l1wfJ3iRX6qCM@nT3g1GKqI4PREpWa1wtI9QHKOu6F4AR2kEsFuNbGln8zv45Zs2dvvo9/em6/5hHtDf9fZ2dyBD7/9HpC@ZqUl/h0ZXMi8UDmWvL5zpJRKA9MjMJXrOhAD5lF5ApJcg6SVMei6Un9X/UHO/vlEsGG3IhdNN5yYBuVDoQrjAgG53803zgpyl2UqVxXS9/vz6AQ" rel="nofollow noreferrer">Try it online!</a></p>

<p>This one is tested with assertions like</p>

<pre><code>static_assert('R' == and_(true_)(false_)('L')('R'));
static_assert('L' == or_(true_)(false_)('L')('R'));
</code></pre>

<p>Notice that <code>or_</code> is defined as effectively</p>

<pre><code>auto or_=[](auto x){return[=](auto y){return x(true_)(y);};};
</code></pre>

<p>We could define <code>or_</code> more "concisely" as</p>

<pre><code>auto or_=[](auto x){return x(true_);};
</code></pre>

<p>but that would cost us because we wouldn't get to use the <code>D</code> macro anymore.</p>
</div>
<div id="pu8" class="pu"><h1>C++17, <s>207&minus;49=158</s> 195 &minus; 58 = 137 bytes</h1>

<p>The linebreaks are unnecessary (other than the first two).</p>

<pre><code>#define A auto
#define D(v,p)A v=[](A x,A y){return p;};
D(true_,x)
D(false_,y)
A not_=[](A f){return f(false_,true_);};
D(and_,x(y,false_))
D(or_,x(true_,y))
D(xor_,x(not_(y),y))
D(implies,x(y,true_))
</code></pre>

<p><a href="https://tio.run/##nZOxboMwEIZ3nuKkDtgKGTp1QAxIjJlYqwpZYCJLxFjYREZRXr3UYGjahKaGDZ//784fhlyIfV4Rfuz7l4KWjFOIgbSq9uZlgs6BwDGco/cPFIMOYujwpaGqbTiI8Bp6CVJNS7NA4wSVpJLmsTMAr1VmmfI7X86BkcCGThDhhWFRF9gtbLrUzVCxXbuhoG1laIk6bGvsJCpG5YjadriXiiiWZ0RK2ijkH3yIIhg3h0UAfupjHHp3sXSM2fG/csvB8RR24rOuh1t4Mnva28aHlzGJw/8j0gdmadLf0HQZ6ybNkLuUuTx3pwfEQenGrDX6ybgIWUpvMNJblPQWJ71Wys6a/qe1X98d5qw2c@52y9yiIOMKToRxhOFy7T/zsiJH2e@lKqJ8t3t9@wI" rel="nofollow noreferrer">Try it online!</a></p>

<p>Unit-tested with assertions such as:</p>

<pre><code>static_assert('L' == true_('L', 'R'));
static_assert('R' == not_(true_)('L', 'R'));
static_assert('L' == and_(true_, true_)('L', 'R'));
static_assert('L' == or_(true_, true_)('L', 'R'));
static_assert('R' == xor_(true_, true_)('L', 'R'));
static_assert('L' == implies(true_, true_)('L', 'R'));
</code></pre>

<p>UPDATED: formerly I'd had</p>

<pre><code>A not_=[](A f){return[f](A x,A y){return f(y,x);};};
</code></pre>

<p>but <a href="https://codegolf.stackexchange.com/a/190398/11791">Roman's answer</a> pointed the way to the shorter version. Notice that now <code>not_(std::plus&lt;&gt;)</code> is ill-formed, where formerly it was equivalent to <code>std::plus&lt;&gt;</code>; but since <code>std::plus&lt;&gt;</code> doesn't "represent a Church boolean," I think either behavior is okay by the rules.</p>
</div>
<div id="pu9" class="pu"><h1><a href="https://github.com/nxadm/rakudo-pkg" rel="nofollow noreferrer">Perl 6</a>, <s>120</s> <s>106</s> <s>102</s> 101 bytes</h1>

<p><em>-1 byte thanks to Jo King</em></p>



<pre class="lang-perl6 prettyprint-override"><code>my (\t,\f,&amp;n,&amp;a,&amp;o,&amp;i,&amp;x)={@_[0]},{@_[1]},|&lt;f,t &amp;^v,f t,&amp;^v &amp;^v,t n(&amp;^v),&amp;v&gt;&gt;&gt;.&amp;{"&amp;\{\&amp;^u($_)}".EVAL}
</code></pre>

<p><a href="https://tio.run/##bY/NasMwEITP1lMsxmxk2Jr20kN@THJoTj2GXqommDQLhkQKjhocFD@7K9kkNSWnmZ2P0aDjrtq/tu3hAlJZUkyoCQtCQ1gS1unMzTefz18NBX3xep0yWcD1mRgsee28BS29poTnPM8zdDEqp3D9I5NN2sTZ28fivQkryWoJM7hOV7DMJ0KcigvEdgwObCY9S6GJJ33KIeX/qTZW2nQMqL10bEi4J3wngk0lolGhv0cE/l/emypYE2x5OO7L3SncZbjrntXiKYdEe7cFF4moez7RSlrqprfewN/6kPOd8wPOtz4/7vOtz8N@0/4C" rel="nofollow noreferrer" title="Perl 6 – Try It Online">Try it online!</a></p>
</div>
<div id="pu10" class="pu"><h1><a href="https://tromp.github.io/cl/cl.html" rel="nofollow noreferrer">Binary Lambda Calculus</a>, <strike>13.875</strike> 12.875 bytes (103 bits)</h1>

<p>Binary Lambda Calculus Language (BLC) by John Tromp is basically an efficient serialization format for lambda calculus. It is a great fit for this task, as Church notation is even the "idiomatic" way to work with booleans in BLC.</p>

<p>I used the following lambda functions for the combinators, <strike>some of which I copied and golfed from the Haskell answer:</strike>, which were found by an exhaustive search with a proof limit of 20 β-reductions for each case. There is a good chance these are shortest possible.</p>

<pre><code>True:  (\a \b a)
False: (\a \b b)
Not:   (\a \b \c a c b)
And:   (\a \b b a b)
Or:    (\a a a)
Xor:   (\a \b b (a (\c \d d) b) a)
Impl:  (\a \b a b (\c \d c))
</code></pre>

<p>These translate to the following (binary) BLC code sequences:</p>

<pre><code> bits |  name | BLC
------+-------+---------
    7 | True  | 0000 110
    6 | False | 0000 10
   19 | Not   | 0000 0001 0111 1010 110
   15 | And   | 0000 0101 1011 010
    8 | Or    | 0001 1010
   28 | Xor   | 0000 0101 1001 0111 0000 0101 0110
   20 | Impl  | 0000 0101 1101 0000 0110
</code></pre>

<p>Functions above are in total <strike>111 bits long (13.875 bytes)</strike> 103 bits long (12.875 bytes). They don't need to be aligned to byte boundaries to be used inside a program, so it makes sense to count fractional bytes. </p>

<p>There is no code re-use between the combinators, because there are no variables/references/names in BLC - everything had to be copied over. Still, the efficiency of the encoding makes for quite a terse representation.</p>
</div>
<div id="pu11" class="pu"><h1><a href="http://julialang.org/" rel="nofollow noreferrer">Julia 1.0</a>, 36 bytes</h1>



<pre class="lang-julia prettyprint-override"><code>(b::Bool)(x,y)=b ? x : y;i(x,y)=!x|y
</code></pre>

<p>I don't know if that counts, I'm actually just overloading the native <code>Bool</code> type to be callable, so I get most of the logic gates for free. Unfortunately, Julia doesn't have an <code>implies</code> gate, so I had to write my own function.</p>

<p><a href="https://tio.run/##yyrNyUw0rPj/XyPJysopPz9HU6NCp1LTNknBXqFCwUqh0joTIqBYUVP5v6AoM68kJ0@jpKg0VcOqQkfBqlJTkwsmmpaYU4xFWEMRpFwTiwRIXKFGAawPp7waQXlFXAoywSp0cEuDZXRQnfcfAA" rel="nofollow noreferrer" title="Julia 1.0 – Try It Online">Try it online!</a></p>
</div>
<div id="pu12" class="pu"><h1><a href="https://github.com/dzaima/APL" rel="nofollow noreferrer">APL (dzaima/APL)</a>, 47 <a href="https://codegolf.meta.stackexchange.com/a/9429/43319" title="When can APL characters be counted as 1 byte each?">bytes</a><sup><a href="https://github.com/abrudz/SBCS" rel="nofollow noreferrer" title=".dyalog files using a single byte character set">SBCS</a></sup></h1>



<p>Based on <a href="https://codegolf.stackexchange.com/a/190379/43319">Jonah's J solution</a>.</p>

<p><code>true</code> and <code>false</code> are infix functions, <code>not</code> is a suffix operator, and the rest are infix operators.</p>

<pre class="lang-apl prettyprint-override"><code>true←⊣
false←⊢
and←{⍺(⍶⍹false)⍵}
not←⍨
or←{⍺(true⍶⍹)⍵}
xor←{⍺(⍶not⍹⍶)⍵}
implies←{⍺(⍹⍶true)⍵}
</code></pre>

<p>As per OP, this counts everything from and including <code>←</code> to the end of each line, and counts each call a previous definition as a single byte.</p>

<p><a href="https://tio.run/##dZFNDsIgEIX3nKI7dNELeBuS1oSkLQ2tCWrcujAh8Qy68QKa1ONwEHGA/gDibnjvm/cmgbRVXhwIrYnWPd@V6nxVlzvakqpz8w2RpoDpqOR7peRLycGaayWfJ9Sw3lDygRifIBtjQceIxQLZbMgBBmfSuq1o2S2AsUyCtbXGZs7ghMy2bjDCAmdWxHv3sIZ7AecTZi1Aw7Ao4YdeZA@H@/0KeEb8rDDug4wnTgExdUnMzqoPh/EimS/@FIh0Q4SPf@PXjFKianJSdcmt0JrXPqztKWs6nXdf" rel="nofollow noreferrer" title="APL (dzaima/APL) – Try It Online">Try it online!</a></p>

<p>true and false are the left and right identity functions.</p>

<p><code>not</code> simply swaps the arguments of its operand function.</p>

<p>The rest implement the decision tree:</p>

<p><code>and</code> uses the righthand function <code>⍹</code> to select the result of the lefthand function <code>⍶</code> if true, else the result of the <code>false</code> function.</p>

<p><code>or</code> uses the lefthand function <code>⍶</code> to select the <code>true</code> if true, else the result of the righthand function <code>⍹</code>.</p>

<p><code>xor</code> uses the righthand function <code>⍹</code> to select the the negated result of the lefthand function <code>⍶not</code> if true, else the result of the lefthand function.</p>

<p><code>implies</code> uses the lefthand function <code>⍶</code> to select the result of the righthand function <code>⍹</code> if true, else the result of the <code>true</code> function.</p>
</div>
<div id="pu13" class="pu"><h1>Java 8, score: <s>360</s> <s>358</s> <s>319</s> <s>271</s> 233 (240-7) bytes</h1>

<pre class="lang-java prettyprint-override"><code>interface J&lt;O&gt;{O f(O x,O y,J...j);}J t=(x,y,j)-&gt;x;J f=(x,y,j)-&gt;y;J n=(x,y,j)-&gt;j[0].f(y,x);J a=(x,y,j)-&gt;j[0].f(j[1].f(x,y),y);J o=(x,y,j)-&gt;j[0].f(x,j[1].f(x,y));J x=(x,y,j)-&gt;j[0].f(j[1].f(y,x),j[1].f(x,y));J i=(x,y,j)-&gt;j[0].f(j[1].f(x,y),x);
</code></pre>
<p><s>This was trickier to accomplish than I thought when I started it.. Especially the <code>implies</code>. Anyway, it works.. Can probably be golfed a bit here and there.</s> EDIT: Ok, not re-using functions but just duplicating the same approach is a lot cheaper in terms of byte-count for Java.. And I get the full -7 bonus for not using any of the functions as well.</p>
<p><a href="https://tio.run/##rZBBa4MwGIbv/RUfngyk2Xada6E7DCZsHrrDoPSQtcmI00Q0dhHxt7vYS7eJ2pSGQPySx3zvk5ge6Dzef7W7hBYFvFAh61ZIzXJOdwzCh2hZR8D9CAyOoMIhISRGQROCXvgGVzhG86UJQuCnsrKlPJXx5nZLuF9hg@wB7R3Em7tusbvITouoHmLwL6hDzNAtXZf/sBhtaVO1AFn5kYgdFJpquxyU2ENq38Jf61zIz80WKKpnYEf3QpAuJPs@fvooOG6vq0KzlKhSk8z@oRPpe295yW6eaFKwe/CGuZRom8Vbedh79NAYx8/iRhK9Kj0RRZ5aYBsMnc/yyyKt5H4iEv0baTJWn@cOPHe8n1@uHuUT5srRXDmaK0dzdS3zdzWlbhzVjaO6cVQ311J/TrNEsGJCXzjqC0d94agvhvSbWdP@AA" rel="nofollow noreferrer">Try it online.</a></p>
<p><strong>Explanation:</strong></p>
<pre class="lang-java prettyprint-override"><code>// Create an interface J to create lambdas with 2 Object and 0 or more amount of optional
// (varargs) J lambda-interfaces, which returns an Object:
interface J&lt;O&gt;{O f(O x,O y,J...j);}

// True: with parameters `x` and `y`, always return `x`
J t=(x,y,j)-&gt;x;
// False: with parameters `x` and `y`, always return `y`
J f=(x,y,j)-&gt;y;

// Not: with parameters `x`, `y`, and `j` (either `t` or `f`), return: j(y, x)
J n=(x,y,j)-&gt;j[0].f(y,x);

// And: with parameters `x`, `y`, and two times `j` (either `t` or `f`), return:
//      j1(j2(x,y), y);
J a=(x,y,j)-&gt;j[0].f(j[1].f(x,y),y);

// Or: with parameters `x`, `y`, and two times `j` (either `t` or `f`), return:
//     j1(x, j2(x,y))
J o=(x,y,j)-&gt;j[0].f(x,j[1].f(x,y));

// Xor: with parameters `x`, `y`, and two times `j` (either `t` or `f`), return:
//      j1(j2(y,x), j2(x,y))
J x=(x,y,j)-&gt;j[0].f(j[1].f(y,x),j[1].f(x,y));

// Implies: with parameters `x`, `y`, and two times `j` (either `t` or `f`), return:
//          j1(j2(x,y), x)
J i=(x,y,j)-&gt;j[0].f(j[1].f(x,y),x);
</code></pre>
</div>
<div id="pu14" class="pu"><h1><a href="https://docs.python.org/2/" rel="noreferrer">Python 2</a>, (-3?) <s> 101 </s> 95 bytes</h1>
<p><a href="https://www.youtube.com/watch?v=pkCLMl0e_0k" rel="noreferrer" title="YouTube: Lambda Calculus from the Ground Up - PyCon 2019">David Beazley</a> eat your heart out!</p>
<p>-6 thanks to Chas Brown (moved the repeated <code>:</code> into the join text &gt;.&lt;)</p>

<pre class="lang-python prettyprint-override"><code>exec'=lambda x,y=0:'.join('F y;T x;N x(F,T);A x(y,F);O x(T,y);X x(N(y),y);I O(y,N(x))'.split())
</code></pre>
<p><strong><a href="https://tio.run/##lZExb4MwEIV3fsVt51OtKOkIYsiClAUWhgyVIpqahAoMoiTCv56eQ5zWTdSqN51833vPZ3dmOLb6eZrUqPYY10Xz@lbAKE28DHHx3lZaYAImymGMUhhFInOK1twYmVCUcZNLQ9GWm1QYsv0GMp6mYiTCxUdXV4Mgmsq2B100CioNbIkSMEcKA@AqT3oPMahzUQvL0OW06ys9zJonwJAVlhMruSQWv2gMghnBNMTA@hf94dQoPexcECY5zhFu5GI89HueN5CQ3ki6JLtIDvc3Wmfbzf/2mVE2qVU57H65uy2Pcd73QroJrHFfHY5/OtvyQWf/QE6ebN7o/hbyUfL1@zz6J3h94y9vfufpEw" rel="noreferrer" title="Python 2 – Try It Online">Try it online!</a></strong></p>
<p>I think it might be <code>95 - 3</code> because I don't reuse the functions <code>A</code>, <code>X</code>, or <code>I</code>, but I use a single <code>=</code> for assignment (in front of <code>lambda</code>). Maybe I cant remove any; maybe I even get to remove 3.5?</p>
</div>
<div id="pu15" class="pu"><h1><a href="https://www.ruby-lang.org/" rel="nofollow noreferrer">Ruby</a>, 82 - 4 = 78 bytes</h1>



<pre class="lang-ruby prettyprint-override"><code>f,t,a,n,i,o,x=%w(y:y x:x f:y t:f t:y y:t y:n[y]).map{|s|eval"-&gt;x,y=0{x==f ?#{s}}"}
</code></pre>

<p><a href="https://tio.run/##VYjBCgIxDETvfkVYERSirNdC9UNCDxUMCNotblcTuv32WhEFD29m3tynk9bKmNBjwAsOKHb1XKtRECPArZPhhoKa1AikbrO7@ZjncT4//LXbHgTV9lmsZTgu81hKV2oEph73bhHBU0J2Xxv@LFD6baFA7PAdn6@@AA" rel="nofollow noreferrer" title="Ruby – Try It Online">Try it online!</a></p>
</div>
<div id="pu16" class="pu"><h1><a href="https://nodejs.org" rel="nofollow noreferrer">JavaScript (Node.js)</a>, <s>92</s> <s>86</s> 83 - 7 = 76 bytes</h1>



<pre class="lang-javascript prettyprint-override"><code>t=p=&gt;q=&gt;p
f=t(q=&gt;q)
n=p=&gt;p(f)(t)
a=p=&gt;n(p)(f)
o=p=&gt;p(t)
x=p=&gt;p(n)(f())
i=p=&gt;n(p)(t)
</code></pre>

<p><a href="https://tio.run/##hY3RDoIwDEXf9xXEpzVRP0Ay/mUq1RmyDpi6v8cCESgh4aW57b2352U/tr01LsSTp3vZddEEU9SmCApN1CxqUL6/BY2gIyjbL14H4F3R6PA5jcrzWQMoN6UidO2TvuZqihv5lqryXNFDX3Vs3iWnbdWWXFh6h3iAXPUtbufSwsnCteUvWcyzOeC5PWuEdd5y/thXeCIXB81z/mD5w@LJsOJiRekibFBol0KSQpJCkkLblLRLSZKSJCVJStqmuF2KkxQnKU5S3J/S/QA" rel="nofollow noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a> Link includes basic test cases. Edit: Saved <s>6</s> 9 bytes thanks to @tsh.</p>
</div>
<div id="pu17" class="pu"><h1><a href="https://www.haskell.org/" rel="noreferrer">Haskell</a>, 50 - 6 = 44 bytes</h1>

<p><em>-1 byte thanks to Khuldraeseth na'Barya, and -1 byte thanks to Christian Sievers.</em></p>



<pre class="lang-hs prettyprint-override"><code>t=const
f=n t
n=flip
a=n n f
o=($t)
x=(n&gt;&gt;=)
i=o.n
</code></pre>

<p><a href="https://tio.run/##bcwxDsIwDIXh3afw0KFdEBzAvUsEWFgEu6IZcvtQKiFV5I3v6df3SOvznnNrRa7hayEV50Iumm2htA1npZBxKBNVGX2eZSKTOHl7JXO5BRHz8jYvPHDhC58PW/d9OLxLvI/SFv1n30@7T0GnPRgADAAGAAOBFYAVgBWAFYEGQAOgAdB@YPsA" rel="noreferrer" title="Haskell – Try It Online">Try it online!</a></p>
</div>
<div id="pu18" class="pu"><h1><a href="https://docs.python.org/2/" rel="nofollow noreferrer">Python 2</a>, <s>133 - 6 = 127</s> 94 bytes</h1>



<pre class="lang-python prettyprint-override"><code>exec"t!u;f!v;n!u(f,t);a!u(v,f);o!u(t,v);x!u(n(v),v);i!o(v,n(u))".replace('!','=lambda u,v=0:')
</code></pre>

<p><a href="https://tio.run/##dc5BDsIgEAXQvaco3cAkxFSXkh4GKxNJKpAGCJ4eaXRRHbv78/l5ITzj3btzraaYqY8sKWRZOZYEyghKt5AlgvItRJlBlRacyLBmy3x7dSIB9MfFhFlPRnDGJR9n/bjedJdkHocLhxoW62IXxUkOcHgfuDk@lRMRthMnEOhKt59879YGfxokG5T/NE80TzRPNL@jFaIVohWilR3NEs0SzRLNEq2@AA" rel="nofollow noreferrer" title="Python 2 – Try It Online">Try it online!</a></p>

<p>Shamelessly stealing the sneaky idea behind <a href="https://codegolf.stackexchange.com/a/190361/69880">Jonathan Allan's</a> answer; no bytes deducted though.</p>
</div>
<div id="pu19" class="pu"><h1><a href="http://jsoftware.com/" rel="nofollow noreferrer">J</a>, 67 bytes - 7 = 60</h1>

<pre><code>t=.[
f=.]
n=.~
a=.2 :'u v]'
o=.2 :'[u v'
x=.2 :'u~v u'
i=.2 :'v u['
</code></pre>

<p><a href="https://tio.run/##fZC9DsMgDIR3P4U3JwtDx0q8QaesKENU1QodwkIiprw6jaBJ84O7IHzH8R28Y/RaGWCtWhi0mqHT6oZ3GnFqCVwezDIRhK8zTzgS2Dwte0Px9ewd0oNQp9UjNQRZbFaRk3hWK49DvTu@3VHxalwcjx36usRIFpctllP8SxVg7hg7WiyVdzLMnWD7@kGGBRkWZFj48zIrf6OVYVaqyFsqfgA" rel="nofollow noreferrer" title="J – Try It Online">Try it online!</a></p>

<p>Worth noting:</p>

<p>Higher order functions work differently in J than in a functional language.  To create a new verb from 1 or 2 existing verbs, you need to use either an adverb (in the case of 1) or a conjunction (in the case of 2).</p>

<p>Syntactically, adverbs come after a verb, and conjunctions go between them.  Thus to "not" a verb <code>f</code> you do <code>f n</code>, and to "and" verbs <code>f</code> and <code>g</code>, you <code>f a g</code>.</p>
</div>
<!-- TYYY -->

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/190325/">190325</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




