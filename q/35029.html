<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::35029</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>495</td><td>C</td><td>140919T022935Z</td><td><a href="https://codegolf.stackexchange.com/questions/35029/write-an-interpreter-for-my-esoteric-language-jumper/37962#37962">Jerry Je</a></td></tr>
<tr d-ix="1"><td>345</td><td>Perl 5 F</td><td>200205T063013Z</td><td><a href="https://codegolf.stackexchange.com/questions/35029/write-an-interpreter-for-my-esoteric-language-jumper/198967#198967">Xcali</a></td></tr>
<tr d-ix="2"><td>420</td><td>Ruby 2</td><td>140728T022051Z</td><td><a href="https://codegolf.stackexchange.com/questions/35029/write-an-interpreter-for-my-esoteric-language-jumper/35254#35254">Scott Le</a></td></tr>
<tr d-ix="3"><td>584</td><td>Haskell</td><td>140730T231413Z</td><td><a href="https://codegolf.stackexchange.com/questions/35029/write-an-interpreter-for-my-esoteric-language-jumper/35434#35434">Matt Noo</a></td></tr>
<tr d-ix="4"><td>nan</td><td>Haskell an ungodly amount of characters</td><td>140728T221653Z</td><td><a href="https://codegolf.stackexchange.com/questions/35029/write-an-interpreter-for-my-esoteric-language-jumper/35299#35299">Fors</a></td></tr>
<tr d-ix="5"><td>582</td><td>Groovy</td><td>140728T134330Z</td><td><a href="https://codegolf.stackexchange.com/questions/35029/write-an-interpreter-for-my-esoteric-language-jumper/35277#35277">markusw</a></td></tr>
<tr d-ix="6"><td>447</td><td>Ruby</td><td>140726T211624Z</td><td><a href="https://codegolf.stackexchange.com/questions/35029/write-an-interpreter-for-my-esoteric-language-jumper/35191#35191">Martin E</a></td></tr>
<tr d-ix="7"><td>465</td><td>CoffeeScript</td><td>140726T193821Z</td><td><a href="https://codegolf.stackexchange.com/questions/35029/write-an-interpreter-for-my-esoteric-language-jumper/35178#35178">soktinpk</a></td></tr>
<tr d-ix="8"><td>519</td><td>Javascript</td><td>140726T114402Z</td><td><a href="https://codegolf.stackexchange.com/questions/35029/write-an-interpreter-for-my-esoteric-language-jumper/35167#35167">tomsmedi</a></td></tr>
<tr d-ix="9"><td>577</td><td>Clojure</td><td>140725T201802Z</td><td><a href="https://codegolf.stackexchange.com/questions/35029/write-an-interpreter-for-my-esoteric-language-jumper/35117#35117">seequ</a></td></tr>
<tr d-ix="10"><td>729</td><td>Python</td><td>140724T180818Z</td><td><a href="https://codegolf.stackexchange.com/questions/35029/write-an-interpreter-for-my-esoteric-language-jumper/35033#35033">arshajii</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>C 495</h1>
<p><strong>Edits:</strong></p>
<ul>
<li><strong>Thanks to @Dennis it is now much shorter (and works in GCC to boot)</strong></li>
<li><strong>Thanks to @S.S.Anne for suggesting abort()</strong></li>
<li><strong>Thanks to @ceilingcat for some very nice pieces of golfing - now even shorter</strong></li>
</ul>
<p>The golfed version</p>
<pre><code>#define M R=realloc(R,r+Q),bzero(R+r,Q),r+=Q
#define J z&lt;0?abort(),0:z&gt;r
#define G J||R[z]
#define P J?M:0,R[z]
#define O!C[1]?1:V;I
#define I;if(*C==58
#define W;while(*p&amp;*p&lt;33)p++
Q=1024;char*R,C[999][9],*p,*q,*o;r,z,c,V;E(char*C){I+5)G&amp;&amp;E(C+1);else{V=atoi(C+1)I-23)z=V;I+4)z+=O+2)z-=O+3)P=V;V--I-25)P=G+O-13)P=G-O)c=V;}}main(u,v)int**v;{M;for(o=v[u-3||strcpy(R,v[2])];*o;bcopy(p,q,o-p)){p=o;q=C[c++]W;if((*q++=*p++)==63){W;*q++=*p++;}W;strtol(p,&amp;o,0);}for(c=*C[c]=0;*C[c];)E(C[c++]);puts(R);}
</code></pre>
<p><a href="https://tio.run/##VZDBjtowEIbv@xSpKiGP7UhxAu0Gr@EQrRBIiCUHOEQ5BG/YjURxMIGqCTx7OkHdSL3MeL759XtmtPuhddt@f8/3xTF3lk6sbJ4dDkaTmFu2Br6rc2tIzCzHwjK1fvoSL5z6xZtmO2MrAtwb1xPb92bO4naLkzrtyZuzmC7HHv8Prr5FiUinYryR8x7OZbEnNFJq9Nyzrfz9WRxyQssBLV@CAErGntZKeP5Q6s/M0phHSRiGaRKmnJacnjg10vKaa76Rr@ShiaCZsxHMBoNXEjEBMj@c82ajssoUDzB3/QBqhcOwIdRMrZgPtYspgDekG9dFxQjfM7ZyRQdn7go0tu73X1lxJBd@heJYUXqVzVLujSVGXZOLG9xu58rq8g9e9Zr4KaQSx9tpg6TkJ27cEqAplZEnFSWasXTbHYHQE2OK4q6g1I8Amq3sibxvJXpW5oAOA8M9kPfuQ60oOqTKk48sAXd9OIIsL9WZxKhr21b99Cd4PtGF568gsAw6LsJ/lRDDXuFhM5iovw" rel="nofollow noreferrer" title="C (gcc) – Try It Online">Try it online!</a></p>
<p>A slightly less golfed version of my original program:</p>
<pre><code>#include&lt;stdlib.h&gt;
#include&lt;memory.h&gt;
#include&lt;string.h&gt;
#include&lt;stdio.h&gt;
#define CHAR_STAR char*
#define CASTED_R (CHAR_STAR)RAM
#define UNSIGNED_CHAR unsigned char
#define INCREASE_MEMORY RAM=(UNSIGNED_CHAR*)realloc(CASTED_R,RAM_size+1024),memset(CASTED_R+RAM_size,0,1024),RAM_size+=1024
#define IF_ERROR current&lt;0?exit(puts(&quot;!&quot;)),0:current&gt;RAM_size?
#define GET_CELL IF_ERROR 0:RAM[current]
#define PUT_CELL(x) IF_ERROR INCREASE_MEMORY,RAM[current]=x:RAM[current]=x;
#define ONE_IF_EMPTY !*(command+1)?1:
#define VALUE atoi(command+1)
#define REMOVE_WHITESPACE while (*pointer&amp;&amp;*pointer&lt;33)pointer++;
#define COPY_CHAR (*command++ = *pointer++)
#define RETURN return
char commands[999][9];
UNSIGNED_CHAR*RAM = 0;
int RAM_size = 0, current = 0, command_size = 0;
CHAR_STAR get_command(CHAR_STAR a)
{
    CHAR_STAR pointer = a, *command = commands[command_size++], *next;
    REMOVE_WHITESPACE
    if (COPY_CHAR == '?')
    {
        REMOVE_WHITESPACE
        COPY_CHAR;
    }
    REMOVE_WHITESPACE
    int i = strtol(pointer, &amp;next, 0);
    memcpy(command, pointer, next - pointer);
    command[next - pointer] = 0;
    RETURN next;
}
void eval(CHAR_STAR command){
    if (*command == '?')RETURN GET_CELL ? eval(command + 1) : 0;
    if (*command == '#')current = VALUE;
    if (*command == '&gt;')current += ONE_IF_EMPTY VALUE;
    if (*command == '&lt;')current -= ONE_IF_EMPTY VALUE;
    if (*command == '=')PUT_CELL(VALUE)
    if (*command == '+')PUT_CELL(GET_CELL + ONE_IF_EMPTY VALUE - 1)
    if (*command == '-')PUT_CELL(GET_CELL - ONE_IF_EMPTY VALUE - 1)
    if (*command == ':')command_size = VALUE - 1;
}
int main(int argc, CHAR_STAR *argv)
{
    INCREASE_MEMORY;
    argc == 3 ? strcpy(CASTED_R, argv[2]) : 0;
    CHAR_STAR command = argv[1];
    while (*command) command = get_command(command);
    *commands[command_size] = 0; command_size = -1;
    while (*commands[++command_size]) eval(commands[command_size]);
    RETURN puts(CASTED_R);
}
</code></pre>
</div>
<div id="pu1" class="pu"><h1><a href="https://www.perl.org/" rel="nofollow noreferrer">Perl 5</a> <code>-F</code>, 345 bytes</h1>



<pre class="lang-perl prettyprint-override"><code>$#F--;$_=&lt;&gt;;s/\(.*?\)|\s*([+&lt;&gt;#=:?-])\s*/$1/g;die'Error'if/[^+&lt;&gt;#=?:0-9-]/+/\?\d/;s/[&gt;&lt;+-]\K(?=\D|$)/1/g;s/[#=:]\K(?=\D|$)/0/g;map$_=ord,@F;@c=/.*?\d+/g;while($l&lt;@c){$_=$c[$l++];s/\?//*!$F[$p]&amp;&amp;next;/[=+-]/?$F[$p]=eval"(<span class="math-container">\$F[\$</span>p]$_)%256":/[&lt;&gt;]/?eval'$p=$p'.y/&gt;&lt;/+-/r:/#/?$p=y/#//dr:s/://&amp;&amp;($l=$_);die'Error'if$p*$l&lt;0||$l&gt;@c}print$_?chr:last for@F
</code></pre>

<p><a href="https://tio.run/##VU/bUoMwEH33K7SNXE2XtFYtEMKD8uL4BQQ7HaCWGSyZwKgd8dfFxdvoy2bObfdElbpeDqTnLBjINKE0IGseRkEL0po5Qtq9bB0rdcNoyn1BMxshEAYPQVGV5o3WjTarLaT3nw7he3RFM3BBClkAbkmj0KWZvLUEl9c9sWGMIo3b/rIeso8bhbcbXZzFSRDnHMb7hYvK866qS4vUYZzbr@gheUpq183GlgLAOSFJSlRmGPvypQsg5XgSxBfJy6dNPbEkIomQrO3T@fJi4kMaRmgaVZMoTpQ5O0AUgktB@zDFuOIHfKHQfgs@gGFgA475fz8nysFeXt@TOorzN6WrfUfWIt9pv9603fG20XEyDEf8ch5x5rFxXP0MhnAx8mz1jRg7/3V4KC4i/t6ormr27UDvljOPeQNNPgA" rel="nofollow noreferrer" title="Perl 5 – Try It Online">Try it online!</a></p>

<p>The first line of input is the initialization of RAM, the second line is the jumper program.</p>
</div>
<div id="pu2" class="pu"><p><strong>Ruby 2 - <s>540</s> <s>447</s> 420 characters</strong>
<br><br>
Run as " ruby2.0 jumper.rb 'instructions' 'initialization data' ". 1.x Ruby won't work (no String.bytes method).</p>

<p><br>Added multi-line commands and comments and improved my putting.</p>

<pre><code>
i=$*[0].gsub(/\([^)]*\)/m,' ').scan(/(\??)\s*([#=:&gt;&lt;+-])\s*(\d*)/m).map{|a|[a[0]!='?',a[1],a[2]==''?/[#=:]/=~a[1]?0:1:a[2].to_i]}
N=i.size
d=$*[1].bytes
r=p=0
while p&lt;N
u,o,x=i[p]
p+=1
d[r]=0 if d[r].nil?
case o
when'#';r=x
when'&gt;';r+=x
when'&lt;';r-=x
when/[=+-]/;eval "d[r]#{o.tr'=',''}=x";d[r]%=256
when':';p=x;abort'Error'if p&gt;=N
end if u||d[r]&gt;0
abort'Error'if r&lt;0
end
printf"%s\n",d.take_while{|v|v&&v!=0}.pack('C*')

</code></pre>

<p>Here's a test suite with some scatter-shot tests. The easiest way to use it is to stuff the code into t/jumper.t and run "perl t/jumper.t".</p>

<pre><code>
#/usr/bin/perl
use strict;
use warnings;
#       timestamp: 2014 August 3, 19:00
#
# - Assume program takes machine code and initialization string as command
#       line options.
# - Assume all required errors reported as "Error\n".
# - Go with the flow and suffix output with \n. Merged terminal newlines are
#       unacceptable [I'm talkin' to YOU Ruby puts()!].
# - As per OP - jumping to &gt; end-of-program must be an error.

use Test::More qw(no_plan);
# use Test::More tests =&gt; 4;

my $jumper = "jumper.rb";
#
#       "happy" path
#
# starter tests provided by OP
is( `$jumper '=72&gt;=101&gt;=108&gt;=108&gt;=111&gt;=32&gt;=119&gt;=111&gt;=114&gt;=108&gt;=100&gt;=33&gt;=' '' 2&gt;&1`, "Hello world!\n", "hello world (from user2992539)");
is( `$jumper '?:2 :4 &gt;1 :0 =33 &gt;1 =0' 'a' 2&gt;&1`, "a!\n", 'append !, #1 (from user2992539)');

# simple variations
is( `$jumper '?:2 :4 &gt;1 :0 =33 &gt;1 =0' '' 2&gt;&1`, "!\n", 'append !, #2');
is( `$jumper '?:2 :4 &gt;1 :0 =33' '' 2&gt;&1`, "!\n", 'append !, #3, no NUL');

# comment delimiters don't nest
is( `$jumper "(()=" 'oops' 2&gt;&1`, "\n", "() don't nest");
# comments and termination
is( `$jumper '(start with a comment)?(comment w/ trailing sp) # (comment w/ surrounding sp) 1 =98' 'a' 2&gt;&1`, "ab\n", 'walk to exit');
is( `$jumper '(start with a comment)? (comment w/ leading sp)= (comment w/ surrounding sp) 97()' '' 2&gt;&1`, "\n", 'skip to exit');
is( `$jumper '#1=0 (actually two instructions, but it scans well) :5 #=(truncate further if not jumped over)' 'a b' 2&gt;&1`, "Error\n", 'truncate & jump to exit');

# is RAM pointer initialized to 0?
is( `$jumper '-103(g-g) ?:1025(exit) =103 #4=10' 'good' 2&gt;&1`, "good\n\n", 'intial string in right place?');

# TBD, do jumps work?
# TBD, do conditional jumps work?
# jump right to a harder case, copy byte 0 to byte 3 and format, e.g. input="Y" output="Y=&gt;Y"
is( `$jumper '#1=61#2=62#4=0#3=#10=#(11:)?:13:20(13:)#3+#10+#0-:11(20:)#10(21:)?:23:28(23:)#0+#10-:21(28:)#' 'Y' 2&gt;&1`, "Y=&gt;Y\n", 'copy a byte');


# test memory allocation by dropping 255s at increasingly large intervals
is( `$jumper '#16=511 #64=511 #256=511 #1024=511 #4096=511 #16384=511 #65536=511 #262144=511 #1048576=511 #65536-255 (20:)?:23(exit) #=' 'wrong' 2&gt;&1`, "\n", 'test alloc()');

# upcase by subtraction
is( `$jumper '-32' 't' 2&gt;&1`, "T\n", 'upcase via subtraction');
# 2 nested loops to upcase a character, like so: #0=2; do { #0--; #1=16; do { #1--; #2--; } while (#1); } while (#0);
is( `$jumper '#=2 (2:)#- #1=16 (6:)#1- #2- #1?:6 #0?:2 #=32 #1=32' '  t' 2&gt;&1`, "  T\n", 'upcase via loops');
# downcase by addition
is( `$jumper '+32' 'B' 2&gt;&1`, "b\n", 'downcase via addition');
# same thing with a loop, adjusted to walk the plank instead of jumping off it
is( `$jumper '#1 ?:3 :7 -&lt;+ :0 #' 'B ' 2&gt;&1`, "b\n", 'downcase via adder (from  Sieg)');
# base 10 adder with carry
is( `$jumper '#0-48#10=9#11=#5=#0(9:)?:11:22(11:)#10?:14:22(14:)-#11+#5+#0-:9(22:)#0?:110#11(25:)?:27:32(27:)#0+#11-:25(32:)#0+48&gt;-43?:110=43&gt;-48#10=9#11=#2(45:)?:47:58(47:)#10?:50:58(50:)-#11+#5+#2-:45(58:)#2?:110#11(61:)?:63:68(63:)#2+#11-:61(68:)#2+48&gt;-61?:110=61&gt;?:110=32#10=9#11=#5-10(83:)?:85:94(85:)#10?:88:94(88:)-#11+#5-:83(94:)#5?:99#4=49:100(99:)+10(100:)#11(101:)?:103:108(103:)#5+#11-:101(108:)#5+48' '1+1=' 2&gt;&1`, "1+1= 2\n", 'base 10 adder, #1');
is( `$jumper '#0-48#10=9#11=#5=#0(9:)?:11:22(11:)#10?:14:22(14:)-#11+#5+#0-:9(22:)#0?:110#11(25:)?:27:32(27:)#0+#11-:25(32:)#0+48&gt;-43?:110=43&gt;-48#10=9#11=#2(45:)?:47:58(47:)#10?:50:58(50:)-#11+#5+#2-:45(58:)#2?:110#11(61:)?:63:68(63:)#2+#11-:61(68:)#2+48&gt;-61?:110=61&gt;?:110=32#10=9#11=#5-10(83:)?:85:94(85:)#10?:88:94(88:)-#11+#5-:83(94:)#5?:99#4=49:100(99:)+10(100:)#11(101:)?:103:108(103:)#5+#11-:101(108:)#5+48' '9+9=' 2&gt;&1`, "9+9=18\n", 'base 10 adder, #2');

# order of assignment shouldn't affect order of print
is( `$jumper '#1=98 #0=97' '' 2&gt;&1`, "ab\n", 'print order != assignment order');

# are chars modulo 256?
is( `$jumper '#10(#10 defaults to 0) +255+(#10 += 256) ?#(skip if #10==0) =' 'good' 2&gt;&1`, "good\n", 'memory values limited to 0&lt;x&lt;255');
# go for the cycle;
is( `$jumper '(0:)+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ (256:)#4=10' 'BCID' 2&gt;&1`, "ACID\n\n", 'cycle character less 1, PC&gt;255');
# same thing with a loop;
is( `$jumper '#4=255(#4 = 255) (2:)#1+(#1++) #4-(#4--) ?:2(loop 255 times) #4=10(#4 = NL)' 'ADID' 2&gt;&1`, "ACID\n\n", 'cycle character less 1, PC&gt;255');


#       Exercise the program counter.
# PC &gt; 255;
is( `$jumper '(0:)= (1:)############################################################################################################################################################################################################################################################### (256:)?:259 (257:)+ (258:):1 (259:)=97#3=10' 'a==' 2&gt;&1`, "a==\n\n", 'program counter range &gt;255');


#
#       "sad" path
#
#       Error checking required by the specification.
#
# simplest test case of PC going out of bounds
is( `$jumper ':2' '' 2&gt;&1`, "Error\n", 'program counter too big by 1');
is( `$jumper ':1024' '' 2&gt;&1`, "Error\n", 'program counter in space');
is( `$jumper ':1073741824' '' 2&gt;&1`, "Error\n", 'program counter in hyperspace');
# try to drive program counter negative, if 32-bit signed integer
is( `$jumper ':2147483648(exit)' 'ridiculous speed' 2&gt;&1`, "Error\n", 'program counter goes negative?, #1');
# try to drive program counter negative, if 64-bit signed integer
is( `$jumper ':9223372036854775808 (exit)' 'ludicrous speed' 2&gt;&1`, "Error\n", 'program counter goes negative?, #2');

# spaces not allowed in operand; error or silently ignore (my choice)
isnt(`$jumper '#= #= #= #= #= +1 4 ' 'aops' 2&gt;&1`, "oops\n", 'do not accept spaces in operands');
# ditto w/ a comment ; error or silently ignore (my choice)
isnt(`$jumper '#= #= #= #= #= +1(not valid)4 ' 'aops' 2&gt;&1`, "oops\n", 'do not accept spaces in operands');

# RAM pointer error-checking; "Error" or "" are OK
isnt( `$jumper '&lt;&gt;=' 'oops' 2&gt;&1 | grep -v Error`, "oops\n", 'unused negative RAM pointer behavior unspecified');
# RAM pointer negative and use it
is( `$jumper '&lt;=' '' 2&gt;&1`, "Error\n", 'cannot use negative RAM pointer, #1');
# check for RAM pointer wrap-around
is( `$jumper '&lt;=' '0123456789' 2&gt;&1`, "Error\n", 'cannot use negative RAM pointer, #2');

# The way I read this
#       "Commands and arguments may be delimited with spaces or new lines but
#       not necessary."
# multi-line commands are legit.
is( `$jumper "#4#?\n=" 'oops' 2&gt;&1`, "\n", 'multi-line commands allowed');

# Multi-line comments would be consistent with multi-line commands, but I can't
# find something I can translate into a "must" or "must not" requirement in
#       "Program can have comments between (). ... Comments can be placed
#       anywhere."
# Until uncertainty resolved, no test case.


#
#       "bad" path
#
#       These tests violate the assumption that the instruction stream is wellll-farmed.
#
# characters not in the language; error or (my choice) silently skip
isnt(`$jumper 'x =' 'oops' 2&gt;&1`, "oops\n", 'opcode discrimination');
# is ? accepted as an operator (vs operation modifier); error or (my choice) silently skip
is(`$jumper '(bad 0, good 0:)??0 (bad 1, good 0:):3 (bad 2, good 1:)#0' '' 2&gt;&1`, "Error\n", '? not accepted as an opcode');

exit 0;
</code></pre>

<p>Ungolfed version.</p>

<pre><code>
#
#       Turing Machine Mach 2.0.
#       Tape? Tape? We don't need no stinkin' tape! We gots RAM!
#
#       dM = data memory
#       iM = instruction memory
#       pC = program counter
#       rP = RAM pointer
#       u, o, x = current instruction being executed
#
#       N = number of instructions in instruction memory
#

#       instruction decoder
iM = $*[0].gsub(/\([^)]*\)/m,' ').scan(/(\??)\s*([#=:&gt;&lt;+-])\s*(\d*)/m).map { |a|
    [
        a[0] != '?',
        a[1],
        (a[2] == '')  ?  (/[#=:]/ =~ a[1] ? 0 : 1)  :  a[2].to_i
    ]
}
pC = 0
N = iM.size

dM = $*[1].bytes
rP = 0

while pC &lt; N do
    #   u, unconditional instruction,   execute if true || (dM[rP] &gt; 0)
    #                                   skip if false && (dM[rP] == 0)
    #   o, operator
    #   x, operand
    (u, o, x) = iM[pC]
    pC += 1
    dM[rP] = 0  if dM[rP].nil?
    if u || (dM[rP] &gt; 0)
        case o
        when '#'
            rP = x
        when '&gt;'
            rP += x
        when '&lt;'
            rP -= x
        when /[=+-]/
            eval "dM[rP]#{o.tr'=',''}=x"
            dM[rP] %= 256
        when ':'
            pC = x
            abort 'Error'  if pC &gt;= N
        end
    end
    abort 'Error'  if rP &lt; 0
end
printf "%s\n", dM.take_while{|v|v&&v!=0}.pack('C*')
</code></pre>

<p>A quickie proto-assembler.</p>

<pre><code>
#
#       Jumper "assembler" - symbolic goto labels.
#
# what it does:
#       - translates labels/targets into absolute position
#               @label ?:good_exit
#               ...
#               :label
#
#       - a label is [a-zA-Z][a-zA-Z0-9_]*
#       - a target is @label
#       - one special label:
#               - "hyperspace" is last instruction index + 1
#       - strips out user comments
#               - everything from "//" to EOL is stripped
#               - jumper comments are stripped
#       - adds "label" comments of the form "(ddd:)"
# limitations & bugs:
#       - multi-line jumper comments aren't alway handled gracefully
#       - a target not followed by an instruction will reference
#               the previous instruction. this can only happen
#               at the end of the program. recommended idiom to
#               avoid this:
#                       @good_exit #
# what it doesn't do:
#       - TBD, simple error checking
#               - labels defined and not used
#       - TBD, symbolic memory names
#
# Example:
#
#   input -
#       (
#               adder from Sieg
#       )
#       @loop_head # 1  // while (*(1)) {
#       ?:continue
#       :good_exit
#
#       @continue -     //     *(1) -= 1;
#       &lt;-           //     *(0) += 1;
#       +
#       :loop_head      // }
#       @good_exit #
#
#   output -
#       (0:) #1 ?:3 :7 (3:) - &lt; + :0 (7:)#

rawSource = ARGF.map do |line|
  line.gsub(/\([^)]*\)/, ' ')   # eat intra-line jumper comments
    .gsub(/\/\/.*/, ' ')        # eat C99 comments
    .gsub(/^/, "#{$&lt;.filename}@#{$&lt;.file.lineno}\n") # add line ID
end.join
rawSource.gsub! /\([^)]*\)/m, '' # eat multi-line jumper comments
#
# Using example from above
#
# rawSource =
#       "sieg.ja@1\n \n" +
#       "sieg.ja@4\n@loop_head # 1\n"
#       ...
#       "sieg.ja@12\n@good_exit # \n"

instructionPattern = %r{
    (?&lt;label&gt; [[:alpha:]]\w* ){0}
    (?&lt;operator&gt; \??\s*[#=:&gt;&lt;+-]) {0}
    (?&lt;operand&gt; \d+|[[:alpha:]]\w* ){0}

    \G\s*(@\g&lt;label&gt;\s*)?(\g&lt;operator&gt;\s*)?(\g&lt;operand&gt;)?
  }x
FAIL = [nil, nil, nil]
instructionOffset = 0
iStream = Array.new
target = Hash.new
targetComment = nil
for a in rawSource.lines.each_slice(2) do
  # only parse non-empty lines
  if /\S/ =~ a[1]
    m = nil
    catch( :parseError ) do
      chopped = a[1]
      while m = instructionPattern.match(chopped)
        if m.captures.eql?(FAIL) || (!m[:operator] && m[:operand])
          m = nil
          throw :parseError
        end
        if m[:label]
          if target.has_key?(m[:label].to_sym)
            printf $stderr, a[0].chomp + ": error: label '#{m[:label]}' is already defined"
            abort a[1]
          end
          target[ m[:label].to_sym ] = instructionOffset
          targetComment = "(#{instructionOffset}:)"
        end
        if m[:operator]
          iStream[instructionOffset] = [
              targetComment,
              m[:operator],
              /\A[[:alpha:]]/.match(m[:operand]) ? m[:operand].to_sym : m[:operand]
            ]
          targetComment = nil
          instructionOffset += 1
        end
        chopped = m.post_match
        if /\A\s*\Z/ =~ chopped
          # nothing parseable left
          break
        end
      end
    end
    if !m
      printf $stderr, a[0].chomp + ": error: parse failure"
      abort a[1]
    end
  end
end

# inject hyperspace label
target[:hyperspace] = instructionOffset

# replace operands that are labels
iStream.each do |instruction|
  if instruction[2]
    if !(/\A\d/ =~ instruction[2]) # its a label
      if target.has_key?(instruction[2])
        instruction[2] = target[instruction[2]]
      else
        abort "error: label '@#{instruction[2]}' is used but not defined"
      end
    end
  end
  puts instruction.join
end
</code></pre>
</div>
<div id="pu3" class="pu"><h1>Haskell, 584</h1>
<p>The input and jumper program are provided as the first two lines of input from stdin.</p>
<pre><code>a g(i,n,x)=(i+1,n,take n x++((g$x!!n)`mod`256):drop(n+1)x)
b g(i,n,x)=(i+1,g n,x)
c=b.q:a.(+):g:a.(-):b.(-):a.q:b.(+):c
d=(%['0'..'9'])
e=fromEnum
f=0&gt;1
g n(_,x,y)=(n,x,y)
h(x:_)=d x;h _=f
i g p@(j,n,m)|x$m!!n=g p|t=(j+1,n,m)
j=0:1:0:1:1:0:1:j
k=takeWhile
l[]=[];l(x:y)|x%&quot;) \n&quot;=l y|x%&quot;(&quot;=l$u(/=')')y|t=x:l y
main=v&gt;&gt;=(\y-&gt;v&gt;&gt;=putStr.map toEnum.k x.r(0,0,map e y++z).p.l)
o n s|h s=(read$k d s,u d s)|t=(n,s)
p[]=[];p(x:y)|x%&quot;?&quot;=w$p y|t=(c!!e x)n:p m where(n,m)=o(j!!e x)y
q=const
r s@(i,n,m)p|i&lt;length p=r((p!!i)s)p|t=m
t=0&lt;1
u=dropWhile
v=getLine
w(m:n)=i m:n
x=(/=0)
z=0:z
(%)=elem
</code></pre>
<p>I'll post an ungolfed version later, but in the meantime I wanted to leave this as a puzzle for the reader:</p>
<blockquote>
<p>Where are the jumper commands such as '#' etc?</p>
</blockquote>
<p>Have fun!</p>
</div>
<div id="pu4" class="pu"><h1>Haskell: an ungodly amount of characters</h1>

<p>Alright, right now this is something that might or might not be golfed shortly. It is freakishly huge for what it is, with lots and lots of sloppily written code (it was quite some time since I last touched Haskell). But it was fun to write.</p>

<pre class="lang-hs prettyprint-override"><code>import Data.Char

parse [] p c a m i =
    if c == ' ' || c == '?' then
        []
    else
        (p ++ [(c, a, m)])

parse (h:t) p c a m i
    | i
        = parse t p c a m (h == ')')
    | isDigit h &amp;&amp; a &lt; 0
        = parse t p c (digitToInt h) m i
    | isDigit h
        = parse t p c (10 * a + (digitToInt h)) m i
    | elem h "#&gt;&lt;=+-:?"
        = if c == ' ' || c == '?' then
            parse t p h a (c == '?') i
        else
            parse t (p ++ [(c, a, m)]) h (-1) False i
    | otherwise
        = case h of
            '(' -&gt; parse t p c a m True
            ' ' -&gt; parse t p c a m i
            _   -&gt; []

run p pp r rp
    | pp &gt;= length p
        = r
    | pp &lt; 0 || rp &lt; 0
        = []
    | otherwise
        = if mr then
            case c of
                '#' -&gt; run p (pp + 1) r pa
                '&gt;' -&gt; run p (pp + 1) r (rp + pa)
                '&lt;' -&gt; run p (pp + 1) r (rp - pa)
                '=' -&gt; run p (pp + 1) (rh ++ ((chr pa) : rt)) rp
                '+' -&gt; run p (pp + 1) (rh ++ (chr (mod ((ord h) + pa) 256) : rt)) rp
                '-' -&gt; run p (pp + 1) (rh ++ (chr (mod ((ord h) - pa + 256) 256) : rt)) rp
                ':' -&gt; run p pa r rp
        else
            run p (pp + 1) r rp
        where
            (c, a, m)
                = p !! pp
            (rh, h:rt)
                = splitAt rp r
            pa
                = if a &lt; 0 then
                    if elem c "&gt;&lt;+-" then
                        1
                    else
                        0
                else
                    a
            mr
                = ord (r !! rp) &gt; 0 || not m

main = do
    p &lt;- getLine
    let n = parse p [] ' ' (-1) False False
    if n == []
        then do
            putStrLn "Error"
        else do
            s &lt;- getLine
            let r = run n 0 (s ++ (repeat (chr 0))) 0
            if r == []
                then do
                    putStrLn "Error"
                else do
                    putStrLn (takeWhile (/=(chr 0)) r)
</code></pre>
</div>
<div id="pu5" class="pu"><h1>Groovy 582</h1>

<p>ungolfed version:</p>

<p>I think there is a bug with the comments, which are not recognized correctly, which might be caused by the stupid regex I used, but the 2 programs run as they should:</p>

<pre><code>class P {
    def c = 0
    def p = 0
    def m = []

    P(i="") {
        m = i.chars.collect { it }
        m &lt;&lt; 0
    }

    def set(v) { m[p] = v }
    def add(v) { m[p] += v }
    def sub(v) { m[p] -= v }

    def eval(i) {
        while(c &lt; i.size()) {
            if (i[c].p &amp;&amp; m[p] == 0) {c++} 
            else { i[c].f(this,i[c].v) }
        }
        return m
    }
}


def parse(s) {
    def ops = [
       '#' : [{p, v -&gt; p.p = v; p.c++}, "0"],
       '&gt;' : [{p, v -&gt; p.p += v; p.c++}, "1"],
       '&lt;' : [{p, v -&gt; p.p -= v; p.c++}, "1"],
       '=' : [{p, v -&gt; p.set(v); p.c++}, "0"],
       '+' : [{p, v -&gt; p.add(v); p.c++}, "1"],
       '-' : [{p, v -&gt; p.sub(v); p.c++}, "1"],
       ':' : [{p, v -&gt; p.c = v}, "0"]
    ]

    (s =~ /\(.*\)/).each {
        s = s.replace(it, "")
    }

    (s =~ /(\?)?([#&gt;&lt;=+-:])([0-9]*)?/).collect {        
        def op = ops[it[2]]
        [f : op[0], v : Integer.parseInt(it[3] ?: op[1]), p : it[1] != null ]
    }
}
</code></pre>
</div>
<div id="pu6" class="pu"><h2>Ruby, 447 bytes</h2>

<pre><code>p,i=$*
l=(i||'').length
r=[0]*l
l.times{|j|r[j]=i[j].ord}
i=j=0
s=p.gsub(/\(.*?\)|\s/,'')
q=s.scan(/(\?)?([#&lt;&gt;=+:-])(\d*)/)
e=-&gt;{abort"Error"}
p[/\d\s+\d/]||q*''!=s ?e[]:(r+=[0]until i+1&lt;r.length
c=q[j]
j+=1
f=c[1]
c[0]&amp;&amp;r[i]==0?next: a=c[2]==''? '&gt;&lt;+-'[f]?1:0:c[2].to_i
'=+-'[f]&amp;&amp;a&gt;255?e[]: f==?#?i=a :f==?&gt;?i+=a :f==?&lt;?i-=a :f==?=?r[i]=a :f==?+?r[i]+=a :f==?-?r[i]-=a :j=a
i&lt;0?e[]:r[i]%=256)while j&lt;q.length
puts r.first(r.index 0).map(&amp;:chr)*''
</code></pre>

<p>Takes both the program and the input via command line arguments.</p>

<p><strong>EDIT:</strong> Fixed a few bugs, and added support for invalid syntax at the cost of 40 bytes (while adding a few other optimisations).</p>
</div>
<div id="pu7" class="pu"><h1>CoffeeScript (465)</h1>

<p>The first prompt box is for the program and the second prompt box is input.
Test it at <a href="http://coffeescript.org" rel="nofollow">http://coffeescript.org</a>.</p>

<p><strong>Original</strong>:</p>

<pre><code>p=prompt().replace(/\(.*?\)|[\s\n\r]/g,"").match(/\??[^\d]\d*/g) ?[]
y=p[..]
i=prompt()
r=[].map.call i,(c)-&gt;c[0].charCodeAt()
n=0
m=[(d)-&gt;n=d
(d)-&gt;m[5] (r[n]+d)%%256
(d)-&gt;p=y[d..]
(d)-&gt;m[1] -d
(d)-&gt;n-=d
(d)-&gt;r[n]=d
(d)-&gt;n+=d]
while b=p.shift()
 if b[0]=="?"
  continue unless r[n]
  b=b[1..]
 d="&gt;&lt;+-#=:".indexOf(b[0])//4
 ~d||throw "!badcmd '#{b[0]}'"
 m[b[0].charCodeAt()%7](+b[1..]||+!d)
 n&lt;0&amp;&amp;throw "!ramdix&lt;0"
alert String.fromCharCode(r...).replace(/\0.*/,"")
</code></pre>

<p>This is still golfed, but commented:</p>

<pre><code># Get program
p=prompt().replace(/\(.*?\)/g,"").match(/\??[^\s\d]\d*/g) ?[]
# Create a copy of the program (for goto)
y=p[..]
# Get input
i=prompt()
# Put the input in the ram
r=[].map.call i,(c)-&gt;c[0].charCodeAt()
# RAM pointer
n=0
# An array of commands
# Since each of "&lt;&gt;+-#=:" is a different
# value mod 7 (what a coincedence?!)
# So 0th value is "#" command because 
# "#".charCodeAt() % 7 === 0
m=[(d)-&gt;n=d
(d)-&gt;m[5] (r[n]+d)%%256
(d)-&gt;p=y[d..]
(d)-&gt;m[1] -d
(d)-&gt;n-=d
(d)-&gt;r[n]=d
(d)-&gt;n+=d]
# Iterate through commands
while b=p.shift()
 # If you find a "?" skip unless r[n] is &gt; 0
 if b[0]=="?"
  continue unless r[n]
  b=b[1..]
 # Get the default value
 d="&gt;&lt;+-#=:".indexOf(b[0])//4
 # If the command isn't good, throw an error
 throw "!badcmd '#{b[0]}'" if d==-1
 # Call the appropriate command
 # By computing the char code mod 7
 m[b[0].charCodeAt()%7](+b[1..]||+!d)
 # Make sure n is bigger than or equal to 0
 throw "!ramdix&lt;0" if n&lt;0
# Show output
alert String.fromCharCode(r...).replace(/\0.*/,"")
</code></pre>

<p><strong>Edit</strong>: Adding spaces took more bytes than I thought.
This interpreter will throw an error on invalid syntax, the other has unspecified behavior on invalid syntax.</p>

<pre><code>p=prompt().replace(/\(.*?\)/g,"").match(/\??[^\d\s\r\n]\s*\n*\r*\d*/g) ?[]
y=p[..]
i=prompt()
r=[].map.call i,(c)-&gt;c[0].charCodeAt()
n=0
m=[(d)-&gt;n=d
(d)-&gt;m[5] (r[n]+d)%%256
(d)-&gt;p=y[d..]
(d)-&gt;m[1] -d
(d)-&gt;n-=d
(d)-&gt;r[n]=d
(d)-&gt;n+=d]
while b=p.shift()?.replace /^(.)(\s\r\n)*/,"$1"
 if b[0]=="?"
  continue if !r[n]
  b=b[1..]
 d="&gt;&lt;+-#=:".indexOf(b[0])//4
 ~d||throw "!badcmd"
 m[b[0].charCodeAt()%7](+b[1..]||+!d)
 n&lt;0&amp;&amp;throw "!ramdix&lt;0"
alert String.fromCharCode(r...).replace(/\0.*/,"")
</code></pre>
</div>
<div id="pu8" class="pu"><h2>Javascript, 519</h2>
<pre><code>C=prompt().replace(/\(.*?\)/g,&quot;&quot;).match(/\??[#&gt;&lt;=+:-]\d*/g)
M=prompt().split(&quot;&quot;).map(function(c){return c.charCodeAt(0)})
R=0
f=function(I){T=I[0]
A=I.slice(1)
if(T==&quot;?&quot;)return M[R]?f(A):P++
A=A==&quot;&quot;?1:+A
if(T==&quot;&gt;&quot;)R+=A
if(T==&quot;&lt;&quot;)R-=A
if(&quot;=+-&quot;.indexOf(T)+1){if(R&lt;0)throw alert(&quot;ERR RAMidx&lt;0&quot;)
while(R&gt;=M.length)M.push(0)}
if(T==&quot;+&quot;)M[R]=M[R]+A&amp;255
if(T==&quot;-&quot;)M[R]=M[R]-A&amp;255
A=+I.slice(1)
if(T==&quot;#&quot;)R=A
if(T==&quot;=&quot;)M[R]=A
if(T==&quot;:&quot;)P=A;else++P}
for(P=0;C[P];)f(C[P])
alert(String.fromCharCode.apply(7,M).replace(/\0.*/,&quot;&quot;))
</code></pre>
<p>This gets the program and input via prompt boxes. Pasting this in your browser's Javascript console will work, as well as throwing this in a file, pasting before the code <code>&lt;!DOCTYPE html&gt;</code>, newline, <code>&lt;html&gt;&lt;head&gt;&lt;script&gt;</code>, and after the code <code>&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;</code>, and saving the resulting file as &quot;swagger.html&quot;.</p>
<p>This is my first attempt at this thing, and I already like the language. Kinda. It really needs text labels though, instead of this BASIC-style instruction index labeling.</p>
<p>Ungolfed version (kinda):</p>
<pre><code>var C,M,R,P,f;
C=prompt().replace(/\(.*?\)/g,&quot;&quot;).match(/\??[#&gt;&lt;=+:-]\d*/g); //Code
M=prompt().split(&quot;&quot;).map(function(c){return c.charCodeAt(0)}); //Memory
R=0; //RAM pointer
f=function(I){ //parser function, Instruction
    var T,A;
    T=I[0]; //Type
    A=I.slice(1); //Argument
    if(T==&quot;?&quot;)return M[R]?f(A):P++;
    A=A==&quot;&quot;?1:+A;
    if(T==&quot;&gt;&quot;)R+=A;
    if(T==&quot;&lt;&quot;)R-=A;
    if(&quot;=+-&quot;.indexOf(T)+1){
        if(R&lt;0)throw alert(&quot;ERR RAMidx&lt;0&quot;);
        while(R&gt;=M.length)M.push(0);
    }
    if(T==&quot;+&quot;)M[R]=M[R]+A&amp;255;
    if(T==&quot;-&quot;)M[R]=M[R]-A&amp;255;
    A=+I.slice(1);
    if(T==&quot;#&quot;)R=A;
    if(T==&quot;=&quot;)M[R]=A;
    if(T==&quot;:&quot;)P=A;else++P;
}
for(P=0;C[P];f(C[P])); //Program pointer
alert(String.fromCharCode.apply(7,M).replace(/\0.*/,&quot;&quot;));
</code></pre>
</div>
<div id="pu9" class="pu"><h2>Clojure - <s>585</s> 577 bytes</h2>
<pre><code>Edit:   I forgot modulo 256, of course
Edit 2: Now supports whitespace and comments anywhere. (585 -&gt; 578)
</code></pre>
<p>No special golfing tricks used, because I don't know any for Clojure. The interpreter is purely functional. Comes packed with a nice error message in case of negative RAM address (an error is outputted, but no exceptions or errors are thrown).</p>
<pre><code>(defn j[o i](let[o(re-seq #&quot;\??[#&lt;&gt;=+:-]\d*&quot;(clojure.string/replace o #&quot;\(.*?\)|\s&quot;&quot;&quot;))r(loop[c 0 p 0 m(map int i)](if-let[f(nth o c nil)](let[[c p m]((fn r[t](let[f(first t)s(if(next t)(apply str(next t))(case f(\#\=\:)&quot;0&quot;(\&gt;\&lt;\+\-)&quot;1&quot;))v(read-string s)a(nth m p 0)](case f\?(if(=(nth m p 0)0)[c p m](r s))\#[c v m]\&gt;[c(+ p v)m]\&lt;[c(- p v)m]\:[(dec v)p m][c p(assoc(vec(concat m(repeat(- p(count m))0)))p(mod({\+(+ a v)\-(- a v)}f v)256))])))f)](if(&lt; p 0)(str&quot;Negative index &quot;p&quot; caused by &quot;f)(recur(inc c)p m)))m))](if(string? r)r(apply str(map char(take-while #(&gt; % 0)r))))))
</code></pre>
<p>Examples:</p>
<pre class="lang-clojure prettyprint-override"><code>(j &quot;=72&gt;=101&gt;=108&gt;=108&gt;=111&gt;=32&gt;=119&gt;=111&gt;=114&gt;=108&gt;=100&gt;=33&gt;=&quot; &quot;&quot;)
=&gt; &quot;Hello world!&quot;
(j &quot;?:2 :4 &gt;1 :0 =33 &gt;1 =0&quot; &quot;hi there&quot;)
=&gt; &quot;hi there!&quot;
(j &quot;#1 ?:3 :7 -&lt;+ :0&quot; &quot;01&quot;) ; adder
=&gt; &quot;a&quot;
(j &quot;?:2 :4 &gt;1 :0 =33 &lt;10 =0&quot; &quot;hi there&quot;)
=&gt; &quot;Negative index -2 caused by &lt;10&quot;
(j &quot;=72&gt;=101&gt;=108&gt;=108&gt;=111&gt;=3(comment here &lt;100)2&gt;=119&gt;=111&gt;=114&gt;=108&gt;=100&gt;=33&gt;=&quot; &quot;&quot;)
=&gt; &quot;Hello world!&quot;
</code></pre>
<p><s>Original</s> slightly ungolfed code:</p>
<pre class="lang-clojure prettyprint-override"><code>(defn memory
  ([]
    (vec (repeat 1024 0)))
  ([m i v]
    (assoc (vec (concat m (repeat (- i (+ -1024 (mod i 1024)) (count m)) 0)))
           i v)))

(defn parse [c p m t]
  (let [f (first t)
        s (if-let [v (next t)]
            (apply str v)
            (case f
              (\#\=\:) &quot;0&quot;
              (\&gt;\&lt;\+\-) &quot;1&quot;))
        v (read-string s)
        a (nth m p 0)]
    (case f
      \? (if (= (nth m p 0) 0) [c p m] (parse c p m s))
      \# [c v m]
      \&gt; [c (+ p v) m]
      \&lt; [c (- p v) m]
      \: [(dec v) p m]
      [c p (memory m p (mod ({\+ (+ a v) \- (- a v)} f v) 256))])))

(defn jumper [o i]
  (let [o (re-seq #&quot;\??[#&lt;&gt;=+:-]\d*&quot; (clojure.string/replace o #&quot;\(.*?\)|\s&quot; &quot;&quot;))
        r (loop [c 0
                 p 0
                 m (map int i)]
            (if-let [f (nth o c nil)]
              (let [[c p m] (parse c p m f)]
                (if (&lt; p 0)
                  (str &quot;Negative index &quot; p &quot; caused by &quot; (nth o c))
                  (recur (inc c) p m))) m))]
    (if (string? r)
      r
      (apply str (map char (take-while #(&gt; % 0) r))))))
</code></pre>
</div>
<div id="pu10" class="pu"><h2>Python (729)</h2>

<pre class="lang-py prettyprint-override"><code>import re,sys
R,p,i,T,q,g=[0]*1024,0,0,re.findall(r'\d+|[()#&gt;&lt;=+:?-]',sys.argv[1]),lambda i:0&lt;=i&lt;len(T),lambda i,d:int(T[i])if q(i)and T[i].isdigit()else d
def z(p):
 global R;assert p&gt;=0
 if p&gt;=len(R):R+=[0]*1024
s=sys.argv[2]
R[0:len(s)]=map(ord,s)
while i&lt;len(T):
 t=T[i]
 if t=='(': 
  while T[i]!=')':i+=1
  i+=1
  if not q(i):break
  t=T[i]
 i+=1
 if t=='#':p=g(i,0)
 if t=='&gt;':p+=g(i,1)
 if t=='&lt;':p-=g(i,1)
 if t=='=':z(p);R[p]=g(i,0)
 if t=='+':z(p);R[p]+=g(i,1);R[p]%=256
 if t=='-':z(p);R[p]-=g(i,1);R[p]%=256
 if t==':':
  v=int(T[i])
  i,c=-1,-1
  while c!=v:i+=1;c+=T[i]in'#&gt;&lt;=+-:'
 if t=='?':
  assert p&gt;=0
  if p&lt;len(R)and R[p]==0:i+=1
 i+=q(i)and T[i].isdigit()
print''.join(chr(int(c))for c in R).split('\0')[0]
</code></pre>

<p>As for running the program:</p>

<ul>
<li>1st argument: Jumper code</li>
<li>2nd argument: Initialization string</li>
</ul>

<p>Example:</p>

<pre><code>$ python jumper.py "=97&gt;&gt;(this is a comment)=98&gt;2=99#" "xyz123"
ayb1c3
</code></pre>

<p>There are probably a few things I overlooked, so please leave a comment if you happen to try something that should work but doesn't. Note that this is written in Python 2.x code.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/35029/">35029</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




