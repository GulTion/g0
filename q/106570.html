<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::106570</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>059</td><td>Haskell</td><td>170112T134443Z</td><td><a href="https://codegolf.stackexchange.com/questions/106570/symbolic-matrix-multiplication/106587#106587">Laikoni</a></td></tr>
<tr d-ix="1"><td>256</td><td>Prolog</td><td>170325T183643Z</td><td><a href="https://codegolf.stackexchange.com/questions/106570/symbolic-matrix-multiplication/113875#113875">user4699</a></td></tr>
<tr d-ix="2"><td>017</td><td>Pip</td><td>170325T193214Z</td><td><a href="https://codegolf.stackexchange.com/questions/106570/symbolic-matrix-multiplication/113881#113881">DLosc</a></td></tr>
<tr d-ix="3"><td>014</td><td>Pyth</td><td>170112T222543Z</td><td><a href="https://codegolf.stackexchange.com/questions/106570/symbolic-matrix-multiplication/106634#106634">TheBikin</a></td></tr>
<tr d-ix="4"><td>065</td><td>JavaScript ES6</td><td>170112T194514Z</td><td><a href="https://codegolf.stackexchange.com/questions/106570/symbolic-matrix-multiplication/106617#106617">Neil</a></td></tr>
<tr d-ix="5"><td>061</td><td>Ruby</td><td>170112T131406Z</td><td><a href="https://codegolf.stackexchange.com/questions/106570/symbolic-matrix-multiplication/106582#106582">Doorknob</a></td></tr>
<tr d-ix="6"><td>010</td><td>Dyalog APL</td><td>170112T140050Z</td><td><a href="https://codegolf.stackexchange.com/questions/106570/symbolic-matrix-multiplication/106590#106590">Ad&#225;</a></td></tr>
<tr d-ix="7"><td>053</td><td>Clojure</td><td>170112T142118Z</td><td><a href="https://codegolf.stackexchange.com/questions/106570/symbolic-matrix-multiplication/106594#106594">NikoNyrh</a></td></tr>
<tr d-ix="8"><td>007</td><td>Jelly</td><td>170112T133126Z</td><td><a href="https://codegolf.stackexchange.com/questions/106570/symbolic-matrix-multiplication/106584#106584">Dennis</a></td></tr>
<tr d-ix="9"><td>036</td><td>Mathematica</td><td>170112T133613Z</td><td><a href="https://codegolf.stackexchange.com/questions/106570/symbolic-matrix-multiplication/106585#106585">Martin E</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://www.haskell.org/" rel="nofollow noreferrer">Haskell</a>, <s>62</s> <s>61</s> 59 bytes</h1>

<pre class="lang-hs prettyprint-override"><code>e=[]:e
z=zipWith
a!b=[unwords.z(++)r&lt;$&gt;foldr(z(:))e b|r&lt;-a]
</code></pre>
<p><a href="https://tio.run/##HcgxDoMgFIDh3VM8XxwgWg9gpJfo0IEwQMVCSsUAxoT07pR2@//PyPjSzpWiGReTbjLLdr/bZBrZKsaP7fRhiWMmfU/D3F1X75ZAMpko1aA@Yb5IUd7SbsBgP9ItBRghGn9CB5yjxAEVioHjo5ZGIaD9@Vrv@XdTy1YvXw" rel="nofollow noreferrer" title="Haskell – Try It Online">Try it online!</a></p>
<p>Example usage:</p>
<pre class="lang-hs prettyprint-override"><code>Prelude&gt; [[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;e&quot;]] ! [[&quot;f&quot;,&quot;g&quot;],[&quot;h&quot;,&quot;i&quot;]]
[[&quot;af bh&quot;,&quot;ag bi&quot;],[&quot;cf eh&quot;,&quot;cg ei&quot;]]
</code></pre>
<p>I found a way to get a <code>transpose</code> function in one byte shorter than using the import.</p>
<pre class="lang-hs prettyprint-override"><code>import Data.List;transpose
e=[]:e;foldr(zipWith(:))e
</code></pre>
<p>As the code then uses <code>zipWith</code> twice, two more bytes can be saved with the abbreviation <code>z=zipWith</code>.</p>
<hr />
<p><strong>Old version with import:</strong> (62 bytes)</p>
<pre class="lang-hs prettyprint-override"><code>import Data.List
a!b=[unwords.zipWith(++)r&lt;$&gt;transpose b|r&lt;-a]
</code></pre>
<p><a href="https://tio.run/nexus/haskell#JYwxT8MwEEZ3fsVXqwOojcXI0FaqYGBgQGJgiDI4ybU@4drW@UKkqv89GNjee8PjS06ieE5RJQV7zDnw4JS/CU2DSDTSiFMS7NYHzJ4HDy7IQoWigiNeXfmiEPBkH/EuFKaRFv6fvjh19o2L3rlVv2@nOCcZi71y/mT195vNg9Srioslp0Lob7JrXLdcXP3ukSf9UIFF8WnGGm1rnNma3nTb1gyVyHQdVr/9VO38130lrn35AQ" rel="nofollow noreferrer" title="Haskell – TIO Nexus">Try it online!</a></p>
<p>This is quite similar to my answer to <a href="https://codegolf.stackexchange.com/a/106479/56433">non-symbolic matrix multiplication</a>: <code>a!b=[sum.zipWith(*)r&lt;$&gt;transpose b|r&lt;-a]</code>, substituting the multiplication <code>(*)</code> with string concatenation <code>(++)</code> and <code>sum</code> with <code>unwords</code> which concatenates a list of strings with a space in between. The import is needed for the <code>transpose</code> function, so all in all the transposition of the second matrix uses up half of the bytes ...</p>
<hr />
<p><strong>Old version without import:</strong> (64 bytes)</p>
<pre class="lang-hs prettyprint-override"><code>a![]=[];a!b=(unwords.zipWith(++)[h|h:_&lt;-b]&lt;$&gt;a):a![s:t|_:s:t&lt;-b]
</code></pre>
<p><a href="https://tio.run/nexus/haskell#HYzBasMwEER/ZSxySEhseixuXCi99FjooQchgmxvIjWyJCS5hpJ/dzc5zPJmZxg7xZAK3oMvKbjmLUZnB13sL6Gu4YlGGnEOCcfNKxZjBwObERNl8gXW40PnKzmH5@YJn4ncPNKqK6k6qV501Xfb2S8hjbn5s/HbFrPd73fS3Ex7Ota94lW9a7mf23I7tXzv33XSvNwhzuWrJDTIJizYQEqhxUH0Qh2kGJjoQWemi1AK1b1h2FnWzyO7MjnWxPn6Dw" rel="nofollow noreferrer" title="Haskell – TIO Nexus">Try it online!</a></p>
<p>With the import and <code>transpose</code> function taking up so much bytes, I tried solving the task without import. So far this approach turned out being two bytes longer, but it might be more golfable. <em>Edit: The other approach at the top now beats the import!</em></p>
<p>The list comprehension <code>[s:t|_:s:t&lt;-b]</code> gets the non-empty tails of the lists in <code>b</code>, using just <code>[t|_:t&lt;-b]</code> to get the tails would be 4 bytes shorter (even beating the import version) but append an empty row like <code>[&quot;&quot;,&quot;&quot;,&quot;&quot;]</code> to the matrix which I suppose is not allowed.</p>
</div>
<div id="pu1" class="pu"><h2>Prolog, >256 Bytes</h2>

<p>I am using { _ | _ } which is a findall/3, _ [ _ , _ ] which is some arg/3, and sum(_) which is some aggregate. They can all be used inside is/2:</p>

<pre><code>*(X, Y, Z) :- functor(Y, matrice, _), L is len(X[1]), L =:= len(Y), !,
   M is len(X), N is len(Y[1]),
   Z is { { sum({ X[J,K] * Y[K,I] | between(1,L,K) })
                                  | between(1,N,I) }
                                  | between(1,M,J) }.
</code></pre>

<p>Together with the <a href="https://gist.github.com/jburse/b79e21447eda6843daadf52942026eff" rel="nofollow noreferrer">extra definitions</a> for the aforementioned predicates and the non-standard is/2 that can return more than numbers, its sure >256 bytes.</p>
</div>
<div id="pu2" class="pu"><h1><a href="https://github.com/dloscutoff/pip" rel="nofollow noreferrer">Pip</a>, 17 bytes</h1>

<pre><code>{Y Zb{a._JsMy}Ma}
</code></pre>

<p>This is a function that takes two nested lists of (single-character) strings and returns a nested list of strings. <a href="https://tio.run/nexus/pip#c3S0io42VDCK5VIAgmhjBRMoy1TBLDaWy8kJKK2eqKCepKCeDJVRT1FQT1VQTwNKc6VZ/a@OVIhKqk7Ui/cq9q2s9U2s/R@gEBSgoJGm4Oio4OSkyQXhODkB@Zr/AQ" rel="nofollow noreferrer" title="Pip – TIO Nexus">Try it online!</a> (with two test cases).</p>

<h3>Explanation</h3>

<p>Arguments to a <code>{}</code>-delimited function are assigned to the local variables <code>a</code> to <code>e</code>. The first argument of a lambda function is represented by <code>_</code>.</p>

<pre><code>{               }  Define a function:
   Zb              Zip rows of b, transposing it
 Y                 Yank into global variable y for access in nested function
     {       }Ma   To the rows of a, map this function:
           My       To the rows of y (i.e. columns of b), map this function:
      a._           Concatenate, itemwise, the current row of a and row of y
         Js         Join the resulting list on space
                   The result of the outer map operation is returned
</code></pre>
</div>
<div id="pu3" class="pu"><h1>Pyth, 14 bytes</h1>
<pre><code>clQmj;sMCd*QCE
</code></pre>
<p>A program that takes input of two newline-separated two-dimensional lists of characters and prints a two dimensional list of strings.</p>
<p><a href="http://pyth.herokuapp.com/?code=clQmj%3BsMCd%2aQCE&amp;test_suite=1&amp;test_suite_input=%5B%5B%27a%27%5D%5D%0A%5B%5B%27b%27%5D%5D%0A%5B%5B%27a%27%2C%27b%27%5D%2C%5B%271%27%2C%274%27%5D%2C%5B%27y%27%2C%27%7B%27%5D%5D%0A%5B%5B%27%25%27%2C%274%27%2C%271%27%5D%2C%5B%27a%27%2C%27b%27%2C%27c%27%5D%5D%0A%5B%5B%271%27%2C%272%27%2C%273%27%2C%274%27%5D%2C%5B%275%27%2C%276%27%2C%277%27%2C%278%27%5D%2C%5B%279%27%2C%271%27%2C%272%27%2C%273%27%5D%2C%5B%274%27%2C%275%27%2C%276%27%2C%277%27%5D%5D%0A%5B%5B%27a%27%5D%2C%5B%27b%27%5D%2C%5B%27c%27%5D%2C%5B%27d%27%5D%5D&amp;debug=0&amp;input_size=2" rel="nofollow noreferrer">Test suite</a></p>
<p><strong>How it works</strong></p>
<p><em>[Explanation coming later]</em></p>
</div>
<div id="pu4" class="pu"><h2>JavaScript (ES6), 65 bytes</h2>

<pre><code>(a,b)=&gt;a.map(c=&gt;b[0].map((_,j)=&gt;c.map((e,i)=&gt;e+b[i][j]).join` `))
</code></pre>

<p>Takes input as two 2D arrays of characters and returns a 2D array of strings. Add 10 bytes to support input as two 1D arrays of strings.</p>
</div>
<div id="pu5" class="pu"><h2>Ruby, 61 bytes</h2>



<pre class="lang-ruby prettyprint-override"><code>-&gt;a,b{a.map{|x|b.transpose.map{|y|x.zip(y).map(&amp;:join)*' '}}}
</code></pre>

<p>Sample run:</p>

<pre class="lang-ruby prettyprint-override"><code>main(0):007&gt; -&gt;a,b{a.map{|x|b.transpose.map{|y|x.zip(y).map(&amp;:join)*' '}}}[[[?a, ?b], [?1, ?4], [?y, ?{]], [[?%, ?4, ?1], [?a, ?b, ?c]]]
=&gt; [["a% ba", "a4 bb", "a1 bc"], ["1% 4a", "14 4b", "11 4c"], ["y% {a", "y4 {b", "y1 {c"]]
</code></pre>



<pre class="lang-ruby prettyprint-override"><code>-&gt;a,b{
a.map{|x|            # for each row of a
b.transpose.map{|y|  # and for each column of b
x.zip(y)             # match up corresponding elements
.map(&amp;:join)         # join each pair together
*' '                 # join the entire thing on space
}}}
</code></pre>
</div>
<div id="pu6" class="pu"><h1><a href="http://dyalog.com/download-zone.htm" rel="nofollow noreferrer">Dyalog APL</a>, 10 <a href="http://meta.codegolf.stackexchange.com/a/9429/43319">bytes</a></h1>

<p>Takes matrices of characters as left and right arguments. Returns matrix of lists of characters. (APL represents strings as lists of characters.)</p>
<pre class="lang-apl prettyprint-override"><code>{∊⍺' '⍵}.,
</code></pre>
<p><a href="http://tryapl.org/?a=%28%u2355%27A%20%20%3D%27%20%28A%u21903%202%u2374%27ab14y%7B%27%29%29%20%28%u2355%27B%20%20%3D%27%20%28B%u21902%203%u2374%27%2541abc%27%29%29%20%u22C4%20A%7B%u220A%u237A%27%20%27%u2375%7D.%2CB&amp;run" rel="nofollow noreferrer">TryAPL online!</a></p>
<p>Normal inner product is in APL <code>+.×</code>, but the addition and multiplication can be any functions, in particular:</p>
<p>Addition has been replaced by<br>
<code>{</code> an anonymous function:<br>
 <code>∊</code> the flattened<br>
 <code>⍺ ' ' ⍵</code> list consisting of the left argument, a space, and the right argument <code>⍵</code><br>
<code>}</code></p>
<p>Multiplication has been replaced by concatenation, <code>,</code></p>
</div>
<div id="pu7" class="pu"><h2>Clojure, 53 bytes</h2>

<pre><code>#(for[a %](for[b(apply map vector %2)](map str a b)))
</code></pre>

<p>Running with arguments <code>[["a" "b"]["c" "e"]]</code> and <code>[["f" "g"]["h" "i"]]</code> returns <code>((("af" "bh") ("ag" "bi")) (("cf" "eh") ("cg" "ei")))</code>. This is actually shorter than the <a href="https://codegolf.stackexchange.com/a/106491/59617">numeric version</a>.</p>
</div>
<div id="pu8" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="nofollow noreferrer">Jelly</a>, 7 bytes</h1>
<pre><code>Z;&quot;þK€€
</code></pre>
<p>This is a dyadic link that takes <strong>B</strong> and <strong>A</strong> as arguments (in that order) and returns <strong>AB</strong>. Input and output are in the form of 2D arrays of strings, which are actually 3D arrays of characters. A further byte could be saved by taking 2D arrays of <em>characters</em> as input. I'm not sure if that's allowed.</p>
<p><a href="https://tio.run/nexus/jelly#@x9lrXR4n/ejpjVA9P/w8kNbFR7u2P6oYY5zYk6OQklGqkJOZl623qOGuQpZIEWN2ypMDi2BqvHKz8xTSM7PKc3NK1ZIqlRIyy8tUiguSExOLQbriERWV5RfDlYENC81LTU1Bazk///oaHVVdR0FdRMQYageq8OlEK2eCOIkgYhk9dhYkBqoCETaEKIBwqkEcaqBygA" rel="nofollow noreferrer" title="Jelly – TIO Nexus">Try it online!</a></p>
<p>It's a bit hard to determine what Jelly does under the hood when strings are involved, since it does a lot of splattening before printing. <a href="https://tio.run/nexus/jelly#@x9lrXR4n/ejpjVA9F/H@vDy8ENLj056uHMGkJ/1qGHOoW2Htv3/Hx2trqquo6BuAiIM1WN1uBSi1RNBnCQQkaweGwtSAxWBSBtCNEA4lSBONVAZAA" rel="nofollow noreferrer" title="Jelly – TIO Nexus">This is how Jelly represents input and output internally.</a></p>
<h3>How it works</h3>
<pre><code>Z;&quot;þK€€  Dyadic link. Left argument: B. Right argument: A

Z        Zip/transpose B.
 ;&quot;þ     Table vectorized concatenation; for each row in B' and each row in A,
         concatenate the corresponding strings.
    K€€  Join the arrays that correspond to the rows of A by spaces.
</code></pre>
</div>
<div id="pu9" class="pu"><h2>Mathematica, 36 bytes</h2>

<pre><code>Inner[#&lt;&gt;#2&amp;,##,StringRiffle@*List]&amp;
</code></pre>

<p><code>Inner</code> is a generalisation of Mathematica's <code>Dot</code> (i.e. the usual matrix/vector product). It generalises the dot product by letting you provide two function <code>f</code> and <code>g</code>, which will be used in place of the usual multiplication and addition, respectively. We're replacing the multiplication with <code>#&lt;&gt;#2&amp;</code> (which joins the the two characters into a single string) and the addition with <code>StringRiffle@*List</code>, which first wraps all the summands in a list, and then <code>StringRiffle</code> joins them together with spaces.</p>

<p>One could potentially use the <code>Dot</code> operator <code>.</code> and then transform the result, but the trouble is that things like <code>"a"*"a"</code> would immediately get transformed into <code>"a"^2</code> (same for sums), which would be annoying to pick apart again.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/106570/">106570</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




