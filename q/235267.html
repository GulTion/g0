<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::235267</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>857</td><td>closest so far “"^zHf%» => '"*zHf%' 6/7</td><td>231213T030505Z</td><td><a href="https://codegolf.stackexchange.com/questions/235267/jelly-compression-quine/267507#267507">guest430</a></td></tr>
</table>
<div id="pu0" class="pu"><h2>closest so far: <code>“&quot;^zHf-%»</code> =&gt; <code>'&quot;*zHf-%'</code>: 6/7, 85.7%</h2>
<p>no solution yet, but some preliminary results which may be helpful to others.</p>
<p>in the first step of decompression, you divmod by 3 to either select making a character or using one of the dictionaries. if you ignore the dictionary, this  means it basically reduces to a base conversion problem where one side is base <a href="https://en.wikipedia.org/wiki/Non-integer_base_of_numeration" rel="nofollow noreferrer" title="just a cooler way of saying the digits are read backwards, but otherwise the same as normal base 288 (obv. excluding the radix point)">1/288</a>: (using the <code>�</code> for when it would touch a dictionary and ¶ for a newline)</p>
<pre><code> ��!��&quot;��#��$��%��&amp;��'��(��)��*��+��,��-��.��/��0��1��2��3��4��5��6��7��8��9��:��;��&lt;��=��&gt;��?��@��A��B��C��D��E��F��G��H��I��J��K��L��M��N��O��P��Q��R��S��T��U��V��W��X��Y��Z��[��\��]��^��_��`��a��b��c��d��e��f��g��h��i��j��k��l��m��n��o��p��q��r��s��t��u��v��w��x��y��z��{��|��}��~��¶��
</code></pre>
<p>and the other side is <a href="https://en.wikipedia.org/wiki/Bijective_numeration" rel="nofollow noreferrer" title="basically means it starts at 1 instead of 0">bijective</a> base 250:</p>
<pre><code>¡¢£¤¥¦©¬®µ½¿€ÆÇÐÑ×ØŒÞßæçðıȷñ÷øœþ !&quot;#$%&amp;'()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~¶°¹²³⁴⁵⁶⁷⁸⁹⁺⁻⁼⁽⁾ƁƇƊƑƓƘⱮƝƤƬƲȤɓƈɗƒɠɦƙɱɲƥʠɼʂƭʋȥẠḄḌẸḤỊḲḶṂṆỌṚṢṬỤṾẈỴẒȦḂĊḊĖḞĠḢİĿṀṄȮṖṘṠṪẆẊẎŻạḅḍẹḥịḳḷṃṇọṛṣṭ§Äẉỵẓȧḃċḋėḟġḣŀṁṅȯṗṙṡṫẇẋẏż
</code></pre>
<p>since the symbols have different values from each other I think it's just a matter of coincidence to get the same number to be represented with the same symbols.</p>
<p>what this means is that until one of them out-bases the other (after 250^40 (roughly 8.27e95 or 2^318.7), base250 will always take more digits and you'd have to use the dictionaries to pad the output), there may be a number that matches somewhere. what I'm calling a 'near miss' is when an n-1 long string of digits are the same in both bases. I wrote some terrible python code to find a few, but I'm trying to translate it to rust and optimize a bit, and will update the answer when I can get more digits.</p>
<p>near misses at one digit: [<code>“/»</code> = <code>'0'</code>(2 off) and <code>“2»</code> = <code>'1'</code>(1 off)]<br />
near misses at two digits: [<code>“-Ñ»</code> = <code>'¶-'</code>(111 off) jumps to <code>“/_»</code> = <code>' .'</code>(303 off)]</p>
<pre><code>'&quot;*'   “S*»    8,793
'),'   “[,»   10,545
'0.'   “c.»   12,297
'70'   “k0»   14,049
'&gt;2'   “s2»   15,801
'E4'   “{4»   17,553
'c='   “&quot;=»   25,062
'j?'   “*?»   26,814
'qA'   “2A»   28,566
'xC'   “:C»   30,318
'¶E'   “BE»   32,070
also spotted “y©» = 'yC' which I thought was funny since the c is just circled
</code></pre>
<p>near misses at three digits: [<code>“+B&gt;»</code> = <code>'¶B+'</code>(65 off) jumps to <code>“+D⁽»</code> = <code>' C+'</code>(349 off)]</p>
<pre><code>'/D,'   “eD,»   3,017,295
';J/'   “*J/»   3,768,798
';Jb'   “;J/»   3,768,849
'G2 '   “EG2»   4,512,783
'G2#'   “FG2»   4,512,786
'G2&amp;'   “GG2»   4,512,789
'G2)'   “HG2»   4,512,792
'G2,'   “IG2»   4,512,795
'G2/'   “JG2»   4,512,798
'G22'   “KG2»   4,512,801
'G25'   “LG2»   4,512,804
'G28'   “MG2»   4,512,807
'G2;'   “NG2»   4,512,810
'G2&gt;'   “OG2»   4,512,813
'G2A'   “PG2»   4,512,816
'G2D'   “QG2»   4,512,819
'G2G'   “RG2»   4,512,822
'G2J'   “SG2»   4,512,825
'G2M'   “TG2»   4,512,828
'G2P'   “UG2»   4,512,831
'G2S'   “VG2»   4,512,834 [ it's so close to ]
'G2V'   “WG2»   4,512,837 [ being an anagram ]
'G2Y'   “XG2»   4,512,840 [ ...just needs to ]
'G2\'   “YG2»   4,512,843 [ shift a tiny bit ]
'G2_'   “ZG2»   4,512,846
'G2b'   “[G2»   4,512,849
'G2e'   “\G2»   4,512,852
'G2h'   “]G2»   4,512,855
'G2k'   “^G2»   4,512,858
'G2n'   “_G2»   4,512,861
'G2q'   “`G2»   4,512,864
'G2t'   “aG2»   4,512,867
'G2w'   “bG2»   4,512,870
'G2z'   “cG2»   4,512,873
'G2}'   “dG2»   4,512,876
'WW6'   “mW6»   5,522,055
'[Y&lt;'   “[Y7»   5,772,561
'c]9'   “2]9»   6,273,558
'¶j@'   “uj@»   8,026,815
'¶j^'   “¶j@»   8,026,845
</code></pre>
<p>near misses at four digits: [<code>“)f⁸ȧ»</code> = <code>'¶¶g)'</code> jumps to <code>“)i4Ḣ»</code> = <code>'  h)'</code>]</p>
<pre><code>'-I;*'   “-I;V»     723,390,087
'`G]5'   “`G]K»   1,520,148,576
</code></pre>
<p>near misses at five digits: [didn't calculate crossing point]</p>
<pre><code>'^)L75'   “n^)L7»   435,080,769,306
'f&gt;-A8'   “~f&gt;-A»   497,707,074,066
</code></pre>
<p>running the rust code overnight, it made it to somewhere in the middle of 7 digits; but I just noticed a bug in the code that means it didn't check any jelly strings with a ¶ in them, so I'll re run it later.
using a different definition of 'near miss' meaning checking that n-1 digits are the same, comparing at each index:</p>
<pre><code>&quot;*   S*   8793
),   [,   10545
0.   c.   12297
70   k0   14049
&gt;2   s2   15801
E4   {4   17553
c=   &quot;=   25062
j?   *?   26814
qA   2A   28566
xC   :C   30318
2 digits
/D,   eD,   3017295
/_,   /L,   3024045
;J/   *J/   3768798
;Jb   ;J/   3768849
WB6   WQ6   5516805
WW6   mW6   5522055
[Y&lt;   [Y7   5772561
c]9   2]9   6273558
3 digits
-I;V   -I;*   723390087
7iw,   7Rw,   881655045
`G]K   `G]5   1520148576
4 digits
)L]&lt;(   )L]&quot;(   165271515291
5 digits
6 digits
&quot;^zHf-%   &quot;*zHf-%   8638176928324038
</code></pre>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/235267/">235267</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




