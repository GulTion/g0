<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::120487</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>044</td><td>JavaScript Node.js</td><td>240403T064028Z</td><td><a href="https://codegolf.stackexchange.com/questions/120487/11-12345-123-6-4/272282#272282">l4m2</a></td></tr>
<tr d-ix="1"><td>027</td><td>05AB1E</td><td>201117T171714Z</td><td><a href="https://codegolf.stackexchange.com/questions/120487/11-12345-123-6-4/215318#215318">Kevin Cr</a></td></tr>
<tr d-ix="2"><td>059</td><td>PHP 7</td><td>201127T145535Z</td><td><a href="https://codegolf.stackexchange.com/questions/120487/11-12345-123-6-4/215688#215688">Titus</a></td></tr>
<tr d-ix="3"><td>026</td><td>Jelly</td><td>201118T190422Z</td><td><a href="https://codegolf.stackexchange.com/questions/120487/11-12345-123-6-4/215377#215377">Unrelate</a></td></tr>
<tr d-ix="4"><td>028</td><td>Jelly</td><td>170514T060213Z</td><td><a href="https://codegolf.stackexchange.com/questions/120487/11-12345-123-6-4/120519#120519">Jonathan</a></td></tr>
<tr d-ix="5"><td>032</td><td>Husk</td><td>201116T112536Z</td><td><a href="https://codegolf.stackexchange.com/questions/120487/11-12345-123-6-4/215255#215255">Razetime</a></td></tr>
<tr d-ix="6"><td>nan</td><td>C tcc</td><td>170515T180342Z</td><td><a href="https://codegolf.stackexchange.com/questions/120487/11-12345-123-6-4/120725#120725">hvd</a></td></tr>
<tr d-ix="7"><td>091</td><td>C</td><td>170514T065308Z</td><td><a href="https://codegolf.stackexchange.com/questions/120487/11-12345-123-6-4/120523#120523">Khaled.K</a></td></tr>
<tr d-ix="8"><td>064</td><td>Haskell</td><td>170514T014046Z</td><td><a href="https://codegolf.stackexchange.com/questions/120487/11-12345-123-6-4/120502#120502">&#216;rj</a></td></tr>
<tr d-ix="9"><td>081</td><td>Python 2</td><td>170514T084825Z</td><td><a href="https://codegolf.stackexchange.com/questions/120487/11-12345-123-6-4/120530#120530">ovs</a></td></tr>
<tr d-ix="10"><td>nan</td><td></td><td>170514T173340Z</td><td><a href="https://codegolf.stackexchange.com/questions/120487/11-12345-123-6-4/120573#120573">Brad Gil</a></td></tr>
<tr d-ix="11"><td>079</td><td>Mathematica</td><td>170514T170250Z</td><td><a href="https://codegolf.stackexchange.com/questions/120487/11-12345-123-6-4/120570#120570">Martin E</a></td></tr>
<tr d-ix="12"><td>074</td><td>PHP>=7.0</td><td>170513T232635Z</td><td><a href="https://codegolf.stackexchange.com/questions/120487/11-12345-123-6-4/120495#120495">J&#246;r</a></td></tr>
<tr d-ix="13"><td>126</td><td>Batch</td><td>170514T093243Z</td><td><a href="https://codegolf.stackexchange.com/questions/120487/11-12345-123-6-4/120535#120535">Neil</a></td></tr>
<tr d-ix="14"><td>138</td><td>Python 3</td><td>170513T232614Z</td><td><a href="https://codegolf.stackexchange.com/questions/120487/11-12345-123-6-4/120494#120494">L3viatha</a></td></tr>
<tr d-ix="15"><td>061</td><td>dc</td><td>170514T074416Z</td><td><a href="https://codegolf.stackexchange.com/questions/120487/11-12345-123-6-4/120526#120526">eush77</a></td></tr>
<tr d-ix="16"><td>104</td><td>Python 2</td><td>170514T034037Z</td><td><a href="https://codegolf.stackexchange.com/questions/120487/11-12345-123-6-4/120512#120512">mathmand</a></td></tr>
<tr d-ix="17"><td>072</td><td>Mathematica</td><td>170514T015650Z</td><td><a href="https://codegolf.stackexchange.com/questions/120487/11-12345-123-6-4/120504#120504">JungHwan</a></td></tr>
<tr d-ix="18"><td>092</td><td>Mathematica</td><td>170513T235239Z</td><td><a href="https://codegolf.stackexchange.com/questions/120487/11-12345-123-6-4/120496#120496">Greg Mar</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://nodejs.org" rel="nofollow noreferrer">JavaScript (Node.js)</a>, 44 bytes</h1>

<pre class="lang-javascript prettyprint-override"><code>f=(n,L,R)=&gt;n&gt;0?1+f(-n,0|R,L):n&amp;&amp;f(++L+n,L,R)
</code></pre>
<p><a href="https://tio.run/##y0osSyxOLsosKNHNy09J/f8/zVYjT8dHJ0jT1i7PzsDeUDtNQzdPx6AmSMdH0ypPTS1NQ1vbRxui5H9afpFGZkqFrYE1kLQxNDCw1tYGsjST8/OK83NS9XLy00HyOmkgUlPzPwA" rel="nofollow noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a></p>
<h1><a href="https://nodejs.org" rel="nofollow noreferrer">JavaScript (Node.js)</a>, 48 bytes</h1>

<pre class="lang-javascript prettyprint-override"><code>f=(n,S=L=R=0)=&gt;n&gt;0?f(n-++R,1)+!S:n&amp;&amp;f(++L+n,0)+S
</code></pre>
<p><a href="https://tio.run/##FclBCoNADEbhs3QjE/6xxK029gKunBOIGrFIUrSU3n6qm48H7zV8h2Pc1/enNJ/mnFWCxSSd9MIkrbX81GAl0MeKcEu1FYUGoINFJqSsvod1@gk3p4@KuQHOotHt8G2@b75cP@olUf4D" rel="nofollow noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a></p>
</div>
<div id="pu1" class="pu"><h1><a href="https://github.com/Adriandmen/05AB1E/wiki/Commands" rel="nofollow noreferrer">05AB1E</a>, <s>28</s> 27 <a href="https://github.com/Adriandmen/05AB1E/wiki/Commands" rel="nofollow noreferrer">bytes</a></h1>
<pre><code>ÅTθÊiÑÂ&lt;;+ʒ.ï}ßI·t2z+ï-&gt;·ë1
</code></pre>
<p>Port of <a href="https://codegolf.stackexchange.com/a/120519/52210"><em>@JonathanAllan</em>'s Jelly answer</a>, which is using <a href="https://codegolf.stackexchange.com/a/120570/52210"><em>@MartinEnder</em>'s Mathematica formula</a>, so make sure to upvote both of them!</p>
<p><a href="https://tio.run/##ATcAyP9vc2FiaWX//8OFVM64w4ppw5HDgjw7K8qSRMOvUX3Dn0nCt3QyeivDry0@wrfDqzH//zY1NTM2" rel="nofollow noreferrer">Try it online</a> or <a href="https://tio.run/##AUoAtf9vc2FiaWX/MTAwRU4/IiDihpIgIj9Ow5DCqf/DhVTOuMOKacORw4I8OyvKkkTDr1F9w5/CrsK3dDJ6K8OvLT7Ct8OrMf99w68s/w" rel="nofollow noreferrer">verify the first 100 test cases</a>. (NOTE: The <code>.ï</code> has been replaced with <code>DïQ</code> in the TIOs, because <a href="https://github.com/Adriandmen/05AB1E/issues/160" rel="nofollow noreferrer">this <code>.ï</code> bug on floating values, which was fixed on October 23rd</a>, hasn't been pushed to TIO yet.)</p>
<p><strong>Explanation:</strong></p>

<pre class="lang-python prettyprint-override"><code>ÅT             # Push a list of triangular numbers smaller than or equal to the
               # (implicit) input-integer
  θ            # Pop and only leave the last value in this list
   Êi          # If it's NOT equal to the (implicit) input, so the input isn't a
               # triangular number:
     Ñ         #  Get all divisors of the (implicit) input
      Â        #  Bifurcate this list (short for Duplicate &amp; Reverse copy)
       &lt;       #  Decrease each by 1 in the reversed list
        ;      #  Then halve each
         +     #  And add the values at the same positions in the lists together
          ʒ    #  Filter it by:
           .ï  #   Where the decimal value is an integer
          }ß   #  After the filter: pop and leave the minimum
     I·        #  Push the input again and double it
       t       #  Take the square-root of this
        2z+    #  Add 1/2 to it
           ï   #  Floor it to an integer
     -         #  Subtract it from the earlier minimum
      &gt;        #  Increase it by 1
       ·       #  Double it
    ë          # Else (the input is a triangular number):
     1         #  Simply push a 1
               # (after which the top of the stack is output implicitly as result)
</code></pre>
</div>
<div id="pu2" class="pu"><h2>PHP 7, 59 Bytes</h2>
<p>(7.0.1 or later)</p>

<pre class="lang-php prettyprint-override"><code>for(;$d=$argn&lt;=&gt;$s;$x+=$d!=($argn&lt;=&gt;$s))$s+=$$d+=$d;echo$x;
</code></pre>
<p>Run as pipe with <code>-nR</code> or <a href="http://sandbox.onlinephpfunctions.com/code/f4fb3281ef1360cceecd0b16b1dd8042a6b75489" rel="nofollow noreferrer">try it online</a>.</p>
<h3>breakdown:</h3>
<pre class="lang-php prettyprint-override"><code>for(;$d=$argn&lt;=&gt;$s;     # $s&lt;N: $d=+1, $s&gt;N: $d=-1, $s==N: 0 -&gt; falsy -&gt; break
    $x+=$d!=($argn&lt;=&gt;$s))   # 3. if sign of difference changed, increment counter
    $s+=                    # 2. add to sum
        $$d+=$d;            # 1. increment ${1} or decrement ${-1}
echo$x;                 # print step counter
</code></pre>
<p>uses the spaceship operator <code>&lt;=&gt;</code> (<a href="https://www.php.net/migration70.new-features#migration70.new-features.spaceship-op" rel="nofollow noreferrer">introduced in PHP 7.0</a>) and variable variables (<a href="https://www.php.net/manual/phpfi2.php#varvars" rel="nofollow noreferrer">introduced in PHP/FI</a>).</p>
<p>Thanks <a href="https://codegolf.stackexchange.com/a/120495/55735">@Jörg</a> for reminding me of the spaceship.</p>
<p>Without the parentheses around the spaceship in the post condition, PHP wouldn not know what comparison to evaluate first (and throw a syntax error).</p>
<h2>PHP 7 (unary output), 53 bytes</h2>
<pre class="lang-php prettyprint-override"><code>for(;$d=$argn&lt;=&gt;$s;print$d!=($argn&lt;=&gt;$s))$s+=$$d+=$d;
</code></pre>
</div>
<div id="pu3" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="nofollow noreferrer">Jelly</a>, 26 bytes</h1>
<pre><code>S&gt;³
RÄ&lt;i0RḊÇ¿Ṃ;‘ƊÇ?S⁻³ƊÐ¿L
</code></pre>
<p><a href="https://tio.run/##y0rNyan8/z/Y7tBmrqDDLTaZBkEPd3Qdbj@0/@HOJutHDTOOATn2wY8adx/aDGROOLTf5////4aGAA" rel="nofollow noreferrer" title="Jelly – Try It Online">Try it online!</a></p>
<p>Full program only, because <a href="https://github.com/DennisMitchell/jellylanguage/blob/70c9fd93ab009c05dc396f8cc091f72b212fb188/jelly/interpreter.py#L1278" rel="nofollow noreferrer"><code>¿</code> handles dyads in an... interesting way.</a></p>
<p>Directly implements the given algorithm.</p>
<pre><code>S&gt;³                       Monadic helper link:
S                         the sum of the argument,
 &gt;                        is it greater than
  ³                       the input (to the entire program)?

RÄ&lt;i0RḊÇ¿Ṃ;‘ƊÇ?S⁻³ƊÐ¿L    Main link:
 Ä                        cumulative sums of
R                         [1 .. input],
   i0                     first index of 0 in
  &lt;                       whether or not each sum is less than the input,
     R                    starting with [1 .. that index]:
                    ¿     while
               S⁻³Ɗ       the sum is not equal to the input,
              ?           if
             Ç            (helper link) the sum is greater than the input,
      Ḋ                   then remove the first element
       Ç¿                 while the sum is greater than the input,
          ;   ?           else concatenate
         Ṃ                the smallest element to
           ‘Ɗ             the list incremented.
                   Ð¿L    Output the number of iterations this took.
</code></pre>
<p>I haven't finished verifying execution times, but specifically for N = 65536 TIO takes 9 seconds while my computer takes 15.</p>
<p>EDIT: My machine seems to have taken more than a minute for N = 32924, 32933, and 32941. TIO computes each result in less than 5 seconds, however, so I suspect this may be because the lid of my laptop was closed for eight hours.</p>
<p>N = 45596 also just now took a minute and 9 seconds, but this also coincided with my laptop going to sleep, and TIO takes less than 2 seconds for it.</p>
</div>
<div id="pu4" class="pu"><h1><a href="https://github.com/DennisMitchell/jelly" rel="nofollow noreferrer">Jelly</a>, <s>29 31</s> 28 <a href="https://github.com/DennisMitchell/jelly/wiki/Code-page" rel="nofollow noreferrer">bytes</a></h1>
<p>-3 thanks to <a href="https://codegolf.stackexchange.com/users/66833">caird coinheringaahing</a> (save a <code>$</code>, use the newer <code>Ä</code>, and use the newer <code>Ƒ</code>)</p>
<pre><code>ÆDµ’H+ṚḞƑƇṂ
&gt;TḢ_@Ç}‘Ḥ
RÄðċȯç
</code></pre>
<p>A monadic link that returns the result (N=65536 takes less than two seconds).</p>
<p><strong><a href="https://tio.run/##AUMAvP9qZWxsef//w4ZEwrXigJlIK@G5muG4nsaRxofhuYIKPlThuKJfQMOHfeKAmOG4pApSw4TDsMSLyK/Dp////zY1NTM2" rel="nofollow noreferrer" title="Jelly – Try It Online">Try it online!</a></strong></p>
<h3>How?</h3>
<p>For a thorough explanation of the algorithm see the <a href="https://codegolf.stackexchange.com/a/120570/53748">fantastic post by Martin Ender</a>.</p>
<pre><code>ÆDµ’H+ṚḞƑƇṂ - Link 1, smallest natural number, M, that satisfies the below*, N
            - * N = T(M) - T(i) for some non-negative integer i &lt;= M
ÆD          - divisors of N
  µ         - monadic chain separation, call that d
   ’        - increment d (vectorises)
    H       - halve (vectorises
      Ṛ     - reverse d
     +      - add (vectorises)
         Ƈ  - filter keep if:
        Ƒ   -   is invariant under:
       Ḟ    -     floor (i.e. those which are the result of even divisors)
          Ṃ - minimum

&gt;TḢ_@Ç}‘Ḥ - Link 2, evaluate result for non-triangular: list of T(1) to T(N), N
&gt;         - T(i) &gt; N
 T        - truthy indexes
  Ḣ       - head (yields the first i for which T(i) &gt; N)
     Ç}   - call last link (1) as a monad converted to a dyad using the right argument
   _@     - subtract with reverse @rguments
       ‘  - increment
        Ḥ - double 

RÄðċȯç - Main link: N
R      - range -&gt; [1,2,...,N]
 Ä     - reduce with addition -&gt; [1,3,6,10,...T(N)]
  ð    - dyadic chain separation, call that t
   ċ   - count occurrences of N in t (1 if N is triangular else 0)
     ç - call last link (2) as a dyad(t, N)
    ȯ  - or
</code></pre>
<hr />
<p>The 29 byte full-program implementation I created of the algorithm described takes 4 min 30 for N=65536 on my laptop, so I suppose it does not count.</p>
<pre><code>Ṁ‘ṭµS&lt;³µ¿
ḊµS&gt;³µ¿
0®Ḃ‘©¤ĿÐĿL’
</code></pre>
</div>
<div id="pu5" class="pu"><h1><a href="https://github.com/barbuz/Husk" rel="nofollow noreferrer">Husk</a>, 32 bytes</h1>
<pre><code>→L↑o≠⁰Σ¡?oḟo≤⁰ΣṫS:o→→o&gt;⁰Σḟo&gt;⁰ΣḣN
</code></pre>
<p><a href="https://tio.run/##yygtzv7//1HbJJ9HbRPzH3UueNS44dziQwvt8x/umA/kLwHzH@5cHWyVD1QFRPl2ECGgNIy12O////@GhgA" rel="nofollow noreferrer" title="Husk – Try It Online">Try it online!</a></p>
<p>Not that this will <em>not</em> run in 1 minute for n-65536, hence it cannot compete.</p>
<p>However, it can theoretically calculate for any given n.</p>
</div>
<div id="pu6" class="pu"><h1>C (tcc), 71 bytes (61+10)</h1>

<p>Command-line arguments (including a space):</p>

<pre><code>-Dw=while
</code></pre>

<p>Source:</p>

<pre><code>c,m,M,s;f(n){w(++c,s-n){w(c&amp;s&lt;n)s+=++M;w(~c&amp;s&gt;n)s-=m++;}--c;}
</code></pre>

<p>How it works:</p>

<p><code>c</code> counts the number of steps. <code>m</code> and <code>M</code> store the minimum and maximum of the range, <code>s</code> the sum. Initially, they're all zero.</p>

<p>Continuously, <code>c</code> is increased, and <code>s</code> is compared to <code>n</code>. As long as they're unequal:</p>

<ul>
<li><p>If <code>c</code> is odd, then as long as <code>s&lt;n</code>, add an integer to the end of the range: increase <code>M</code> by one, and <code>s</code> by <code>M</code>.</p></li>
<li><p>If <code>c</code> is even, then as long as <code>s&gt;n</code>, remove an integer from the start of the range: decrease <code>s</code> by <code>m</code>, and increase <code>m</code> by one.</p></li>
</ul>

<p>When the loop exits, <code>c</code> has been increased one too many times. Decrementing it produces the correct result, and it happens to be calculated in the correct register to act as the return value.</p>

<p>Amusingly happens to use the exact same variable names as <a href="https://codegolf.stackexchange.com/a/120523">Khaled.K's C answer</a>. They aren't copied.</p>
</div>
<div id="pu7" class="pu"><h1>C, <s>94</s> 91 bytes</h1>



<p><a href="http://ideone.com/bIiKpU" rel="nofollow noreferrer"><strong>Try Online</strong></a></p>

<pre class="lang-c prettyprint-override"><code>c;s;m;M;f(n){while(s-n){while(s&lt;n)s+=++M;c++;if(s==n)break;while(s&gt;n)s-=++m;c++;}return c;}
</code></pre>
</div>
<div id="pu8" class="pu"><h1><a href="https://www.haskell.org/" rel="nofollow noreferrer">Haskell</a>, <s>70 63 68</s> 64 bytes</h1>
<p>EDIT:</p>
<ul>
<li>-7 bytes: Got rid of a space, two signs, and some parentheses by negating the sense of <code>a</code>. Fixed off-by-one errors in the explanation.</li>
<li>+5 bytes: Argh, completely missed that 65536 requirement, and it turns out (1) powers of 2 are particularly expensive, because they only get hit when you get to the number itself (2) so is summing long ranges (that wrap <em>around</em> zero) all the time. Replaced the sum with a mathematical formula.</li>
<li>-4 bytes: Adjusted <code>a</code> and <code>b</code> linearly to get terms in the summation formula to cancel.</li>
</ul>
<p><code>1#1</code> is an anonymous function taking and returning an integer.</p>
<p>Use as <code>(1#1) 100</code>.</p>

<pre class="lang-hs prettyprint-override"><code>1#1
(a#b)n|s&lt;-a*a-b*b=sum$[a#(b+2)$n|s&gt;8*n]++[(b#a)(-n)+1|s&lt;8*n]
</code></pre>
<p><a href="https://tio.run/nexus/haskell#FZBNbuMwDIX3PcWHJgs7hgOTEiUKaHKRzizsNsUEmKhF3KKb3j1VliTf4/u5zOd6ONfP03V@@dx@1f/nelr3l/mj6/7U8bj@e/@mDsMj45HHYbjP3Ru17/fX0/za77/fr6/r7e0gG3no5s3S15/1aZx387jslsP6ddk@z5tuGbTftsvRd/XvMDx3y2buu7H2gzT4fXm7CUogYiQyTkEmRBBFAhIRQxKSEUcKOqGNo2hAI2poQjPqaCFMBCG0l4EQCUZIhExwQiFORCEqsSlGohETMROdWLAJE0yxgDVDhiUsY44V0kQSkpICKZKa30TKJCcV8kQWspIDOZKN3OJkspMLPuGCKx7wiBue8JbW8UKZKEJRSqBEilESJVNaGfc2mrBZSL8" rel="nofollow noreferrer" title="Haskell – TIO Nexus">Try it online!</a></p>
<h1>How it works</h1>
<ul>
<li><code>(a#b)n</code> represents the current step of calculation. <code>a, b</code> are numbers in <code>1, 3, 5, ..</code>, while <code>n</code> can be either positive or negative depending on the step.
<ul>
<li>When in step 1 or 3, it represents the list <code>[(a+1)/2,(a+3)/2..(b-1)/2]</code> and goal number <code>-n</code>.</li>
<li>When in step 2, it represents the list <code>[(b+1)/2,(b+3)/2..(a-1)/2]</code> and goal number <code>n</code>.</li>
</ul>
</li>
<li>The strange correspondence between <code>a, b</code> and the lists is in order to be able to do summation with the short expression <code>s=a*a-b*b</code>.
<ul>
<li>In step 1 and 3, this is the same as <code>s= -8*sum[(a+1)/2..(b-1)/2]</code>.</li>
<li>In step 2, this is the same as <code>s=8*sum[(b+1)/2..(a-1)/2]</code>.</li>
</ul>
</li>
<li>Branching is done by having list comprehensions that produce elements in only one case each, and summing the results.
<ul>
<li>If <code>s&gt;8*n</code>, then <code>b</code> is incremented by 2 before recursing.
<ul>
<li>In step 1 and 3, this grows the list, while in step 2, this shrinks it.</li>
</ul>
</li>
<li>If <code>s&lt;8*n</code>, then recursion changes the step by swapping <code>a</code> and <code>b</code>, and negating <code>n</code>, and 1 is added to the result.</li>
<li>If <code>s==8*n</code>, then neither of the two list comprehensions gives any elements, so the sum is <code>0</code>.</li>
</ul>
</li>
<li><code>(1#1) n</code> represents a dummy &quot;stage 2&quot; before starting, that immediately gets changed to step 1, building the list from <code>[1..0]=[]</code>.</li>
</ul>
</div>
<div id="pu9" class="pu"><h1>Python 2, <s>86</s> 81 bytes</h1>



<pre class="lang-python prettyprint-override"><code>n=input()
l=u=i=s=0
while n:k=n&gt;0;i+=k^s;s=k;l+=k;n-=l*k;u+=k^1;n+=u*-~-k
print i
</code></pre>

<p><a href="https://tio.run/nexus/python2#FcgxCoAwDAXQvafoqJVCuhq@R3ETDCmh2BY3r151e7xhECu9TbPL6BBUkLtPyYe3VWEbsSzQvXKFcv7IFpGDcv87sS3oIT5RXbnEmpcxEtEL" rel="nofollow noreferrer" title="Python 2 – TIO Nexus">Try it online!</a></p>

<p>Computes the <em>65536</em> test case in <code>0.183s</code> on TIO.</p>

<hr>

<p><strong>This recursive version at 84 bytes is not able to compute all values up to 65536:</strong>
</p>

<pre class="lang-python prettyprint-override"><code>def f(n,l=[0],m=1):k=n&gt;sum(l);return n==sum(l)or f(n,[l[1:],l+[l[-1]+1]][k],k)+(m^k)
</code></pre>

<p><a href="https://tio.run/nexus/python3#JYtBCgIxDAC/0mNiI2yuK/UjIYJgK6VtlLj7/rrobRhm5iOXUMCoJ1mURmJcW7LrZx/Q8eJ5292CpfQXL//F0oVXpR4POLNGVpWm1DDCuDWcb6@2wUkKVCzHU0O14Hd7ZmDihVFxfgE" rel="nofollow noreferrer" title="Python 3 – TIO Nexus">Try it online!</a></p>
</div>
<div id="pu10" class="pu">

<h1><a href="https://perl6.org" rel="nofollow noreferrer">Perl 6</a>, 114 bytes</h1>

<pre class="lang-perl6 prettyprint-override"><code>{((0,0,1),-&gt;(\a,\b,\c){b,(a..*).first(-&gt;\d{(d,b).minmax.sum*c&gt;=$_*c}),-c}...-&gt;(\a,\b,\c){(a,b).minmax.sum==$_})-1}
</code></pre>

<p>(inspired by an earlier <a href="https://codegolf.stackexchange.com/questions/120487/11-12345-123-6-4/120502#120502">Haskell</a> implementation)</p>

<p><a href="https://tio.run/nexus/perl6#dVBLboMwEN1zilnQxo7MyDbgRkLkJEiRA6FKVULEp2oVcbLuejFqPhEmalczHr/fTFuf4ENhGjnFFzynZXaCuL8RwhlngjJvTxLNkiNLUno7MqIRtxTzc1U3xNsn2Y1k7EixOF8K/Yl1W2zTfewetmlnuGmHiCsFotfo2GA76omuN@7uu65ejT3Uja4aGLOoMPRV5FzbBtzDzzfmRUM2T37GNhTfyvMF8rICIhAF50ZYX8m4A8WqbMqKSE6jHkAwAMmmGli9qYL/8aeWmRzqboV1FrINtoTFPBOGGPJ/RBeeA3J@yJ2VxvQ@X8RGwmziq/UWw3wIE9wTBoP7BBbcEg0exO7pwjnt4yahGoWdKZ0BK74ApHU/pdZ3HOZyxg2pXqw7gvoF" rel="nofollow noreferrer" title="Perl 6 – TIO Nexus">Try it</a><br>
It runs with an input of 65536 in under 45 seconds on my computer, but I have been unable to get it to run in under 60 seconds with TIO.run.<br>
I have Rakudo v2017.04+ , where it has <a href="https://tio.run/nexus/perl6#@19QlJlXoqCiFeAa5KOXnJ9bkJmTWqSXnllc8v//17x83eTE5IxUAA" rel="nofollow noreferrer" title="Perl 6 – TIO Nexus">v2017.01</a>.<br>
Rakudo/NQP/MoarVM gets optimizations almost daily, so there could be any number of them from the interim that are needed to get it in under time.</p>

<hr>

<h2>Expanded</h2>

<pre class="lang-perl6 prettyprint-override"><code>{
  (

    # generate a sequence

    (0,0,1),           # initial value 

    -&gt; (\a,\b,\c) {
      b,               # swap the first two values

      (a..*)
      .first(          # find the first number that brings us to or past the input

        -&gt; \d {
          (d,b).minmax # get a Range object regardless of which is larger
          .sum * c     # sum it, and negate it every other time

          &gt;=           # is it equal to or greater than

          $_ * c       # negate the original input every other time
        }

      ),

      -c               # invert for next round
    }

    ...                # keep doing that until

    -&gt; (\a,\b,\c) {
     (a,b).minmax.sum == $_ # it finally reaches the input
    }

  ) - 1 # count the number of elements in the sequence
        # and subtract one for the initializer
}
</code></pre>

<p>Note that Rakudo has an optimization for <code>Range.sum</code> so that it doesn't have to iterate through all of the values.</p>
</div>
<div id="pu11" class="pu"><h2>Mathematica, 79 bytes</h2>

<pre><code>Min[2#/(d=Divisors@#~Cases~_?OddQ)+d]-2⌊(2#)^.5+.5⌋+⌈Sqrt[8#+1]~Mod~1⌉&amp;
</code></pre>

<h3>Explanation</h3>

<p>I couldn't be bothered to implement the algorithm in the challenge, so I wanted to look for a shortcut to the solution. While I found one, unfortunately it doesn't beat the Mathematica answer that does implement the algorithm. That said, I'm sure this isn't optimally golfed yet, and there might be other languages who can benefit from this approach or some of the insights gained in the process.</p>

<p>So I claim that the sequence we're supposed to compute is:</p>

<p><strong>f(n) = 2*(<a href="https://oeis.org/A212652" rel="noreferrer">A212652</a>(n) - <a href="https://oeis.org/A002024" rel="noreferrer">A002024</a>(n)) + 1 + <a href="https://oeis.org/A023532" rel="noreferrer">A023532</a>(n-1)</strong></p>

<p>Alternatively, it's <strong>f(n) = 1</strong> if <strong>n</strong> is a triangular number and <strong>f(n) = 2*(<a href="https://oeis.org/A212652" rel="noreferrer">A212652</a>(n) - <a href="https://oeis.org/A002024" rel="noreferrer">A002024</a>(n) + 1)</strong> otherwise.</p>

<p>In the first expression, <strong><a href="https://oeis.org/A023532" rel="noreferrer">A023532</a></strong> simply encodes these two different cases. The other two sequences (plus 1) are the difference between the the largest integer <strong>k</strong> in the longest decomposition of <strong>n</strong> into consecutive integers <strong>(k-i+1) + (k-i+2) + ... + k = n</strong> and the largest integer <strong>j</strong> so that <strong>1 + 2 + ... + j &lt; n</strong>.</p>

<p>In somewhat simpler words, here is how we find the answer for non-triangular numbers: first, find the largest triangular number <strong>T<sub>j</sub></strong> which is <em>less</em> than <strong>n</strong>. Then <strong>j</strong> is the penultimate integer that gets added during step <strong>1</strong> (because after adding <strong>j+1</strong> we will have exceeded <strong>n</strong>). Then decompose <strong>n</strong> into as many (or as small) consecutive integers as possible and call the maximum among these numbers <strong>k</strong>. The result is simply <strong>2*(k-j)</strong>. The intuitive reason for this is that the maximum in the decomposition grows by <strong>1</strong> every other step and we stop when we reach <strong>k</strong>.</p>

<p>We need to show four things to prove that this works:</p>

<ol>
<li><strong>f(n) = 1</strong> for triangular numbers. This is trivially the case, because the first step simply iterates through all triangular numbers. If we hit <strong>n</strong> exactly during this process we're done and there was only one step to compute.</li>
<li>For all other numbers, we always end after a deletion step, never after an insertion step. That means all other <strong>f(n)</strong> are even.</li>
<li>In each insertion step after the first, we only add a single number. This guarantees that we'll reach a decomposition including <strong>k</strong> after <strong>k-j</strong> pairs of steps.</li>
<li>The final decomposition of <strong>n</strong> that we obtain is always the longest possible decomposition of <strong>n</strong> into consecutive integers, or in other words, it's always the decomposition of <strong>n</strong> with the lowest maximum among the summed numbers. In other words, the last number we add to the sum is always <strong><a href="https://oeis.org/A212652" rel="noreferrer">A212652</a>(n)</strong>.</li>
</ol>

<p>We've already shown why (1) is true. Next, we prove that we can't end on an insertion step except the initial one (which doesn't happen for non-triangular numbers).</p>

<p>Suppose we ended on an insertion step, reaching <strong>n</strong> after adding a value <strong>p</strong> to the sum. That means that before this insertion step, the value was <strong>n-p</strong> (<em>or less</em> if we added multiple values at once). But this insertion step was preceded by a deletion step (since we couldn't have hit <strong>n</strong> during step 1). The last value <strong>q</strong> we removed during this deletion step was necessarily less than <strong>p</strong> due to the way the algorithm works. But that means before we removed <strong>q</strong> we had <strong>n-p+q</strong> (<em>or less</em>) which is less than <strong>n</strong>. But that's a contradiction, because we would have had to stop removing integers when we hit <strong>n-p+q</strong> instead of removing another <strong>q</strong>. This proves point (2) above. So now we know that we always end on a deletion step and that therefore all non-triangular numbers have even outputs.</p>

<p>Next we prove (3), that each insertion step can only insert one value. This is essentially a corollary of (2). We have shown that after adding one value we cannot hit <strong>n</strong> exactly and since the prove was using an inequality, we also cannot end up below <strong>n</strong> (since then <strong>n-p+q</strong> would still be less than <strong>n</strong> and we shouldn't have removed that many values in the first place). So whenever we add a single value, we're guaranteed to exceed <strong>n</strong> because we went below <strong>n</strong> by removing a smaller value. Hence, we know that the upper end of the sum grows by <strong>1</strong> every other step. We know the initial value of this upper end (it's the smallest <strong>m</strong> such that <strong>T<sub>m</sub> > n</strong>). Now we just need to figure out this upper end once we've reached the final sum. Then the number of steps is simply twice the difference (plus 1).</p>

<p>To do this, we prove (4), that the final sum is always the decomposition of <strong>n</strong> into as many integers as possible, or the decomposition where the maximum in that decomposition is minimal (i.e. it's the earliest possible decomposition). We'll again do this by contradiction (the wording in this part could be a bit more rigorous, but I've already spent way too much time on this...).</p>

<p>Say the earliest/longest possible decomposition of <strong>n</strong> is some <strong>a + (a+1) + ... (b-1) + b</strong>, <strong>a ≤ b</strong>, and say the algorithm skips it. That means at the time that <strong>b</strong> gets added, <strong>a</strong> must no longer be part of the sum. If <strong>a</strong> was part of the sum <strong>s</strong>, then we'd have <strong>n ≤ s</strong> at that moment. So either the sum only contains the values from <strong>a</strong> to <strong>b</strong>, which equals <strong>n</strong> and we stop (hence we didn't skip this decomposition), or there is at least one value less than <strong>a</strong> in the sum, win which case <strong>n &lt; s</strong> and that value would get removed until we hit the exact sum (again, the decomposition wasn't skipped). So we'd have to get rid of <strong>a</strong> before adding <strong>b</strong>. But that means we'd have to reach a situation in which <strong>a</strong> is the smallest component of the sum, and the largest isn't <strong>b</strong> yet. However, at that point we can't remove <strong>a</strong>, because the sum is clearly less than <strong>n</strong> (since <strong>b</strong> is missing), so we're required to add values first until we add <strong>b</strong> and hit <strong>n</strong> exactly. This proves (4).</p>

<p>So taking these things together: we know that the first pair of steps gives us a maximum value of <strong><a href="https://oeis.org/A002024" rel="noreferrer">A002024</a>(n)</strong>. We know that the maximum value of the final decomposition is <strong><a href="https://oeis.org/A212652" rel="noreferrer">A212652</a>(n)</strong>. And we know that this maximum is incremented once in every pair of steps. Hence, the final expression is <strong>2*(<a href="https://oeis.org/A212652" rel="noreferrer">A212652</a>(n) - <a href="https://oeis.org/A002024" rel="noreferrer">A002024</a>(n) + 1)</strong>. This formula almost works for triangular numbers, except that for those we only need 1 step instead of 2, which is why we correct the result with the indicator function of the triangular numbers (or its inverse, whichever is more convenient).</p>

<p>Finally, as for the implementation. For the former sequence, I'm using the formula <strong>MIN(odd d|n; n/d + (d-1)/2)</strong> from OEIS. It turns out to save a few bytes if we take the factor of <strong>2</strong> into this expression to get <strong>MIN(odd d|n; 2n/d + d-1)</strong>, because that <strong>-1</strong> then cancels with the <strong>+1</strong> in my first version of <strong>f(n)</strong> which directly encodes the two cases for triangular and non-triangular numbers. In the code, this is:</p>

<pre><code>Min[2#/(d=Divisors@#~Cases~_?OddQ)+d]
</code></pre>

<p>For the latter sequence (<code>1, 2, 2, 3, 3, 3, ...</code>), we can use a simple closed form:</p>

<pre><code>⌊(2#)^.5+.5⌋
</code></pre>

<p>And finally, the inverse indicator function of the triangular numbers is <strong>0</strong> whenever <strong>8n+1</strong> is a perfect square. This can be expressed in Mathematica as </p>

<pre><code>⌈Sqrt[8#+1]~Mod~1⌉
</code></pre>

<p>There are a lot of ways to express these last two sequences and to shift some constant offset between them, so I'm sure this is not an optimal implementation yet, but I hope this might give others a starting point to look into new approaches in their own languages.</p>

<p>Since I went to all this trouble, here is a plot of the sequence up to <strong>n = 1000</strong> (I could also compute 100k in a couple of seconds, but it doesn't really show any additional insights):</p>

<p><a href="https://i.stack.imgur.com/e8IqN.png" rel="noreferrer"><img src="https://i.stack.imgur.com/e8IqN.png" alt="enter image description here"></a></p>

<p>It might be interesting to look into the variations about those very straight lines, but I'll leave that to someone else...</p>
</div>
<div id="pu12" class="pu"><h1>PHP>=7.0, 74 Bytes</h1>

<pre class="lang-php prettyprint-override"><code>while($i=$r&lt;=&gt;$argn)for($s++;($r&lt;=&gt;$argn)==$i;)$r+=$i+1?-++$y:++$x;echo$s;
</code></pre>

<p>use the <a href="http://php.net/manual/en/migration70.new-features.php#migration70.new-features.spaceship-op" rel="nofollow noreferrer">spaceship operator</a></p>

<p><a href="https://tio.run/nexus/php#s7EvyCjgSi0qyi@KL0otyC8qycxL16hzjffzD/F0dtW05lJJLErPszUzNTU2s/5fnpGZk6qhkmmrUmRjaweW0kzLL9JQKdbWttZAErS1Vcm01lQp0gbS2ob2utraKpVWQKLCOjU5I1@l2Pr/fwA" rel="nofollow noreferrer" title="PHP – TIO Nexus">Try it online!</a></p>

<p>Expanded</p>

<pre><code>while($i=$r&lt;=&gt;$argn) # if input is not equal sum of array
  for($s++;  # raise count steps
  ($r&lt;=&gt;$argn)==$i;)
  # so long as value compare to input has not change to lower/higher to higher/lower or equal  
    $r+=$i+1
      ?-++$y # if $i was higher remove the first integer
      :++$x;} # if $i was lower add the next highest integer     
echo$s; # Output steps
</code></pre>
</div>
<div id="pu13" class="pu"><h2>Batch, 126 bytes</h2>

<pre><code>@echo off
set/an=s=l=u=0
:l
if %s% lss %1 set/as+=u+=1,n+=!!l&amp;goto l
if %s% gtr %1 set/as-=l+=1&amp;goto l
cmd/cset/an+n+2-!l
</code></pre>

<p>Explanation: <code>l</code> is zero if step 2 has never executed. This allows <code>n</code> to track number of iterations of step 3. Since the algorithm never stops at step 3, it must therefore have run step 1 once and step 2 <code>n+1</code> times for a total of <code>n+n+2</code> steps. However if the parameter is a triangular number then step 2 never executes so we need to subtract one step.</p>
</div>
<div id="pu14" class="pu"><h1>Python 3, <s>150</s> 138 bytes</h1>

<pre><code>n=int(input())
S=sum
l=[1]
i=s=1
while S(l)&lt;n:i+=1;l+=[i]
while S(l)!=n:
 while S(l)&gt;n:l.pop(0)
 s+=1
 if S(l)&lt;n:i+=1;l+=[i];s+=1
print(s)
</code></pre>

<p>Changelog:</p>

<ul>
<li>Changed append to +=, removed else (thanks musicman523, Loovjo; -12 bytes)</li>
</ul>
</div>
<div id="pu15" class="pu"><h1><a href="https://www.gnu.org/software/bc/manual/dc-1.05/html_mono/dc.html" rel="nofollow noreferrer">dc</a>, 61 bytes</h1>

<pre><code>dsN[ddd9k4*d2*1+dv-0k2/-d1+*2/-d[q]s.0=.-lN-0lN-sNlFx]dsFxz2-
</code></pre>

<p><a href="https://tio.run/nexus/dc#HZC9bhtBDIT771FknLP8XbII0rmz4F5QleusIsEBhuCXV1YpiCk4Q87M5bEf58u@7/3pp11P8rJ/beNTf2y7vJyecPl7PV7Hz9ftdt7GmuN8e7tf9@Pt/q3b43p8XH7/@t7/U24f9z@39@fy/f4QFMMJkknRyEAEUcQQRwJJZCKFNDrQpVHUUEcDTXSihTY2MMHWScMcCyyxiRXW@MAFV3x9dDzwxCdeeBODEEIJI5ahIJKYRBFNDlJIJY10cvlNcpJFNnMwhalMYzozmCvOZBazqUEJpZRRTgWV1EpbVNODFlppo50OOulJrzKebYx/" rel="nofollow noreferrer" title="dc – TIO Nexus">Try it online!</a></p>

<h2>Explanation</h2>

<p>Main recursive macro:</p>

<pre><code>ddd9k4*d2*1+dv-0k2/-d1+*2/-d[q]s.0=.-lN-0lN-sNlFx
   9k4*d2*1+dv-0k2/-                              # Compute triangular root
                    d1+*2/                        # Compute triangular number
  d                       -d[q]s.0=.              # Check if sum is exact
 d                                  -lN-          # Compute S-N or S+N
                                        0lN-sN    # Update N := -N
d                                             lFx # Leave the trail and recurse
</code></pre>

<p>This macro:</p>

<ol>
<li>Finds minimum triangular number that exceeds the current number on the stack (using the modified <a href="https://en.wikipedia.org/wiki/Triangular_number#Triangular_roots_and_tests_for_triangular_numbers" rel="nofollow noreferrer">triangular root</a> formula).</li>
<li>Checks if triangular sum <code>S</code> represents the current number exactly. Exits if it does.</li>
<li>Proceeds to step 1 with either <code>S+N</code> (over-approximation) or <code>S-N</code> (under-approximation), the choice alternates between iterations.</li>
</ol>

<p>When it does exit, the trail left on the stack tells the main program how many iterations it took.</p>
</div>
<div id="pu16" class="pu"><h1><a href="https://docs.python.org/2/" rel="noreferrer">Python 2</a>, 104 bytes</h1>



<pre class="lang-python prettyprint-override"><code>N=input();i=s=0;l=()
while N!=sum(l):exec'while sum(l)'+['&lt;N:i+=1;l+=i,','&gt;N:l=l[1:]'][s%2];s+=1
print s
</code></pre>

<p><a href="https://tio.run/nexus/python2#JckxCoAwDADA3VfoIGmpg3VsjU/oB0onKRiIIkbR31fB9a4EpG2/TqU9oWDvGZWu7oU416FBuVbF2uUnz/DjL2AijMGRQevZIHXQwRQcI0frEqQo7ZC8fF3tB21nLaVY@wI" rel="noreferrer" title="Python 2 – TIO Nexus">Try it online!</a></p>

<p>Alternates between adding terms to the end of the list, and removing terms from the beginning.</p>
</div>
<div id="pu17" class="pu"><h1>Mathematica, 72 bytes</h1>
<pre><code>(For[l=u=c=k=0,k!=#,c++,If[#&gt;k,While[#&gt;k,k+=++u],While[#&lt;k,k-=l++]]];c)&amp;
</code></pre>
<p>Pure function taking an integer argument.</p>
<h2>How it works</h2>
<pre><code>For[ ... ]
</code></pre>
<p>A <code>For</code> loop.</p>
<pre><code>l=u=c=k=0
</code></pre>
<p>Initialization; set <code>l</code> (lower), <code>u</code> (upper), <code>c</code> (counter), and <code>k</code> (sum) to 0.</p>
<pre><code>k!=#
</code></pre>
<p>Condition; repeat while <code>k</code> is not equal to the input.</p>
<pre><code>c++
</code></pre>
<p>Increment; increment the counter <code>c</code>.</p>
<pre><code>If[#&gt;k,For[,#&gt;k,,k+=++u],For[,#&lt;k,,k-=l++]]
</code></pre>
<p>Body</p>
<pre><code>If[#&gt;k, ... ]
</code></pre>
<p>If the input is greater than <code>k</code>:</p>
<pre><code>While[#&gt;k,k+=++u]
</code></pre>
<p>While the input is greater than <code>k</code>, increment <code>u</code> and increment <code>k</code> by <code>u</code>.</p>
<p>If the input is not greater than <code>k</code>:</p>
<pre><code>While[#&lt;k,k-=l++]
</code></pre>
<p>While the input is less than <code>k</code>, decrement <code>k</code> by <code>l</code> and increment <code>l</code>.</p>
<pre><code>( ... ;c)
</code></pre>
<p>Return <code>c</code> after the loop.</p>
</div>
<div id="pu18" class="pu"><h1>Mathematica, 92 bytes</h1>

<pre><code>(For[q=a=b=0;t={},t~AppendTo~q;q!=#,If[q&lt;#,q+=++b,q-=++a]];Length@Split@Sign@Differences@t)&amp;
</code></pre>

<p>Pure function taking an integer argument and returning an integer.</p>

<p>The variables <code>a</code> and <code>b</code> stand for the (constantly changing) beginning and end numbers in the sum under consideration, while <code>q</code> stands for the running total (of the numbers from <code>a+1</code> to <code>b</code>); <code>t</code> keeps track of all the values of <code>q</code> encountered so far. After initializing these variables, the <code>For</code> loop keeps executing <code>If[q&lt;#,q+=++b,q-=++a]</code>, which either adds a new number on to the end or subtracts the number at the front as dictated by the spec, until <code>q</code> equals the input.</p>

<p>Now we just have to extract the number of steps from <code>t</code>, the list of <code>q</code> values encountered along the way. For example, when the input is <code>11</code>, the <code>For</code> loop exits with <code>t</code> equaling <code>{0,1,3,6,10,15,14,12,9,15,11}</code>. The best way I found to calculate the number of steps from this is to count how many times the differences switch from going up to going down; that's what the verbose command <code>Length@Split@Sign@Differences@t</code> does, but I suspect that can be improved.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/120487/">120487</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




