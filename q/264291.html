<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::264291</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>011</td><td>Vyxal</td><td>230821T070335Z</td><td><a href="https://codegolf.stackexchange.com/questions/264291/how-turing-complete-is-your-language/264437#264437">emanresu</a></td></tr>
<tr d-ix="1"><td>008</td><td>Jelly</td><td>230820T012446Z</td><td><a href="https://codegolf.stackexchange.com/questions/264291/how-turing-complete-is-your-language/264393#264393">ais523</a></td></tr>
<tr d-ix="2"><td>002</td><td>C</td><td>230817T190151Z</td><td><a href="https://codegolf.stackexchange.com/questions/264291/how-turing-complete-is-your-language/264302#264302">l4m2</a></td></tr>
<tr d-ix="3"><td>002</td><td>JavaScript</td><td>230819T173142Z</td><td><a href="https://codegolf.stackexchange.com/questions/264291/how-turing-complete-is-your-language/264382#264382">Joao-3</a></td></tr>
<tr d-ix="4"><td>002</td><td>Lua</td><td>230819T134818Z</td><td><a href="https://codegolf.stackexchange.com/questions/264291/how-turing-complete-is-your-language/264380#264380">bluswimm</a></td></tr>
<tr d-ix="5"><td>002</td><td>Javascript</td><td>230819T073458Z</td><td><a href="https://codegolf.stackexchange.com/questions/264291/how-turing-complete-is-your-language/264377#264377">emanresu</a></td></tr>
<tr d-ix="6"><td>003</td><td>Python 3</td><td>230819T052458Z</td><td><a href="https://codegolf.stackexchange.com/questions/264291/how-turing-complete-is-your-language/264375#264375">dingledo</a></td></tr>
<tr d-ix="7"><td>002</td><td>Python 3</td><td>230818T194537Z</td><td><a href="https://codegolf.stackexchange.com/questions/264291/how-turing-complete-is-your-language/264367#264367">Unrelate</a></td></tr>
<tr d-ix="8"><td>002</td><td>Python 2</td><td>230818T100339Z</td><td><a href="https://codegolf.stackexchange.com/questions/264291/how-turing-complete-is-your-language/264330#264330">Bubbler</a></td></tr>
<tr d-ix="9"><td>nan</td><td>Incident</td><td>230817T212355Z</td><td><a href="https://codegolf.stackexchange.com/questions/264291/how-turing-complete-is-your-language/264310#264310">ais523</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://github.com/Vyxal/Vyxal" rel="nofollow noreferrer">Vyxal</a>, score 11</h1>
<pre><code>1+C†
k⟇hoĖ
⌈¢ `
‛p&quot;øV
56S)ŀẊ
⟨⟩|₅ṫ⁽İ$J
4L{ḣτ0€∇iWfḢ…
λ;←→wMt∧
Þ∞(„‟[]¬₈Q
\01ḊȧḞƛ‡∷¥£Ṫẋ
2ʁṘ⅛≬ḭ'¼¦ɖ*-aNßX:^}
</code></pre>
<p>For a language to be Turing-Complete, it must be (among other things) possible to loop infinitely. There are several ways to do this in Vyxal:</p>
<ul>
<li><p><code>Ė</code> and <code>†</code> evaluate a string as Vyxal and Python respectively.</p>
</li>
<li><p>In versions 2.6-2.8.2 an ACE vulnerability exists that allows passing arbitrary Python code into any sympy builtin. All variants of this require <code>∆</code>, the math element digraph.</p>
</li>
<li><p><code>(ƛ'µ⟑</code>, <code>¨2</code> and <code>¨3</code> can all iterate over an infinite list. However, there aren't that many ways to create infinite lists:</p>
<ul>
<li>Various digraphs starting with <code>Þ</code> push a constant infinite list to the stack, or have the ability to create infinite lists from finite ones</li>
<li>The builtin <code>Ḟ</code> can create an infinite list based on a generating function, which may not be usable (see below)</li>
</ul>
</li>
<li><p><code>λ⁽‡≬)</code>, and until recently <code>@</code>, can define functions. There are a wide range of builtins which call functions in certain ways, which can be used to implement some form of lambda calculus or similar.</p>
</li>
<li><p><code>¢</code> and <code>øV</code> perform repeated replacement in different ways, which allows implementing some form of string rewriting system.</p>
</li>
<li><p><code>{</code> creates a while/infinite loop by itself.</p>
</li>
</ul>
<p>I'll start with the eval solutions, because they're the easiest:</p>
<h3>Easy eval</h3>
<p><code>1+C†</code> allows getting any number with <code>1+</code>, converting it to a character with <code>C</code>, concatenating those into a program with <code>+</code>, and evaluating with <code>†</code>.</p>
<p>To create a character with character code <code>n</code>, we start with <code>1CC</code>, then append <code>n-1</code> copies of <code>1+</code>, and append a <code>C</code> to turn into a character. (<code>CC</code> is a no-op, casting to char then back). We can repeat this as many times as we want and use <code>+</code> to concatenate the result into a single string before evaluating as Python with <code>†</code>.</p>
<p><a href="https://vyxal.pythonanywhere.com/?v=2#WyIiLCIiLCLGm0PigLlgMStgKlxcQytgMUNDYHA74bijXFwraitcXCsrXFzigKArIiwiIiwiXCJwcmludCg1KVwiIl0=" rel="nofollow noreferrer">Here's a compiler from Python to this</a>, and <a href="https://ato.pxeger.com/run?1=m720rLIiMWfBgqWlJWm6FrdYGwydnQ21hzN0HvY-BPtSexh6c1h6asR4j8ZepWvo0cQyZ-1HDQuWFCclF0OL4wULDSAMAA" rel="nofollow noreferrer">here</a>'s a program running <code>print(5)</code>.</p>
<h3>Harder eval</h3>
<p><code>k⟇hoĖ</code> allows getting the Vyxal codepage with <code>k⟇</code>, accessing any character by repeatedly removing (<code>o</code>) the first item (<code>h</code>). (The cost of this is exponential but it doesn't matter). Then we can evaluate this as Vyxal code with <code>Ė</code>. (note: Unlike the above we can just evaluate single characters, as 1-byte Vyxal programs still work).</p>
<p>Here's an example: <code>k⟇h</code> gets <code>λ</code>, the first character in the Vyxal codepage. Then, <code>k⟇k⟇ho</code> removes <code>λ</code> from the vyxal codepage, leaving <code>ƛ</code>, the second character, in the first position, which can be obtained with another <code>h</code>. This can be repeated any number of times, gaining access to any character in the Vyxal codepage. More examples of this technique can be found <a href="https://codegolf.stackexchange.com/a/236209/100664">here</a>.</p>
<p><a href="https://vyxal.pythonanywhere.com/?v=2#WyJEIiwiIiwia+Kfh+G4n+KfqOKfqSQoOlxcbyvhuYVga+KfhyVoYCQlSil0XFzElisiLCIiLCLDlyJd" rel="nofollow noreferrer">Here</a>'s a program that compiles a single-character program into this. To create strings we can evaluate <code>+</code> (although the program that does so has length 2<sup>44</sup> ≈ 17 trillion bytes) and concatenate two characters.</p>
<h2>String rewriting</h2>
<p>The builtins <code>¢</code> and <code>øV</code> can be used to repeatedly perform string replacments until nothing changes, similar to <a href="https://esolangs.org/wiki/Thue" rel="nofollow noreferrer">Thue</a>. For example, <a href="https://vyxal.pythonanywhere.com/?v=2#WyIiLCIiLCJgXjEwMTFgIOKfqGAxYHxgKjBgfGBeMGDin6kg4p+oYDAqYHxgMCoqYHxgXmDin6kgw7hWIiwiIiwiIl0=" rel="nofollow noreferrer">here</a>'s a binary-to-unary converter.</p>
<p>The main difference is that, while Thue performs replacements randomly, these builtins perform all replacements in parallel. However, this turns out not to be an issue as it's possible to write Thue programs that only allow one replacement at a time.</p>
<p>With this in mind, we need two disjoint ways to generate arbitrary strings and sequences of strings. We don't need access to all ASCII characters, as Thue is Turing-complete with only two characters.</p>
<h3>The easy way: string literals</h3>
<pre><code>⌈¢ `
</code></pre>
<p>In Vyxal, strings are delimited by backticks, for example <code>`abc`</code> represents &quot;abc&quot;. We can then split these strings by spaces with <code>⌈</code>. This does come with the slight snag that non-ASCII characters within strings represent compressed words, but we can still write a turing machine with the symbols <code>disappointed</code> and <code>aquarium</code>. <a href="https://vyxal.pythonanywhere.com/?v=2#WyIiLCIiLCJgwqLijIjijIjijIjijIjCouKMiOKMiOKMiOKMiGAgYOKMiOKMiCDCosKi4oyIwqIgwqLijIjijIjCoiBg4oyIYOKMiMKiwqLCoiDijIjCosKiwqLCosKiIMKi4oyIYOKMiCDCoiIsIiIsIiJd" rel="nofollow noreferrer">here</a>'s the binary-to-unary converter from before, using <code>disappointed</code> as <code>1</code> and <code>aquarium</code> as <code>0</code>.</p>
<h3>The hard way: more annoying string literals</h3>
<pre><code>‛p&quot;øV
</code></pre>
<p>Backtick-delimited strings aren't the only way of creating string literals. There's also <code>‛</code>, which groups the two characters in front of it as a string.</p>
<p>We can then concatenate these strings with p, or pair two into a list with &quot; and prepend other strings with p. While this does restrict us to even-length strings, that doesn't really matter - we can simply use pairs of tokens to represent single tokens.</p>
<p>Again, <a href="https://vyxal.pythonanywhere.com/?v=2#WyIiLCIiLCIjYF4xMDExYCDin6hgMWB8YCowYHxgXjBg4p+pIOKfqGAwKmB8YDAqKmB8YF5g4p+pIMO4VlxuI+KAm0pcIsO4VlxuXG7igJtcInDigJtcInDigJtcIlbigJtcInDigJtcIlwicHBwcOKAm1wiVuKAm1wiw7hw4oCbXCJW4oCbXCJcInBcIuKAm1wicHDigJtcIsO44oCbXCLDuOKAm1wiVnBw4oCbXCJcIlwi4oCbXCLDuOKAm1wiVnBww7hWIiwiIiwiIl0=" rel="nofollow noreferrer">here</a>'s the binary converter, this time using <code>&quot;p</code> as 1 and <code>&quot;V</code> as 0.</p>
<h3>The even more annoying way - reject string, return to number</h3>
<pre><code>56S)ŀẊ
</code></pre>
<p>There's one more builtin that performs infinite replacement - <code>ŀ</code>. Unfortunately, this only works on strings, not on string lists, so it needs another operation to work.</p>
<p>We use <code>)</code>, which groups all elements up to the previous newline into a function, then use <code>Ẋ</code> to repeatedly apply that function to a value until something repeats.</p>
<p>As before, we only need two symbols - we can use the digits 5 and 6, and use <code>S</code> to stringify them (since <code>ŀ</code> only works on strings).</p>
<p><a href="https://vyxal.pythonanywhere.com/?v=2#WyIiLCIiLCI2NTVTNjU2NjY2U8WANjY2NjU2UzY1NjY2NjY2NlPFgDY2NTY1NlM2NjVTxYApNjY1NjU1NjU2NjU1NjU1U+G6iiIsIiIsIiJd" rel="nofollow noreferrer">Here</a>'s the binary converter from before, representing 1 with 655 and 0 with 656.</p>
<h3>Tag systems</h3>
<pre><code>⟨⟩|₅ṫ⁽İ$J
</code></pre>
<p><a href="https://esolangs.org/wiki/Tag_system" rel="nofollow noreferrer">Tag systems</a> are turing-complete languages that use a constantly-changing tape. They have a set of rules, which decide how to map one value to several other values, and repeatedly remove the first few characters from the tape, and append the sequence corresponding to the first removed item.</p>
<p>So, I've implemented the tag system from <a href="https://codegolf.stackexchange.com/a/264393/100664">ais523's answer</a> <a href="https://vyxal.pythonanywhere.com/?v=2#WyIiLCIiLCLhuavin6jin6jin6l84p+oM3wy4p+pfOKfqDHin6l84p+oMXwxfDHin6l84p+oMXwxfDHin6nin6kkaSThuapKKTTEsCIsIiIsIiJd" rel="nofollow noreferrer">here</a>. The map is hardcoded as a 2d list of numbers - Vyxal lists are delimited by <code>⟨⟩</code> and each term is separated by <code>|</code>. The list of numbers, and the initial value, are the program; everything else is fixed.</p>
<p>The program starts by removing the last item and pushing it separately (<code>ṫ</code>), then indexes that into the rule list. After that, it prepends the rule to what remains and removes the last item. It's quite a bit more complicated than it needs to be due to my attempts to minimise the amount of unique characters.</p>
<p>This is then iterated until a repeated state is detected, using the builtin <code>İ</code>. The program halts by repeating states. Since the progression from one state to the next is entirely deterministic, a tag system has no meaningful behaviour once states repeat anyway. An explicit halt symbol could be added in without too much trouble. The output is all the states the program has gone through, which is definitely sufficient.</p>
<p>Finally, all the integers can be replaced with getting the length of a list, since we can construct arbitrary lists. I'm using the builtin <code>₅</code> here (push length without popping) instead of <code>L</code> because <code>L</code> can also be used to get the length of a number.</p>
<p>While writing this, I also realised I can use the single-element lambda builtin <code>⁽</code> here, which is otherwise not particularly useful, because I can wrap the whole output in a list.</p>
<p><a href="https://vyxal.pythonanywhere.com/?v=2#WyIiLCIiLCLigb3in6jhuavhuavin6jin6jin6l84p+o4p+o4p+o4p+pfOKfqOKfqXzin6jin6nin6nigoV84p+o4p+o4p+pfOKfqOKfqeKfqeKCheKfqXzin6jin6jin6jin6nin6nigoXin6l84p+o4p+o4p+o4p+p4p+p4oKFfOKfqOKfqOKfqeKfqeKChXzin6jin6jin6nin6nigoXin6l84p+o4p+o4p+o4p+p4p+p4oKFfOKfqOKfqOKfqeKfqeKChXzin6jin6jin6nin6nigoXin6l84p+o4p+o4p+o4p+p4p+p4oKFfOKfqOKfqOKfqeKfqeKChXzin6jin6jin6nin6nigoV84p+o4p+o4p+p4p+p4oKF4p+p4p+pJOKfqOKfqUrEsOG5q0okSuG5qyTin6nin6jin6jin6l84p+o4p+pfOKfqOKfqXzin6jin6l84p+o4p+p4p+p4oKFJOG5q0rhuatK4bmrSuG5q0rhuatKSsSwIiwiIiwiIl0=" rel="nofollow noreferrer">Here</a>'s the tag system from before without digits.</p>
<h3>More tag systems</h3>
<pre><code>4L{ḣτ0€∇iWfḢ…
</code></pre>
<p>So, we don't necessarily need to explicitly hardcode the rule table. We can construct it. We can represent any number <code>n</code> as <code>n</code> 4s followed by an <code>L</code> - taking the length of the number with n 4s. If we use base conversion (<code>τ</code>) to convert this to base 4, and then split on 0s, we've created a way to define arbitrary 2d lists of integers. If we need numbers greater than 4 we can just use base-44. (note: This does come with an exponentially large program size. Representing the rule table from before is 80 megabytes)</p>
<p>So, <a href="https://vyxal.pythonanywhere.com/?v=2#WyIiLCIiLCIjNDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NEw0z4RcblxuNSB74bij4p+o4p+oMeKfqXzin6gyfDPin6l84p+oMeKfqXzin6gxfDF8MeKfqXzin6gxfDF8MeKfqXzin6gxfDF8MXwx4p+p4p+p4oiH4oiHaVdm4bii4oCmXG4iLCIiLCIiXQ==" rel="nofollow noreferrer">here</a>'s another implementation of the same tag system, but backwards – This one pops from the start and appends to the end, and consequentially all the values are backwards.</p>
<p>This one uses a while loop (<code>{</code>) and just prints every value. It doesn't halt, but Vyxal has live output and I can define &quot;halting behaviour&quot; as printing a value that's already been printed, which shows the program has entered a permanent loop, and is fully distinguishable from any nonhalting behaviour.</p>
<p>And <a href="https://vyxal.pythonanywhere.com/?v=2#WyIiLCIiLCI0NDQ0NEx74bijODA2MDMyNzIyNzcgNM+EMOKCrOKIh+KIh2lXZuG4ouKApiIsIiIsIiJd" rel="nofollow noreferrer">here</a> is the same program with the rule table encoded properly. (note: the <code>80603272277</code> would be replaced with that many 4s followed by an L).</p>
<p>There's probably quite a few characters to be saved here.</p>
<h2>Lambda calculus / combinatory logic</h2>
<pre><code>λ;←→wMt∧
</code></pre>
<p>In Vyxal, we can define lambda functions with <code>λ...;</code>. Additionally, although lambdas can't have named arguments, we can set/get variables with <code>→a</code>/<code>←a</code>. Vyxal's variables are <a href="https://vyxal.pythonanywhere.com/?v=2#WyJjIiwiIiwizrs14oaSYTsg4oCgIOKGkGEiLCIiLCIiXQ==" rel="nofollow noreferrer">actually local</a> by default, inheriting Python's behaviour.</p>
<p>Calling a function is a little difficult, as <code>†</code> (function call) is taken, but we can wrap our arguments in a list (<code>w</code>), map (<code>M</code>) the function over the list, and unwrap the result (<code>t</code>). <code>M</code> does take the argument followed by the function, so some tricky stack manipulation is required for this to work.</p>
<p>So, we can implement the SKI combinators quite simply with this:</p>
<pre><code>λ; # I
λ→aλ←a;; # K
λ→aλ→bλ→c ←c w ←b M ←c w ←a M t M t ;;; # S
</code></pre>
<p>The first two are fairly self-explanatory. The third, however, nedds its own explanation so I can understand it:</p>
<pre><code>λ→a                                   ; # a =&gt; 
   λ→b                               ;  # b =&gt;
      λ→c                           ;   # c =&gt; 
          ←c w                    t     # c
               ←b M                     # b(c)
                    ←c w      t         # c
                         ←a M           # a(c)
                                M       # a(c)(b(c))
</code></pre>
<p>Note that the variables are named a, b, c for clarity – they could just be named a, aa, aaa.</p>
<p>However, there's another issue here: Variable names can have multiple alphabetic characters, so we can't just run <code>←aM</code> as that will get interpreted as retrieving the variable aM. We need some form of no-op (or similar).</p>
<p>Space and newline are both no-ops, but there's a better alternative: <code>∨</code>, logical or, which takes two arguments and returns the first truthy argument. The definition of &quot;first&quot; is a little weird due to being on a stack, but all we have to care about is that, when given two functions, it <a href="https://vyxal.pythonanywhere.com/?v=2#WyIiLCIiLCLOuzU7IM67NDviiKjigKAiLCIiLCIiXQ==" rel="nofollow noreferrer">returns the second</a>.</p>
<p>With that in mind, <a href="https://vyxal.pythonanywhere.com/?v=2#WyIiLCIiLCLOuzsgIyBJXG7Ou+KGknTOu+KGkHQ7OyAjIEtcbs674oaSdM674oaSdHTOu+KGknR0dOKGkHR0dOKGkHR0dOKIp3fihpB0dOKGkHR04oinTeKGkHR0dOKGknR0dOKIp3fihpB04oaQdOKIp010TXQ7OzsgIyBTIiwiIiwiIl0=" rel="nofollow noreferrer">here</a>'s the list of functions. With a careful ordering of these we can call any combination of S, K, and I, which is sufficient for Turing-Completeness.</p>
<h2>A solution based on <a href="https://codegolf.stackexchange.com/a/63284/100664">Picofuck</a></h2>
<pre><code>Þ∞(„‟[]¬₈Q
</code></pre>
<p>Picofuck is a brainfuck derivative in which the program loops indefinitely, and the only conditionals allowed are unnested if statements. The instructions translate quite easily to Vyxal:</p>
<ul>
<li><code>&gt;</code> (shift pointer right) becomes <code>„</code> (rotate stack left)</li>
<li><code>&lt;</code> (shift pointer left) becomes <code>‟</code> (rotate stack right)</li>
<li><code>*</code> (invert bit at pointer) becomes <code>¬</code> (logical not)</li>
<li><code>(</code> (open if statement) becomes <code>[</code></li>
<li><code>)</code> (close if statement) becomes <code>]</code></li>
</ul>
<p>I/O is not required for Turing Completeness, and the entire program runs in an infinite loop (<code>Þ∞(</code>). <code>Þ∞</code> represents the list of all positive integers, and <code>(</code> iterates over it.</p>
<p>There are a couple of minor differences between the two approaches:</p>
<ul>
<li>Picofuck requires if statements to not be nested, but this allows nesting if statements, which makes some constructions to bypass the following requirements easier.</li>
<li>While Picofuck runs on a unbounded tape, this runs on a cyclic tape. To add elements to the tape, we have <code>₈</code>, which pushes 256 (could be any integer). Since we can run <code>₈</code> in a loop to give the tape an arbitrary length, this allows us to initialise an arbitrary amount of memory.</li>
<li>While if statements in Picofuck preserve the condition, <code>[</code> in Vyxal pops from the stack. This can be bypassed by working with multiple copies of each value, and ensuring popped values are restored. (I could just add <code>:</code> (duplicate) to the command set but I might need that later)</li>
<li>In Picofuck, the program terminates when the program attempts to move the pointer to the left of the start point. While termination isn't strictly necessary, some form of distinguishable output is necessary, so I've added <code>Q</code> (quit) to halt execution.</li>
</ul>
<p>For reasons <a href="https://codegolf.stackexchange.com/a/63284/100664">the author hasn't written down</a>, Picofuck is Turing-Complete, but it's not hard to imagine a potential construction with the increased flexibility of this language.</p>
<h2>Compiling from <a href="https://esolangs.org/wiki/Bitwise_Cyclic_Tag" rel="nofollow noreferrer">Bitwise Cyclic Tag</a></h2>
<pre><code>\01ḊȧḞƛ‡∷¥£Ṫẋ
</code></pre>
<p>Bitwise Cyclic Tag is a minimalist Turing-Complete tag-system-based language. It operates on a string of bits, and has two instructions:</p>
<ul>
<li><code>0</code> deletes the leftmost bit</li>
<li><code>1x</code> (where x is 1 or 0) appends x if the leftmost bit is 1.</li>
</ul>
<p>The program is made of a sequence of bits, and loops forever.</p>
<p>These instructions can be quite easily mapped to Vyxal, however we're running out of ways to concatenate/append. Fortunately, <code>Ḋȧ</code> does the trick - concatenating with a space in between and removing the space.</p>
<p>We also don't have many ways left to get the first/last item of a string, but we can cast to an integer and take it modulo 2.</p>
<p>With this, it's fairly simple to translate BCT to Vyxal:</p>
<ul>
<li><code>0</code> becomes <code>Ṫ</code></li>
<li><code>1x</code> becomes <code>:⌊∷\<b>x</b>ẋḊȧ</code></li>
</ul>
<p>Additionally, we need a looping construct. There aren't many left, so I've decided to use <code>0‡∷∷Ḟƛ</code>. <code>‡∷∷</code> is a function that modulos its input by 2 twice (could be anything really), then <code>Ḟ</code> uses that combined with the 0 to generate an infinite list of values, which <code>ƛ</code> can then iterate over.</p>
<p>Unlike some of the previous looping constructs, this doesn't maintain state between calls, so we need to use the register. <code>£</code> and <code>¥</code> respectively set and retrieve the register, a global variable initialised at 0.
We can also use <code>£¥¥</code> to replace duplication (<code>:</code>).</p>
<p>The data-string also needs to be initialised. This can be done by repeatedly prepending characters using <code>Ḋȧ</code>, and then storing this in the register.</p>
<p><a href="https://vyxal.pythonanywhere.com/?v=2#WyJEIiwiIiwi4oyIxpvhuKMkXFwwPVtcXOG5qnxgwqPCpcKl4oyK4oi3XFxcXM6g4bqL4biKyKdgO+KIkWAw4oCh4oi34oi34biexpvCpWBwYMKjwqVgKz/huZhmXFxcXCQr4bijYOG4isinYCviiJErXFzCoytwIiwiIiwiMTAgMTEgMTAgMTAgMTAgMTEgMCAxMSAxMCAxMCAwIDExIDEwIDEwIDExIDEwIDEwIDExIDEwIDEwIDAgMCAwIDBcblwiMTAwMTAwMTAwXCIiXQ==" rel="nofollow noreferrer">Here</a>'s a compiler from BCT to this subset of Vyxal. And <a href="https://vyxal.pythonanywhere.com/?v=2#WyIiLCIiLCJcXDBcXDDhuIrIp1xcMeG4isinXFww4biKyKdcXDDhuIrIp1xcMeG4isinXFww4biKyKdcXDDhuIrIp1xcMeG4isinwqMw4oCh4oi34oi34biexpvCpcKjwqXCpeKMiuKIt1xcMOG6i+G4isinwqPCpcKl4oyK4oi3XFwx4bqL4biKyKfCo8KlwqXijIriiLdcXDDhuovhuIrIp8KjwqXCpeKMiuKIt1xcMOG6i+G4isinwqPCpcKl4oyK4oi3XFww4bqL4biKyKfCo8KlwqXijIriiLdcXDHhuovhuIrIp+G5qsKjwqXCpeKMiuKIt1xcMeG6i+G4isinwqPCpcKl4oyK4oi3XFww4bqL4biKyKfCo8KlwqXijIriiLdcXDDhuovhuIrIp+G5qsKjwqXCpeKMiuKIt1xcMeG6i+G4isinwqPCpcKl4oyK4oi3XFww4bqL4biKyKfCo8KlwqXijIriiLdcXDDhuovhuIrIp8KjwqXCpeKMiuKIt1xcMeG6i+G4isinwqPCpcKl4oyK4oi3XFww4bqL4biKyKfCo8KlwqXijIriiLdcXDDhuovhuIrIp8KjwqXCpeKMiuKIt1xcMeG6i+G4isinwqPCpcKl4oyK4oi3XFww4bqL4biKyKfCo8KlwqXijIriiLdcXDDhuovhuIrIp+G5quG5quG5quG5qsKjwqVcblxuIiwiIiwiIl0=" rel="nofollow noreferrer">here</a>'s the example Collatz Sequence program from the esolangs page.</p>
<p>Although this doesn't halt per se, due to how Vyxal handles printing lists it outputs the state of the data string every cycle - i.e. each time the whole program is iterated through. Since, once again, the transformation of the data string from one cycle to another is completely deterministic, we can define &quot;halting behaviour&quot; as entering an infinite loop. Again, it's still possible to create programs that loop forever by this definition as long as they don't end up in a loop with the same state.</p>
<h2>Blindfolded Arithmetic</h2>
<pre><code>2ʁṘ⅛≬ḭ'¼¦ɖ*-aNßX:^}
</code></pre>
<p>I stole this idea from <a href="https://codegolf.stackexchange.com/a/264393/100664">ais523's answer</a>, and I'd recommend reading the Blindfolded Arithmetic section on that as its explanation is far better than mine.</p>
<p>Blindfolded Arithmetic is a language with six variables, although only two are needed for Turing-Completeness. The variables are named X and Y, and start at 1 and 0 respectively. Each operation performs some arithmetic operation on two variables and stores the result into another variable. The operations are cyclically repeated until a division by 0 occurs.</p>
<p>As ais discovered, (almost) all of the possible operations can be emulated on an array of [X, Y]. Here's the direct translations of the operations:</p>
<pre><code>Y = X + Y: ¦
Y = X * Y: ɖ*
Y = X - Y: ɖ-
Y = Y - X: ɖ-2ʁ2*2Ṙ2ḭ-Ṙ*
Y = X // Y: :2ʁ*a2:ḭ-2:ḭ2-*:ßX-ɖḭ
Y = Y // X: :2ʁṘ*a2:ḭ-2:ḭ2-*:ßX-::Ṙḭ2ʁ*^2ʁ2Ṙ2ḭ-*-

Swap Y, X: Ṙ
Y = Y + Y = Y * 2: 2ʁ2:ḭ2--*
Y = Y // 2: 2ʁ2:ḭ2--ḭ
</code></pre>
<p><a href="https://vyxal.pythonanywhere.com/?v=2#WyIiLCIiLCLin6gxMjMgfCA0NeKfqSDigKYgXG7CpiDigKYgXG7Jliog4oCmIFxuyZYtIOKAplxuyZYtMsqBMioy4bmYMuG4rS3huZgqIOKAplxuOjLKgSphMjrhuK0tMjrhuK0yLSo6w59YLcmW4bitIOKAplxu4bmYIOKAplxuOjLKgeG5mCphMjrhuK0tMjrhuK0yLSo6w59YLTo64bmY4bitMsqBKl4yyoEy4bmYMuG4rS0qLSDigKZcbjLKgTI64bitMi0tKiDigKZcbjLKgTI64bitMi0t4bitIOKApiIsIiIsIiJd" rel="nofollow noreferrer">Here</a>'s all the operators working.</p>
<p>Here <code>ɖ</code> is the scan operator. When given a list [x, y, z, ...] and a binary operation *, it computes [x, x * y, x * y * z ...] which is very useful for these purposes. <code>ḭ</code> is the floor division operator, and <code>*</code> and <code>-</code> do what you'd expect.</p>
<p>Only operations assigning to Y are implemented here because we can use Ṙ, reverse, to swap X and Y.</p>
<p>While Jelly has the quick @, which inverts the order of an element's arguments, Vyxal does not, so inverse subtraction/division is decidedly more complicated. Here's the subtraction one explained:</p>
<pre><code>ɖ-            # Y = X - Y
  2ʁ          # [0, 1]
    2*        # [0, 2]
      2Ṙ2ḭ    # 1
          -   # [0, 2] - 1 = [-1, 1]
           Ṙ  # [1, -1]
            * # Multiply by that (negate second element)
</code></pre>
<p>The division one is even more complicated. Because of this I've been forced to bring in two stack-manipulation operators: <code>:</code>, duplicate, and <code>^</code>, which reverses the stack (essentially behaving like swap for our purposes)</p>
<pre><code>:2ʁṘ*a2:ḭ-2:ḭ2-*:ßX- # Halt check (see below)
 :Ṙḭ                 # [X, Y] / [Y, X] = [X / Y, Y / X]
    2ʁ*              # [X / Y, Y / X] * [0, 1] = [0, Y / X]
        2ʁ           # [0, 1]
          2Ṙ2ḭ-      # [0, 1] - 1 = [-1, 0]
:      ^       *     # [X, Y] * [-1, 0] = [-X, 0]
                -    # [0, Y / X] - [-X, 0] = [X, Y / X]
</code></pre>
<p>Here we can't use + because that's already taken. Double negation is fine though.</p>
<p>We can also generate the list <code>[1, 2]</code> with <code>2ʁ2:ḭ2--</code>. By multiplying or dividing by this we can halve or double Y. As explained in ais's answer, this is sufficient for Turing-Completeness.</p>
<p>Now we need a looping construct. We can use <code>≬</code> to group the next three elements as a function, and combine this with <code>'...}</code> (filter by) to contain arbitrarily long code. By using the construct <code>≬ḭ'...2:-}a</code>, we can filter the list [1] by our code, returning a 0 by default, unless the program is halted. Then, each iteration, the <code>a</code> will only return true if the program has halted.</p>
<p>We can then use a builtin like <code>N</code> (first natural number for which a function is true) to call this repeatedly until it halts.</p>
<p>We also need to store data between each cycle. This can be done by pushing/popping to/from the global array, <code>⅛</code>/<code>¼</code> respectively.</p>
<p>We also need to initialise [X, Y] as [1, 0], which can be done with <code>2ʁṘ⅛</code>.</p>
<p>The one thing that remains is halting. We still have the element <code>X</code> available, which returns from a function. By using the modifier <code>ß</code> we can return a truthy value (and halt) if the dividend is 0.</p>
<p>We can do this fairly simply with <code>:2ʁ*a2:ḭ-2:ḭ2-*:ßX*</code>.</p>
<pre><code>:2ʁ*                # [X, Y] * [0, 1] = [0, Y]
    a               # Any - 0 if Y=0
     2:ḭ-2:ḭ2-*     # Not ^ - 1 if Y=0
               :ßX  # If true return 1, halting
                  - # Else subtract 0 from whatever was on the stack, NOP
</code></pre>
<p>For Y = Y / X we multiply by [1, 0] instead of [0, 1], checking that X ≠ 0.</p>
<p>Subtracting a variable from itself, self-multiplication and self-division are also possible, although not necessary as shown by ais.</p>
<p><a href="https://vyxal.pythonanywhere.com/?v=2#WyIiLCIiLCIyyoHhuZjihZsg4oms4bitJ8K8IMKmIMKmIMKmIOG5mCDJliog4bmYIDLKgTI64bitMi0t4bitIDLKgTI64bitMi0t4bitIOKApuKFmzI6LX1hTiIsIiIsIiJd" rel="nofollow noreferrer">Here</a>'s an example compiled program.</p>
<h2>Solution 12?</h2>
<p>As far as I'm aware, I've used up every single listed looping construct. <code>¨@</code> can be used to define a named function, but that requires <code>|</code>, which would require completely rewriting one of the tag systems in a way which may not be possible.</p>
<p>There is always the sympy ACE, but using an older version of Vyxal feels questionable.</p>
<p>In older versions of Vyxal (I'm not sure when it was changed) it was possible to do a recursive call (<code>x</code>) within a mapping lambda / similar, allowing for an infinite loop. Again, though, downgrading Vyxal is questionable and may have some side effects on these solutions' functionality.</p>
<p>So, I'm going to say 11 is close to optimal, and certainly as far as I'm prepared to go with this.</p>
</div>
<div id="pu1" class="pu"><h1>Jelly, score <s>7</s> 8</h1>
<pre><code>VŻỌ‘’
01uvọŒ⁾¤
2ṭḊḢĿ¶
3[,];?ÑṖṪị
:@U\_½ÄÇ×Ø
jµœƬṣ“”
&quot;$+4DLMṀns¿
CNt©®ÐƊḌḶṃṄẒẸ
</code></pre>
<p>There is some room for interpretation as to what a Turing-complete language is, and thus what a Turing-complete subset of a language is. For these answers, I have used the strictest common definition: these are subsets for which it is possible to compile a Turing machine into that subset of Jelly, producing a finitely long program that halts if and only if the Turing machine halts. (Note that the proofs below don't start all the way from Turing machines, but from other Turing-complete languages; this is valid because you can first compile the Turing machine into the language I started from because it's Turing-complete, and then into Jelly.) Halt behaviour is the only thing that matters for Turing-completeness; things like I/O are not important, and the compiled Jelly programs are thus written as full programs that take no input.</p>
<p>This is almost certainly beatable – I still have lots of characters unused, and some of these character sets are slightly larger than necessary (but easier to explain than a fully-&quot;golfed&quot; set would be). However, I decided this answer was worth posting even in its early stages, in case it inspires people to new solutions in Jelly or other golfing languages (or maybe even practical languages?).</p>
<p>Note that many of these character sets can be considered as interesting &quot;cop problems&quot; for a hypothetical <a href="/questions/tagged/cops-and-robbers" class="post-tag" title="show questions tagged &#39;cops-and-robbers&#39;" aria-label="show questions tagged &#39;cops-and-robbers&#39;" rel="tag" aria-labelledby="tag-cops-and-robbers-tooltip-container">cops-and-robbers</a> question; some readers might find it fun to try to figure out for themself how some of these subsets are Turing-complete before reading onwards.</p>
<h2>Explanations</h2>
<p>There are a lot of solutions here (by &quot;solution&quot;, I mean a subset of characters via which Jelly is Turing-complete, with the solutions chosen so that none of them overlap in characters), with some parts of the explanation common to multiple solutions but most of it specific to a particular solution. As such, each answer is going to get its own individual explanation, but sometimes there will be shared explanation in a section beforehand.</p>
<h3>Eval-based solutions</h3>
<p>One way (but not the only way!) to prove a character subset Turing-complete is to show that it can <code>eval</code> arbitrary code in a Turing-complete language, using an <code>eval</code> builtin or equivalent. Jelly has a few different ways to <code>eval</code> code, but all of them are spelled using the character <code>v</code> or <code>V</code>, meaning that there is a limit of two <code>eval</code>-based solutions.</p>
<p>Now, there's one property of Jelly that makes writing <code>eval</code>-based solutions fairly difficult: Jelly does not like to do arithmetic on characters, and has very few operations that can change a character into a different character, or create an arbitrary character from scratch. This is a problem because the <code>eval</code> functions operate on strings (which in Jelly are lists of characters), but in order to evaluate arbitrary code, we have to be able to produce arbitrary strings starting from a limited character set (ideally as small as possible, to leave more characters for the other subsets).</p>
<p>The usual approach for constructing arbitrary strings in Jelly is to use the <code>Ọ</code> command, which takes an integer (or list of integers) as its argument, and outputs the character with the given character code (or string whose characters have the specified character code). That's one perfectly fine solution to the problem of &quot;starting from a limited character set, produce an arbitrary string in Jelly&quot;. The problem is that it's only <em>one</em> solution, but there's space for two <code>eval</code>-based solutions, meaning that a second way to produce strings is needed. See below for how I managed it!</p>
<h4><code>eval</code>, the easy approach: using <code>Ọ</code></h4>
<p><em>Character set: <code>VŻỌ‘’</code></em></p>
<p>A very simple approach to get things started. Using <code>Ż</code> at the start of a 0-argument program produces the list [0]. That element can be incremented and decremented to any desired value with the increment instruction <code>‘</code> and decrement instruction <code>’</code>. Then a new 0 can be prepended to the list with <code>Ż</code>, and the increment and decrement instructions will then affect the entire list, and this can be continued making the list longer and longer over time. It's possible to produce an arbitrary list of integers this way: just set each element to its correct value <em>relative to the previous element</em>, and finally set the first element to its correct value, which will cause all the other values to be correct.</p>
<p>After producing an arbitrary list of integers, it can be converted to a string with <code>Ọ</code> and evaluated as a program with <code>V</code>.</p>
<p><a href="https://tio.run/##y0rNyan8//9Rw8wRiI7uHpn@pl/ozhhFQxod3Q2CgzUyH@7uCfv/HwA" rel="nofollow noreferrer" title="Jelly – Try It Online">Here's an example program written in this subset.</a> <a href="https://tio.run/##AUAAv/9qZWxsef//4bmgwrsw4buL4oG@4oCZ4oCYeEEKT8W7VcW7ScOH4oKsauKAncW7O@KBvuG7jFb///8xMDAww4ZS" rel="nofollow noreferrer" title="Jelly – Try It Online">And here's a compiler.</a> This construction is simple and small enough that it's possible to run the compiler, and the compiled program is small enough to fit in this post. This will not be the case for all the future constructions!</p>
<h4><code>eval</code>, the hard approach: without using <code>Ọ</code></h4>
<p><em>Character set: <code>01uvọŒ⁾¤</code></em></p>
<p><code>Ọ</code> makes things easy, but it turns out that avoiding it is just about possible. The basic idea is to note that because we have an <code>eval</code> operator in our character set, it's possible to get at the <em>effect</em> of <code>Ọ</code> either by using the <code>Ọ</code> command itself (which we can't use), or by producing the <em>string</em> <code>&quot;Ọ&quot;</code> and <code>eval</code>ing it. However, this is still fairly difficult as <code>Ọ</code> is the primary way to produce arbitrary strings in Jelly, with the main obstacle reducing to &quot;how do you produce an <code>'Ọ'</code> if you don't have one already?&quot;.</p>
<p>I could actually only find two ways in Jelly to produce an <code>'Ọ'</code> without already having a string that contained an <code>'Ọ'</code>. One possible approach is to index into <code>ØJ</code>, a predefined constant that contains all the characters used by Jelly (including <code>'Ọ'</code>); but indexing operators are <em>really</em> useful when implementing Turing-complete languages from scratch, so I didn't really want to spend them here. Instead, I used the other approach: Jelly has a few case-changing operators that take strings as input and return strings as output, meaning that it is possible to produce <code>'Ọ'</code> by uppercasing a lowercase <code>'ọ'</code>, and although a few different commands work, I couldn't find a reason to use anything other than the uppercasing command <code>Œu</code> (all casing commands contain <code>Œ</code> so there is no way to avoid using that, and <code>u</code> is not useful except to spell <code>Œu</code> – it doesn't spell any other commands).</p>
<p>Producing <code>ọ</code> is basically as difficult as producing <code>Ọ</code>, but because <code>ọ</code> is in our character set, it's possible to just write it in a string literal. For this subset, I used the <code>⁾</code> form of string literals, which is limited to strings that are exactly two characters long – this is sufficient for this subset, and the least generally useful for other subsets.</p>
<p>This approach needs at least <code>uvọŒ⁾</code>, and adding <code>01¤</code> produces a complete Turing-complete subset. Unfortunately, this is one of those JSFuck-style subsets in which a full construction gets slowly built up out of smaller parts and the resulting programs are basically unreadable, so I'm going to go through the steps one at a time.</p>
<p><a href="https://tio.run/##y0rNyan8//9R476Hu3uB6Oik0kNLuAwNqACAphkaAA1DNbuMmmbTyHTc1pXR1DOoxsGFQRFi5BLKZUgfYDAKqAxcjix4uKvj4e4eLuRQRg9rEN/l6KR0oFJ6RfWQS0nQ8AEGJTiv/Dc8tPjhzpaHO2crGMFZxnCWCZxlCmeZwVnmcJbFocX/AQ" rel="nofollow noreferrer" title="Jelly – Try It Online">A snippet demonstrating each step, at Try It Online!</a></p>
<ol>
<li>Jelly is normally a fairly linear language (start with value <strong>y</strong>, do <strong>A</strong> to it, then do <strong>B</strong> to it, etc.), but the construction here contains expressions which are more complicated in shape. As such, I'm using the grouping operator <code>¤</code> which basically makes Jelly into a postfix language if used everywhere: what would be written <code>1 + 2</code> in an infix language becomes <code>1 2 +</code> in a postfix language and <code>1+2¤</code> in Jelly, and what would be written <code>¬3</code> in a language with prefix unary operators becomes <code>3 ¬</code> in a postfix language and <code>3¬¤</code> in Jelly. As such, the string <code>&quot;ỌỌ&quot;</code> (which has the same effect when executed as <code>&quot;Ọ&quot;</code> – <code>Ọ</code> is idempotent) can be written as <code>⁾ọọŒu¤</code>, i.e. &quot;<code>Œu</code> applied to <code>&quot;ọọ&quot;</code>, written as a postfix expression&quot;).</li>
<li>In addition to being a lowercase <code>Ọ</code>, the <code>ọ</code> command is actually mildly useful in its own right; it returns the number of times its right-hand argument divides into its left-hand argument. This means that with <code>01ọ¤</code> it is possible to write arbitrary nonnegative integers, e.g. <code>1000ọ10¤</code> is 3 because <span class="math-container">\$10^3=1000\$</span>, and it is possible to create larger numbers simply by adding more zeroes.</li>
<li>Being able to construct <code>&quot;ỌỌ&quot;</code>, it is then possible to evaluate it using the evaluate-with-argument command <code>v</code>. Because it's possible to produce arbitrary integers, this can produce arbitrary single characters. The example in the TIO! link produces <code>'D'</code> by doing <code>“ỌỌ”v68¤</code>.</li>
<li>By nesting uses of <code>…v…¤</code> it is possible to produce arbitrary expressions that consist of a constant, followed by any number of single-character unary builtins. The expression shown here is <code>“U”v“D”v12¤¤</code>…</li>
<li>…which is just another way to write <code>12DU</code>, i.e. &quot;reverse the digits of 12&quot;. I will be writing the remaining examples in this linear form, because it's much easier to read, but all of them can in theory be expanded to use <code>…v…¤</code> rather than being written linearly.</li>
<li>Directly producing arbitrary strings using only the single-character unary builtins is nontrivial (the single-character nullary builtins aren't useful, and the single-character binary builtins aren't useful here because <code>v</code> has no way to give them two different arguments). There are some strings that can be constructed, though. On this line, I construct the string <code>&quot;Œg&quot;</code> by starting with a number with 338 0 digits and 103 1 digits (which can just be written directly because the character set contains both <code>0</code> and <code>1</code>), taking its digits (<code>D</code>), grouping the digit positions by their values (<code>Ġ</code> – this produces a list of a 338-element list and a 103-element list), taking the length of each of the inner lists (<code>Ẉ</code>) to produce [338, 103], and then converting those character codes to characters to produce <code>&quot;Œg&quot;</code>. Note that the <code>D</code>, <code>Ġ</code>, etc. don't need to appear literally in the source; they are all produced using the technique shown in step 3, and combined into a single expression using the technique shown in step 4.</li>
<li>Now that it's possible to produce the string <code>&quot;Œg&quot;</code>, it can be evaluated in order to run the <code>Œg</code> builtin. It's possible to produce an arbitrary list whose elements are 0 and 1 (starting with 1) by using <code>D</code> on a number that can be written directly using our character set. <code>Œg</code> does run-length grouping, so it produces a list of lists for which the length of each internal element matches a run length in the original array. <code>Ẉ</code> can convert that format into an arbitrary list of positive integers. In the example, starting with <code>11111111110011110000000000001111</code> gives us <code>[10,2,4,12,4]</code> – the run lengths of the original constant (it has 10 1s, then 2 0s, then 4 1s, etc.).</li>
<li>Being able to produce arbitrary lists and run <code>ỌỌ</code> on them makes it possible to produce arbitrary strings; these can be given to <code>v</code> to make it possible to run arbitrary code in Jelly's character set (because the character set does not contain NUL, all its characters have positive Unicode codepoints and thus it doesn't matter that step 7 generates positive integers only). The TIO! example runs a program that prints the positive prime integers below 1000.</li>
</ol>
<p>So in summary: there is a way to bracket expressions arbitrarily, <code>ọ</code> can be used to produce arbitrary integers, and that makes it possible to produce and evaluate single-character strings. That isn't fully general on its own but is good enough to produce <code>&quot;Œg&quot;</code>, which in turn makes it possible to write arbitrary arrays of integers, and those can be converted to strings and evaluated in order to write any program.</p>
<h3>Solutions based on tag systems</h3>
<p>A <a href="https://esolangs.org/wiki/Tag_system" rel="nofollow noreferrer">tag system</a> is a simple Turing-complete language that works as follows. A program consists of a map from characters to strings, and a number <em>m</em>, together with an initial string. Data storage is done by using a string that acts like a queue (and starts with the specified value). To execute the program, delete the leftmost <em>m</em> characters of the queue-string; then, look up the string that corresponds to the first of the deleted characters according to the map, and append that string to the queue-string. There is a special &quot;halt&quot; character, not found in the map, that causes the program to end if an attempt is made to look it up in the map.</p>
<p>It is possible to compile Turing machines into tag systems with any chosen value of <em>m</em> from 2 upwards; thus, if a language can have an <em>m</em>-tag system for any specific <em>m</em> ≥ 2 compiled into it, then it is Turing-complete (by compiling from a Turing machine into a tag system and then into the language). Tag systems are often a fairly easy way to prove a language/subset Turing-complete, as long as it has something that's usable as a map/dictionary (either a read-write map or a constant map literal, it doesn't matter), because the other operations performed by the language are very simple.</p>
<h4>Using <code>Ŀ</code></h4>
<p><em>Character set: <code>2ṭḊḢĿ¶</code></em></p>
<p>One simple way to compile a tag system to Jelly is to use the <code>Ŀ</code> builtin. Here's what that could look like if we had Jelly's full character set available, implementing <a href="https://esolangs.org/wiki/Tag_system#Example" rel="nofollow noreferrer">the example tag system on Esolang</a>:</p>
<pre><code>Ḋ3ṭ3ṭ2ṭ1ṭ4ṭḢĿ
Ḋ3ṭ3ṭ1ṭḢĿ
Ḋ3ṭ3ṭḢĿ

2Ḋ1ṭ2Ŀ
</code></pre>
<p><a href="https://tio.run/##y0rNyan8///hji7jhzvXgrAREBsCsQkQP9zZ8nDHoiP7uZDkDXGIw8W4jICiUFVGR/b//w8A" rel="nofollow noreferrer" title="Jelly – Try It Online">Try it online!</a> (has added <code>Ṅ</code> to show the steps of execution)</p>
<p>The <code>Ŀ</code> builtin is designed for function calls, but in this program, it is used only at the end of a function – in tail position – so it effectively acts like a <code>goto</code> command (as soon as any function returns, all of them return, so the call stack is irrelevant). It is preceded by an argument that specifies which line to jump to, so this version of the construction needs newlines (in Jelly's character set, the newline character can be rendered either with an actual newline or as <code>¶</code>, but the two are equivalent views of the same character rather than being two separate characters, so it's usual to use whichever rendering makes more sense in the context). The key observation is that <code>ḢĿ</code> – &quot;jump to the line given by the first element {of the list on which we're currently operating}&quot; – can be used as a lookup-in-map operation: using line numbers as the characters of the string, the code on line <em>n</em> can be code that appends a specific string literal to the string (and then removes the characters from the start and jumps with <code>ḢĿ</code>). Halting can be implemented using a line with no code.</p>
<p>To implement this in Jelly, the idea is for each line of code to remove characters from the start (<code>Ḋ</code> – this can be repeated to remove as many characters as needed, with one already having been removed by <code>Ḣ</code>), and to append the appropriate elements at the end (e.g. [3,3,1] can be appended using <code>3ṭ3ṭ1ṭ</code>, using the &quot;append element&quot; command <code>ṭ</code>).</p>
<p>The initial string can be implemented using very similar code, but there's a need to produce a list to append to so that <code>ṭ</code> behaves appropriately. <code>Ḋ</code> is overloaded to produce a list from 2 to the given integer inclusive, so <code>2Ḋ</code> produces the list [2]. This means that the second element of the initial string must be 2, but fortunately that's one of the elements that is skipped, so its value has no effect on the resulting program.</p>
<p>In the &quot;all of Jelly is allowed&quot; method of compiling a tag system, the used characters are <code>0123456789ṭḊḢĿ¶</code>. However, if you spread the program out enough, only <code>2</code> is actually needed (for <code>2Ḋ</code>): nothing goes wrong if you name the elements of the tag system <code>2</code>, <code>22</code>, <code>222</code>, etc. rather than <code>1</code>, <code>2</code>, <code>3</code>, etc., and simply add a lot of newlines to the program to put the various code that implements map elements onto the appropriate line.</p>
<h4>Using <code>ị</code></h4>
<p><em>Character set: <code>3[,];?ÑṖṪị</code></em></p>
<p>Instead of baking the tag system's map into our program's control flow, it's also possible to simply just use a list as though it were a map; the tag system alphabet can be made out of integers, and those integers can be list indexes. Reading from the map can thus be done with a list indexing instruction, such as <code>ị</code>.</p>
<p>For this construction, I'll use an alternative definition of a tag system, which is also Turing-complete: instead of having a specific halt symbol, the program halts once its internal string gets down to a single element.</p>
<p>Here's what that might look like if we had Jelly's entire character set to play with, implementing <a href="https://en.wikipedia.org/wiki/Tag_system#Example:_Computation_of_Collatz_sequences" rel="nofollow noreferrer">this tag system for calculating Collatz sequences found on Wikipedia</a>:</p>
<pre><code>Ṫị[[3,2],[1],[1,1,1],[1,1,1]];ṖÑ3Ṗ?
</code></pre>
<p><a href="https://tio.run/##y0rNyan8///hzlUPd3dHRxvrGMXqRBuCsA4QwulY64c7pz3c2XJ4ojGQYf//PwA" rel="nofollow noreferrer" title="Jelly – Try It Online">Try it online!</a> (contains added print statements so that you an see what is happening)</p>
<p>The implementation starts by removing the last element from the current value (<code>Ṫ</code>) and using it to index (<code>ị</code>) into a list literal (specified using Jelly's list literal syntax, which involves <code>[,]</code> and decimal integers) – the queue is stored &quot;backwards&quot; compared to the previous case. It then appends (<code>;</code>) the current value minus its last element (<code>Ṗ</code>) – two elements were removed from the end, of which only one was used, and so this is a 2-tag implementation. It is possible to add additional <code>Ṗ</code> at this point in order to implement higher values of <em>m</em>.</p>
<p>All that's needed after this is to handle halting, which here is done with an <code>if</code> statement, <code>Ñ3Ṗ?</code> (<code>?</code> specifies an <code>if</code> statement, and is preceded by the true case <code>Ñ</code>, the false case <code>3</code>, and the condition <code>Ṗ</code>). If the list has multiple elements, it'll be truthy when an element is removed with <code>Ṗ</code>, so <code>Ñ</code> is run, which is a recursive call to the main program. (This <code>Ṗ</code> does not actually affect the content of the list – it just provides a truth value to the <code>if</code> statement.) If the list does not have multiple elements, removing an element will produce an empty list, which is falsey, so <code>3</code> runs – that isn't a recursive call (it's an integer constant), so the program exits.</p>
<p>There is something apparently missing in the above explanation: how does the initial string get there, given that the program is run with no argument? The behaviour of <code>ị</code> when given no useful input data is to return the last element of the list it's indexing into, so it's possible to simply append the input string (<code>[1,1,1]</code>)  to the end of the list that serves as the tag system's map, as an additional element that's never read once the program has started but will be used on the first iteration. (If <em>m</em>&gt;2, some of the elements at the end will get removed on the first pass through the program, but this can be compensated for by adding extra junk elements to the initial string.)</p>
<p>One thing worth noting is that Jelly's list literal syntax is broken and doesn't support empty lists (<code>[]</code> seems like it should work, but actually causes the lexer to crash). Fortunately, although it is common to use empty productions when writing tag systems, they don't actually seem to be a necessary part of the language. (It is possible to add a &quot;null&quot; state that, when run, produces <em>m</em> copies of itself – an empty list can then be represented with <em>m</em> copies of that null state – but such programs can't get down to one element to halt. However, it is possible to start with such a program that has an explicit halt state, and find a corresponding program with twice the value of <em>m</em> that is able to halt itself correctly by getting down to one element; the idea is for both the data queue, and all the map elements, to alternate between commands used for running and commands used for halting.)</p>
<p>As in the previous solution, it's possible to remove digits other than <code>3</code> from the character set by using only list elements 3, 33, 333, etc., with irrelevant data in the others. The only part of the program that varies is the list literal, written using <code>[3,]</code>, and the rest of the program is fixed and uses only <code>;?ÑṖṪị</code>.</p>
<h3>A solution based on Blindfolded Arithmetic</h3>
<p><em>Character set: <code>:@U\_½ÄÇ×Ø</code></em></p>
<p><a href="https://esolangs.org/wiki/Blindfolded_Arithmetic" rel="nofollow noreferrer">Blindfolded Arithmetic</a> is a language that I originally created as <a href="https://codegolf.stackexchange.com/a/162531/">a cop in a cops-and-robbers challenge</a>. The original version had six variables, but I subsequently proved that it is <a href="http://nethack4.org/esolangs/blindfolded-arithmetic-2var.txt" rel="nofollow noreferrer">Turing-complete using only two variables</a>. It's the two-variable version that I'm using for this solution.</p>
<p>The two-variable Blindfolded Arithmetic has two unbounded integer variables (here called <em>X</em> and <em>Y</em>, starting at 1 and 0 respectively), and each command adds, subtracts, multiplies or floor-divides two variables and stores the result back into a variable. For example, a command might be <code>X = X + Y</code> or <code>Y = Y / X</code>. The program runs in an infinite loop forever, ending only upon division by zero. There are a couple of complications when it comes to working out how many commands need to be implemented:</p>
<ul>
<li>Subtractions and divisions are asymmetrical, so <code>Y = Y / X</code> is a different command from <code>Y = X / Y</code>, and both are useful. So when taking two different variables as arguments, these need to be counted twice.</li>
<li>It is occasionally useful to be able to use the same variable as both operands, along the lines of <code>X = X + X</code>. The Turing-completeness proof only does this when the result is being stored back into that variable (it doesn't, e.g., self-add one variable into the other).</li>
</ul>
<p>That comes out to a lot of commands, and this construction doesn't quite manage to implement all of them: self-subtract, self-multiply and self-divide are missing (although self-add is present). It does, however, have a &quot;halve&quot; command <code>Y = Y / 2</code> (which is not present in the original language: it <em>only</em> contains the variables, no constants!). This can be used to replace the two uses of self-subtraction in the original proof; the first use appears in a sequence of commands that go from <span class="math-container">\$X=Y=e\times t\$</span> to <span class="math-container">\$X=e\times t, Y=t\$</span> (which can be accomplished easily using a &quot;halve&quot; command because <em>e</em> is a constant power of 2, so you just halve Y <span class="math-container">\$log_2 e\$</span> times); and the second use is used to set Y from a known value <em>d</em> to 0 (which can be accomplished by repeatedly halving <em>Y</em> until it hits zero – because the value of <em>d</em> is known, it is known how many halvings this will require).</p>
<p>Unlike some of the previous answers, this one can be given as an explicit translation of each of the commands that are implemented:</p>
<pre><code>Y=Y/X               :@\×Ø½:Ø½
Y=X/Y               :\×Ø½:Ø½
Y=Y-X               _@\
Y=X-Y               _\
Y=Y+X or Y=X+Y      Ä
Y=Y*X or Y+Y*X      ×\

start of program    Ø½:@UU:Ø½U
swap X, Y           U
Y=Y+Y (or Y = Y*2)  ×Ø½
Y=Y/2               :Ø½
end of program      U×Ø½×Ø½Ç
</code></pre>
<p>Only the commands that assign to <em>Y</em> are implemented directly; for commands that assign to <em>X</em>, you swap <em>X</em> and <em>Y</em>, run the command with <em>X</em> and <em>Y</em> swapped, then swap <em>X</em> and <em>Y</em> back again.</p>
<p><a href="https://tio.run/##y0rNyan8/z/eIUbh4c4WBSuHmMPTD884tNcKRECEMETiIWoPT4fQML2HW6DCCK1wVihRpv///z/axEBHwdjMMBYA" rel="nofollow noreferrer" title="Jelly – Try It Online">Here's a demonstration of the commands doing their thing</a>, and <a href="https://tio.run/##y0rNyan8///wjEN7rRxCQ61AjFCFE@sUtGOgKFTh8HQQCZaCkg93tiiEHp4OYkPJ9v//AQ" rel="nofollow noreferrer" title="Jelly – Try It Online">here's an example of a compiled program</a>. Both have had print statements added so that you can see them in action.</p>
<p>The basic construction is very simple: <code>\</code> is a modifier to a two-argument builtin that makes it act cumulatively on a list, e.g. <code>[<em>x</em>,<em>y</em>,<em>z</em>]+\</code> is [<em>x</em>, <em>x</em>+<em>y</em>, <em>x</em>+<em>y</em>+<em>z</em>]. When operating on a two-argument list, this maps [<em>x</em>, <em>y</em>] to [<em>x</em>, <em>x</em> op <em>y</em>] which is exactly what most Blindfolded Arithmetic instructions do. As a result, by putting Jelly's operators for addition <code>+</code>, subtraction <code>_</code>, multiplication <code>×</code> and floor-division <code>:</code> before the backslash, it is possible to implement four of the Blindfolded Arithmetic commands – and the modifier <code>@</code>, meaning &quot;swap arguments&quot;, immediately gives two more. Reversing the list (<code>U</code>) makes it possible to operate on <em>X</em> rather than <em>Y</em>, producing the twelve &quot;basic&quot; commands. (One small variation: although <code>+\</code> is a perfectly fine implementation of <code>Y = Y + X</code>, I used the equivalent abbreviation <code>Ä</code> because I wanted to use <code>+</code> in a different solution.)</p>
<p>Three obstacles remain. One is to get the program started; the first iteration of the program needs to start with the list [1,0], but subsequent iterations need to start with the value at which the previous iteration ended. Ending the program is also nontrivial: unlike Blindfolded Arithmetic's <code>/</code> operator, Jelly's <code>:</code> does not crash when dividing by zero (returning infinity or NaN as appropriate). Extra characters will be needed simply to get at a two-element list in the first place. The other obstacle is implementing the self-additions, self-subtractions, etc.; most of these are nontrivial in Jelly (which is why this construction uses a modified version of the language which doesn't need self-subtractions/multiplications/divisions for Turing-completeness).</p>
<p>The same builtin happens to solve all these problems at once: the builtin <code>Ø½</code>, which is a constant with value [1,2]. It solves the problem of forming a two-element list, because it is a two-element list. It also immediately provides <code>Y = Y * 2</code> and <code>Y = Y / 2</code> instructions because <code>×</code> and <code>:</code> do pointwise multiplication and floor-division when operating on lists, thus <code>×Ø½</code> multiplies X by 1 (a no-op) and Y by 2, and likewise for <code>:Ø½</code> and division. It also happens to be of use in starting and ending the program, but this is a bit more subtle.</p>
<p>This construction, when wrapping from the end to the start of the program, encodes the list not as [<em>X</em>, <em>Y</em>] but as [<em>Y</em>, 4<em>X</em>], an encoding that is easily produced directly using <code>U×Ø½×Ø½</code>. The start of the program, <code>Ø½:@UU:Ø½U</code>, undoes this translation. However, the &quot;goto&quot; command (actually a tail-call) that goes back to the start is not the usual <code>ß</code>, but rather <code>Ç</code>, &quot;run the next line (wrapping around the program) parsing it as a 1-argument function&quot;. This reruns the main program, but the main program is a 0-argument function, so the use of a different parser means that the start of the program parses slightly differently:</p>
<pre><code>Ø½:@UU:Ø½U  (0-argument function)
Ø½          [1,2]
  :@        pointwise divide into
    U         the reversed {initial expression [1,2]} (i.e. [2,1])
            (producing [2÷1, 1÷2] = [2,0] using floor-division)
     U      reverse (producing [0,2])
      :Ø½   pointwise divide by [1,2]
            (producing [0÷1, 2÷2] = [0,1])
         U  reverse (producing [1,0])

Ø½:@UU:Ø½U  (0-argument function)
Ø½          [1,2]
  :@        pointwise divide into the {argument} (i.e. [Y, 4X])
            (producing [Y÷1, 4X÷2] = [Y, 2X])
    UU      reverse twice (no-op)
      :Ø½   pointwise divide by [1,2]
            (producing [Y÷1, 2X÷2] = [Y,X])
         U  reverse (producing [X,Y])
</code></pre>
<p>In the former case, the <code>U</code> is <em>inside</em> the <code>:@</code>; in the latter case, it comes <em>afterwards</em>. I think it would be possible to get the wrap around the program to work correctly even if Jelly didn't have the special case; but because the special case exists, the code has to be written to compensate for it.</p>
<p>As for the end of the program, this exploits what is probably a bug in Jelly. <code>:</code> has been extended to handle infinities, and cases like 0/0, 0/infinity, and the like all work correctly. However, apparently only the corner cases, not the edge cases, were implemented, because dividing infinity by a normal integer (e.g. infinity/2) causes the Jelly interpreter to crash with an exception. (It took me a surprisingly long time to find this; after discovering that all the corner cases worked correctly, I assumed there was no way to get it to crash until I hit an edge case by accident.) As such, after every division, Y is immediately doubled and then halved again; this is a no-op in most cases, but after a division by zero, it will cause the program to crash, emulating Blindfolded Arithmetic's halt behaviour. (0÷0 probably doesn't work, but the halt case for Blindfolded Arithmetic's Turing-completeness proof is implemented by dividing 0 into a positive number and never uses the case of 0÷0.)</p>
<h3>A solution based on Thue</h3>
<p><em>Character set: <code>jµœƬṣ“”</code></em></p>
<p><a href="https://esolangs.org/wiki/Thue" rel="nofollow noreferrer">Thue</a> is a very simple programming language based around find and replace: starting with an initial string, each instruction specifies a search string, and a string to replace it with if it is found. The instructions run in an arbitrary order, as many times as necessary, until no more instructions can be run. (The original version of Thue had a mathematically nondeterministic evaluation order – i.e. the interpreter was supposed to look ahead to work out what sequence of replacements would cause the program to halt – but that mutated at some point into &quot;just run a random command&quot; due to a misunderstanding of &quot;nondeterministic&quot;, and the language turns out to be Turing-complete no matter what algorithm the interpreter uses to decide which order to run the commands in, because it is possible to write Thue programs such that only one command is runnable at a time. In fact, Turing machines compile pretty much directly into Thue with that restriction.)</p>
<p>Thue compiles almost directly into Jelly, as long as the program is written to not care about evaluation order. The form of the program is <em>initial string</em> <code>µ</code> <em>productions</em> <code>µƬ</code> (with <code>µ…µT</code> being &quot;loop until nothing changes&quot;), where each production is of the form <em>string</em> <code>œṣ</code> <em>string</em> <code>j</code> (i.e. &quot;split on <em>string 1</em>, then join on <em>string 2</em>&quot;, a very simple way to implement find-and-replace). Characters like <code>j</code> and <code>œ</code> are perfectly usable as the content of string literals (and Thue only needs two different characters to be Turing-complete), so in addition to <code>jµœƬṣ</code>, all that is needed are the string literal delimiters <code>“”</code>.</p>
<p><a href="https://tio.run/##y0rNyan8//9Rw5yjk0EwKyvrUcPcQ1uPTn64czFYFMQH4jlZRyeDZY6t@X@43fs/AA" rel="nofollow noreferrer" title="Jelly – Try It Online">Here's an example program using this character set.</a></p>
<h3>A solution based on The Waterfall Model</h3>
<p><em>Character set: <code>&quot;$+4DLMṀns¿</code></em></p>
<p><a href="https://esolangs.org/wiki/The_Waterfall_Model" rel="nofollow noreferrer">The Waterfall Model</a> is what seems like one of my more fundamental programming discoveries. I stumbled across the language several times in different contexts, and it took me a while to make the connection, but nowadays it's one of my most powerful tools for proving things Turing-complete.</p>
<p>The basic idea behind the language is: you have a number of counters (&quot;waterclocks&quot;) each of which holds an unbounded integer; if none of them are 0, then all of them are decreased by 1; if one of them is 0, then a specific number is added to each counter, based on which counter it is that zeroed. A program consists of initial values for each counter, plus a two-dimensional matrix that specifies the amount added to each counter when each counter zeroes (with the coordinates being the counter that zeroed, and the counter that is added to). Counters aren't allowed to go negative, so every counter is supposed to add to itself when it zeroes.</p>
<p>It is known that it is possible to write an interpreter for The Waterfall Model using only four different characters. <a href="https://codegolf.stackexchange.com/a/125815">Using each of them only once.</a> That was one of the first occasions upon which I stumbled across it, and at that point it didn't even have a name yet. However, the four-byte interpreter isn't really usable for <em>this</em> challenge, for two reasons: a) it's an interpreter not a compiler, and the implicit input of the program is exploited to set up the data structures it uses; b) it doesn't implement the language's halting behaviour.</p>
<p>Still, it wasn't too hard to adapt it into a subset of characters that can be compiled into. This solution implements a variant of The Waterfall Model in which the initial counter values are all in the range 0…9, as are the values added when a counter zeroes; it's still Turing-complete with that restriction (the Turing-completeness construction uses only small integers, none as large as 10). There are two basic parts to the program: a) setting up an appropriate data structure in memory, and b) implementing the language once the data structure is set up.</p>
<p>First, the setup (which has a <a href="https://tio.run/##y0rNyan8/98EDbj4uHAZGhmbmJqZW1hamJuZmhgbuRSb/Dc8tPjhzpaHO2crGB1a/B8A" rel="nofollow noreferrer" title="Jelly – Try It Online">couple of accompanying examples on TIO!</a>). This is done using the four characters <code>4DLs</code>. It is possible to create integers with arbitrary numbers of digits by writing a lot of 4s in a row; <code>DL</code> (digit length) can then be used to construct an arbitrary integer (e.g. <code>44444DL</code> is the integer 5). Following this with <code>D</code> (digits) can then be used to produce an arbitrary list with all elements in the range 0…9 (as long as the first is nonzero), as shown in the first line of the TIO! link.</p>
<p>That list can then be split using <code>s</code> into a list of lists (a matrix), so long as the number of columns is 4, or 44, or 444, etc.; the number of columns in the matrix equals the number of counters plus one, and it's possible to add &quot;junk counters&quot; that never become zero in order to top the number of counters up to an appropriate number. This forms a data structure that is used to store both the counter values, and all the zeroing triggers.</p>
<p>In order to shrink the set of used characters slightly, the data structure is stored &quot;upside down&quot; (lower numbers within the data structure correspond to higher numbers within the program that was compiled), and has the following structure:</p>
<ul>
<li>The first row is arbitrary, except that all elements but the first are equal to each other, with the first being smaller.</li>
<li>The rest of the first column stores the counter values, encoded as the difference between the actual counter value and the largest value within the column (with lower meaning a larger value); only their relative values matter, not the absolute value. For example, counter values of [1,4,3] could be encoded as [4-1, 4-4, 4-3] (i.e. [3,0,1]), or as [9-1, 9-4, 9-3] (i.e. [8,5,6]), or even as [1000-1, 1000-4, 1000-3] (i.e. [999, 996, 997]). (This implementation has a tendency to use unnecessarily large values as a base to subtract from; with many programs they will increase exponentially over the lifetime of the program.)</li>
<li>The remainder of each row stores the zeroing triggers, again with only their relative values mattering (and lower values meaning &quot;increase the counter by more&quot;). If the first counter zeroing increases itself by 3, the second counter by 0, and the third by 2, that could be represented as [<em>x</em>, 0, 3, 1] (where <em>x</em> represents the counter value), but, e.g., [<em>x</em>, 6, 9, 7] would be equally valid.</li>
</ul>
<p>When all the counters and all the zeroing triggers are in the range 0…9, it is possible to subtract them all from 9 (and add a row of the form [1,2,2,…,2] at the start) in order to produce a matrix of the required form using only elements in the 0…9 range (which can be created using the <code>444…444DLDs</code> construction).</p>
<p>To actually implement The Waterfall Model given this data structure, all that is needed is a loop that repeatedly finds the lexicographically largest line within the data structure, then adds the first element of that line to the entire first line, the second element of that line to the entire second line, and so on (in Jelly this addition is a builtin, <code>+&quot;</code>, and there is a <code>Ṁ</code> builtin for &quot;maximum&quot; to identify the appropriate line).</p>
<p>To see why this works, realise that the row with the largest value in the first column, if it's a counter, will be the counter nearest zero (because the encoding is upside-down), thus it will be the counter that zeroes next. The addition's effect on the first column will then change the relative values of the counters as though the appropriate value from the zeroing trigger were being added (and the absolute value doesn't matter, meaning in turn that only the relative values of the &quot;rest of the row&quot; matter). It also has an effect on columns other than the first, but this affects all those columns equally, so they will still have the correct relative vaues.</p>
<p>It is possible that the first row (which doesn't correspond to a counter) will have the largest value. In this case, it adds a smaller value to itself than it does to each of the other rows, so it doesn't change the relative values of the counters, and will eventually not be the largest any more; in other words, it ends up having no effect on the program execution as a whole.</p>
<p>The main tricky remaining part is to halt the program when the halt counter zeroes. It is sufficient for Turing-completeness to have a single halt counter with a fixed index; in this case, I used the third counter (which corresponds to the fourth row of the matrix).</p>
<p>The code for the main loop looks like this in Jelly:</p>
<pre><code>+&quot;Ṁ$MṀ$n4<span class="math-container">$$¿
           ¿   while loop
   $           body (2-builtin block):
+"               {to each row of the matrix}, add corresponding elements of
  Ṁ                the maximum {row of the matrix}
      $  $$</span>    condition (4-builtin block):
    M            the index of the maximum row
     Ṁ             tiebreak: maximum index
       n4        is not equal to 4
</code></pre>
<p>Using lots of <code>$</code> like this to introduce block structure used to be the primary way to create nontrivial loop bodies and conditions in Jelly, but is now obsolete because it takes up so many bytes. It still works, though, and is nice for minimal-subsets challenges because you can do it all with just <code>$</code>, you don't need any other character. The tiebreak on the maximum index is required even if there aren't ties; otherwise, Jelly tries to compare the list [4] to the number 4 and those are not equal, so the loop would never end.</p>
<p><a href="https://tio.run/##y0rNyan8/9/QCATMzSzMLc3NzM3NLU3NLEHACChgZmFkAQRmCi7FCmYK2koPdzao@IKIPAUTBRWVQ/v/H25/uLMl3tDI9D8A" rel="nofollow noreferrer" title="Jelly – Try It Online">Here's an example of a program compiled from The Waterfall Model running.</a> To save space, I didn't pad it out to 44 counters, but left it at 6 (likewise, the integer constant that represents the program is written in decimal rather than unary for space reasons). The arbitrary offsets applied to counter elements have a tendency to increase exponentially, so I added a footer that shows both the final value of the internal state, and the internal state normalized so that the halting counter has its value represented as 0.</p>
<h3>A solution based on Addition Automaton</h3>
<p><em>Character set: <code>CNt©®ÐƊḌḶṃṄẒẸ</code></em></p>
<p>The Waterfall Model can be implemented in Jelly in four bytes. <a href="https://esolangs.org/wiki/Addition_Automaton" rel="nofollow noreferrer">Addition Automaton</a> outgolfs that – <a href="https://codegolf.stackexchange.com/a/264429">it can be implemented in three</a>, and the important ones haven't been used so far by the other subsets. So after discovering the language, I was naturally going to have to try to fit it in here.</p>
<p>Addition Automaton is basically a find-and-replace operation on the digits of a number; a program specifies a replacement value for each digit, and the digits get replaced, repeatedly. The computational power comes from the way multiple-digit replacements are handled; they don't push the other digits away to make room, but instead carry into the more significant digits of the number (meaning that the higher digits of one replacement will end up adding onto the replacement of some more significant digit, thus the name &quot;Addition Automaton&quot;).</p>
<p>The primary challenge here is trying to get the halt state to work. Addition Automaton is defined in terms of the base <em>b</em> used to convert the number to digits; the smaller <em>b</em> is, the more complicated the definition of &quot;halting program&quot; you need for Turing-completeness. For this program, <em>b</em>=10, and the halting behaviour required for that (as far as has been proven so far is) &quot;halt if you see the same number twice, but possibly with a different number of trailing zeroes&quot;. That's a little complicated, but can be handled by removing zeroes while the program runs, and using one of Jelly's &quot;loop until you see the same thing twice&quot; loops.</p>
<p><a href="https://tio.run/##y0rNyan8/9/PGQIPrYSxIPDhzuZDKw@te7hrB1zFOq5oQwMdQxMdEyBlBMRmBkCugY4FSNRCx0jHIPbQSrAGkOZ1JQ93TXq4o@dY18OdLce6Dk94uGPbf8NDi4G8hztnKxgdWvwfAA" rel="nofollow noreferrer" title="Jelly – Try It Online">Here are the TIO! examples for this section.</a> There are actually only two steps to this solution: a) expressing the relevant values (a list of numbers, and a number) despite not having any literals available in the character set, and b) writing an Addition Automaton interpreter to run on those values.</p>
<p>First, the construction of the data. With <code>N</code> (subtract from 0) and <code>C</code> (subtract from 1), it is possible to reach arbitrary integers by alternating between <code>N</code> and <code>C</code> (you may have seen people use <code>~-</code> and <code>-~</code> in practical languages as a method of doing small adjustments to numbers in <a href="/questions/tagged/code-golf" class="post-tag" title="show questions tagged &#39;code-golf&#39;" aria-label="show questions tagged &#39;code-golf&#39;" rel="tag" aria-labelledby="tag-code-golf-tooltip-container">code-golf</a>, or strung together into long strings in <a href="/questions/tagged/restricted-source" class="post-tag" title="show questions tagged &#39;restricted-source&#39;" aria-label="show questions tagged &#39;restricted-source&#39;" rel="tag" aria-labelledby="tag-restricted-source-tooltip-container">restricted-source</a> – this is the same principle). <code>©</code> stores the result returned from a builtin in a register, so it's possible to place a <code>©</code> in an appropriate place in an <code>NCNC…NC</code> chain to construct two numbers (the current value and the register). It's then possible to use <code>ṃ</code>, which on numbers does base conversion, to produce an arbitrary list of integers (by expressing it as a number in a sufficiently high base), as long as the first element of the list isn't 0 (a restriction that turns out not to matter) – it can take its right-hand argument from the register, meaning that we can use any base we want here.</p>
<p>In the construction here, I use <code>ṃ©</code> to store the resulting list in the register, and then just need to create another number to serve as the initial value for the Addition Automaton state value. This is done by using <code>Ẹ</code> (&quot;contains any nonzeroes&quot;) to produce an arbitrary integer (in this case, 1), and then using repeats of <code>NC</code> to increment that to the desired value.</p>
<p>Now all that's needed is an Addition Automaton interpreter with lax loop detection:</p>
<pre><code>ṃ®tẒḌƊṄƊÐḶ
ṃ            Map the digits of {the state value}
 ®             using the list stored in the register as the map
  t          Delete all leading and trailing
   Ẓ           0s if there is a non-prime, 1s if there is a prime
    Ḍ        Convert from decimal to integer, with carry
     Ɗ Ɗ     Specifies loop body length: five builtins
      Ṅ      An arbitrary fifth builtin (&quot;print with newline&quot;)
        ÐḶ   Loop until the same value is seen twice
</code></pre>
<p>There are two weirdnesses here. One is that I'm starting to run out of ways to specify the size of a loop body; <code>Ʋ</code> didn't work for some reason, but <code>Ɗ</code> did as long as I added an extra pointless builtin for it to count. I chose <code>Ṅ</code> because it's a no-op apart from producing output, and the output is actually useful to see the program running. The other weirdness is that I want to say &quot;remove all trailing zeroes&quot; (base-conversion won't produce leading zeroes, so those don't matter), but don't have any easy ways to produce zero in the character set. Instead, I use <code>Ẓ</code> which will test something or other for primality (I'm not entirely sure what), but there are definitely non-primes present so zeroes will be removed (trailing zeroes on the number imply that it isn't prime!). It might also remove leading and trailing digits that map to the digit 1, but it isn't difficult to write an Addition Automaton program so that those are never produced (the Turing-completeness proof for <em>b</em>=10 does it naturally).</p>
<p>The first line of the linked example shows how to create a list and an integer using <code>CN©®ṃ</code>. The second line shows an Addition Automaton program running in the interpreter, and halting when it reaches the end. (This one was compiled from a 4-state 2-symbol busy beaver Turing Machine – to prove Turing-completeness you would use Echo Tag instead, but the halt condition is the same.)</p>
</div>
<div id="pu2" class="pu"><h2>C, 2</h2>
<p><a href="https://tio.run/##S9ZNT07@n5uYmaehWf0/Jz8vXSHHmgtM50PpPCBtm6MLFM63zdcFiubZ5ukCBXVBQmhEji2ITLeC8EAq9UH8/JJ8hXTr/7X/AQ" rel="nofollow noreferrer"><code>longt=-/ ?:;</code></a></p>
<p><a href="https://tio.run/##S9ZNT07@/z9NI1EnSSdZs7qWKzcxM09DszozTSNNw0AHCDWBorX//wMA" rel="nofollow noreferrer">others</a></p>
<p><sup>Body must be at least 30 characters; you entered 24.</sup></p>
</div>
<div id="pu3" class="pu"><h1>JavaScript, 2 subsets</h1>
<p>Here are the subsets, one on each line:</p>
<pre><code>x=&gt;()
Function`${re \}.al
</code></pre>
<p>Both implement lambda calculus, <a href="https://en.wikipedia.org/wiki/Lambda_calculus#Computability" rel="nofollow noreferrer">which is Turing Complete</a>, so I'll explain both.</p>
<p>The first subset allows you to (trivially) express any lambda calculus expression, so it is Turing Complete.</p>
<p>The second subset is possible because of tagged template literals, type coercion and template literal nesting. Here is the identity function on itself:</p>
<pre class="lang-javascript prettyprint-override"><code>Function`F${`return F.call\`F\${F}\``}`.call`F${Function`F${`return F`}`}`
</code></pre>
</div>
<div id="pu4" class="pu"><h1>Lua, 2</h1>

<pre class="lang-lua prettyprint-override"><code>#load(').chr
</code></pre>
<p>The <code>load</code> function allows for arbitrary code execution. <code>('').char</code> allows us to construct a string using charcodes. To get a charcode, all we need to do call char with a string of a certain length. For example, <code>('').char(#'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa')</code> gets us a space.</p>
<pre class="lang-lua prettyprint-override"><code>_G[]&quot;\0123456789
</code></pre>
<p>Again, allows for arbitrary code execution. Every global function, including <code>load</code>, is located within the <code>_G</code> table. We can use backslash followed by a number to get an arbitrary character (<code>\32</code> gives us a space). <code>_G[&quot;\108\111\97\100&quot;]</code> allows us to use load, and we can keep using the same trick to execute any code we want.</p>
<p>I don't believe it's possible to get higher than this, as most of the keywords involved in flow control use overlapping characters (<code>for</code>, <code>do</code>, <code>end</code>, <code>then</code>, <code>goto</code>, <code>while</code>, <code>function</code>, etc). I'd love to be proven wrong, though.</p>
</div>
<div id="pu5" class="pu"><h1>Javascript, score 2</h1>
<pre><code>(x)=&gt;
</code></pre>
<p>With this we can implement untyped lambda calculus (idea stolen from <a href="https://codegolf.stackexchange.com/questions/210753/minimal-maximum-byte-for-turing-completeness/210764#210764">this answer</a>)</p>
<pre class="lang-js prettyprint-override"><code>x=xx=&gt;xx // I
xx=x=&gt;xx=&gt;x // K
xxx=x=&gt;xx=&gt;xxx=&gt;x(xxx)(x(xxx)) // S
</code></pre>
<p>Although we don't have newlines or spaces it's easy to do something like this:</p>
<pre><code>(f=()=&gt;f)(&lt;definition&gt;)(&lt;definition&gt;)(&lt;definition&gt;)
</code></pre>
<p>Where each <code>&lt;definition&gt;</code> is a statement.</p>
<hr />
<pre><code>Functioesap`${}%bdf0123456789
</code></pre>
<p>From this we can construct</p>
<pre class="lang-js prettyprint-override"><code>Function`a${unescape`...`}```
</code></pre>
<p>Where the ... is URL-encoded text, in which each character is represented by a <code>%</code> followed by two hexadecimal digits. This allows the execution of arbitrary code. It's not necessary to use all the hex digits, as you could evaluate some other Turing-complete subset of JS, but whatever.</p>
<p>I seriously doubt a score of 3 is possible. Either function calls or some form of loop is required. Function calls require <code>()</code> or backticks, and loops require <code>()</code>. While there are ways to use proxies to allow function calls with <code>[]</code>, those require function calls themselves.</p>
</div>
<div id="pu6" class="pu"><h1>Python 3, score 3</h1>
<pre><code>()+1𝒸𝑒𝒽𝓇𝓍
'*.23;&lt;=F^_{}𝓪𝓬𝓮𝓱𝓵𝓹𝓺𝓻𝓼𝔁
 &quot;%,-0:[]acefinorst~𝐀𝐄𝐜𝐞𝐢𝐧𝐨𝐫𝐬𝐭𝐱
</code></pre>
<p>This is an extension of <strong><a href="https://codegolf.stackexchange.com/a/264367/88546">@UnrelatedString's answer</a></strong>, but too long to fit in a comment. Each line contains a subset of characters that can perform arbitrary code execution. A meaningless bonus is that none of these require newlines, although there was a reason for this which I explain later.</p>
<h3>Subset 1</h3>
<p>The first subset is simple, and is the same as <a href="https://codegolf.stackexchange.com/users/85334/unrelated-string">@UnrelatedString's</a> second subset. The code itself looks something like this:</p>
<pre class="lang-py prettyprint-override"><code>𝑒𝓍𝑒𝒸(𝒸𝒽𝓇(1+1+...+1)+𝒸𝒽𝓇(...)+...)
</code></pre>
<h3>Subset 2</h3>
<p>In the other answer, they wondered whether it was possible to set attributes on a type without creating a new <code>class</code>. Yes we can, and a quick examination shows that the following built-ins are available:</p>
<pre class="lang-py prettyprint-override"><code>__loader__, quit, exit, copyright, credits, license, help
</code></pre>
<p>Using one of these built-ins, we can redefine one of its class attributes to avoid using parentheses. We can for example, redefine the less-than operator (<code>&lt;</code>):</p>
<pre class="lang-py prettyprint-override"><code>help.__class__.__lt__=exec;help&lt;'print(1)'
</code></pre>
<p>To construct arbitrary strings, f-strings are a reasonable replacement for concatenation. We can also re-use the trick of redefining operators to call <code>chr()</code>. Here's how to execute <code>print(1)</code> using this subset:</p>
<pre class="lang-py prettyprint-override"><code>𝓱𝓮𝓵𝓹.__𝓬𝓵𝓪𝓼𝓼__.__𝓮𝓺__=𝓮𝔁𝓮𝓬;𝓱𝓮𝓵𝓹.__𝓬𝓵𝓪𝓼𝓼__.__𝓵𝓮__=𝓬𝓱𝓻;𝓱𝓮𝓵𝓹==F'{𝓱𝓮𝓵𝓹&lt;=2*2*2*2^2*2*2*2*2^2*2*2*2*2*2}{𝓱𝓮𝓵𝓹&lt;=2^2*2*2*2^2*2*2*2*2^2*2*2*2*2*2}{𝓱𝓮𝓵𝓹&lt;=2^3^2*2*2^2*2*2*2*2^2*2*2*2*2*2}{𝓱𝓮𝓵𝓹&lt;=2^2*2^2*2*2^2*2*2*2*2^2*2*2*2*2*2}{𝓱𝓮𝓵𝓹&lt;=2*2^2*2*2*2^2*2*2*2*2^2*2*2*2*2*2}{𝓱𝓮𝓵𝓹&lt;=2*2*2^2*2*2*2*2}{𝓱𝓮𝓵𝓹&lt;=2^3^2*2*2*2^2*2*2*2*2}{𝓱𝓮𝓵𝓹&lt;=2^3^2*2*2^2*2*2*2*2}'
</code></pre>
<h3>Subset 3</h3>
<p>We've already used up <code>.</code>, <code>=</code>, and <code>()</code>, so finding a way to call <code>exec</code> is becoming difficult. The one thing that is free are variable names, since Unicode provides us with more than enough variations of each letter. However, it is possible to do so by abusing asserts:</p>
<pre class="lang-py prettyprint-override"><code>AssertionError=exec;assert 0,'print(1)'
</code></pre>
<p><code>assert</code> takes two arguments: the pass/fail condition, and a string which is printed when the condition fails. This is roughly equivalent to <code>if cond: raise AssertionError(msg)</code>. By reassigning <code>AssertionError</code> to <code>exec</code>, the <code>msg</code> parameter effectively becomes the first argument of <code>exec</code>. Curiously, this feature seems exclusive to <code>AssertionError</code>, as other error types I've tried don't behave like this. Anyway, this by itself doesn't work because we can't use <code>=</code> or <code>;</code>.</p>
<p>The second trick is to abuse <code>for</code> loops. Let's just do <code>for AssertionError in[exec]:</code> instead! The last thing we need is the string construction, which can be done using <code>%</code>-formatting and repeated <code>-~</code>s. The size of the code grows exponentially, but here's an <code>exec('print(1)')</code>:</p>
<pre class="lang-py prettyprint-override"><code>for 𝐀𝐬𝐬𝐞𝐫𝐭𝐢𝐨𝐧𝐄𝐫𝐫𝐨𝐫 in[𝐞𝐱𝐞𝐜]:assert 0,&quot;%c%%c%%%%c%%%%%%%%c%%%%%%%%%%%%%%%%c%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%c%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%c%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%c&quot;%-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~0%-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~0%-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~0%-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~0%-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~0%-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~0%-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~0%-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~0
</code></pre>
<h3>Subset 4??</h3>
<p>Originally, I planned for a 4th subset through executing Python bytecode, since Python is able to natively run <code>pyc</code> files. The magic header for <code>pyc</code> files in Python 3.11 is <code>\xa7\x0d\x0d\x0a</code>. I noticed the <code>\x0d</code> and <code>\x0a</code> as being newlines, so I crafted my other solutions specifically without them. But I somehow missed the <code>\xa7</code> byte which is not representable in UTF-8, making this solution automatically invalid.</p>
<p>Still, there is some good potential for a 4th subset. For example, using <code>#coding:u7</code> to change the source's encoding could've also worked in place of Subset 3. Decorators are a possibility as well. I also vaguely recall Python also being able to natively handle zip files, and the PKZip magic header makes this a possibility: <code>\x50\x4b\x03\x04</code>.</p>
<p>Lastly, the challenge only asks for &quot;Turing-completeness&quot;, not arbitrary code execution. I only tried to do the latter, so it's possible that scoring 4 is quite a bit easier than I'm making it.</p>
</div>
<div id="pu7" class="pu"><h1>Python 3, score 2</h1>
<h2>Arbitrary code execution without <code>()</code></h2>
<pre><code>clags x:[]
_.time=hr+1
</code></pre>
<p>Any function <code>f</code> of a single argument can be called without parentheses as so:</p>
<pre class="lang-python prettyprint-override"><code>class F:[]
F.__class_getitem__=f
F[arg]
</code></pre>
<p>where <code>F</code> can obviously be any identifier constructed from the characters in the set, and the <code>[]</code> is just a funny way to <code>pass</code> because it would feel weird to put <code>p</code> in the set just for that. <code>exec</code> and <code>chr</code> only need one argument, and <code>+</code> doesn't need parentheses to begin with.</p>
<p><a href="https://ato.pxeger.com/run?1=m72soLIkIz9vwYKlpSVpuhY3ZxcUZeaVaKirqyfnJBYXK6RaRcdyperFx4O58empJZklqbnx8bapFanJXBA1ySA1yVjUJGcUAQ3S5IKamRqtrg2Eeln5mXka6skoPEN1rfyiFI1kTU1t9Vj1tPwihWSFzDwgKigt0YAIakKcCHXpgm0QU5U8UnNy8nUUyvOLclIUlaCKAA" rel="noreferrer">Translate here.</a></p>
<h2>Arbitrary code execution without <code>=</code>, or the characters in <code>exec</code></h2>
<pre><code>(~{f0ｒ&quot;ｃｈｅｘ}-)
</code></pre>
<p>I guess the lack of <code>=</code> isn't a big deal since this doesn't <a href="https://codegolf.stackexchange.com/a/110722/78410">have to milk out every last character</a>, actually; the real highlight is <code>exec</code>ing without <code>exec</code> by abusing Python's NFKC normalization of identifiers. With <code>+1</code> taken, arbitrary integers are constructed with <code>-~0</code>, and the characters are concatenated in an f-string.</p>
<p><a href="https://ato.pxeger.com/run?1=m72soLIkIz9vwYKlpSVpuhY3wwqKMvNKNNTf7219v3cGmGzWSFNS11ZX18vKz8zTUK8Girzf2_F-7yQNoKhunbpWflGKRrKmtrqBZq16Wn6RQrJCZh4QFZSWaGgChZU01TUhpkMtWbANYomSR2pOTr6OQnl-UU6KohJUEQA" rel="noreferrer">Translate here.</a></p>
<hr />
<p>While it's difficult to imagine a score-3 solution, a few extra bits of note:</p>
<ul>
<li>Spaces can be replaced with backslash-newline combinations.</li>
<li>There's plenty of other stuff that normalizes to <code>exec</code>, provided you can find a third way to call it.</li>
<li>Obviously, arbitrary code execution isn't necessary for Turing completeness; I actually meant to do the <code>__class_getitem__</code> set without <code>exec</code> to begin with by implementing ais's <a href="https://esolangs.org/wiki/The_Waterfall_Model" rel="noreferrer">Waterfall Model</a> but once I started using list comprehensions I realized I may as well just cheap out and do something easier to play with.</li>
<li>If there's any way to get a type you can set <code>__class_getitem__</code> on (or make a type you can define normal <code>__getitem__</code> for) without a <code>class</code> definition (or calling <code>type</code>), then that frees <code>:</code> up for control flow statements. How to do anything with them without newlines, parentheses, or <code>=</code> is beyond me.</li>
</ul>
</div>
<div id="pu8" class="pu"><h1>Python 2, score 2</h1>
<h3>Arbitrary code execution with <code>exec</code> and <code>%</code> formatting (from <a href="https://codegolf.stackexchange.com/a/110722/78410">this answer</a> by xsot)</h3>
<pre><code>exc=&quot;%

</code></pre>
<p>(six visible chars and newline)</p>
<h3>Untyped lambda calculus with <code>lambda</code> (from <a href="https://codegolf.stackexchange.com/a/210764/78410">this answer</a> of mine)</h3>
<pre><code>lambd :()
</code></pre>
<p>The score for Python 3 would be very likely 1 since <code>()</code>s are necessary for more things.</p>
</div>
<div id="pu9" class="pu"><h2><a href="https://esolangs.org/wiki/Incident" rel="noreferrer">Incident</a>, 128 or 557056</h2>
<h3>If &quot;character&quot; means byte</h3>
<p>Any set of two bytes is Turing-complete in Incident; thus it's possible to create 128 disjoint subsets, e.g. {0x00, 0x01}, {0x02, 0x03}, {0x04, 0x05}, and so on up to {0xFE, 0xFF}.</p>
<p>The reason is that the language determines its token set at runtime: the set of tokens used by a program is the set of substrings of that program that appear exactly three times (without being contained within or overlapping other such substrings within the input program). The language gives meanings to tokens based on their relative positioning, rather than the bytes that make them up. As such, an Incident program is <code>tr</code>-invariant; you can change the character set it uses simply by consistently replacing bytes, because that doesn't change the token structure of the program.</p>
<p>(The creation of Incident was actually inspired by this site: I wanted to find a way to avoid <a href="/questions/tagged/answer-chaining" class="post-tag" title="show questions tagged &#39;answer-chaining&#39;" aria-label="show questions tagged &#39;answer-chaining&#39;" rel="tag" aria-labelledby="tag-answer-chaining-tooltip-container">answer-chaining</a> <a href="/questions/tagged/restricted-code" class="post-tag" title="show questions tagged &#39;restricted-code&#39;" aria-label="show questions tagged &#39;restricted-code&#39;" rel="tag" aria-labelledby="tag-restricted-code-tooltip-container">restricted-code</a> questions getting stuck in a set of bytes that they had no way to get themselves out of. So being Turing-complete off any set of two bytes is a natural consequence of the way the language developed.)</p>
<h3>If &quot;character&quot; means Unicode character</h3>
<p>Incident doesn't attempt to parse its input into characters; it just looks at it as a single binary stream of bytes. However, that doesn't mean that you can't just simply feed a text file to the Incident interpreter. As such, it's meaningful to ask about what subsets of Unicode characters are Turing-complete if you put them into a text file, and ask the Incident interpreter to run the resulting text file as a program.</p>
<p>Assuming that the two characters in question have no bytes in common in their encodings, you actually end up with the exact same case as when you're using two different bytes: the &quot;identify substrings that occur three times&quot; routine is invariant under the operation of replacing one byte with two or more, so long as each byte that appear within the encoding always uniquely comes from one of the same two original characters. As such, the goal is to find 557056 subsets (because there are 1114112 encodeable Unicode characters).</p>
<p>This can be done fairly simply using UTF-8, choosing the two characters in each subset to always be the same length as each other:</p>
<ul>
<li><p>For ASCII (0x00 to 0x7F), simply pair the characters as bytes, as in the previous case;</p>
</li>
<li><p>For two-byte characters, sort the characters into four groups {00, 01, 10, 11}, based on the least significant bit of their leading byte and least significant bit of their trailing byte: all four groups are the same size. Characters in group 00 have no bytes in common with characters in group 11, so you can form a subset by pairing an arbitrary character in each group. Likewise, characters in group 01 have no bytes in common with characters in group 10, so those form subsets in the same way.</p>
</li>
<li><p>For three-byte characters, divide into groups based on the least significant bit of the leading byte and the least significant two bits of the trailing byte: this produces 32 groups which are all the same size. The groups can be paired into 16 pairs as follows:</p>
<pre><code>0 00 00 with 1 11 11
0 00 01 with 1 11 10
0 00 10 with 1 11 01
0 00 11 with 1 01 10
0 01 00 with 1 10 11
0 01 01 with 1 10 10
0 01 10 with 1 00 11
0 01 11 with 1 10 00
0 10 00 with 1 01 11
0 10 01 with 1 11 00
0 10 10 with 1 01 01
0 10 11 with 1 01 00
0 11 00 with 1 10 01
0 11 01 with 1 00 10
0 11 10 with 1 00 01
0 11 11 with 1 00 00
</code></pre>
<p>For each pair of groups, picking an arbitrary character from each group will produce a valid subset (i.e. no bytes that exist in one character in UTF-8 will exist in the other).</p>
</li>
<li><p>Four-byte characters use a similar construction, but now 1024 groups are used (taking one bit from the leading byte and three bits from each of the trailing bytes). Listing all the pairings wouldn't easily fit in the post, so here are the rules:</p>
<ul>
<li>Label the bits of each group as <code>A BCD EFG HIJ</code>.</li>
<li>Consider the three values obtained by bitwise-XORing two of <code>BCD</code>, <code>EFG</code> and <code>HIJ</code>:
<ul>
<li>if none of them are 1 (001), XOR the group number with <code>1 001 001 001</code> to produce the group number it's paired with; otherwise,</li>
<li>if none of them are 2 (010), XOR the group number with <code>1 010 010 010</code> to produce the group number it's paired with; otherwise,</li>
<li>if none of them are 4 (100), XOR the group number with <code>1 100 100 100</code> to produce the group number it's paired with.</li>
</ul>
</li>
</ul>
<p>It is not possible for the three resulting values to be 1, 2 and 4 (if BCD xor EFG is 1 and EFG xor HIJ is 2, then BCD xor HIJ is BCD xor EFG xor EFG xor HIJ which is 3; likewise for other assigments of positions to values). So these rules will always produce a result. Additionally, the pairing is consistent (i.e. if X is paired with Y, then Y will be paired with X); this is because the same number is being XORed into all three of the relevant segments of the trailing bytes, so it won't change the result you get when you XOR two of those segments together. Finally, it will ensure that the two members of each subset have no bytes in common because their leading bytes have different parities, and there is no way for a trailing byte of one member to equal a trailing byte of the other member (which can be seen by considering the pairwise XORs of the two equal trailing bytes, and the bytes in the corresponding position of the other member).</p>
</li>
</ul>
<p>There is some room for interpretation as to whether 557056 is actually the correct number of subsets here, depending on what exactly you consider a Unicode character to be. For example, the original version of UTF-8 allowed up to 2<sup>31</sup> different characters, meaning 2<sup>30</sup> subsets, but Unicode is nowadays capped at 1114112. Additionally, some of the characters may be considered invalid due to, e.g., being noncharacters or surrogates. However, the Incident interpreter doesn't care about any of this because it isn't trying to parse the UTF-8 anyway, and just looks at the bytes that make it up.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/264291/">264291</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




