<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::264291</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>002</td><td>Python 3</td><td>230818T194537Z</td><td><a href="https://codegolf.stackexchange.com/questions/264291/how-turing-complete-is-your-language/264367#264367">Unrelate</a></td></tr>
<tr d-ix="1"><td>001</td><td>05AB1E</td><td>230818T113525Z</td><td><a href="https://codegolf.stackexchange.com/questions/264291/how-turing-complete-is-your-language/264340#264340">Kevin Cr</a></td></tr>
<tr d-ix="2"><td>002</td><td>Python 2</td><td>230818T100339Z</td><td><a href="https://codegolf.stackexchange.com/questions/264291/how-turing-complete-is-your-language/264330#264330">Bubbler</a></td></tr>
<tr d-ix="3"><td>nan</td><td>Incident</td><td>230817T212355Z</td><td><a href="https://codegolf.stackexchange.com/questions/264291/how-turing-complete-is-your-language/264310#264310">ais523</a></td></tr>
<tr d-ix="4"><td>002</td><td>C</td><td>230817T190151Z</td><td><a href="https://codegolf.stackexchange.com/questions/264291/how-turing-complete-is-your-language/264302#264302">l4m2</a></td></tr>
</table>
<div id="pu0" class="pu"><h1>Python 3, score 2</h1>
<h2>Arbitrary code execution without <code>()</code></h2>
<pre><code>clags x:[]
_.time=hr+1
</code></pre>
<p>Any function <code>f</code> of a single argument can be called without parentheses as so:</p>
<pre class="lang-python prettyprint-override"><code>class F:[]
F.__class_getitem__=f
F[arg]
</code></pre>
<p>where <code>F</code> can obviously be any identifier constructed from the characters in the set, and the <code>[]</code> is just a funny way to <code>pass</code> because it would feel weird to put <code>p</code> in the set just for that. <code>exec</code> and <code>chr</code> only need one argument, and <code>+</code> doesn't need parentheses to begin with.</p>
<p><a href="https://ato.pxeger.com/run?1=m72soLIkIz9vwYKlpSVpuhY3ZxcUZeaVaKirqyfnJBYXK6RaRcdyperFx4O58empJZklqbnx8bapFanJXBA1ySA1yVjUJGcUAQ3S5IKamRqtrg2Eeln5mXka6skoPEN1rfyiFI1kTU1t9Vj1tPwihWSFzDwgKigt0YAIakKcCHXpgm0QU5U8UnNy8nUUyvOLclIUlaCKAA" rel="nofollow noreferrer">Translate here.</a></p>
<h2>Arbitrary code execution without <code>=</code>, or the characters in <code>exec</code></h2>
<pre><code>(~{f0ｒ&quot;ｃｈｅｘ}-)
</code></pre>
<p>I guess the lack of <code>=</code> isn't a big deal since this doesn't <a href="https://codegolf.stackexchange.com/a/110722/78410">have to milk out every last character</a>, actually; the real highlight is <code>exec</code>ing without <code>exec</code> by abusing Python's NFKC normalization of identifiers. With <code>+1</code> taken, arbitrary integers are constructed with <code>-~0</code>, and the characters are concatenated in an f-string.</p>
<p><a href="https://ato.pxeger.com/run?1=m72soLIkIz9vwYKlpSVpuhY3wwqKMvNKNNTf7219v3cGmGzWSFNS11ZX18vKz8zTUK8Girzf2_F-7yQNoKhunbpWflGKRrKmtrqBZq16Wn6RQrJCZh4QFZSWaGgChZU01TUhpkMtWbANYomSR2pOTr6OQnl-UU6KohJUEQA" rel="nofollow noreferrer">Translate here.</a></p>
<hr />
<p>While it's difficult to imagine a score-3 solution, a few extra bits of note:</p>
<ul>
<li>Spaces can be replaced with backslash-newline combinations.</li>
<li>There's plenty of other stuff that normalizes to <code>exec</code>, provided you can find a third way to call it.</li>
<li>Obviously, arbitrary code execution isn't necessary for Turing completeness; I actually meant to do the <code>__class_getitem__</code> set without <code>exec</code> to begin with by implementing ais's <a href="https://esolangs.org/wiki/The_Waterfall_Model" rel="nofollow noreferrer">Waterfall Model</a> but once I started using list comprehensions I realized I may as well just cheap out and do something easier to play with.</li>
<li>If there's any way to get a type you can set <code>__class_getitem__</code> on (or make a type you can define normal <code>__getitem__</code> for) without a <code>class</code> definition (or calling <code>type</code>), then that frees <code>:</code> up for control flow statements. How to do anything with them without newlines, parentheses, or <code>=</code> is beyond me.</li>
</ul>
</div>
<div id="pu1" class="pu"><h1><a href="https://github.com/Adriandmen/05AB1E/wiki/Commands" rel="nofollow noreferrer">05AB1E</a>, 1</h1>
<p>Unfortunately, we need <code>.</code> in order to make an 05AB1E program Turing-complete. In the new 05AB1E version for either <code>.V</code> (evaluate as 05AB1E code) or <code>.E</code> (evaluate as Elixir code); and in the legacy version of 05AB1E for one of <code>.V</code> (evaluate as 05AB1E code), <code>.E</code> (evaluate as Bash code), or <code>.e</code> (evaluate as Python code).</p>
<p>The least distinct number of <a href="https://github.com/Adriandmen/05AB1E/wiki/Codepage" rel="nofollow noreferrer">bytes</a> necessary to make 05AB1E Turing-complete would be 4:</p>
<pre><code>.gBV
</code></pre>
<p><a href="https://codegolf.stackexchange.com/a/210771/52210">See this answer of mine</a> for the <a href="https://codegolf.stackexchange.com/q/110648/52210"><em>Fewest (distinct) characters for Turing Completeness</em> challenge</a> for details.</p>
</div>
<div id="pu2" class="pu"><h1>Python 2, score 2</h1>
<h3>Arbitrary code execution with <code>exec</code> and <code>%</code> formatting (from <a href="https://codegolf.stackexchange.com/a/110722/78410">this answer</a> by xsot)</h3>
<pre><code>exc=&quot;%

</code></pre>
<p>(six visible chars and newline)</p>
<h3>Untyped lambda calculus with <code>lambda</code> (from <a href="https://codegolf.stackexchange.com/a/210764/78410">this answer</a> of mine)</h3>
<pre><code>lambd :()
</code></pre>
<p>The score for Python 3 would be very likely 1 since <code>()</code>s are necessary for more things.</p>
</div>
<div id="pu3" class="pu"><h2><a href="https://esolangs.org/wiki/Incident" rel="noreferrer">Incident</a>, 128 or 557056</h2>
<h3>If &quot;character&quot; means byte</h3>
<p>Any set of two bytes is Turing-complete in Incident; thus it's possible to create 128 disjoint subsets, e.g. {0x00, 0x01}, {0x02, 0x03}, {0x04, 0x05}, and so on up to {0xFE, 0xFF}.</p>
<p>The reason is that the language determines its token set at runtime: the set of tokens used by a program is the set of substrings of that program that appear exactly three times (without being contained within or overlapping other such substrings within the input program). The language gives meanings to tokens based on their relative positioning, rather than the bytes that make them up. As such, an Incident program is <code>tr</code>-invariant; you can change the character set it uses simply by consistently replacing bytes, because that doesn't change the token structure of the program.</p>
<p>(The creation of Incident was actually inspired by this site: I wanted to find a way to avoid <a href="/questions/tagged/answer-chaining" class="post-tag" title="show questions tagged &#39;answer-chaining&#39;" aria-label="show questions tagged &#39;answer-chaining&#39;" rel="tag" aria-labelledby="tag-answer-chaining-tooltip-container">answer-chaining</a> <a href="/questions/tagged/restricted-code" class="post-tag" title="show questions tagged &#39;restricted-code&#39;" aria-label="show questions tagged &#39;restricted-code&#39;" rel="tag" aria-labelledby="tag-restricted-code-tooltip-container">restricted-code</a> questions getting stuck in a set of bytes that they had no way to get themselves out of. So being Turing-complete off any set of two bytes is a natural consequence of the way the language developed.)</p>
<h3>If &quot;character&quot; means Unicode character</h3>
<p>Incident doesn't attempt to parse its input into characters; it just looks at it as a single binary stream of bytes. However, that doesn't mean that you can't just simply feed a text file to the Incident interpreter. As such, it's meaningful to ask about what subsets of Unicode characters are Turing-complete if you put them into a text file, and ask the Incident interpreter to run the resulting text file as a program.</p>
<p>Assuming that the two characters in question have no bytes in common in their encodings, you actually end up with the exact same case as when you're using two different bytes: the &quot;identify substrings that occur three times&quot; routine is invariant under the operation of replacing one byte with two or more, so long as each byte that appear within the encoding always uniquely comes from one of the same two original characters. As such, the goal is to find 557056 subsets (because there are 1114112 encodeable Unicode characters).</p>
<p>This can be done fairly simply using UTF-8, choosing the two characters in each subset to always be the same length as each other:</p>
<ul>
<li><p>For ASCII (0x00 to 0x7F), simply pair the characters as bytes, as in the previous case;</p>
</li>
<li><p>For two-byte characters, sort the characters into four groups {00, 01, 10, 11}, based on the least significant bit of their leading byte and least significant bit of their trailing byte: all four groups are the same size. Characters in group 00 have no bytes in common with characters in group 11, so you can form a subset by pairing an arbitrary character in each group. Likewise, characters in group 01 have no bytes in common with characters in group 10, so those form subsets in the same way.</p>
</li>
<li><p>For three-byte characters, divide into groups based on the least significant bit of the leading byte and the least significant two bits of the trailing byte: this produces 32 groups which are all the same size. The groups can be paired into 16 pairs as follows:</p>
<pre><code>0 00 00 with 1 11 11
0 00 01 with 1 11 10
0 00 10 with 1 11 01
0 00 11 with 1 01 10
0 01 00 with 1 10 11
0 01 01 with 1 10 10
0 01 10 with 1 00 11
0 01 11 with 1 10 00
0 10 00 with 1 01 11
0 10 01 with 1 11 00
0 10 10 with 1 01 01
0 10 11 with 1 01 00
0 11 00 with 1 10 01
0 11 01 with 1 00 10
0 11 10 with 1 00 01
0 11 11 with 1 00 00
</code></pre>
<p>For each pair of groups, picking an arbitrary character from each group will produce a valid subset (i.e. no bytes that exist in one character in UTF-8 will exist in the other).</p>
</li>
<li><p>Four-byte characters use a similar construction, but now 1024 groups are used (taking one bit from the leading byte and three bits from each of the trailing bytes). Listing all the pairings wouldn't easily fit in the post, so here are the rules:</p>
<ul>
<li>Label the bits of each group as <code>A BCD EFG HIJ</code>.</li>
<li>Consider the three values obtained by bitwise-XORing two of <code>BCD</code>, <code>EFG</code> and <code>HIJ</code>:
<ul>
<li>if none of them are 1 (001), XOR the group number with <code>1 001 001 001</code> to produce the group number it's paired with; otherwise,</li>
<li>if none of them are 2 (010), XOR the group number with <code>1 010 010 010</code> to produce the group number it's paired with; otherwise,</li>
<li>if none of them are 4 (100), XOR the group number with <code>1 100 100 100</code> to produce the group number it's paired with.</li>
</ul>
</li>
</ul>
<p>It is not possible for the three resulting values to be 1, 2 and 4 (if BCD xor EFG is 1 and EFG xor HIJ is 2, then BCD xor HIJ is BCD xor EFG xor EFG xor HIJ which is 3; likewise for other assigments of positions to values). So these rules will always produce a result. Additionally, the pairing is consistent (i.e. if X is paired with Y, then Y will be paired with X); this is because the same number is being XORed into all three of the relevant segments of the trailing bytes, so it won't change the result you get when you XOR two of those segments together. Finally, it will ensure that the two members of each subset have no bytes in common because their leading bytes have different parities, and there is no way for a trailing byte of one member to equal a trailing byte of the other member (which can be seen by considering the pairwise XORs of the two equal trailing bytes, and the bytes in the corresponding position of the other member).</p>
</li>
</ul>
<p>There is some room for interpretation as to whether 557056 is actually the correct number of subsets here, depending on what exactly you consider a Unicode character to be. For example, the original version of UTF-8 allowed up to 2<sup>31</sup> different characters, meaning 2<sup>30</sup> subsets, but Unicode is nowadays capped at 1114112. Additionally, some of the characters may be considered invalid due to, e.g., being noncharacters or surrogates. However, the Incident interpreter doesn't care about any of this because it isn't trying to parse the UTF-8 anyway, and just looks at the bytes that make it up.</p>
</div>
<div id="pu4" class="pu"><h2>C, 2</h2>
<p><a href="https://tio.run/##LcmxCoAwDIThvU/RUYfg3hJ8FskQhJhb3MRnj2lxuQ/@E1KRuI7Tl/UJg2u1Xqb49ZSNMoNBWZ2dMhZthUY2Hptg96bz3/JX3Kja440P" rel="nofollow noreferrer"><code>longt=-/ ?:;</code></a></p>
<p><a href="https://tio.run/##S9ZNT07@/z9NI1EnSSdZs7qWKzcxM09DszozTSNNw0AHCDWBorX//wMA" rel="nofollow noreferrer">others</a></p>
<p><sup>Body must be at least 30 characters; you entered 24.</sup></p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/264291/">264291</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




