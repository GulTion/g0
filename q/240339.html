<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::240339</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
<tr d-ix="0"><td>194</td><td>JavaScript Node.js</td><td>220127T185428Z</td><td><a href="https://codegolf.stackexchange.com/questions/240339/counting-universal-n-ary-logic-gates/241884#241884">l4m2</a></td></tr>
<tr d-ix="1"><td>242</td><td>Python 3.8 prerelease</td><td>211230T095023Z</td><td><a href="https://codegolf.stackexchange.com/questions/240339/counting-universal-n-ary-logic-gates/240341#240341">AnttiP</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://nodejs.org" rel="nofollow noreferrer">JavaScript (Node.js)</a>, 194 bytes</h1>

<pre class="lang-javascript prettyprint-override"><code>f=(n,c=[],k=0)=&gt;k-n?1/c[n*n]?(F=&gt;g=s=&gt;s[n**n*8]?eval(`try{for(A=n;A--;)for(B=n;B--;)eval(s)+~(A&lt;B?A:B)%n&amp;&amp;G;1}catch{}`):[...'AB()F'].some(_=&gt;g(s+_)))(t=&gt;u=&gt;c[t*n+u])``:f(n,c,k+1)+f(n,[...c,k]):0
</code></pre>
<p><a href="https://tio.run/##Hc5BboMwEAXQq3TTZAaDG3YVdIzsRXoIZAXkQtpCxxV2IlVRenWKu5sn/a8/n/21D275@I4F@7dhXUcCzh21Np/ogKSmgpvyybWcsW3gSOpMgVTYnHH2bJvh2s/QxeXnNvoFNHGti6LGBLPBJPxnAopf0C@m0ZXBR97tXuvy7vro3m/3DqtWSrnXBvC4tzL4rwFO2xYEcUJEiKQupFwbMxYXi11XjenNfBIlinSm@kaL1WGtH5zn4OdBzv4MI5SI6x8" rel="nofollow noreferrer" title="JavaScript (Node.js) – Try It Online">Try it online!</a></p>
<p>If a function can express <code>f(x,y)=max(x,y)+1</code>, then it's universal:</p>
<ul>
<li><code>f(x,x)=x+1</code>, therefore we can get <code>x+c</code> for any <code>c</code></li>
<li><code>max(x,x+1,...,x+n-2)</code> is <code>n-1</code>, unless <code>x</code> is zero where the result is <code>n-2</code></li>
<li><code>max(x,max(a,a+1,...,a+n-2,b,b+1,...,b+n-2)+1)</code> is <code>x</code> if either <code>a</code> or <code>b</code> is not 0, and <code>n+1</code> if <code>a</code> and <code>b</code> are both 0</li>
<li>Set the value using this</li>
</ul>
<p>The <code>eval</code> never meet a function that can't fit the exact length:</p>
<ul>
<li>The expression built with <code>AB()F</code> is always of odd length (<code>F(A)(B)</code>)</li>
<li>One can write <code>A</code> as <code>((((A))))</code> to use even spaces</li>
</ul>
</div>
<div id="pu1" class="pu"><h1><a href="https://docs.python.org/3.8/" rel="nofollow noreferrer">Python 3.8 (pre-release)</a>, <strike>287</strike> <strike>282</strike> 242  bytes</h1>
<p><sup>-5 bytes thanks to @Dialfrost</sup></p>

<pre class="lang-python prettyprint-override"><code>f=lambda n,g=0,c=0:g&lt;n**len(e:=range(n*n))!=(s:={g,sum(i//n*n**i for i in e),sum(i%n*n**i for i in e)})and f(n,g+1,c+([s:=s|{sum(g//n**(l//n**i%n*n+r//n**i%n)%n*n**i for i in e)}for _ in&quot;a&quot;*n**n**2for l in s for r in s]!=len(s)==n**n**2))or c
</code></pre>
<p><a href="https://tio.run/##bY/BCsIwEER/JRWE3TTQVi9S3C8RkVjbGGi3JakHqX57TaqeFAI7zJtMssN9vPa83Q1unhtqdXe@aMHKUK4qykuzZynbmqEuyWk2NbBkxITAlzQZ5W8d2CwLppRWNL0TVlgWNb7J@hc8UfNFNBDeSAtVpXAITf4xxbyJTRLaZSyXU/fV@K8r6lPQK72KMJxNtNqI/ZJ0izwmFJfwSPSJIQZYzYOzPEIDBarwp@DOLw" rel="nofollow noreferrer" title="Python 3.8 (pre-release) – Try It Online">Try it online!</a></p>
<p>Uses a simple integer encoding of the gates, and composes them to depth <code>n**(n*n)</code> which should be sufficient. It's able to calculate up to <code>n=2</code>.</p>
<p>Full disclosure, this python golf is just to qualify this answer as code golf. The rest of this answer will explain how to calculate <code>n=4</code></p>
<h1>Explanation of the algorithm used to calculate n=4</h1>
<p>The following algorithm works for all <code>n&gt;=2</code>. In this explanation I refer to gates (also) as functions. <code>f(a,b)</code> denotes the value of gate <code>f</code> with inputs <code>a</code> and <code>b</code>. Gates can be composed just like functions. To keep every function binary, I often use the special functions <code>l(a,b)=a</code> and <code>r(a,b)=b</code> (which just pass the left/right argument).</p>
<h2>Core algorithm</h2>
<h3>Unary completeness</h3>
<p>A gate <code>f</code> is said to be unary complete if it's possible to create every unary function using <code>f</code>. Obviously, <code>f</code> has to be unary complete to be functionally complete.</p>
<p>We first check if <code>f</code> is unary complete. If not, then it's not functionally complete. Then we move to the next section.</p>
<h3>Functional completeness</h3>
<p>Assuming that <code>f</code> is unary complete, we can check if <code>f</code> is functionally complete with the two following tests.</p>
<h3>Lonelyness-test</h3>
<p>We want to find some symbols <code>a, b, c, d</code> where <code>a≠b</code> and <code>c≠d</code>, so that <code>f(a, c)</code> is distinct from <code>f(a, d)</code>, <code>f(b, c)</code> and <code>f(b, d)</code>. This means that <code>f</code> is &quot;lonely&quot;.</p>
<p>Using these values, and unary functions, we can simulate all of boolean logic.</p>
<p>If there are no such <code>a, b, c, d</code> I claim that <code>f</code> can't be functionally complete.</p>
<p>To see why, let's look at how non-lonely functions compose. Note that the functions <code>l(x,y)=x</code> and <code>r(x,y)=y</code> are not lonely. Assume <code>L</code> and <code>R</code> are non-lonely functions. <code>g(a,b)=f(L(a, b), R(a,b))</code>. In general, <code>L</code>, <code>R</code> and <code>f</code> have the one of the three following &quot;truth&quot; tables, for the relevant inputs:</p>
<pre class="lang-python prettyprint-override"><code>. a b
c x x
d y y

. a b
c x y
d x y

. a b
c x y
d y x
</code></pre>
<p>It should be clear that composing these does not make the resulting function lonely. This is a finitary problem and can be easily proved with brute-force. It is the same reason <code>xor</code> and <code>not</code> are not functionally complete.</p>
<p>In other words, composing non-lonely functions makes non-lonely functions, and since some gates are lonely, a non-lonely gate cannot be universal.</p>
<h3>Constructible-test</h3>
<p>Again, we assume <code>f</code> is unary complete, and also lonely.</p>
<p>A function <code>f</code> is n+1-constructible if there are some subsets of the alphabet <code>L</code> and <code>R</code> where <code>|L|=|R|=n</code>, <code>|f[L,R]|≥n+1</code>. A function <code>f</code> is constructible iff it is n-constructible for all <code>n≥3</code> up to the length of the alphabet.</p>
<p>If <code>f</code> is constructible, then it is definitely functionally complete. You can just convert your input to base-2, do whatever calculations you want, and then convert back to the full alphabet.</p>
<p>Now is it possible to not be constructible and still be functionally complete? No.</p>
<p>Let's assume that there is some <code>n</code> so that <code>f</code> is not n-constructible. Note that the functions <code>l(x,y)=x</code> and <code>r(x,y)=y</code> are never n-constructible. Assume <code>L</code> and <code>R</code> are non-n-constructible functions. Then <code>g(a,b)=f(L(a,b),R(a,b))</code> is also non-n-constructible. Because the image of <code>L</code> and <code>R</code> has cardinality <code>≤n</code>, so does <code>g</code>. Therefore <code>g</code> is also non-n-constructible</p>
<p>Therefore <code>f</code> has to be constructible to be functionally complete, because again, non-n-constructible gates compose to create non-n-constructible gates and some gates are n-constructible.</p>
<h2>Optimizations</h2>
<h3>Data Format</h3>
<p>A duadic function <code>f</code> is represented as a <code>n*n</code> list, so that <code>f(a, b) = list[a*n+b]</code>.
This is a bit slow, so for <code>n=4</code> I use a 32-bit integer.
Every function has a unique index. The indices start from 0 and have no gaps.
Every monadic function <code>f(a,b)=g(b)</code> has a unique index. It also starts from 0 and has no gaps.</p>
<h3>Transposition</h3>
<p>A transposition <code>fᵀ</code> is defined as <code>fᵀ(a,b)=f(b,a)</code></p>
<h3>Permutation</h3>
<p><code>p</code> is a permutation of the alphabet. <code>p(x)</code> applies the permutation. <code>p⁻¹(x)</code> applies the inverse. <code>p(p⁻¹(x))=p⁻¹(p(x))=x</code>.</p>
<p><code>fₚ</code> is defined as <code>fₚ(a,b)=p⁻¹(f(p(a),p(b)))</code></p>
<h3>Theorem 1</h3>
<p>Claim: <code>f</code> is functionally complete, iff <code>fᵀ</code> also is.</p>
<p>Proof: You can just swap the arguments lol</p>
<h3>Theorem 2</h3>
<p>Claim: <code>f</code> is functionally complete, iff <code>fₚ</code> also is (for all permutations <code>p</code>)</p>
<p>Proof: When you do function composition with <code>fₚ</code>, the outer and inner permutations cancel out. So the &quot;meat&quot; of the function doesn't change, just that the alphabet is relabled.</p>
<h3>Minimal representation</h3>
<p><code>f</code> is said to be minimal if <code>f≤fₚ</code> and <code>f≤fₚᵀ</code> for all permutations <code>p</code> (here <code>≤</code> refers to some total order). By theorem 1 and 2, we only need to consider minimal elements.</p>
<h1>Rust code for n=4</h1>
<h2>main.rs</h2>

<pre class="lang-rust prettyprint-override"><code>#![feature(let_else)]
#![feature(map_first_last)]
#![feature(adt_const_params)]
#![feature(generic_const_exprs)]
#![feature(label_break_value)]
use indicatif::{ProgressBar, ProgressStyle};
use itertools::Itertools;
use rand::Rng;
use rayon::prelude::*;
use std::sync::atomic::AtomicBool;
use std::sync::atomic::AtomicUsize;
use std::sync::atomic::Ordering::*;
use std::thread;

#[cfg(not(debug_assertions))]
macro_rules! get_unsafe {
    [$a:expr, $i:expr] =&gt; {
        *unsafe {$a.get_unchecked($i)}
    };
}

#[cfg(debug_assertions)]
macro_rules! get_unsafe {
    [$a:expr, $i:expr] =&gt; {
        *$a.get($i).unwrap()
    };
}

#[cfg(not(debug_assertions))]
macro_rules! get_mut_unsafe {
    [$a:expr, $i:expr] =&gt; {
        *unsafe {$a.get_unchecked_mut($i)}
    };
}

#[cfg(debug_assertions)]
macro_rules! get_mut_unsafe {
    [$a:expr, $i:expr] =&gt; {
        *$a.get_mut($i).unwrap()
    };
}

trait Function: std::hash::Hash + Clone + std::cmp::Eq + std::fmt::Debug + std::cmp::Ord {
    const N: usize;

    fn impl_eval(&amp;self, a: usize, b: usize) -&gt; usize;

    #[cfg(debug_assertions)]
    fn eval(&amp;self, a: usize, b: usize) -&gt; usize {
        assert!(
            a &lt; Self::N &amp;&amp; b &lt; Self::N,
            &quot;Called eval with a={}, b={} but N={}&quot;,
            a,
            b,
            Self::N
        );
        self.impl_eval(a, b)
    }

    #[cfg(not(debug_assertions))]
    fn eval(&amp;self, a: usize, b: usize) -&gt; usize {
        use std::hint::unreachable_unchecked;
        if a &gt;= Self::N || b &gt;= Self::N {
            // I am speed
            unsafe {
                unreachable_unchecked();
            }
        }
        self.impl_eval(a, b)
    }

    fn pass_left() -&gt; Self;
    fn pass_right() -&gt; Self;

    fn compose(&amp;self, left: &amp;Self, right: &amp;Self) -&gt; Self;

    fn unary_compose(&amp;self, left: usize, right: usize) -&gt; usize {
        self.compose(
            &amp;Self::from_unary_index(left),
            &amp;Self::from_unary_index(right),
        )
        .unary_index()
    }

    // Used by fuzzers
    fn random&lt;R: Rng&gt;(rng: &amp;mut R) -&gt; Self;

    // Returns true if should be discarded
    fn low_effort_discard(&amp;self) -&gt; bool {
        for n in 0..Self::N {
            if self.eval(n, n) == n {
                return true;
            }
        }
        false
    }

    // Unique, no holes, for r-unary ops
    fn unary_index(&amp;self) -&gt; usize {
        let mut ret = 0;
        for a in (0..Self::N).rev() {
            ret *= Self::N;
            ret += self.eval(a, a);
        }
        ret
    }

    fn from_unary_index(i: usize) -&gt; Self;

    fn is_unary_complete(&amp;self) -&gt; bool
    where
        [(); Self::N.pow(Self::N as u32)]:,
    {
        // Bruteforce-checks if self is a unary-complete function
        // Keeps track of all the visited nodes and has a queue of functions to add
        // A function is popped from the queue and composed with every previous function, plus itself
        // The new compositions are added to the queue

        // visited is a &quot;Linked list&quot; containing the already visited unary functions
        // 0 - not visited
        // n - visited, next visited in n steps (n is possibly negative)
        // Hack - this list can store BOTH the queue AND the already visited nodes
        let mut visited = [0isize; Self::N.pow(Self::N as u32)];
        let vl = visited.len() as isize;
        let mut start = vl;
        let mut queue;

        let pri = Self::pass_right().unary_index();
        get_mut_unsafe![visited, pri] = vl - pri as isize;
        queue = pri as isize;

        while queue != vl {
            let ui = queue as usize;
            // Pop from queue
            queue += get_unsafe![visited, ui];
            // Redundant, visited[ui] will get overwritten anyway
            // visited[ui] = 0;

            // Start iterating
            let mut ptr = start;
            while ptr != vl {
                let add = [
                    self.unary_compose(ptr as usize, ui as usize),
                    self.unary_compose(ui as usize, ptr as usize),
                ];
                // Push to queue
                for x in add {
                    if get_unsafe![visited, x] == 0 {
                        get_mut_unsafe![visited, x] = queue - x as isize;
                        queue = x as isize;
                    }
                }
                // Next visited function
                ptr += get_unsafe![visited, ptr as usize];
            }
            // Self-composition
            let x = self.unary_compose(ui as usize, ui as usize);
            // Push
            if get_unsafe![visited, x] == 0 {
                get_mut_unsafe![visited, x] = queue - x as isize;
                queue = x as isize;
            }

            // Add self
            get_mut_unsafe![visited, ui] = start - ui as isize;
            start = ui as isize;
        }
        visited.iter().all(|&amp;x| x != 0)
    }

    fn is_functionally_complete(&amp;self) -&gt; bool
    where
        [(); Self::N.pow(Self::N as u32)]:,
    {
        let n = Self::N;
        let unary = self.is_unary_complete();
        if !unary {
            return false;
        }
        // Loneliness
        let mut pass = false;
        'a: for a in 0..n {
            for b in 0..a {
                for c in 0..n {
                    for d in 0..c {
                        let ac = self.eval(a, c);
                        let bc = self.eval(b, c);
                        let ad = self.eval(a, d);
                        let bd = self.eval(b, d);
                        let mut arr = [ac, bc, ad, bd];
                        arr.sort_unstable();
                        if arr[0] != arr[1] || arr[2] != arr[3] {
                            pass = true;
                            break 'a;
                        }
                    }
                }
            }
        }

        if !pass {
            return false;
        }

        // k+1 - completeness
        self.is_k_complete()
    }

    fn is_k_complete(&amp;self) -&gt; bool {
        let n = Self::N;
        let mut counter = vec![0; n];
        let mut k = 2;
        'b: while k &lt; n {
            let cmb: Vec&lt;_&gt; = (0..n).combinations(k).collect();
            for l in &amp;cmb {
                for r in &amp;cmb {
                    for &amp;a in l {
                        for &amp;b in r {
                            counter[self.eval(a, b)] = 1;
                        }
                    }
                    let s = counter.iter().sum();
                    counter.fill(0);
                    if s &gt; k {
                        k = s;
                        continue 'b;
                    }
                }
            }
            return false;
        }
        true
    }

    fn from_index(i: usize) -&gt; Self;
    fn to_index(&amp;self) -&gt; usize;

    // If this function is minimal in it's equivalence class, returns the number of functions in the equivalence class
    // Else returns zero
    fn cifminelse0(&amp;self) -&gt; usize;

    // Pretty prints this gate
    fn pretty_print(&amp;self) {
        println!(&quot;Gate i={}&quot;, self.to_index());
        let pad = &quot; &quot;;
        let space = &quot; &quot;;
        print!(&quot;{}?&quot;, pad);
        for b in 0..Self::N {
            print!(&quot;{}{}&quot;,space,b);
        }
        println!();
        for a in 0..Self::N {
            print!(&quot;{}{}&quot;, pad, a);
            for b in 0..Self::N {
                print!(&quot;{}{}&quot;,space,self.eval(a,b));
            }
            println!();
        }
    }
}

// Four bit functions
impl Function for u32 {
    const N: usize = 4;
    fn impl_eval(&amp;self, a: usize, b: usize) -&gt; usize {
        *self as usize &gt;&gt; (a * 4 + b) * 2 &amp; 3
    }

    fn pass_left() -&gt; u32 {
        0xFFAA5500
    }

    fn pass_right() -&gt; u32 {
        0xE4E4E4E4
    }

    fn compose(&amp;self, l: &amp;Self, r: &amp;Self) -&gt; Self {
        let mut ret = 0;
        for a in (0..4).rev() {
            for b in (0..4).rev() {
                ret &lt;&lt;= 2;
                ret |= self.eval(l.eval(a, b), r.eval(a, b));
            }
        }
        ret as u32
    }

    fn random&lt;R: Rng&gt;(rng: &amp;mut R) -&gt; Self {
        rng.gen()
    }

    fn to_index(&amp;self) -&gt; usize {
        *self as usize
    }

    fn from_index(i: usize) -&gt; Self {
        i as u32
    }

    fn unary_index(&amp;self) -&gt; usize {
        *self as usize &amp; 255
    }

    fn from_unary_index(i: usize) -&gt; Self {
        let r = i | (i &lt;&lt; 8);
        let r = r | (r &lt;&lt; 16);
        r as u32
    }

    fn cifminelse0(&amp;self) -&gt; usize {
        const PERM4: [[usize; 4]; 24] = [
            [0, 1, 2, 3],
            [0, 1, 3, 2],
            [0, 2, 1, 3],
            [0, 2, 3, 1],
            [0, 3, 1, 2],
            [0, 3, 2, 1],
            [1, 0, 2, 3],
            [1, 0, 3, 2],
            [1, 2, 0, 3],
            [1, 2, 3, 0],
            [1, 3, 0, 2],
            [1, 3, 2, 0],
            [2, 0, 1, 3],
            [2, 0, 3, 1],
            [2, 1, 0, 3],
            [2, 1, 3, 0],
            [2, 3, 0, 1],
            [2, 3, 1, 0],
            [3, 0, 1, 2],
            [3, 0, 2, 1],
            [3, 1, 0, 2],
            [3, 1, 2, 0],
            [3, 2, 0, 1],
            [3, 2, 1, 0],
        ];

        fn flipped(f: u32) -&gt; u32 {
            f &amp; 0xc0_30_0c_03
                | f &lt;&lt; 6 &amp; 0x30_0c_03_00
                | f &lt;&lt; 12 &amp; 0x0c_03_00_00
                | f &lt;&lt; 18 &amp; 0x03_00_00_00
                | f &gt;&gt; 6 &amp; 0x00_c0_30_0c
                | f &gt;&gt; 12 &amp; 0x00_00_c0_30
                | f &gt;&gt; 18 &amp; 0x00_00_00_c0
        }

        fn permuted(f: u32, p: &amp;[usize; 4]) -&gt; u32 {
            let mut invp = [0, 0, 0, 0];
            for i in 0..4 {
                invp[p[i]] = i as u32;
            }
            let mut r = 0;
            for a in (0..4).rev() {
                for b in (0..4).rev() {
                    r &lt;&lt;= 2;
                    r |= invp[f.eval(p[a], p[b])];
                }
            }
            r
        }

        let mut m = vec![*self; 48];
        m[1] = flipped(*self);
        if m[1] &lt; *self {
            return 0;
        }
        for (i, p) in PERM4.iter().enumerate().skip(1) {
            m[i * 2] = permuted(*self, p);
            m[i * 2 + 1] = flipped(m[i * 2]);
            if m[i * 2] &lt; *self || m[i * 2 + 1] &lt; *self {
                return 0;
            }
        }
        m.sort_unstable();
        m.dedup();
        m.len()
    }
}

impl&lt;const N: usize&gt; Function for [[usize; N]; N] {
    const N: usize = N;
    fn impl_eval(&amp;self, a: usize, b: usize) -&gt; usize {
        self[a][b]
    }

    fn pass_left() -&gt; Self {
        let mut r = [[0; N]; N];
        for a in 0..N {
            r[a] = [a; N];
        }
        r
    }

    fn pass_right() -&gt; Self {
        let mut d = [0; N];
        for b in 0..N {
            d[b] = b;
        }
        [d; N]
    }

    fn compose(&amp;self, l: &amp;Self, r: &amp;Self) -&gt; Self {
        let mut ret = [[0; N]; N];
        for a in 0..N {
            for b in 0..N {
                ret[a][b] = self.eval(l.eval(a, b), r.eval(a, b));
            }
        }
        ret
    }

    fn random&lt;R: Rng&gt;(rng: &amp;mut R) -&gt; Self {
        let mut r = [[0; N]; N];
        for a in 0..N {
            for b in 0..N {
                r[a][b] = rng.gen_range(0..N);
            }
        }
        r
    }

    fn from_index(mut i: usize) -&gt; Self {
        let mut r = [[0; N]; N];
        for a in 0..N {
            for b in 0..N {
                r[a][b] = i % N;
                i /= N;
            }
        }
        r
    }

    fn to_index(&amp;self) -&gt; usize {
        let mut r = 0;
        for a in (0..N).rev() {
            for b in (0..N).rev() {
                r *= N;
                r += self[a][b];
            }
        }
        r
    }

    fn from_unary_index(mut i: usize) -&gt; Self {
        let mut x = [0; N];
        for n in 0..N {
            x[n] = i % N;
            i /= N;
        }
        [x; N]
    }

    fn cifminelse0(&amp;self) -&gt; usize {
        let flip = |i: &amp;Self| i.compose(&amp;Self::pass_right(), &amp;Self::pass_left());
        let permute_self = |p: &amp;[usize]| {
            let mut inv = [0; N];
            for i in 0..N {
                inv[p[i]] = i;
            }
            let mut ret = [[0; N]; N];
            for a in 0..N {
                for b in 0..N {
                    ret[a][b] = inv[self.eval(p[a], p[b])];
                }
            }
            ret
        };

        let mut m = vec![*self; (1..=N).product::&lt;usize&gt;() * 2];
        m[1] = flip(self);
        if m[1] &lt; *self {
            return 0;
        }
        for (i, p) in (0..N).permutations(N).enumerate().skip(1) {
            m[i * 2] = permute_self(&amp;p);
            m[i * 2 + 1] = flip(&amp;m[i * 2]);
            if m[i * 2] &lt; *self || m[i * 2 + 1] &lt; *self {
                return 0;
            }
        }
        m.sort_unstable();
        m.dedup();
        m.len()
    }
}

#[test]
fn test_pass() {
    fn test_pass_g&lt;F: Function + std::fmt::Debug&gt;() {
        let l = F::pass_left();
        let r = F::pass_right();
        for a in 0..F::N {
            for b in 0..F::N {
                assert_eq!(l.eval(a, b), a, &quot;a is {}, b is {}, l is {:?}&quot;, a, b, l);
                assert_eq!(r.eval(a, b), b, &quot;a is {}, b is {}, r is {:?}&quot;, a, b, r);
            }
        }
    }
    test_pass_g::&lt;u32&gt;();
    test_pass_g::&lt;[[usize; 3]; 3]&gt;();
    test_pass_g::&lt;[[usize; 4]; 4]&gt;();
}

#[test]
fn test_compose() {
    use rand::rngs::SmallRng;
    use rand::SeedableRng;
    fn test_compose_g&lt;F: Function + std::fmt::Debug&gt;() {
        let mut rng = SmallRng::seed_from_u64(42);
        let repeats = 1_000_000;
        for _ in 0..repeats {
            let f = F::random(&amp;mut rng);
            let l = F::random(&amp;mut rng);
            let r = F::random(&amp;mut rng);
            let c = f.compose(&amp;l, &amp;r);
            let a = rng.gen_range(0..F::N);
            let b = rng.gen_range(0..F::N);
            assert_eq!(
                c.eval(a, b),
                f.eval(l.eval(a, b), r.eval(a, b)),
                &quot;a:{} b:{} f:{:?} l:{:?} r:{:?} c:{:?}&quot;,
                a,
                b,
                f,
                l,
                r,
                c
            );
        }
    }
    test_compose_g::&lt;u32&gt;();
    test_compose_g::&lt;[[usize; 3]; 3]&gt;();
    test_compose_g::&lt;[[usize; 4]; 4]&gt;();
}

#[test]
fn test_low_effort_discard() {
    use rand::rngs::SmallRng;
    use rand::SeedableRng;
    fn test_low_effort_discard_g&lt;F: Function + std::fmt::Debug&gt;()
    where
        [(); F::N.pow(F::N as u32)]:,
    {
        let mut rng = SmallRng::seed_from_u64(42);
        let repeats = 1_000;
        for _ in 0..repeats {
            let f = F::random(&amp;mut rng);
            assert!(
                !f.low_effort_discard() || !f.is_functionally_complete(),
                &quot;Discarded f:{:?}&quot;,
                f
            );
        }
    }
    test_low_effort_discard_g::&lt;u32&gt;();
    test_low_effort_discard_g::&lt;[[usize; 3]; 3]&gt;();
    test_low_effort_discard_g::&lt;[[usize; 4]; 4]&gt;();
}

#[test]
fn test_specifics() {
    // Using the examples from the blog post + = 0, 0 = 1, 1 = 2
    let triplets = [
        ([[0; 3]; 3], false),
        ([[1; 3]; 3], false),
        ([[2; 3]; 3], false),
        ([[0, 1, 2]; 3], false),
        ([[0; 3], [1; 3], [2; 3]], false),
        ([[0, 1, 2], [1, 1, 2], [2, 2, 2]], false), // Min
        ([[0, 1, 2], [0, 1, 1], [0, 0, 0]], false), // Imp
        ([[0; 3], [1; 3], [0; 3]], false),          // Imp composition
        ([[2, 0, 0], [0, 0, 0], [0, 0, 1]], true),  // Tand
        ([[2, 1, 1], [1, 0, 1], [1, 1, 1]], true),  // Modified Tand
        ([[2, 2, 2], [2, 0, 2], [2, 2, 1]], true),  // Modified Tand
        ([[1, 0, 0], [0, 2, 0], [0, 0, 0]], true),  // Modified Tand
        ([[1, 1, 1], [1, 2, 1], [1, 1, 0]], true),  // Modified Tand
        ([[1, 2, 2], [2, 2, 2], [2, 2, 0]], true),  // Modified Tand
        ([[2, 0, 1], [0, 0, 0], [1, 0, 1]], true),  // Pointy Tand
        // Experimentally found
        ([[0, 2, 0], [0, 0, 0], [0, 0, 0]], false),
        ([[1, 2, 0], [0, 0, 0], [0, 0, 0]], true),
        // From the post
        ([[2, 0, 1], [0, 0, 0], [2, 2, 0]], true),
        ([[2, 0, 1], [1, 0, 0], [2, 2, 0]], true),
        ([[2, 0, 1], [2, 0, 0], [2, 2, 0]], true),
        ([[1, 0, 0], [1, 0, 2], [2, 2, 1]], false),
    ];
    for (f, r) in triplets {
        println!(&quot;{:?} -&gt; {}&quot;, f, r);
        assert_eq!(f.is_functionally_complete(), r);
    }
}

fn smart_method&lt;F: Function&gt;()
where
    [(); F::N.pow(F::N as u32)]:,
{
    let amount = F::N.pow(F::N as u32 * F::N as u32);
    (0..amount).into_par_iter().for_each(|i| {
        let n = F::from_index(i);
        let m = n.cifminelse0();
        if m == 0 {
            return;
        }
        let r = n.low_effort_discard() || !n.is_functionally_complete();
        if !r {
            TC.fetch_add(m, Relaxed);
        } else {
            FC.fetch_add(m, Relaxed);
        }
    });
    CONT.store(false, Release);
}

static TC: AtomicUsize = AtomicUsize::new(0);
static FC: AtomicUsize = AtomicUsize::new(0);
static CONT: AtomicBool = AtomicBool::new(true);

// Change this to [[usize;3];3] for n=3
type T = u32;

fn main() {
    // Fluff
    let start = std::time::Instant::now();
    let amount = T::N.pow(T::N as u32 * T::N as u32);
    let pb = ProgressBar::new(amount as u64);
    pb.set_style(
        ProgressStyle::default_bar().template(
            &quot;{wide_bar:.green/red}\n{pos}/{len} - {percent}% - {per_sec} - {eta} - {msg}&quot;,
        ),
    );
    let t = thread::spawn(move || {
        while CONT.load(Acquire) {
            thread::sleep(std::time::Duration::from_millis(100));
            let t = TC.load(Relaxed);
            let f = FC.load(Relaxed);
            pb.set_position(t as u64 + f as u64);
            pb.set_message(format!(
                &quot;Ratio at {}/{} = {:.5}&quot;,
                t,
                t + f,
                t as f64 / (t as f64 + f as f64)
            ));
            pb.tick();
        }
    });
    // Call
    smart_method::&lt;T&gt;();
    // Fluff
    match t.join() {
        Err(_e) =&gt; {
            println!(&quot;Failed to join ui-thread :/&quot;);
        }
        _ =&gt; {}
    };
    let t = TC.load(Relaxed);
    let f = FC.load(Relaxed);
    println!(
        &quot;Ended with {} universal gates and {} non-universal gates. Ratio is {}/{} = {:.5}&quot;,
        t,
        f,
        t,
        t + f,
        t as f64 / (t as f64 + f as f64)
    );
    println!(&quot;Took {:?}&quot;, start.elapsed());
    // Remember to reset TC, FC and CONT if you want to call again
}
</code></pre>
<h2>cargo.toml</h2>

<pre class="lang-toml prettyprint-override"><code>[dependencies]
itertools = &quot;0.10&quot;
rand = {version=&quot;0.8&quot;, features=[&quot;small_rng&quot;]}
rayon = &quot;1.5&quot;
indicatif = {version = &quot;0.16&quot;, features = [&quot;rayon&quot;]}
</code></pre>
<p>Takes around 20 minutes on my machine™. The actual code is not that interesting, maybe with the exception of the unary completeness check, which uses a buffer with two non-overlapping linked lists, to form a very efficient deduplicated queue + set data structure.</p>
<h1>n=5?</h1>
<p>For <code>n=5</code> you basically need a new idea (or a lot of computing power). Checking each gate individually becomes impractical (if you could do it in one cycle, it would still take two years). If someone manages to calculate <code>n=5</code>, I'm happy to forward Bubblers +500 bounty to them.</p>
</div>

<table id="st">
<!-- Popups content will be added here -->
</table>

<table id="at">
<!-- Popups content will be added here -->
</table>

</div>





  <div class="footer">
      <b><a class="nonewtab" href="../">GOLFSCORE/</a><a href="https://codegolf.stackexchange.com/questions/240339/">240339</a></b>
  </div>
<div class="footer-space">&nbsp;</div>



<script src="../c.js"> </script>
</body>
</html>




