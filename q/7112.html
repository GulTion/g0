<!DOCTYPE html>
<html>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6EBTM9J4LK"></script>
<script src="../g.js"></script>
    <title>cg::QNNN</title>
    <link rel="stylesheet" href="../c.css">
</head>
<body>
    <br><br>
    <div id = "content">
    <div id="container">
    <div id="mf">
        <a href="#" class="nonewtab" d-g="g">g</a> | 
        <a href="#" class="nonewtab" d-g="x">x</a> | 
        <a href="#" class="nonewtab" d-g="w">w</a> | 
        <a href="#" class="nonewtab" d-g="">all</a>
    </div>
    <input type="text" id="mi" placeholder="/">
    </div>

<table id="mt">
  <tr class="header">
    <th class="tbytes">Bytes</th>
    <th class="tlang">Lang</th>
    <th class="ttime">Time</th>
    <th class="tlink">Link</th>
  </tr>
  <!-- TXXX -->
<tr d-ix="0"><td>034</td><td>jq</td><td>230718T111158Z</td><td><a href="https://codegolf.stackexchange.com/questions/7112/calculate-pi-to-5-decimals/262968#262968">manatwor</a></td></tr>
<tr d-ix="1"><td>020</td><td>CJam</td><td>201027T100904Z</td><td><a href="https://codegolf.stackexchange.com/questions/7112/calculate-pi-to-5-decimals/214215#214215">JosiahRy</a></td></tr>
<tr d-ix="2"><td>030</td><td>Desmos</td><td>201027T021256Z</td><td><a href="https://codegolf.stackexchange.com/questions/7112/calculate-pi-to-5-decimals/214205#214205">Ethan Ch</a></td></tr>
<tr d-ix="3"><td>nan</td><td>VBA  80</td><td>201014T032057Z</td><td><a href="https://codegolf.stackexchange.com/questions/7112/calculate-pi-to-5-decimals/213492#213492">Ben</a></td></tr>
<tr d-ix="4"><td>016</td><td>Husk</td><td>201020T214341Z</td><td><a href="https://codegolf.stackexchange.com/questions/7112/calculate-pi-to-5-decimals/213907#213907">Dominic </a></td></tr>
<tr d-ix="5"><td>025</td><td>GolfScript</td><td>201014T161811Z</td><td><a href="https://codegolf.stackexchange.com/questions/7112/calculate-pi-to-5-decimals/213525#213525">2014MELO</a></td></tr>
<tr d-ix="6"><td>059</td><td>Python</td><td>120901T184353Z</td><td><a href="https://codegolf.stackexchange.com/questions/7112/calculate-pi-to-5-decimals/7138#7138">primo</a></td></tr>
<tr d-ix="7"><td>129</td><td>Befunge</td><td>171105T161307Z</td><td><a href="https://codegolf.stackexchange.com/questions/7112/calculate-pi-to-5-decimals/147149#147149">James Ho</a></td></tr>
<tr d-ix="8"><td>032</td><td>Mathematica</td><td>120829T173511Z</td><td><a href="https://codegolf.stackexchange.com/questions/7112/calculate-pi-to-5-decimals/7113#7113">DavidC</a></td></tr>
<tr d-ix="9"><td>045</td><td>JavaScript</td><td>120830T142808Z</td><td><a href="https://codegolf.stackexchange.com/questions/7112/calculate-pi-to-5-decimals/7119#7119">FireFly</a></td></tr>
<tr d-ix="10"><td>253</td><td>SQL</td><td>170918T235253Z</td><td><a href="https://codegolf.stackexchange.com/questions/7112/calculate-pi-to-5-decimals/143154#143154">phroureo</a></td></tr>
<tr d-ix="11"><td>082</td><td>Ruby</td><td>170918T183648Z</td><td><a href="https://codegolf.stackexchange.com/questions/7112/calculate-pi-to-5-decimals/143101#143101">Simply B</a></td></tr>
<tr d-ix="12"><td>030</td><td>Julia</td><td>140430T012138Z</td><td><a href="https://codegolf.stackexchange.com/questions/7112/calculate-pi-to-5-decimals/26429#26429">Milktrad</a></td></tr>
<tr d-ix="13"><td>039</td><td>Perl</td><td>120829T221555Z</td><td><a href="https://codegolf.stackexchange.com/questions/7112/calculate-pi-to-5-decimals/7117#7117">ardnew</a></td></tr>
<tr d-ix="14"><td>055</td><td>PHP</td><td>120831T143404Z</td><td><a href="https://codegolf.stackexchange.com/questions/7112/calculate-pi-to-5-decimals/7130#7130">TwoScoop</a></td></tr>
<tr d-ix="15"><td>032</td><td>Haskell</td><td>120831T204213Z</td><td><a href="https://codegolf.stackexchange.com/questions/7112/calculate-pi-to-5-decimals/7132#7132">ceased t</a></td></tr>
<tr d-ix="16"><td>067</td><td>Java</td><td>120829T174357Z</td><td><a href="https://codegolf.stackexchange.com/questions/7112/calculate-pi-to-5-decimals/7114#7114">Peter Ta</a></td></tr>
<tr d-ix="17"><td>026</td><td>J</td><td>120830T183934Z</td><td><a href="https://codegolf.stackexchange.com/questions/7112/calculate-pi-to-5-decimals/7121#7121">fftw</a></td></tr>
<tr d-ix="18"><td>044</td><td>C GCC</td><td>120830T190235Z</td><td><a href="https://codegolf.stackexchange.com/questions/7112/calculate-pi-to-5-decimals/7122#7122">Peter Ta</a></td></tr>
<tr d-ix="19"><td>014</td><td>APL</td><td>120906T162833Z</td><td><a href="https://codegolf.stackexchange.com/questions/7112/calculate-pi-to-5-decimals/7188#7188">marinus</a></td></tr>
<tr d-ix="20"><td>021</td><td>CJam</td><td>140429T211856Z</td><td><a href="https://codegolf.stackexchange.com/questions/7112/calculate-pi-to-5-decimals/26421#26421">aditsu q</a></td></tr>
<tr d-ix="21"><td>033</td><td>Javascript  33 Characters</td><td>140227T110110Z</td><td><a href="https://codegolf.stackexchange.com/questions/7112/calculate-pi-to-5-decimals/22304#22304">MT0</a></td></tr>
<tr d-ix="22"><td>049</td><td>Python</td><td>121212T004237Z</td><td><a href="https://codegolf.stackexchange.com/questions/7112/calculate-pi-to-5-decimals/9187#9187">arshajii</a></td></tr>
<tr d-ix="23"><td>025</td><td>k</td><td>120905T193724Z</td><td><a href="https://codegolf.stackexchange.com/questions/7112/calculate-pi-to-5-decimals/7159#7159">skeevey</a></td></tr>
<tr d-ix="24"><td>025</td><td>R</td><td>120911T003754Z</td><td><a href="https://codegolf.stackexchange.com/questions/7112/calculate-pi-to-5-decimals/7267#7267">flodel</a></td></tr>
<tr d-ix="25"><td>076</td><td>Perl</td><td>120906T160823Z</td><td><a href="https://codegolf.stackexchange.com/questions/7112/calculate-pi-to-5-decimals/7186#7186">memowe</a></td></tr>
<tr d-ix="26"><td>054</td><td>Ruby</td><td>120831T122441Z</td><td><a href="https://codegolf.stackexchange.com/questions/7112/calculate-pi-to-5-decimals/7129#7129">Perello</a></td></tr>
<tr d-ix="27"><td>056</td><td>Python</td><td>120831T210914Z</td><td><a href="https://codegolf.stackexchange.com/questions/7112/calculate-pi-to-5-decimals/7133#7133">chucksma</a></td></tr>
<tr d-ix="28"><td>084</td><td>Java</td><td>120831T095651Z</td><td><a href="https://codegolf.stackexchange.com/questions/7112/calculate-pi-to-5-decimals/7127#7127">Averroes</a></td></tr>
<tr d-ix="29"><td>079</td><td>Clojure</td><td>120831T002139Z</td><td><a href="https://codegolf.stackexchange.com/questions/7112/calculate-pi-to-5-decimals/7124#7124">arrdem</a></td></tr>
<tr d-ix="30"><td>069</td><td>C</td><td>120830T124835Z</td><td><a href="https://codegolf.stackexchange.com/questions/7112/calculate-pi-to-5-decimals/7118#7118">ugoren</a></td></tr>
</table>
<div id="pu0" class="pu"><h1><a href="https://stedolan.github.io/jq/" rel="nofollow noreferrer">jq</a>, 34 characters</h1>
<pre><code>[range(1;1e6;4)|1/.-1/(.+2)]|add*4
</code></pre>
<p>Sample run:</p>
<pre><code>bash-5.2$ jq -n '[range(1;1e6;4)|1/.-1/(.+2)]|add*4'
3.1415906535898936
</code></pre>
<p><a href="https://tio.run/##yyr8/z@6KDEvPVXD0Now1czaRLPGUF9P11BfQ0/bSDO2JjElRcvk//9/@QUlmfl5xf91dfNKc3J0M/MKSksA" rel="nofollow noreferrer" title="jq – Try It Online">Try it online!</a></p>
</div>
<div id="pu1" class="pu"><h1><a href="https://sourceforge.net/p/cjam" rel="nofollow noreferrer">CJam</a>, 20 bytes</h1>
<pre><code>V4e5{4T2*)d/WT#*+}fT
</code></pre>
<p><a href="https://tio.run/##S85KzP3/P8wk1bTaJMRISzNFPzxEWUu7Ni3k/38A" rel="nofollow noreferrer" title="CJam – Try It Online">Try it online!</a></p>
<p>One byte shorter than aditsu's answer. ;)</p>
<h2>Alternate 20-byter</h2>
<pre><code>4_e5,f{_2*)W@#*d/}:+
</code></pre>
<p><a href="https://tio.run/##S85KzP3/3yQ@1VQnrTreSEsz3EFZK0W/1kr7/38A" rel="nofollow noreferrer" title="CJam – Try It Online">Try it online!</a></p>
<p>Does the same thing, but I like this better for some reason.</p>
</div>
<div id="pu2" class="pu"><h1><a href="https://www.desmos.com/calculator" rel="nofollow noreferrer">Desmos</a>, 30 bytes</h1>
<pre><code>4\sum_{n=0}^{9^6}(-1)^n/(1+2n)
</code></pre>
<p><a href="https://www.desmos.com/calculator/nivxhndq6p" rel="nofollow noreferrer">Try it on Desmos</a></p>
<p>Pretty self-explanatory coding of the sequence. An array-based method, while it sounds like it should be more efficient, runs into Desmos' limitations on array length.</p>
</div>
<div id="pu3" class="pu"><h1>VBA - 80 <strike>105</strike> characters</h1>
<p>From the VBE immediate window:</p>
<pre><code>s=-1:x=1:i=3:While Left(4*x,7)&lt;&gt;3.14159:x=x+((1/i)*s):s=-s:i=i+2:Wend:Debug.?4*x    
</code></pre>
<p>Using <code>Left()</code> instead of <code>Round()</code> saves a character but also makes it more accurate to the definition of the challenge.
I'm getting my character count from Notepad++.  I do see that other systems may count differently.</p>
<p>The algorithm below is easier to read:</p>
<pre><code>Sub p
    s=-1:x=1:i=3
    While Left(4*x,7)&lt;&gt;3.14159
        x=x+((1/i)*s)
        s=-s
        i=i+2
    Wend
    Debug.?4*x
    Debug.?&quot;Pi to 5 places solved in &quot;;(i-1)/2;&quot; steps.&quot;
End Sub  
</code></pre>
<p><em>If you want to test this code and have Microsoft Excel, Word, Access, or Outlook installed (Windows only), press Alt+F11 to open the VBA IDE. Insert a new code module (Alt+I,M) and clear out <code>Option Explicit</code> if shown at the top. Then paste in the code and press F5 to run it. The results should appear in the Immediate Window (press Ctrl+G if you don't see it).</em></p>
</div>
<div id="pu4" class="pu"><h1><a href="https://github.com/barbuz/Husk" rel="nofollow noreferrer">Husk</a>, 16 bytes</h1>
<pre><code>*_4ṁ\↑^9 9z*İ_İ1
</code></pre>
<p><a href="https://tio.run/##yygtzv5/eLuhlqEBCDxqavyvFW/ycGdjzKO2iXEmCpZVWkc2xB/ZYPj/PwA" rel="nofollow noreferrer" title="Husk – Try It Online">Try it online!</a> using series of only 6561 (9^4) terms (times-out on TIO for longer series).</p>
<p>Output is a rational number expressed as a fraction: TIO header multiplies by 100,000 and rounds to nearest integer.</p>
<pre><code>*_4ṁ\↑^9 9z*İ_İ1
*_4                 # multiply by -4:
   ṁ                # sum of series of
    \               # reciprocals of
     ↑^9 9          # first 387420489 (9^9) terms of
          z*        # pairwise products of
            İ_      # powers of -1 (-1,1,-1,1,...) and
              İ1    # odd numbers (1,3,5,7,9,...)
</code></pre>
</div>
<div id="pu5" class="pu"><h1><a href="http://www.golfscript.com/golfscript/" rel="nofollow noreferrer">GolfScript</a>, 25 bytes</h1>
<pre><code>7.?,{2*)2.-1??./\/\-}*)4*
</code></pre>
<p><a href="https://tio.run/##S8/PSStOLsosKPn/31zPXqfaSEvTSE/X0N5eTz9GP0a3VkvTROv/fwA" rel="nofollow noreferrer" title="GolfScript – Try It Online">Try it online!</a></p>
<pre><code>7.?                         # Push 7^7=823543, we just need an odd number bigger than 136120
   ,{               }*      # For every number k from 1 to 823542
     2*)                    # 2*k+1
        2.-1??./            # sqrt(2)/sqrt(2)=1.0 this number is just 1, but it is a float
                \/          # 1.0 / (2*k+1)
                  \-        # Subtract the sequence from this number
                      )     # Add 1 because 1/1 was skipped
                       4*   # Multiply by 4
</code></pre>
<p>Output:</p>
<pre><code>3.141593867855424
</code></pre>
</div>
<div id="pu6" class="pu"><h2>Python 59 bytes</h2>

<pre class="lang-py prettyprint-override"><code>print reduce(lambda x,p:p/2*x/p+2*10**999,range(6637,1,-2))
</code></pre>

<p>This prints out 1000 digits; slightly more than the required 5. Instead of using the prescribed iteration, it uses this:</p>

<pre><code>pi = 2 + 1/3*(2 + 2/5*(2 + 3/7*(2 + 4/9*(2 + 5/11*(2 + ...)))))
</code></pre>

<p>The <code>6637</code> (the innermost denominator) can be formulated as:</p>

<pre>digits * 2*log<sub>2</sub>(10)</pre>

<p>This implies a linear convergence. Each deeper iteration will produce one more binary bit of <em>pi</em>.</p>

<p><em><strong>If</strong></em>, however, you insist on using the <em>tan<sup>-1</sup></em> identity, a similar convergence can be achieved, if you don't mind going about the problem slightly differently. Taking a look at the partial sums:</p>

<p><em>4.0, 2.66667, 3.46667, 2.89524, 3.33968, 2.97605, 3.28374, ...</em></p>

<p>it is apparent that each term jumps back and forth to either side of the convergence point; the series has alternating convergence. Additionally, each term is closer to the convergence point than the previous term was; it is absolutely monotonic with respect to its convergence point. The combination of these two properties implies that the arithmetic mean of any two neighboring terms is closer to the convergence point than either of the terms themselves. To give you a better idea of what I mean, consider the following image:</p>

<p><img src="https://i.stack.imgur.com/YeJmY.gif" alt="Partial Sums"></p>

<p>The outer series is the original, and the inner series is found by taking the average of each of the neighboring terms. A remarkable difference. But what's truly remarkable, is that this new series also has alternating convergence, and is absolutely monotonic with respect to its convergence point. That means that this process can be applied over and over again, ad nauseum.</p>

<p>Ok. But how?</p>

<p>Some formal definitions. Let <em>P<sub>1</sub>(n)</em> be the <em>n<sup>th</sup></em> term of the first sequence, <em>P<sub>2</sub>(n)</em> be the <em>n<sup>th</sup></em> term of the second sequence, and similarly <em>P<sub>k</sub>(n)</em> the <em>n<sup>th</sup></em> term of the <em>k<sup>th</sup></em> sequence as defined above.</p>

<p><em>P<sub>1</sub> = [P<sub>1</sub>(1), P<sub>1</sub>(2), P<sub>1</sub>(3), P<sub>1</sub>(4), P<sub>1</sub>(5), ...]</em></p>

<p><em>P<sub>2</sub> = [(P<sub>1</sub>(1) +P<sub>1</sub>(2))/2, (P<sub>1</sub>(2) +P<sub>1</sub>(3))/2, (P<sub>1</sub>(3) +P<sub>1</sub>(4))/2, (P<sub>1</sub>(4) +P<sub>1</sub>(5))/2, ...]</em></p>

<p><em>P<sub>3</sub> = [(P<sub>1</sub>(1) +2P<sub>1</sub>(2) +P<sub>1</sub>(3))/4, (P<sub>1</sub>(2) +2P<sub>1</sub>(3) +P<sub>1</sub>(4))/4, (P<sub>1</sub>(3) +2P<sub>1</sub>(4) +P<sub>1</sub>(5))/4, ...]</em></p>

<p><em>P<sub>4</sub> = [(P<sub>1</sub>(1) +3P<sub>1</sub>(2) +3P<sub>1</sub>(3) +P<sub>1</sub>(4))/8, (P<sub>1</sub>(2) +3P<sub>1</sub>(3) +3P<sub>1</sub>(4) +P<sub>1</sub>(5))/8, ...]</em></p>

<p>Not surprisingly, these coefficients follow exactly the binomial coefficients, and can expressed as a single row of Pascal's Triangle. Since an arbitrary row of Pascal's Triangle is trivial to calculate, an arbitrarily 'deep' series can be found, simply by taking the first <em>n</em> partial sums, multiply each by the corresponding term in the <em>k<sup>th</sup></em> row of Pascal's Triangle, and dividing by <em>2<sup>k-1</sup></em>.</p>

<p>In this way, full 32-bit floating point precision (~14 decimal places) can be achieved with just 36 iterations, at which point the partial sums haven't even converged on the second decimal place. This is obviously not golfed:</p>

<pre class="lang-py prettyprint-override"><code># used for pascal's triangle
t = 36; v = 1.0/(1&lt;&lt;t-1); e = 1
# used for the partial sums of pi
p = 4; d = 3; s = -4.0

x = 0
while t:
  t -= 1
  p += s/d; d += 2; s *= -1
  x += p*v
  v = v*t/e; e += 1

print "%.14f"%x
</code></pre>

<p>If you wanted arbitrary precision, this can be achieved with a little modification. Here once again calculating 1000 digits:</p>

<pre class="lang-py prettyprint-override"><code># used for pascal's triangle
f = t = 3318; v = 1; e = 1
# used for the partial sums of pi
p = 4096*10**999; d = 3; s = -p

x = 0
while t:
  t -= 1
  p += s/d; d += 2; s *= -1
  x += p*v
  v = v*t/e; e += 1

print x&gt;&gt;f+9
</code></pre>

<p>The initial value of <em>p</em> begins <em>2<sup>10</sup></em> larger, to counteract the integer division effects of <em>s/d</em> as <em>d</em> becomes larger, causing the last few digits to not converge. Notice here again that <code>3318</code> is also:</p>

<pre>digits * log<sub>2</sub>(10)</pre>

<p>The same number of iteratations as the first algorithm (halved because <em>t</em> decreases by <em>1</em> instead of <em>2</em> each iteration). Once again, this indicates a linear convergence: one binary bit of <em>pi</em> per iteration. In both cases, 3318 iterations are required to calculate 1000 digits of <em>pi</em>, as slightly better quota than 1 million iterations to calculate 5.</p>
</div>
<div id="pu7" class="pu"><h1>Befunge, 129 bytes</h1>
<pre><code>p08p109p^v*86%+55:&lt;$$$&lt;
\$\&gt;:#,_@&gt;+\55+/:#^_&quot;.&quot;
v&gt;p&quot;~&quot;/:&quot;~&quot;%08p&quot;~&quot;/00p:2\4%-*&quot;(}&quot;
8^90%&quot;~&quot;:+2:+g90*+g80*&lt;
&gt;*:**\/+&gt;&quot;~~&quot;00g:&quot;~&quot;`!|
</code></pre>
<p><a href="http://befunge.tryitonline.net/#code=cDA4cDEwOXBedio4NiUrNTU6PCQkJDwKXCRcPjojLF9APitcNTUrLzojXl8iLiIKdj5wIn4iLzoifiIlMDhwIn4iLzAwcDoyXDQlLSoiKH0iCjheOTAlIn4iOisyOitnOTAqK2c4MCo8Cj4qOioqXC8rPiJ+fiIwMGc6In4iYCF8&amp;input=" rel="nofollow noreferrer">Try it online!</a></p>
<p>In case anyone is wondering, it's an elephant.</p>
<p><img src="https://i.stack.imgur.com/bw4mu.png" alt="Cartoon elephant" /></p>
</div>
<div id="pu8" class="pu"><h1>Mathematica <strike>42 39 34 33 31 26</strike> 32</h1>
<p><strong>Archimedes' Approach</strong> 26 chars</p>
<pre><code>N@#*Sin[180 Degree/#]&amp;
</code></pre>
<p>This reaches the criterion when input is 822.</p>
<p>Question: Does anyone know how he computed the Sin of 180 degrees? I don't.</p>
<hr />
<p><strong>Leibniz' Approach</strong> (Gregory's series) 32 chars</p>
<p>This is the same function the problem poser gave as an example.
It reaches the criterion in approximately one half million iterations.</p>
<pre><code>N@4Sum[(-1)^k/(2k+1),{k,0,10^6}]
</code></pre>
<hr />
<p><strong>Madhava-Leibniz Approach</strong> 37 chars</p>
<p>This variation uses a few more characters but converges to criterion in only 9 iterations!</p>
<pre><code>N@Sqrt@12 Sum[(-1/3)^k/(2k+1),{k,0,9}]
</code></pre>
</div>
<div id="pu9" class="pu"><h2>JavaScript, <s>46 58 56</s> 45 bytes</h2>



<p><em>ES6 update</em>: Turns out there's more features available to us now that five years have passed.</p>

<pre class="lang-javascript prettyprint-override"><code>let f=(i=0,a=0)=&gt;i&gt;1e6?a:f(i+4,a+8/-~i/(i+3))
</code></pre>

<p>This version (<strong>45</strong> bytes; yes, the <code>let</code> is required) works in ES6 strict mode <em>in theory</em>.  In practice, you can run it in V8 (e.g. with node) with <code>--use-strict --harmony-tailcalls</code>; the Proper Tailcalls feature isn't widely implemented yet, alas.  However, it's specified behaviour, so it should be fine.</p>

<p>If we want to stick to what's widely implemented, and not require strict-mode, we can simply use the ES6 fat-arrow syntax for functions but otherwise retain the same implementation as before (suggested by Brian H) for a cost of <strong>48</strong> bytes.</p>

<pre class="lang-javascript prettyprint-override"><code>a=&gt;{for(a=i=0;i&lt;1e6;a+=8/++i/~-(i+=3));return a}
</code></pre>

<p>The choice of name for the single parameter doesn't <em>really</em> matter, but we might as well pick one of the names we use so as to minimise the global-scope pollution.</p>

<hr>

<pre class="lang-javascript prettyprint-override"><code>function(){for(a=i=0;i&lt;1e6;a+=8/++i/~-(i+=3));return a}
</code></pre>

<p>This version is a function expression; add two characters (e.g. " <code>f</code>") if you want it named.  This version clobbers the globals <code>a</code> and <code>i</code>; this could be prevented if we added "<code>a,i</code>" to the parameter list.</p>

<p>Makes use of a reformulated version of the algorithm in order to circumvent the need for subtraction.</p>

<pre class="lang-javascript prettyprint-override"><code> 1/1 - 1/3  +   1/5 - 1/7   +    1/9 - 1/11  + ...
(3/3 - 1/3) + (7/35 - 5/35) + (11/99 - 9/99) + ...
    2/3     +      2/35     +       2/99     + ...
  2/(1*3)   +    2/(5*7)    +     2/(9*11)   + ...
</code></pre>

<p>Here's a "plain" version without this adjustment:</p>

<pre class="lang-javascript prettyprint-override"><code>function(){for(a=0,i=1;i&lt;1e6;i+=2)a+=[,4,,-4][i%4]/i;return a}
</code></pre>

<p>which clocks in at <s><em>64</em></s> <strong>62</strong> characters.</p>

<p>Thanks to @ardnew for the suggestion to get rid of the <code>4*</code> before the <code>return</code>.</p>

<hr>

<h3>History</h3>

<pre class="lang-javascript prettyprint-override"><code>function(){for(a=i=0;i&lt;1e6;a+=8/++i/~-(i+=3));return a}     // got rid of `i+=4`; restructured
// Old versions below.
function(){for(a=0,i=1;i&lt;1e6;i+=4)a+=8/i/-~-~i;return a}    // got rid of `4*`
function(){for(a=0,i=1;i&lt;1e6;i+=4)a+=2/i/-~-~i;return 4*a}
</code></pre>
</div>
<div id="pu10" class="pu"><h1>SQL, 253 bytes</h1>
<pre><code>DECLARE @B int=3, @A varchar(max), @C varchar(max)='1'
WHILE @B&lt;100000
BEGIN
SELECT @C=@C+(select case when (@B-1)%4=0 then'+'else'-'end)+
(SELECT cast(cast(1.0/@B as decimal(9,8)) as varchar(max)))
SELECT @B=@B+2
END
EXECUTE('SELECT 4*('+@C+')')
</code></pre>
<p>I would provide a SQL Fiddle, but this goes too many loops deep finding the 1/3 1/5 1/7 etc. fractions and gives errors lol. However, if you change <code>@B&lt;100000</code> to <code>1000</code> then it runs (obviously not to the same number of digits of accuracy).</p>
</div>
<div id="pu11" class="pu"><h2>Ruby - 82 chars</h2>

<pre><code>def f(n,k=n)k&gt;0?(f(n,k-1)+f(n+1,k-1))/2:n&lt;0?0:f(n-1,0)+(-1)**n/(2*n+1.0)end;4*f(9)
</code></pre>

<p>Try it : <a href="https://repl.it/LQ8w" rel="nofollow noreferrer">https://repl.it/LQ8w</a></p>

<p>The approach uses the given series indirectly using a numerical acceleration approach. The resulting output is</p>

<p><code>pi ≈ 3.14159265161</code></p>

<p>vs.</p>

<p><code>pi = 3.14159265359</code></p>

<p>It starts with</p>

<pre><code>f(n,0) = 1/1 - 1/3 + 1/5 - ... + ((-1)**n)/(2*n+1)
</code></pre>

<p>And then, since this is alternating, we can accelerate the convergence using</p>

<pre><code>f(n,1) = (f(n,0) + f(n+1,0))/2
</code></pre>

<p>And it repeatedly applies this:</p>

<pre><code>f(n,k) = (f(n,k-1) + f(n+1,k-1))/2
</code></pre>

<p>And for simplicity, <code>f(n) = f(n,n)</code>.</p>

<hr>

<h2>Ruby - 50 chars</h2>

<p>If you don't mind running for a really long while, then you could simply use</p>

<pre><code>def f(n)n&lt;0?0:f(n-1)+(-1)**n/(2*n+1.0)end;4*f(1e7)
</code></pre>

<p>or</p>

<pre><code>a=0;for k in 0..1e7 do a+=(-1)**k/(2*k+1.0)end;4*a
</code></pre>
</div>
<div id="pu12" class="pu"><h1>Julia - 30 characters</h1>

<pre><code>sum(4./[1:4:1e6] - 4./[3:4:1e6])
</code></pre>
</div>
<div id="pu13" class="pu"><h2>Perl - <strike>43</strike> 39 chars</h2>

<p>not sure the rules on anonymous subroutines, but here's another implementation using @FireFly's series construction</p>

<pre class="lang-perl prettyprint-override"><code>sub{$s+=8/((4*$_+2)**2-1)for 0..1e6;$s}
</code></pre>

<p><strike></p>

<pre><code>sub p{$s+=(-1)**$_*4/(2*$_+1)for 0..1e6;$s}
</code></pre>

<p></strike></p>
</div>
<div id="pu14" class="pu"><h1>PHP - <strike>56</strike> 55 chars</h1>

<pre class="lang-php prettyprint-override"><code>&lt;?for($j=$i=-1;1e6&gt;$j;){$p+=($i=-$i)/($j+=2);}echo$p*4;
</code></pre>

<p>I don't know that I can get it much smaller without breaking the algorithm rule.</p>
</div>
<div id="pu15" class="pu"><h2>Haskell, 32</h2>

<pre class="lang-haskell prettyprint-override"><code>foldr(\k-&gt;(4/(2*k+1)-))0[0..8^7]
</code></pre>

<blockquote>
  <p>GHCi> foldr(\k->(4/(2*k+1)-))0[0..8^7]<br>
  3.141593130426724</p>
</blockquote>

<p>Counting a function name it's</p>

<h2>34</h2>

<pre class="lang-haskell prettyprint-override"><code>π=foldr(\k-&gt;(4/(2*k+1)-))0[0..8^7]
</code></pre>
</div>
<div id="pu16" class="pu"><h2>Java (67 chars)</h2>

<pre class="lang-java prettyprint-override"><code>float r(){float p=0,s=4,i=1E6f;while(--i&gt;0)p+=(s=-s)/i--;return p;}
</code></pre>

<p>Note that this avoids loss of significance by adding the numbers up in the correct order.</p>
</div>
<div id="pu17" class="pu"><p><strong>J, 26 chars</strong></p>

<p><strike>+/+/_2((4 _4)&amp;%)>:+:i.100</strike> </p>

<p>Moved from 100 items of sequence to  1e6 items. Also now it's a code tagged and could be copypasted from browser to the console without errors.</p>

<pre class="lang-j prettyprint-override"><code>+/+/_2((4 _4)&amp;%)\&gt;:+:i.1e6
</code></pre>
</div>
<div id="pu18" class="pu"><h2>C (GCC) (44 chars)</h2>

<pre class="lang-c prettyprint-override"><code>float p(i){return i&lt;1E6?4./++i-p(++i):0;}
</code></pre>

<p>That's 41 chars, but it also has to be compiled with <code>-O2</code> to get the optimiser to eliminate the tail recursion. This also relies on undefined behaviour with respect to the order in which the <code>++</code> are executed; thanks to ugoren for pointing this out. I've tested with gcc 4.4.3 under 64-bit Linux .</p>

<p>Note that unless the optimiser also reorders the sum, it will add from the smallest number, so it avoids loss of significance.</p>

<p>Call as <code>p()</code>.</p>
</div>
<div id="pu19" class="pu"><h2>APL (14)</h2>

<pre class="lang-apl prettyprint-override"><code>4×-/÷1-⍨2×⍳1e6
</code></pre>

<p>&nbsp;</p>
</div>
<div id="pu20" class="pu"><h1>CJam - 21</h1>

<pre><code>1e6{WI#4d*I2*)/}fI]:+
</code></pre>

<p>Pretty straightforward calculation of the given series.<br>
CJam is <a href="http://sf.net/p/cjam" rel="nofollow">http://sf.net/p/cjam</a></p>
</div>
<div id="pu21" class="pu"><h1>Javascript - 33 Characters</h1>
<pre><code>p=x=&gt;4*(1-(x&amp;2))/x+(x&gt;1?p(x-2):0)
</code></pre>
<p>Call <code>p</code> passing a positive odd number <code>x</code> and it will calculate Pi with <code>(x-1)/2</code> terms.</p>
</div>
<div id="pu22" class="pu"><h2>Python (49)</h2>

<pre><code>print 4*sum((-1)**i/(2*i+1.)for i in range(9**6))
</code></pre>

<pre>
<b>3.14159</b>453527
</pre>
</div>
<div id="pu23" class="pu"><h1>k (25 chars)</h1>

<p><s>
    4*+/%(i#1 -1)<em>'1+2</em>!i:1000000
</s></p>

<p>Slightly shorter:</p>

<pre><code>+/(i#4 -4)%1+2*!i:1000000
</code></pre>
</div>
<div id="pu24" class="pu"><h2>R - 25 chars</h2>

<pre><code>sum(c(4,-4)/seq(1,1e6,2))
</code></pre>
</div>
<div id="pu25" class="pu"><h2>Perl (76 chars)</h2>

<pre><code>$y=1e4;for$x(0..1e4-1){$y--while sqrt($x**2+$y**2)&gt;1e4;$a+=$y}print 4*$a/1e8
</code></pre>

<p>(Result: 3.14159052)</p>

<p>Not the shortest possible solution, but maybe interesting. It's a geometrical one. I calculate the area under a circle.</p>

<p>I got another funny approach, but it's really slow. It counts the number of discrete points in a square that are below a quarter circle and calculates pi from it:</p>

<pre><code>$i=shift;for$x(0..$i){for$y(0..$i){$h++if sqrt($x**2+$y**2)&lt;$i}}print$h*4/$i**2
</code></pre>

<p>It expects the number of iterations as command line argument. Here you can see how run time relates to accuracy. ;)</p>

<pre><code>$ time perl -e '$i=shift;for$x(0..$i){for$y(0..$i){$h++if sqrt($x**2+$y**2)&lt;$i}}print$h*4/$i**2' 100
3.1796
real    0m0.011s
user    0m0.005s
sys 0m0.003s

$ time perl -e '$i=shift;for$x(0..$i){for$y(0..$i){$h++if sqrt($x**2+$y**2)&lt;$i}}print$h*4/$i**2' 1000
3.14552
real    0m0.354s
user    0m0.340s
sys 0m0.004s

$ time perl -e '$i=shift;for$x(0..$i){for$y(0..$i){$h++if sqrt($x**2+$y**2)&lt;$i}}print$h*4/$i**2' 10000
3.14199016
real    0m34.941s
user    0m33.757s
sys 0m0.097s
</code></pre>
</div>
<div id="pu26" class="pu"><p><strong>Ruby - 54 chars</strong></p>

<pre><code>def a()p=0;1000000.times{|i|p+=8/(4*i*(4*i+2))};p;end;
</code></pre>

<p>My first try on console </p>

<pre><code>def a()i=1;p=0;while i&lt;2**100 do p+=8/(i*(i+2));i+=4;end;p;end;
</code></pre>

<p>63 chars.</p>
</div>
<div id="pu27" class="pu"><h2>Python - 56 chars</h2>

<p>Meh, My python-fu is not strong enough. I couldn't see any more shortcuts but maybe a more experienced golfer could find something to trim here?</p>

<pre><code>t=s=0
k=i=1
while t&lt;1e6:t,s,i,k=t+1,k*4./i+s,i+2,-k
</code></pre>
</div>
<div id="pu28" class="pu"><h2>Java - <strike>92</strike> 84 chars</h2>

<p>I cannot beat by far Peter Taylor's result, but here is mine:</p>

<pre><code>double d(){float n=0,k=0,x;while(n&lt;9E5){x=1/(1+2*n++);k+=(n%2==0)?-x:x;}return 4*k;}
</code></pre>

<p>Ungolfed version:</p>

<pre><code>double d() {
    float n = 0, k = 0, x;
    while (n &lt; 9E5) {
        x = 1 / (1 + 2 * n++);
        k += (n % 2 == 0) ? -x : x;
    }
    return 4 * k;
}
</code></pre>

<p>Edit: Saved a few characters using ternary operator.</p>
</div>
<div id="pu29" class="pu"><h1>Clojure - 79 chars</h1>
<pre><code>(fn [](* 4(apply +(map #(*(Math/pow -1 %1)(/ 1.0(+ 1 %1 %1)))(range 377000)))))
</code></pre>
<p>This creates a function of no arguments which will calculate a float which approximates pi correctly to five decimal places. Note that this does not bind the function to a name such as <code>pi</code>, so this code must either be evaluated in place with <code>eval</code> as <code>(&lt;code&gt;)</code> or bound to a name in which case the solution is</p>
<pre><code>(defn p[](* 4(apply +(map #(*(Math/pow -1 %1)(/ 1.0(+ 1 %1 %1)))(range 377000)))))
</code></pre>
<p>for 82 chars</p>
<h3>About</h3>
<pre><code>(defn nth-term-of-pi [n] (* (Math/pow -1 n) (/ 1.0 (+ 1 n n))))
(defn pi [c] (* 4 (apply + (map nth-term-of-pi (range c)))))
(def  pi-accuracy-constant (loop [c 1000] (if (&lt; (pi c) 3.14159) (recur (inc c)) c)))
; (pi pi-accuracy-constant) is then the value of pi to the accuracy of five decimal places
</code></pre>
</div>
<div id="pu30" class="pu"><h2>C, 69 chars</h2>

<pre><code>float p,b;void main(a){b++&lt;9e6?p+=a/b++,main(-a):printf("%f\n",4*p);}
</code></pre>

<ul>
<li>Run with no command line parameters (so <code>a</code> is initialized to 1).</li>
<li>Must be compiled with optimization.</li>
<li><code>void main</code> is strange and non-standard, but makes things work. Without it, the recursion is implemented as a real call, leading to a stack overflow. An alternative is adding <code>return</code>.</li>
<li>Two characters <code>4*</code> can be saved, if running with three command line parameters.</li>
</ul>
</div>
